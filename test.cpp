// Generated by IDA Pro
#include <stdint.h>
#include <string.h>


============================================================
// Segment: .text
============================================================


// ========== Function: sub_401000 @ 0x401000 ==========
_UNKNOWN ***sub_401000()
{
  return &off_429558;
}


// ========== Function: sub_401030 @ 0x401030 ==========
LPVOID __thiscall sub_401030(LPVOID lpMem, char a2)
{
  sub_401050();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_401050 @ 0x401050 ==========
// attributes: thunk
int sub_401050(void)
{
  return sub_423DB0();
}


// ========== Function: sub_401060 @ 0x401060 ==========
int sub_401060()
{
  unknown_libname_1();
  return atexit(unknown_libname_2);
}


// ========== Function: unknown_libname_1 @ 0x401070 ==========
// Microsoft VisualC 2-14/net runtime
_DWORD *unknown_libname_1()
{
  CWinApp::CWinApp((CWinApp *)dword_4372B0, 0);
  dword_4372B0[0] = &off_429590;
  return dword_4372B0;
}


// ========== Function: unknown_libname_2 @ 0x401090 ==========
// Microsoft VisualC 2-14/net runtime
void __cdecl unknown_libname_2()
{
  sub_401050(dword_4372B0);
}


// ========== Function: sub_4010A0 @ 0x4010A0 ==========
int __thiscall sub_4010A0(CWinApp *this)
{
  _BYTE v3[92]; // [esp+4h] [ebp-51Ch] BYREF
  _BYTE v4[136]; // [esp+60h] [ebp-4C0h] BYREF
  _BYTE v5[60]; // [esp+E8h] [ebp-438h] BYREF
  _BYTE v6[60]; // [esp+124h] [ebp-3FCh] BYREF
  _BYTE v7[60]; // [esp+160h] [ebp-3C0h] BYREF
  _BYTE v8[60]; // [esp+19Ch] [ebp-384h] BYREF
  _BYTE v9[60]; // [esp+1D8h] [ebp-348h] BYREF
  _BYTE v10[60]; // [esp+214h] [ebp-30Ch] BYREF
  _BYTE v11[60]; // [esp+250h] [ebp-2D0h] BYREF
  _BYTE v12[60]; // [esp+28Ch] [ebp-294h] BYREF
  _BYTE v13[60]; // [esp+2C8h] [ebp-258h] BYREF
  _BYTE v14[60]; // [esp+304h] [ebp-21Ch] BYREF
  _BYTE v15[64]; // [esp+340h] [ebp-1E0h] BYREF
  _BYTE v16[396]; // [esp+380h] [ebp-1A0h] BYREF
  _BYTE v17[8]; // [esp+50Ch] [ebp-14h] BYREF
  int v18; // [esp+51Ch] [ebp-4h]

  AfxEnableControlContainer(0);
  CWinApp::Enable3dControlsStatic(this);
  sub_4013B0(0);
  v18 = 0;
  *((_DWORD *)this + 7) = v3;
  sub_41CF40(v3);
  v18 = 14;
  sub_4200DD(v17);
  LOBYTE(v18) = 13;
  `eh vector destructor iterator'(v16, 4u, 99, sub_4200DD);
  LOBYTE(v18) = 12;
  CWnd::~CWnd((CWnd *)v15);
  LOBYTE(v18) = 11;
  sub_423995(v14);
  LOBYTE(v18) = 10;
  sub_423995(v13);
  LOBYTE(v18) = 9;
  sub_423995(v12);
  LOBYTE(v18) = 8;
  sub_423995(v11);
  LOBYTE(v18) = 7;
  sub_423995(v10);
  LOBYTE(v18) = 6;
  sub_423995(v9);
  LOBYTE(v18) = 5;
  sub_423995(v8);
  LOBYTE(v18) = 4;
  sub_423995(v7);
  LOBYTE(v18) = 3;
  sub_423995(v6);
  LOBYTE(v18) = 2;
  sub_423995(v5);
  LOBYTE(v18) = 1;
  `eh vector destructor iterator'(v4, 8u, 12, sub_401380);
  v18 = -1;
  sub_41CC1E(v3);
  return 0;
}


// ========== Function: sub_401250 @ 0x401250 ==========
int __thiscall sub_401250(int this)
{
  sub_4200DD((void *)(this + 1288));
  `eh vector destructor iterator'((void *)(this + 892), 4u, 99, sub_4200DD);
  CWnd::~CWnd((CWnd *)(this + 828));
  sub_423995(this + 768);
  sub_423995(this + 708);
  sub_423995(this + 648);
  sub_423995(this + 588);
  sub_423995(this + 528);
  sub_423995(this + 468);
  sub_423995(this + 408);
  sub_423995(this + 348);
  sub_423995(this + 288);
  sub_423995(this + 228);
  `eh vector destructor iterator'((void *)(this + 92), 8u, 12, sub_401380);
  return sub_41CC1E(this);
}


// ========== Function: sub_401380 @ 0x401380 ==========
// attributes: thunk
void __thiscall sub_401380(void *this)
{
  sub_4200DD(this);
}


// ========== Function: j_??1CWnd@@UAE@XZ @ 0x401390 ==========
// attributes: thunk
void __thiscall CWnd::~CWnd(CWnd *this)
{
  ??1CWnd@@UAE@XZ(this);
}


// ========== Function: nullsub_4 @ 0x4013A0 ==========
void __stdcall nullsub_4(int a1)
{
  ;
}


// ========== Function: sub_4013B0 @ 0x4013B0 ==========
_DWORD *__thiscall sub_4013B0(_DWORD *this, struct CWnd *a2)
{
  CString *v3; // edi
  struct AFX_MODULE_STATE *ModuleState; // eax
  HICON IconA; // eax
  int i; // ebp
  int v7; // eax
  int v8; // eax
  _DWORD *v9; // edi
  int v10; // ebp
  int v12; // [esp+10h] [ebp-18h]
  _BYTE v13[4]; // [esp+18h] [ebp-10h] BYREF
  int v14; // [esp+24h] [ebp-4h]

  v12 = 0;
  CDialog::CDialog((CDialog *)this, 0x66u, a2);
  v14 = 0;
  `eh vector constructor iterator'(this + 23, 8u, 12, sub_404120, sub_401380);
  sub_41D43B(this + 57);
  this[57] = &CComboBox::`vftable';
  sub_41D43B(this + 72);
  this[72] = &CComboBox::`vftable';
  sub_41D43B(this + 87);
  this[87] = &CComboBox::`vftable';
  sub_41D43B(this + 102);
  this[102] = &CComboBox::`vftable';
  sub_41D43B(this + 117);
  this[117] = &CComboBox::`vftable';
  sub_41D43B(this + 132);
  this[132] = &CComboBox::`vftable';
  sub_41D43B(this + 147);
  this[147] = &CComboBox::`vftable';
  sub_41D43B(this + 162);
  this[162] = &CComboBox::`vftable';
  sub_41D43B(this + 177);
  this[177] = &CComboBox::`vftable';
  sub_41D43B(this + 192);
  this[192] = &CComboBox::`vftable';
  sub_41D43B(this + 207);
  this[207] = &off_429900;
  v3 = (CString *)(this + 223);
  `eh vector constructor iterator'(this + 223, 4u, 99, sub_404120, sub_4200DD);
  this[322] = off_433548;
  LOBYTE(v14) = 14;
  *this = &off_429830;
  AfxGetModuleState();
  ModuleState = AfxGetModuleState();
  IconA = LoadIconA(*((HINSTANCE *)ModuleState + 3), (LPCSTR)0x80);
  this[222] = 0;
  this[323] = IconA;
  for ( i = 1; i < 100; ++i )
  {
    a2 = (struct CWnd *)off_433548;
    LOBYTE(v14) = 15;
    if ( i > 9 )
      sub_41B028((int)&a2, Ptr, i);
    else
      sub_41B028((int)&a2, (unsigned __int8 *)aHttpWww266CcWe, i);
    sub_4201D2(v3, (int)&a2);
    v14 = 15;
    if ( (v12 & 1) != 0 )
    {
      v7 = v12;
      LOBYTE(v7) = v12 & 0xFE;
      v12 = v7;
      sub_4200DD(v13);
    }
    LOBYTE(v14) = 14;
    sub_4200DD(&a2);
    v3 = (CString *)((char *)v3 + 4);
  }
  CString::operator=((CString *)(this + 23), &byte_4330C4);
  this[24] = 0;
  v8 = 1;
  v9 = this + 26;
  do
  {
    a2 = (struct CWnd *)off_433548;
    v10 = v8 + 1;
    LOBYTE(v14) = 17;
    sub_41B028((int)&a2, &byte_4330C0, v8 + 1);
    sub_4201D2((CString *)(v9 - 1), (int)&a2);
    *v9 = 0;
    LOBYTE(v14) = 14;
    sub_4200DD(&a2);
    v8 = v10;
    v9 += 2;
  }
  while ( v10 < 11 );
  memset(this + 47, 0xFFu, 0x28u);
  return this;
}


// ========== Function: sub_401680 @ 0x401680 ==========
int __stdcall sub_401680(int a1, int a2, int a3, RECT *lprcSrc, int a5, int a6, int a7)
{
  return sub_405A3D((int)&unk_4299B8, a2, a3, lprcSrc, a5, a6, 0, 0, 0);
}


// ========== Function: sub_4016B0 @ 0x4016B0 ==========
LPVOID __thiscall sub_4016B0(LPVOID lpMem, char a2)
{
  sub_401250((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_4016D0 @ 0x4016D0 ==========
CWnd *__thiscall sub_4016D0(CWnd *lpMem, char a2)
{
  CWnd::~CWnd(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_4016F0 @ 0x4016F0 ==========
void __thiscall sub_4016F0(int this, struct CDataExchange *a2)
{
  DDX_Control(a2, 1054, (struct CWnd *)(this + 228));
  DDX_Control(a2, 1053, (struct CWnd *)(this + 288));
  DDX_Control(a2, 1052, (struct CWnd *)(this + 348));
  DDX_Control(a2, 1051, (struct CWnd *)(this + 408));
  DDX_Control(a2, 1049, (struct CWnd *)(this + 468));
  DDX_Control(a2, 1048, (struct CWnd *)(this + 528));
  DDX_Control(a2, 1047, (struct CWnd *)(this + 588));
  DDX_Control(a2, 1046, (struct CWnd *)(this + 648));
  DDX_Control(a2, 1055, (struct CWnd *)(this + 708));
  DDX_Control(a2, 1008, (struct CWnd *)(this + 768));
  DDX_Control(a2, 1003, (struct CWnd *)(this + 828));
}


// ========== Function: sub_4017D0 @ 0x4017D0 ==========
_UNKNOWN ****sub_4017D0()
{
  return &off_429630;
}


// ========== Function: sub_4017E0 @ 0x4017E0 ==========
int __thiscall sub_4017E0(CWnd *this)
{
  CHAR *v2; // eax
  int *v3; // ebx
  char *String; // [esp+Ch] [ebp-38h] BYREF
  int v6; // [esp+10h] [ebp-34h]
  struct tagRECT Rect; // [esp+14h] [ebp-30h] BYREF
  _BYTE v8[20]; // [esp+24h] [ebp-20h] BYREF
  int v9; // [esp+40h] [ebp-4h]

  CDialog::OnInitDialog(this);
  SendMessageA(*((HWND *)this + 7), 0x80u, 1u, *((_DWORD *)this + 323));
  SendMessageA(*((HWND *)this + 7), 0x80u, 0, *((_DWORD *)this + 323));
  v2 = (CHAR *)sub_42034E(260);
  GetCurrentDirectoryA(0x104u, v2);
  SetTimer(*((HWND *)this + 7), 1u, 0x1D4C0u, 0);
  SetTimer(*((HWND *)this + 7), 2u, 0x64u, 0);
  GetWindowRect(*((HWND *)this + 7), &Rect);
  CWnd::MoveWindow(this, Rect.left, Rect.top, (Rect.right - Rect.left) / 2, Rect.bottom, 1);
  sub_402E60(this);
  SendMessageA(*((HWND *)this + 199), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 169), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 154), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 139), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 124), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 109), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 94), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 79), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 64), 0x14Eu, 0, 0);
  SendMessageA(*((HWND *)this + 184), 0x14Eu, 0, 0);
  CStdioFile::CStdioFile((CStdioFile *)v8);
  v9 = 0;
  if ( CStdioFile::Open((CStdioFile *)v8, aSetIni, 0, 0) )
  {
    String = (char *)off_433548;
    LOBYTE(v9) = 1;
    v3 = (int *)((char *)this + 188);
    v6 = 10;
    do
    {
      sub_4209A7((CString *)&String);
      *v3++ = atoi(String);
      --v6;
    }
    while ( v6 );
    CStdioFile::Close((CStdioFile *)v8);
    LOBYTE(v9) = 0;
    sub_4200DD(&String);
    SendMessageA(*((HWND *)this + 199), 0x14Eu, *((_DWORD *)this + 47), 0);
    SendMessageA(*((HWND *)this + 169), 0x14Eu, *((_DWORD *)this + 48), 0);
    SendMessageA(*((HWND *)this + 154), 0x14Eu, *((_DWORD *)this + 49), 0);
    SendMessageA(*((HWND *)this + 139), 0x14Eu, *((_DWORD *)this + 50), 0);
    SendMessageA(*((HWND *)this + 124), 0x14Eu, *((_DWORD *)this + 51), 0);
    SendMessageA(*((HWND *)this + 109), 0x14Eu, *((_DWORD *)this + 52), 0);
    SendMessageA(*((HWND *)this + 94), 0x14Eu, *((_DWORD *)this + 53), 0);
    SendMessageA(*((HWND *)this + 79), 0x14Eu, *((_DWORD *)this + 54), 0);
    SendMessageA(*((HWND *)this + 64), 0x14Eu, *((_DWORD *)this + 55), 0);
    SendMessageA(*((HWND *)this + 184), 0x14Eu, *((_DWORD *)this + 56), 0);
    sub_402800((HWND)this);
    sub_402B30((HWND)this);
    sub_403120((HWND)this);
    sub_403450((HWND)this);
    sub_403790((HWND)this);
    sub_403AC0((HWND)this);
    sub_403DF0((HWND)this);
    sub_404130((HWND)this);
    sub_404460((HWND)this);
    sub_404790((HWND)this);
    sub_403020(this);
    v9 = -1;
    CStdioFile::~CStdioFile((CStdioFile *)v8);
    return 1;
  }
  else
  {
    SendMessageA(*((HWND *)this + 199), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 169), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 154), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 139), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 124), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 109), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 94), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 79), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 64), 0x14Eu, 0, 0);
    SendMessageA(*((HWND *)this + 184), 0x14Eu, 0, 0);
    sub_403020(this);
    v9 = -1;
    CStdioFile::~CStdioFile((CStdioFile *)v8);
    return 1;
  }
}


// ========== Function: sub_401C30 @ 0x401C30 ==========
void __thiscall sub_401C30(struct CWnd *this)
{
  int SystemMetrics; // ebx
  int v3; // edi
  struct tagRECT Rect; // [esp+4h] [ebp-64h] BYREF
  _BYTE v5[4]; // [esp+14h] [ebp-54h] BYREF
  HDC hDC; // [esp+18h] [ebp-50h]

  if ( IsIconic(*((HWND *)this + 7)) )
  {
    CPaintDC::CPaintDC((CPaintDC *)v5, this);
    SendMessageA(*((HWND *)this + 7), 0x27u, v5 != 0 ? (unsigned int)hDC : 0, 0);
    SystemMetrics = GetSystemMetrics(11);
    v3 = GetSystemMetrics(12);
    GetClientRect(*((HWND *)this + 7), &Rect);
    DrawIcon(
      hDC,
      (Rect.right - Rect.left - SystemMetrics + 1) / 2,
      (Rect.bottom - Rect.top - v3 + 1) / 2,
      *((HICON *)this + 323));
    CPaintDC::~CPaintDC((CPaintDC *)v5);
  }
  else
  {
    sub_41D7CD(this);
  }
}


// ========== Function: sub_401CF0 @ 0x401CF0 ==========
int __thiscall sub_401CF0(_DWORD *this)
{
  return this[323];
}


// ========== Function: sub_401D00 @ 0x401D00 ==========
void __thiscall sub_401D00(HWND *this, int a2, int a3)
{
  HGLOBAL v4; // ebx
  char *v5; // edx
  const char *v6; // [esp+8h] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-4h]

  v7 = 1;
  v6 = (const char *)off_433548;
  sub_4201D2((CString *)&v6, (int)&a2);
  keybd_event(0xDu, 0, 0, 0);
  keybd_event(0xDu, 0, 2u, 0);
  if ( OpenClipboard(this[7]) )
  {
    EmptyClipboard();
    v4 = GlobalAlloc(0x2000u, *((_DWORD *)v6 - 2) + 1);
    v5 = (char *)GlobalLock(v4);
    strcpy(v5, v6);
    GlobalUnlock(v4);
    SetClipboardData(1u, v4);
    CloseClipboard();
  }
  keybd_event(0x11u, 0, 0, 0);
  keybd_event(0x56u, 0, 0, 0);
  keybd_event(0x56u, 0, 2u, 0);
  keybd_event(0x11u, 0, 2u, 0);
  if ( !a3 )
  {
    keybd_event(0xDu, 0, 0, 0);
    keybd_event(0xDu, 0, 2u, 0);
  }
  LOBYTE(v7) = 0;
  sub_4200DD(&v6);
  v7 = -1;
  sub_4200DD(&a2);
}


// ========== Function: sub_401F40 @ 0x401F40 ==========
int __thiscall sub_401F40(_DWORD *this, int a2)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  HKEY hKey; // [esp+4h] [ebp-314h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-310h] BYREF
  DWORD cchValueName; // [esp+Ch] [ebp-30Ch] BYREF
  DWORD cbData; // [esp+10h] [ebp-308h] BYREF
  DWORD Type; // [esp+14h] [ebp-304h] BYREF
  CHAR CmdLine[256]; // [esp+18h] [ebp-300h] BYREF
  BYTE Data[256]; // [esp+118h] [ebp-200h] BYREF
  CHAR ValueName[256]; // [esp+218h] [ebp-100h] BYREF

  if ( a2 == 1 )
  {
    v8 = this[222];
    if ( v8 < 99 )
    {
      sub_404E50(this[v8 + 223], 0, 0, 0, 0);
      ++this[222];
    }
    return sub_41D7CD(this);
  }
  if ( a2 == 2 )
  {
    v4 = sub_420432(1005);
    sub_402130(v4, 132);
    v5 = sub_420432(1004);
    sub_402130(v5, 135);
    v6 = sub_420432(1006);
    sub_402130(v6, 133);
    v7 = sub_420432(1007);
    sub_402130(v7, 134);
    return sub_41D7CD(this);
  }
  if ( a2 != 3 )
    return sub_41D7CD(this);
  cchValueName = 256;
  cbData = 256;
  if ( RegOpenKeyA(HKEY_CLASSES_ROOT, 0, &phkResult) || RegOpenKeyExA(phkResult, aHtmlfileShellO, 0, 0xF003Fu, &hKey) )
  {
    sub_423222(aWeb, 0, 0);
  }
  else
  {
    RegEnumValueA(hKey, 0, ValueName, &cchValueName, 0, &Type, Data, &cbData);
    strcpy(CmdLine, (const char *)Data);
    strcat(CmdLine, aHttpWww266CcWe_1);
    WinExec(CmdLine, 6u);
  }
  RegCloseKey(hKey);
  RegCloseKey(phkResult);
  return sub_41D7CD(this);
}


// ========== Function: sub_402130 @ 0x402130 ==========
int __stdcall sub_402130(int a1, unsigned __int16 a2)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  HBITMAP BitmapA; // eax
  HDC DC; // eax
  int v5; // esi
  _DWORD v7[2]; // [esp+4h] [ebp-14h] BYREF
  int v8; // [esp+14h] [ebp-4h]

  v7[1] = 0;
  v7[0] = &off_4299C8;
  v8 = 0;
  ModuleState = AfxGetModuleState();
  BitmapA = LoadBitmapA(*((HINSTANCE *)ModuleState + 3), (LPCSTR)a2);
  sub_4229CA(BitmapA);
  DC = GetDC(*(HWND *)(a1 + 28));
  v5 = sub_4221FC(DC);
  DrawStateA(*(HDC *)(v5 + 4), 0, 0, 0, 0, 5, 5, 32, 30, 4u);
  sub_422279(v5);
  sub_422A21(v7);
  v7[0] = &CGdiObject::`vftable';
  v8 = 1;
  return sub_422A21(v7);
}


// ========== Function: sub_402200 @ 0x402200 ==========
BOOL __thiscall sub_402200(HWND *this)
{
  int i; // esi
  HWND v3; // eax
  BOOL result; // eax

  CWnd::OnDestroy((CWnd *)this);
  KillTimer(this[7], 1u);
  KillTimer(this[7], 2u);
  for ( i = 1; i < 12; ++i )
  {
    if ( this )
      v3 = this[7];
    else
      v3 = 0;
    result = UnregisterHotKey(v3, i);
  }
  return result;
}


// ========== Function: sub_402250 @ 0x402250 ==========
void __thiscall sub_402250(_DWORD *hWnd, unsigned __int8 *Str1, int id)
{
  HWND v3; // esi
  HWND v4; // eax
  int v5; // edi
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND v13; // eax
  HWND v14; // eax

  v3 = (HWND)hWnd;
  if ( hWnd )
    v4 = (HWND)hWnd[7];
  else
    v4 = 0;
  v5 = id;
  UnregisterHotKey(v4, id);
  if ( !_mbscmp(Str1, &byte_43324C) )
  {
    if ( v3 )
      v6 = (HWND)*((_DWORD *)v3 + 7);
    else
      v6 = 0;
    RegisterHotKey(v6, v5, 0, 0x71u);
  }
  v7 = (HWND)_mbscmp(Str1, &byte_433248);
  if ( !v7 )
  {
    if ( v3 )
      v7 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v7, v5, 0, 0x72u);
  }
  v8 = (HWND)_mbscmp(Str1, &byte_433244);
  if ( !v8 )
  {
    if ( v3 )
      v8 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v8, v5, 0, 0x73u);
  }
  v9 = (HWND)_mbscmp(Str1, &byte_433240);
  if ( !v9 )
  {
    if ( v3 )
      v9 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v9, v5, 0, 0x74u);
  }
  v10 = (HWND)_mbscmp(Str1, &byte_43323C);
  if ( !v10 )
  {
    if ( v3 )
      v10 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v10, v5, 0, 0x75u);
  }
  v11 = (HWND)_mbscmp(Str1, &byte_433238);
  if ( !v11 )
  {
    if ( v3 )
      v11 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v11, v5, 0, 0x76u);
  }
  v12 = (HWND)_mbscmp(Str1, &byte_433234);
  if ( !v12 )
  {
    if ( v3 )
      v12 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v12, v5, 0, 0x77u);
  }
  v13 = (HWND)_mbscmp(Str1, &byte_433230);
  if ( !v13 )
  {
    if ( v3 )
      v13 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v13, v5, 0, 0x78u);
  }
  v14 = (HWND)_mbscmp(Str1, &byte_43322C);
  if ( !v14 )
  {
    if ( v3 )
      v14 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v14, v5, 0, 0x79u);
  }
  if ( !_mbscmp(Str1, &byte_433228) )
  {
    if ( v3 )
      v3 = (HWND)*((_DWORD *)v3 + 7);
    RegisterHotKey(v3, v5, 0, 0x7Au);
  }
  sub_4200DD(&Str1);
}


// ========== Function: sub_402400 @ 0x402400 ==========
void __thiscall sub_402400(LPCSTR *this)
{
  int *v2; // esi
  int v3; // edi
  char *v4; // [esp+4h] [ebp-24h] BYREF
  _BYTE v5[20]; // [esp+8h] [ebp-20h] BYREF
  int v6; // [esp+24h] [ebp-4h]

  SetCurrentDirectoryA(this[322]);
  CStdioFile::CStdioFile((CStdioFile *)v5);
  v6 = 0;
  if ( CStdioFile::Open((CStdioFile *)v5, aSetIni, 0x1001u, 0) )
  {
    v4 = (char *)off_433548;
    LOBYTE(v6) = 1;
    v2 = (int *)(this + 47);
    v3 = 10;
    do
    {
      sub_41B028((int)&v4, &byte_433250, *v2);
      CStdioFile::WriteString((CStdioFile *)v5, v4);
      ++v2;
      --v3;
    }
    while ( v3 );
    CStdioFile::Close((CStdioFile *)v5);
    LOBYTE(v6) = 0;
    sub_4200DD(&v4);
  }
  v6 = -1;
  CStdioFile::~CStdioFile((CStdioFile *)v5);
}


// ========== Function: nullsub_5 @ 0x4024D0 ==========
void nullsub_5()
{
  ;
}


// ========== Function: sub_4024E0 @ 0x4024E0 ==========
int __thiscall sub_4024E0(HWND hWnd)
{
  struct CWinThread *Thread; // eax
  struct CWnd *v3; // eax
  int v4; // eax
  HWND v5; // edi
  int v6; // ebp
  char *String; // [esp+4h] [ebp-220h] BYREF
  char *v9; // [esp+8h] [ebp-21Ch] BYREF
  _BYTE v10[20]; // [esp+Ch] [ebp-218h] BYREF
  _BYTE v11[172]; // [esp+20h] [ebp-204h] BYREF
  _BYTE v12[332]; // [esp+CCh] [ebp-158h] BYREF
  int v13; // [esp+220h] [ebp-4h]

  Thread = AfxGetThread();
  if ( Thread )
    v3 = (struct CWnd *)(*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 116))(Thread);
  else
    v3 = 0;
  sub_41B03B(1, 0, 0, 6, (int)&unk_433254, v3);
  v13 = 0;
  if ( sub_41B19D((struct CWnd *)v11) == 1 )
  {
    v9 = (char *)off_433548;
    LOBYTE(v13) = 1;
    v4 = sub_41B278(&String);
    LOBYTE(v13) = 2;
    sub_4201D2((CString *)&v9, v4);
    LOBYTE(v13) = 1;
    sub_4200DD(&String);
    CStdioFile::CStdioFile((CStdioFile *)v10);
    LOBYTE(v13) = 3;
    if ( CStdioFile::Open((CStdioFile *)v10, v9, 0, 0) )
    {
      String = (char *)off_433548;
      LOBYTE(v13) = 4;
      v5 = hWnd + 47;
      v6 = 10;
      do
      {
        sub_4209A7((CString *)&String);
        *(_DWORD *)v5++ = atoi(String);
        --v6;
      }
      while ( v6 );
      CStdioFile::Close((CStdioFile *)v10);
      LOBYTE(v13) = 3;
      sub_4200DD(&String);
    }
    SendMessageA(*((HWND *)hWnd + 199), 0x14Eu, *((_DWORD *)hWnd + 47), 0);
    SendMessageA(*((HWND *)hWnd + 169), 0x14Eu, *((_DWORD *)hWnd + 48), 0);
    SendMessageA(*((HWND *)hWnd + 154), 0x14Eu, *((_DWORD *)hWnd + 49), 0);
    SendMessageA(*((HWND *)hWnd + 139), 0x14Eu, *((_DWORD *)hWnd + 50), 0);
    SendMessageA(*((HWND *)hWnd + 124), 0x14Eu, *((_DWORD *)hWnd + 51), 0);
    SendMessageA(*((HWND *)hWnd + 109), 0x14Eu, *((_DWORD *)hWnd + 52), 0);
    SendMessageA(*((HWND *)hWnd + 94), 0x14Eu, *((_DWORD *)hWnd + 53), 0);
    SendMessageA(*((HWND *)hWnd + 79), 0x14Eu, *((_DWORD *)hWnd + 54), 0);
    SendMessageA(*((HWND *)hWnd + 64), 0x14Eu, *((_DWORD *)hWnd + 55), 0);
    SendMessageA(*((HWND *)hWnd + 184), 0x14Eu, *((_DWORD *)hWnd + 56), 0);
    sub_402800(hWnd);
    sub_402B30(hWnd);
    sub_403120(hWnd);
    sub_403450(hWnd);
    sub_403790(hWnd);
    sub_403AC0(hWnd);
    sub_403DF0(hWnd);
    sub_404130(hWnd);
    sub_404460(hWnd);
    sub_404790(hWnd);
    sub_403020(hWnd);
    LOBYTE(v13) = 1;
    CStdioFile::~CStdioFile((CStdioFile *)v10);
    LOBYTE(v13) = 0;
    sub_4200DD(&v9);
  }
  v13 = 5;
  sub_4200DD(v12);
  v13 = -1;
  return sub_41CC1E(v11);
}


// ========== Function: sub_4027B0 @ 0x4027B0 ==========
int __thiscall sub_4027B0(int this)
{
  sub_4200DD((void *)(this + 172));
  return sub_41CC1E(this);
}


// ========== Function: sub_402800 @ 0x402800 ==========
void __thiscall sub_402800(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[199];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 192), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020(hWnd);
      v17 = 1;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[199], 0x14Eu, hWnd[47], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 1);
    sub_403020(hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_402B30 @ 0x402B30 ==========
void __thiscall sub_402B30(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[169];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 162), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020(hWnd);
      v17 = 2;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[169], 0x14Eu, hWnd[48], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 2);
    sub_403020(hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_402E60 @ 0x402E60 ==========
LRESULT __thiscall sub_402E60(HWND *this)
{
  LPARAM *v2; // ebx
  int v3; // ebp
  LRESULT result; // eax

  SendMessageA(this[199], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[169], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[154], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[139], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[124], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[109], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[94], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[79], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[64], 0x143u, 0, (LPARAM)byte_4330C4);
  SendMessageA(this[184], 0x143u, 0, (LPARAM)byte_4330C4);
  v2 = (LPARAM *)(this + 25);
  v3 = 11;
  do
  {
    result = v2[1];
    if ( !result )
    {
      SendMessageA(this[199], 0x143u, 0, *v2);
      SendMessageA(this[169], 0x143u, 0, *v2);
      SendMessageA(this[154], 0x143u, 0, *v2);
      SendMessageA(this[139], 0x143u, 0, *v2);
      SendMessageA(this[124], 0x143u, 0, *v2);
      SendMessageA(this[109], 0x143u, 0, *v2);
      SendMessageA(this[94], 0x143u, 0, *v2);
      SendMessageA(this[79], 0x143u, 0, *v2);
      SendMessageA(this[64], 0x143u, 0, *v2);
      result = SendMessageA(this[184], 0x143u, 0, *v2);
    }
    v2 += 2;
    --v3;
  }
  while ( v3 );
  return result;
}


// ========== Function: sub_403020 @ 0x403020 ==========
LRESULT __thiscall sub_403020(int this)
{
  LRESULT result; // eax

  *(_DWORD *)(this + 188) = SendMessageA(*(HWND *)(this + 796), 0x147u, 0, 0);
  *(_DWORD *)(this + 192) = SendMessageA(*(HWND *)(this + 676), 0x147u, 0, 0);
  *(_DWORD *)(this + 196) = SendMessageA(*(HWND *)(this + 616), 0x147u, 0, 0);
  *(_DWORD *)(this + 200) = SendMessageA(*(HWND *)(this + 556), 0x147u, 0, 0);
  *(_DWORD *)(this + 204) = SendMessageA(*(HWND *)(this + 496), 0x147u, 0, 0);
  *(_DWORD *)(this + 208) = SendMessageA(*(HWND *)(this + 436), 0x147u, 0, 0);
  *(_DWORD *)(this + 212) = SendMessageA(*(HWND *)(this + 376), 0x147u, 0, 0);
  *(_DWORD *)(this + 216) = SendMessageA(*(HWND *)(this + 316), 0x147u, 0, 0);
  *(_DWORD *)(this + 220) = SendMessageA(*(HWND *)(this + 256), 0x147u, 0, 0);
  result = SendMessageA(*(HWND *)(this + 736), 0x147u, 0, 0);
  *(_DWORD *)(this + 224) = result;
  return result;
}


// ========== Function: sub_403120 @ 0x403120 ==========
void __thiscall sub_403120(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[154];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 147), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 3;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[154], 0x14Eu, hWnd[49], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 3);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_403450 @ 0x403450 ==========
void __thiscall sub_403450(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[139];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 132), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 4;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[139], 0x14Eu, hWnd[50], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 4);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: nullsub_2 @ 0x403780 ==========
void nullsub_2()
{
  ;
}


// ========== Function: sub_403790 @ 0x403790 ==========
void __thiscall sub_403790(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[124];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 117), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 5;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[124], 0x14Eu, hWnd[51], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 5);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_403AC0 @ 0x403AC0 ==========
void __thiscall sub_403AC0(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[109];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 102), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 6;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[109], 0x14Eu, hWnd[52], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 6);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_403DF0 @ 0x403DF0 ==========
void __thiscall sub_403DF0(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[94];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 87), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 7;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[94], 0x14Eu, hWnd[53], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 7);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_404120 @ 0x404120 ==========
void __thiscall sub_404120(_DWORD *this)
{
  *this = off_433548;
}


// ========== Function: sub_404130 @ 0x404130 ==========
void __thiscall sub_404130(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[79];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 72), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 8;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[79], 0x14Eu, hWnd[54], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 8);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_404460 @ 0x404460 ==========
void __thiscall sub_404460(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[64];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 57), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[184], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 177), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 9;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[64], 0x14Eu, hWnd[55], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 9);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_404790 @ 0x404790 ==========
void __thiscall sub_404790(_DWORD *hWnd)
{
  HWND v2; // eax
  LRESULT v3; // eax
  HWND v4; // eax
  LRESULT v5; // eax
  BOOL v6; // ebp
  LRESULT v7; // eax
  LRESULT v8; // eax
  LRESULT v9; // eax
  LRESULT v10; // eax
  LRESULT v11; // eax
  LRESULT v12; // eax
  LRESULT v13; // eax
  LRESULT v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // [esp-8h] [ebp-2Ch] BYREF
  int v17; // [esp-4h] [ebp-28h]
  unsigned __int8 *Str2; // [esp+Ch] [ebp-18h] BYREF
  unsigned __int8 *Str1[2]; // [esp+10h] [ebp-14h] BYREF
  int v20; // [esp+20h] [ebp-4h]

  Str1[0] = (unsigned __int8 *)off_433548;
  v20 = 0;
  Str2 = (unsigned __int8 *)off_433548;
  v2 = (HWND)hWnd[184];
  LOBYTE(v20) = 1;
  v3 = SendMessageA(v2, 0x147u, 0, 0);
  CComboBox::GetLBText((CComboBox *)(hWnd + 177), v3, (struct CString *)Str1);
  v4 = (HWND)_mbscmp(Str1[0], (const unsigned __int8 *)byte_4330C4);
  if ( v4 )
  {
    v5 = SendMessageA((HWND)hWnd[199], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 192), v5, (struct CString *)&Str2);
    v6 = _mbscmp(Str1[0], Str2) != 0;
    v7 = SendMessageA((HWND)hWnd[169], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 162), v7, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v8 = SendMessageA((HWND)hWnd[154], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 147), v8, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v9 = SendMessageA((HWND)hWnd[139], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 132), v9, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v10 = SendMessageA((HWND)hWnd[124], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 117), v10, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v11 = SendMessageA((HWND)hWnd[109], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 102), v11, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v12 = SendMessageA((HWND)hWnd[94], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 87), v12, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v13 = SendMessageA((HWND)hWnd[79], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 72), v13, (struct CString *)&Str2);
    if ( !_mbscmp(Str1[0], Str2) )
      v6 = 0;
    v14 = SendMessageA((HWND)hWnd[64], 0x147u, 0, 0);
    CComboBox::GetLBText((CComboBox *)(hWnd + 57), v14, (struct CString *)&Str2);
    if ( _mbscmp(Str1[0], Str2) && v6 )
    {
      sub_403020((int)hWnd);
      v17 = 10;
      v16 = v15;
      Str1[1] = (unsigned __int8 *)&v16;
      sub_41FE52((CString *)&v16, Str1);
      sub_402250(hWnd, v16, v17);
    }
    else
    {
      sub_41EDA1(&Text, 0, 0);
      SendMessageA((HWND)hWnd[184], 0x14Eu, hWnd[56], 0);
    }
  }
  else
  {
    if ( hWnd )
      v4 = (HWND)hWnd[7];
    UnregisterHotKey(v4, 10);
    sub_403020((int)hWnd);
  }
  LOBYTE(v20) = 0;
  sub_4200DD(&Str2);
  v20 = -1;
  sub_4200DD(Str1);
}


// ========== Function: sub_404AC0 @ 0x404AC0 ==========
void __thiscall sub_404AC0(int *this)
{
  CHAR *v2; // eax
  struct CWinThread *Thread; // eax
  struct CWnd *v4; // eax
  int v5; // eax
  int *v6; // esi
  int v7; // edi
  char *v8; // [esp+4h] [ebp-224h] BYREF
  LPCSTR lpPathName; // [esp+8h] [ebp-220h] BYREF
  _BYTE v10[4]; // [esp+Ch] [ebp-21Ch] BYREF
  _BYTE v11[20]; // [esp+10h] [ebp-218h] BYREF
  _BYTE v12[172]; // [esp+24h] [ebp-204h] BYREF
  _BYTE v13[332]; // [esp+D0h] [ebp-158h] BYREF
  int v14; // [esp+224h] [ebp-4h]

  lpPathName = (LPCSTR)off_433548;
  v14 = 0;
  v2 = (CHAR *)sub_42034E(260);
  GetCurrentDirectoryA(0x104u, v2);
  Thread = AfxGetThread();
  if ( Thread )
    v4 = (struct CWnd *)(*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 116))(Thread);
  else
    v4 = 0;
  sub_41B03B(0, 0, 0, 6, (int)&unk_433254, v4);
  LOBYTE(v14) = 1;
  if ( sub_41B19D((struct CWnd *)v12) == 1 )
  {
    v8 = (char *)off_433548;
    LOBYTE(v14) = 2;
    v5 = sub_41B278(v10);
    LOBYTE(v14) = 3;
    sub_4201D2((CString *)&v8, v5);
    LOBYTE(v14) = 2;
    sub_4200DD(v10);
    if ( sub_41ACA2((unsigned __int8 *)Substr) == -1 )
      sub_420327(Substr);
    CStdioFile::CStdioFile((CStdioFile *)v11);
    LOBYTE(v14) = 4;
    if ( CStdioFile::Open((CStdioFile *)v11, v8, 0x1001u, 0) )
    {
      v6 = this + 47;
      v7 = 10;
      do
      {
        sub_41B028((int)&v8, &byte_433250, *v6);
        CStdioFile::WriteString((CStdioFile *)v11, v8);
        ++v6;
        --v7;
      }
      while ( v7 );
      CStdioFile::Close((CStdioFile *)v11);
    }
    LOBYTE(v14) = 2;
    CStdioFile::~CStdioFile((CStdioFile *)v11);
    LOBYTE(v14) = 1;
    sub_4200DD(&v8);
  }
  SetCurrentDirectoryA(lpPathName);
  LOBYTE(v14) = 5;
  sub_4200DD(v13);
  LOBYTE(v14) = 0;
  sub_41CC1E(v12);
  v14 = -1;
  sub_4200DD(&lpPathName);
}


// ========== Function: sub_404CE0 @ 0x404CE0 ==========
LPVOID __thiscall sub_404CE0(LPVOID lpMem, char a2)
{
  sub_404D00();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_404D00 @ 0x404D00 ==========
int __thiscall sub_404D00(_DWORD *this)
{
  *this = &CGdiObject::`vftable';
  return sub_422A21(this);
}


// ========== Function: sub_404D40 @ 0x404D40 ==========
LPVOID __thiscall sub_404D40(LPVOID lpMem, char a2)
{
  sub_404D60();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_404D60 @ 0x404D60 ==========
int __thiscall sub_404D60(_DWORD *this)
{
  *this = &CGdiObject::`vftable';
  return sub_422A21(this);
}


// ========== Function: sub_404DA0 @ 0x404DA0 ==========
BOOL __thiscall sub_404DA0(HWND *this)
{
  return EnableWindow(this[7], 0);
}


// ========== Function: sub_404DB0 @ 0x404DB0 ==========
BOOL __thiscall sub_404DB0(HWND *this)
{
  return EnableWindow(this[7], 1);
}


// ========== Function: sub_404DC0 @ 0x404DC0 ==========
LPVOID __thiscall sub_404DC0(LPVOID lpMem, char a2)
{
  sub_423995(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_404DE0 @ 0x404DE0 ==========
// attributes: thunk
int __thiscall sub_404DE0(void *this)
{
  return sub_41CC1E(this);
}


// ========== Function: sub_404DF0 @ 0x404DF0 ==========
_DWORD *sub_404DF0()
{
  _DWORD *v0; // esi
  _DWORD *result; // eax

  v0 = (_DWORD *)sub_41CA70(0x3Cu);
  result = 0;
  if ( v0 )
  {
    sub_41D43B(v0);
    *v0 = &off_429900;
    return v0;
  }
  return result;
}


// ========== Function: sub_404E40 @ 0x404E40 ==========
char **sub_404E40()
{
  return &off_4299D8;
}


// ========== Function: sub_404E50 @ 0x404E50 ==========
int __thiscall sub_404E50(void *this, int a2, int a3, int a4, int a5, int a6)
{
  return sub_42067C(this, 104, 1, 0, 0, &unk_4332DC, a2, a3, a4, a5, a6);
}


// ========== Function: sub_404E90 @ 0x404E90 ==========
int __stdcall sub_404E90(LPVOID lpMem)
{
  return sub_41CA99(lpMem);
}


// ========== Function: sub_404EA0 @ 0x404EA0 ==========
int sub_404EA0()
{
  struct CWinThread *Thread; // eax

  Thread = AfxGetThread();
  if ( Thread )
    return (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 116))(Thread);
  else
    return 0;
}


// ========== Function: ??_9@$BMI@A @ 0x404EBC ==========
int __thiscall  `vcall'{200,{flat}}(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 200))(this);
}


// ========== Function: sub_404EC4 @ 0x404EC4 ==========
BOOL sub_404EC4()
{
  BOOL result; // eax
  HMODULE ModuleHandleA; // eax
  HMODULE v2; // edi

  if ( dword_438CC8 )
    return GetMonitorInfoA != 0;
  ModuleHandleA = GetModuleHandleA("USER32");
  v2 = ModuleHandleA;
  if ( ModuleHandleA
    && (GetSystemMetrics_0 = (int (__stdcall *)(int))GetProcAddress(ModuleHandleA, "GetSystemMetrics")) != 0
    && (MonitorFromWindow = (HMONITOR (__stdcall *)(HWND, DWORD))GetProcAddress(v2, "MonitorFromWindow")) != 0
    && (MonitorFromRect = (HMONITOR (__stdcall *)(LPCRECT, DWORD))GetProcAddress(v2, "MonitorFromRect")) != 0
    && (MonitorFromPoint = (HMONITOR (__stdcall *)(POINT, DWORD))GetProcAddress(v2, "MonitorFromPoint")) != 0
    && (EnumDisplayMonitors = (BOOL (__stdcall *)(HDC, LPCRECT, MONITORENUMPROC, LPARAM))GetProcAddress(
                                                                                           v2,
                                                                                           "EnumDisplayMonitors")) != 0
    && (GetMonitorInfoA = (BOOL (__stdcall *)(HMONITOR, LPMONITORINFO))GetProcAddress(v2, "GetMonitorInfoA")) != 0 )
  {
    result = 1;
    dword_438CC8 = 1;
  }
  else
  {
    GetSystemMetrics_0 = 0;
    MonitorFromWindow = 0;
    MonitorFromRect = 0;
    MonitorFromPoint = 0;
    GetMonitorInfoA = 0;
    EnumDisplayMonitors = 0;
    dword_438CC8 = 1;
    return 0;
  }
  return result;
}


// ========== Function: sub_404F9C @ 0x404F9C ==========
HMONITOR __stdcall sub_404F9C(const RECT *a1, DWORD a2)
{
  if ( sub_404EC4() )
    return MonitorFromRect(a1, a2);
  if ( (a2 & 3) != 0
    || a1->right > 0 && a1->bottom > 0 && a1->left < GetSystemMetrics(0) && a1->top < GetSystemMetrics(1) )
  {
    return (HMONITOR)305397826;
  }
  return 0;
}


// ========== Function: _xMonitorFromWindow@8 @ 0x404FF2 ==========
HMONITOR __stdcall xMonitorFromWindow(HWND hWnd, DWORD dwFlags)
{
  BOOL WindowPlacement; // eax
  WINDOWPLACEMENT wndpl; // [esp+0h] [ebp-2Ch] BYREF

  if ( sub_404EC4() )
    return MonitorFromWindow(hWnd, dwFlags);
  if ( (dwFlags & 3) != 0 )
    return (HMONITOR)305397826;
  if ( IsIconic(hWnd) )
    WindowPlacement = GetWindowPlacement(hWnd, &wndpl);
  else
    WindowPlacement = GetWindowRect(hWnd, &wndpl.rcNormalPosition);
  if ( WindowPlacement )
    return sub_404F9C(&wndpl.rcNormalPosition, dwFlags);
  else
    return 0;
}


// ========== Function: sub_40505D @ 0x40505D ==========
BOOL __stdcall sub_40505D(HMONITOR a1, LPMONITORINFO a2)
{
  int SystemMetrics; // eax
  bool v4; // cf
  _DWORD pvParam[4]; // [esp+8h] [ebp-10h] BYREF

  if ( sub_404EC4() )
    return GetMonitorInfoA(a1, a2);
  if ( a1 != (HMONITOR)305397826 || !a2 || a2->cbSize < 0x28 || !SystemParametersInfoA(0x30u, 0, pvParam, 0) )
    return 0;
  a2->rcMonitor.left = 0;
  a2->rcMonitor.top = 0;
  a2->rcMonitor.right = GetSystemMetrics(0);
  SystemMetrics = GetSystemMetrics(1);
  a2->rcWork.left = pvParam[0];
  a2->rcWork.top = pvParam[1];
  a2->rcWork.right = pvParam[2];
  v4 = a2->cbSize < 0x48;
  a2->rcWork.bottom = pvParam[3];
  a2->rcMonitor.bottom = SystemMetrics;
  a2->dwFlags = 1;
  if ( !v4 )
    lstrcpyA((LPSTR)&a2[1], "DISPLAY");
  return 1;
}


// ========== Function: ?GetOwner@CWnd@@QBEPAV1@XZ @ 0x4050F0 ==========
struct CWnd *__thiscall CWnd::GetOwner(CWnd *this)
{
  HWND Parent; // eax

  Parent = (HWND)*((_DWORD *)this + 8);
  if ( !Parent )
    Parent = GetParent(*((HWND *)this + 7));
  return (struct CWnd *)sub_41D866(Parent);
}


// ========== Function: sub_405114 @ 0x405114 ==========
int sub_405114()
{
  nullsub_6();
  return atexit(sub_40512B);
}


// ========== Function: nullsub_6 @ 0x40511E ==========
void nullsub_6()
{
  ;
}


// ========== Function: sub_40512B @ 0x40512B ==========
void __stdcall sub_40512B(int a1)
{
  JUMPOUT(0x424EA0);
}


// ========== Function: ?AfxEnableControlContainer@@YAXPAVCOccManager@@@Z @ 0x40513A ==========
void __cdecl AfxEnableControlContainer(struct COccManager *a1)
{
  struct COccManager *v1; // esi

  v1 = a1;
  if ( !a1 )
    v1 = (struct COccManager *)sub_424E45(sub_405A0D);
  *((_DWORD *)AfxGetModuleState() + 1038) = v1;
}


// ========== Function: sub_405161 @ 0x405161 ==========
char __stdcall sub_405161(int *a1)
{
  int v1; // ebx
  __int16 *v2; // eax
  __int16 v3; // cx
  __int16 v4; // cx

  v1 = *a1;
  if ( *((_WORD *)a1 + 1) == 0xFFFF )
  {
    v1 = a1[3];
    v2 = (__int16 *)a1 + 13;
  }
  else
  {
    v2 = (__int16 *)a1 + 9;
  }
  v3 = *v2;
  if ( *v2 == -1 )
  {
    v2 += 2;
  }
  else
  {
    while ( 1 )
    {
      ++v2;
      if ( !v3 )
        break;
      v3 = *v2;
    }
  }
  v4 = *v2;
  if ( *v2 == -1 )
  {
    v2 += 2;
  }
  else
  {
    while ( 1 )
    {
      ++v2;
      if ( !v4 )
        break;
      v4 = *v2;
    }
  }
  while ( *v2++ )
    ;
  if ( (v1 & 0x40) != 0 )
  {
    v2 += *((_WORD *)a1 + 1) == 0xFFFF ? 3 : 1;
    while ( *v2++ )
      ;
  }
  return ((_BYTE)v2 + 3) & 0xFC;
}


// ========== Function: sub_4051E7 @ 0x4051E7 ==========
char __stdcall sub_4051E7(int a1, int a2)
{
  __int16 *v2; // eax
  __int16 v3; // cx
  __int16 v4; // cx

  if ( a2 )
    v2 = (__int16 *)(a1 + 24);
  else
    v2 = (__int16 *)(a1 + 18);
  v3 = *v2;
  if ( *v2 == -1 )
  {
    v2 += 2;
  }
  else
  {
    while ( 1 )
    {
      ++v2;
      if ( !v3 )
        break;
      v3 = *v2;
    }
  }
  v4 = *v2;
  if ( *v2 == -1 )
  {
    v2 += 2;
  }
  else
  {
    while ( 1 )
    {
      ++v2;
      if ( !v4 )
        break;
      v4 = *v2;
    }
  }
  return (*v2 + (_BYTE)v2 + 5) & 0xFC;
}


// ========== Function: ?OnEvent@COccManager@@UAEHPAVCCmdTarget@@IPAUAFX_EVENT@@PAUAFX_CMDHANDLERINFO@@@Z @ 0x40523B ==========
int __thiscall COccManager::OnEvent(
        COccManager *this,
        struct CCmdTarget *a2,
        unsigned int a3,
        struct AFX_EVENT *a4,
        struct AFX_CMDHANDLERINFO *a5)
{
  return sub_406C3E(a3, a4, a5);
}


// ========== Function: ?CreateContainer@COccManager@@UAEPAVCOleControlContainer@@PAVCWnd@@@Z @ 0x405253 ==========
struct COleControlContainer *__thiscall COccManager::CreateContainer(COccManager *this, struct CWnd *a2)
{
  COleControlContainer *v2; // ecx
  struct COleControlContainer *result; // eax

  v2 = (COleControlContainer *)sub_41CA70(0x54u);
  result = 0;
  if ( v2 )
    return COleControlContainer::COleControlContainer(v2, a2);
  return result;
}


// ========== Function: sub_40528A @ 0x40528A ==========
COleControlSite *__stdcall sub_40528A(struct COleControlContainer *a1)
{
  COleControlSite *v1; // ecx
  COleControlSite *result; // eax

  v1 = (COleControlSite *)sub_41CA70(0xDCu);
  result = 0;
  if ( v1 )
    return COleControlSite::COleControlSite(v1, a1);
  return result;
}


// ========== Function: ?PreCreateDialog@COccManager@@UAEPBUDLGTEMPLATE@@PAU_AFX_OCC_DIALOG_INFO@@PBU2@@Z @ 0x4052C4 ==========
const struct DLGTEMPLATE *__thiscall COccManager::PreCreateDialog(
        COccManager *this,
        struct _AFX_OCC_DIALOG_INFO *a2,
        const struct DLGTEMPLATE *a3)
{
  unsigned __int16 *p_cy; // eax
  const struct DLGTEMPLATE *result; // eax

  p_cy = (unsigned __int16 *)&a3->cy;
  if ( HIWORD(a3->style) != 0xFFFF )
    p_cy = &a3->cdit;
  result = (const struct DLGTEMPLATE *)malloc(4 * *p_cy + 4);
  *((_DWORD *)a2 + 1) = result;
  if ( result )
  {
    result = (const struct DLGTEMPLATE *)(*(int (__thiscall **)(COccManager *, const struct DLGTEMPLATE *, const struct DLGTEMPLATE *))(*(_DWORD *)this + 24))(
                                           this,
                                           a3,
                                           result);
    *(_DWORD *)a2 = result;
    if ( !result )
      return a3;
  }
  return result;
}


// ========== Function: ?PostCreateDialog@COccManager@@UAEXPAU_AFX_OCC_DIALOG_INFO@@@Z @ 0x40530E ==========
void __thiscall COccManager::PostCreateDialog(COccManager *this, HGLOBAL *a2)
{
  HGLOBAL v2; // esi

  if ( *a2 )
    GlobalFree(*a2);
  v2 = a2[1];
  if ( v2 )
    sub_40D386(v2);
}


// ========== Function: sub_405332 @ 0x405332 ==========
_WORD *__stdcall sub_405332(int *Src, char **a2)
{
  char *v2; // eax
  size_t v3; // ebx
  char *v4; // eax
  char *v5; // eax
  int v6; // esi
  char *v7; // edi
  int v8; // eax
  _WORD *v9; // ecx
  _WORD *v11; // edi
  _WORD *v12; // eax
  char *v13; // ebx
  char *v14; // eax
  char *v15; // esi
  _WORD *v16; // eax
  size_t v17; // esi
  _WORD *v18; // eax
  bool v19; // zf
  char *v20; // [esp+Ch] [ebp-14h]
  char *v21; // [esp+10h] [ebp-10h]
  char *v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  char *v24; // [esp+14h] [ebp-Ch]
  SIZE_T dwBytes; // [esp+18h] [ebp-8h]
  char *dwBytesa; // [esp+18h] [ebp-8h]
  BOOL v27; // [esp+1Ch] [ebp-4h]
  char **Srca; // [esp+28h] [ebp+8h]

  LOBYTE(v2) = sub_405161(Src);
  v21 = (char *)v2;
  v3 = (char *)v2 - (char *)Src;
  dwBytes = (char *)v2 - (char *)Src;
  v27 = *((_WORD *)Src + 1) == 0xFFFF;
  v4 = (char *)(Src + 4);
  if ( *((_WORD *)Src + 1) != 0xFFFF )
    v4 = (char *)(Src + 2);
  v5 = (char *)*(unsigned __int16 *)v4;
  v23 = 0;
  v6 = (int)v21;
  v20 = v5;
  if ( !v5 )
    goto LABEL_12;
  v7 = v5;
  do
  {
    LOBYTE(v8) = sub_4051E7(v6, v27);
    v9 = (_WORD *)(v6 + 24);
    if ( !v27 )
      v9 = (_WORD *)(v6 + 18);
    if ( *v9 == 123 )
      v23 = 1;
    else
      dwBytes += v8 - v6;
    --v7;
    v6 = v8;
  }
  while ( v7 );
  if ( v23 )
  {
    v11 = GlobalAlloc(0, dwBytes);
    memcpy(v11, Src, v3);
    dwBytesa = (char *)v11 + v3;
    v12 = v11 + 8;
    if ( v11[1] != 0xFFFF )
      v12 = v11 + 4;
    *v12 = 0;
    v13 = v21;
    Srca = (char **)a2;
    v22 = v20;
    do
    {
      LOBYTE(v14) = sub_4051E7((int)v13, v27);
      v15 = v14;
      v24 = v14;
      v16 = v13 + 24;
      if ( !v27 )
        v16 = v13 + 18;
      if ( *v16 == 123 )
      {
        *Srca = v13;
      }
      else
      {
        v17 = v15 - v13;
        memcpy(dwBytesa, v13, v17);
        dwBytesa += v17;
        v18 = v11 + 8;
        if ( v11[1] != 0xFFFF )
          v18 = v11 + 4;
        ++*v18;
        *Srca = 0;
      }
      ++Srca;
      v19 = v22-- == (char *)1;
      v13 = v24;
    }
    while ( !v19 );
    a2[(_DWORD)v20] = -1;
    return v11;
  }
  else
  {
LABEL_12:
    *a2 = -1;
    return 0;
  }
}


// ========== Function: sub_405471 @ 0x405471 ==========
int __thiscall sub_405471(void *this, int a2, LPCSTR lpName, int a4)
{
  LPVOID v4; // edi
  HMODULE v6; // esi
  HRSRC ResourceA; // eax
  int result; // eax

  v4 = 0;
  if ( lpName )
  {
    v6 = (HMODULE)*((_DWORD *)AfxGetModuleState() + 3);
    ResourceA = FindResourceA(v6, lpName, (LPCSTR)0xF0);
    if ( ResourceA )
    {
      result = (int)LoadResource(v6, ResourceA);
      if ( !result )
        return result;
      v4 = LockResource((HGLOBAL)result);
    }
  }
  result = 1;
  if ( v4 )
    return (*(int (__thiscall **)(void *, int, LPVOID, int))(*(_DWORD *)this + 28))(this, a2, v4, a4);
  return result;
}


// ========== Function: sub_4054CC @ 0x4054CC ==========
int __stdcall sub_4054CC(int a1, unsigned __int8 *a2, HWND *hWnd)
{
  HWND Parent; // eax
  int v5; // esi
  unsigned __int8 *v6; // edi
  HWND v7; // ecx
  _WORD *v8; // edi
  unsigned int v9; // edx
  unsigned __int8 *v10; // edi
  DWORD *v11; // esi
  int v12; // edx
  DWORD **v13; // ebx
  HWND Window; // eax
  HWND v15; // ebx
  COleControlContainer *v16; // ecx
  HWND v17; // [esp+4h] [ebp-1Ch]
  HWND v18; // [esp+8h] [ebp-18h]
  unsigned int v19; // [esp+10h] [ebp-10h]
  OLECHAR *bstrString; // [esp+14h] [ebp-Ch]
  HWND v21; // [esp+18h] [ebp-8h]
  int v22; // [esp+1Ch] [ebp-4h]
  int v23; // [esp+2Ch] [ebp+Ch]
  HWND hWnda; // [esp+30h] [ebp+10h]

  Parent = *hWnd;
  if ( !*hWnd )
    return 1;
  v5 = a1;
  if ( a1 )
    v21 = *(HWND *)(a1 + 28);
  else
    v21 = 0;
  v6 = a2;
  v22 = 1;
  bstrString = (OLECHAR *)(*((_WORD *)Parent + 1) == 0xFFFF);
  if ( a2 )
  {
    v7 = hWnd[1];
    v23 = 0;
    v18 = v7;
    hWnda = 0;
    while ( *(_WORD *)v6 )
    {
      v8 = v6 + 2;
      LOWORD(Parent) = *v8++;
      v17 = Parent;
      v9 = *(_DWORD *)v8;
      v10 = (unsigned __int8 *)(v8 + 2);
      v19 = v9;
      if ( (_WORD)Parent == 886
        || (_WORD)Parent == 890
        || (_WORD)Parent == 887
        || (_WORD)Parent == 891
        || (_WORD)Parent == 888 )
      {
        v11 = (DWORD *)*((_DWORD *)v7 + v23);
        v12 = ++v23;
        if ( !v11 )
        {
          v13 = (DWORD **)(v7 + v12);
          do
          {
            if ( hWnda )
              Window = GetWindow(hWnda, 2u);
            else
              Window = GetWindow(v21, 5u);
            v11 = *v13;
            ++v23;
            ++v13;
            hWnda = Window;
          }
          while ( !v11 );
          Parent = v17;
        }
        if ( v11 == (DWORD *)-1
          || (Parent = (HWND)sub_405742(a1, hWnda, bstrString, (COleControlSite *)v11, (int)Parent, v10, v19),
              (v15 = Parent) == 0) )
        {
          v22 = 0;
        }
        else
        {
          if ( bstrString )
            SetWindowContextHelpId(Parent, *v11);
          Parent = GetParent(v15);
          if ( Parent == v21 )
            hWnda = v15;
        }
      }
      v6 = &v10[v19];
      if ( !v22 )
        break;
      v7 = v18;
    }
    if ( !v22 )
      return v22;
    v5 = a1;
  }
  v16 = *(COleControlContainer **)(v5 + 52);
  if ( v16 )
    COleControlContainer::FreezeAllEvents(v16, 0);
  sub_405627(v5);
  return v22;
}


// ========== Function: sub_405627 @ 0x405627 ==========
int __stdcall sub_405627(int a1)
{
  int v1; // edi
  int result; // eax
  CDataBoundProperty *i; // esi
  unsigned __int16 v4; // ax
  int v5; // eax
  unsigned __int16 v6; // ax
  int v7; // esi
  bool v8; // zf
  int v9; // ecx
  char v10[4]; // [esp+4h] [ebp-8h] BYREF
  int v11; // [esp+8h] [ebp-4h] BYREF

  v1 = a1;
  result = *(_DWORD *)(a1 + 52);
  if ( result )
  {
    v11 = -(*(_DWORD *)(result + 44) != 0);
    while ( v11 )
    {
      sub_41BD8F(&v11, v10, &a1);
      for ( i = *(CDataBoundProperty **)(a1 + 140); i; i = (CDataBoundProperty *)sub_40B52C(*(_DWORD *)(a1 + 140)) )
      {
        unknown_libname_9(a1);
        v4 = *((_WORD *)i + 2);
        if ( v4 )
        {
          v5 = sub_420432(v4);
          CDataBoundProperty::SetDSCSite(i, *(struct COleControlSite **)(v5 + 56));
        }
      }
      v6 = *(_WORD *)(a1 + 144);
      if ( v6 )
      {
        v7 = sub_420432(v6);
        (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(v7 + 56) + 176))(*(_DWORD *)(v7 + 56));
        *(_DWORD *)(a1 + 144) = *(_DWORD *)(v7 + 56);
        (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(*(_DWORD *)(v7 + 56) + 136) + 8))(
          *(_DWORD *)(*(_DWORD *)(v7 + 56) + 136),
          a1,
          1);
      }
    }
    result = -(*(_DWORD *)(*(_DWORD *)(v1 + 52) + 44) != 0);
    v8 = *(_DWORD *)(*(_DWORD *)(v1 + 52) + 44) == 0;
    v11 = result;
    if ( !v8 )
    {
      do
      {
        sub_41BD8F(&v11, v10, &a1);
        result = a1;
        v9 = *(_DWORD *)(a1 + 136);
        if ( v9 )
          result = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 12))(v9);
      }
      while ( v11 );
    }
  }
  return result;
}


// ========== Function: sub_405742 @ 0x405742 ==========
HWND __stdcall sub_405742(
        int a1,
        HWND hWndInsertAfter,
        BSTR bstrString,
        HWND *a4,
        int a5,
        const OLECHAR *a6,
        unsigned int a7)
{
  COleControlSite *v7; // edi
  HWND v8; // ebx
  __int16 v9; // ax
  __int16 v10; // dx
  __int16 v11; // ax
  LONG v12; // edx
  int v13; // ecx
  LONG v14; // esi
  unsigned __int8 *v15; // esi
  UINT v16; // ebx
  BSTR v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  const CHAR *v22; // esi
  HWND v23; // eax
  int v24; // eax
  void *v25; // eax
  struct CDataBoundProperty *v26; // eax
  unsigned __int8 *v27; // eax
  _BYTE *v28; // esi
  HWND v30; // [esp-Ch] [ebp-A0h]
  _BYTE v31[40]; // [esp+8h] [ebp-8Ch] BYREF
  _DWORD v32[2]; // [esp+30h] [ebp-64h] BYREF
  __int16 v33; // [esp+38h] [ebp-5Ch]
  __int16 v34; // [esp+3Ah] [ebp-5Ah]
  __int16 v35; // [esp+3Ch] [ebp-58h]
  __int16 v36; // [esp+3Eh] [ebp-56h]
  __int16 v37; // [esp+40h] [ebp-54h]
  CLSID pclsid; // [esp+44h] [ebp-50h] BYREF
  struct tagRECT Rect; // [esp+54h] [ebp-40h] BYREF
  LPVOID lpMem; // [esp+64h] [ebp-30h]
  int v41; // [esp+68h] [ebp-2Ch]
  int v42; // [esp+6Ch] [ebp-28h]
  HWND v43; // [esp+70h] [ebp-24h]
  HWND v44; // [esp+74h] [ebp-20h]
  HWND v45; // [esp+78h] [ebp-1Ch]
  LPCOLESTR lpsz; // [esp+7Ch] [ebp-18h]
  struct CDataBoundProperty *v47; // [esp+80h] [ebp-14h]
  int v48; // [esp+84h] [ebp-10h] BYREF
  int v49; // [esp+90h] [ebp-4h]
  OLECHAR *bstrStringa; // [esp+A4h] [ebp+10h]

  v7 = (COleControlSite *)a4;
  v8 = 0;
  lpsz = (LPCOLESTR)a4 + 9;
  if ( bstrString )
  {
    v9 = *((_WORD *)a4 + 9);
    v32[0] = a4[2];
    v32[1] = a4[1];
    v33 = *((_WORD *)a4 + 6);
    v34 = *((_WORD *)a4 + 7);
    v10 = *((_WORD *)a4 + 8);
    v36 = v9;
    v11 = *((_WORD *)a4 + 10);
    v35 = v10;
    v37 = v11;
    v7 = (COleControlSite *)v32;
    lpsz = (LPCOLESTR)(a4 + 6);
  }
  v12 = *((__int16 *)v7 + 5);
  v13 = *((__int16 *)v7 + 6);
  v14 = *((__int16 *)v7 + 4);
  Rect.bottom = v12 + *((__int16 *)v7 + 7);
  Rect.left = v14;
  v30 = *(HWND *)(a1 + 28);
  Rect.top = v12;
  Rect.right = v14 + v13;
  MapDialogRect(v30, &Rect);
  v15 = (unsigned __int8 *)a6;
  bstrStringa = 0;
  if ( a7 >= 4 )
  {
    v16 = *(_DWORD *)a6;
    a7 -= 4;
    v15 = (unsigned __int8 *)(a6 + 2);
    if ( v16 )
    {
      v17 = SysAllocStringLen(a6 + 2, v16);
      v18 = 2 * v16;
      bstrStringa = v17;
      v15 += v18;
      a7 -= v18;
    }
    v8 = 0;
  }
  v47 = 0;
  v48 = (int)off_433548;
  v49 = 0;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  if ( (_WORD)a5 == 890 || (_WORD)a5 == 891 )
  {
    v19 = *(_DWORD *)v15;
    v15 += 12;
    v41 = v19;
    a6 = (const OLECHAR *)(v19 - 12);
    if ( v19 != 12 )
    {
      do
      {
        v20 = *(_DWORD *)v15;
        LOWORD(v8) = *((_WORD *)v15 + 2);
        a6 -= 3;
        v42 = v20;
        v15 += 6;
        if ( v20 == -2147418111 )
        {
          v21 = *(_DWORD *)v15;
          v22 = (const CHAR *)(v15 + 4);
          v44 = (HWND)v21;
          v23 = *(HWND *)v22;
          v22 += 12;
          v43 = v23;
          CString::operator=((CString *)&v48, v22);
          v45 = v8;
          v24 = *(_DWORD *)(v48 - 8);
          a6 = (const OLECHAR *)((char *)a6 - 17 - v24);
          v15 = (unsigned __int8 *)&v22[v24 + 1];
        }
        else
        {
          v25 = (void *)sub_41CA70(0x1Cu);
          lpMem = v25;
          LOBYTE(v49) = 1;
          if ( v25 )
            v26 = CDataBoundProperty::CDataBoundProperty((CDataBoundProperty *)v25, v47, v42, (unsigned __int16)v8);
          else
            v26 = 0;
          LOBYTE(v49) = 0;
          v47 = v26;
        }
      }
      while ( a6 );
      v19 = v41;
      v8 = 0;
    }
    a7 -= v19;
    a5 += 65532;
  }
  if ( *lpsz == 123 )
    v27 = (unsigned __int8 *)CLSIDFromString(lpsz, &pclsid);
  else
    v27 = (unsigned __int8 *)CLSIDFromProgID(lpsz, &pclsid);
  a6 = (const OLECHAR *)v27;
  CMemFile::CMemFile((CMemFile *)v31, v15, a7, 0);
  LOBYTE(v49) = 2;
  a4 = 0;
  v28 = (_WORD)a5 != 888 ? v31 : 0;
  if ( (int)a6 >= 0
    && sub_405AE4(a1)
    && sub_405CF2(
         0,
         (int)&pclsid,
         0,
         *(_DWORD *)v7,
         &Rect,
         *((unsigned __int16 *)v7 + 8),
         (int)v28,
         (_WORD)a5 == 887,
         (int)bstrStringa,
         (int)&a4) )
  {
    COleControlSite::FreezeEvents((COleControlSite *)a4, 1);
    SetWindowPos(a4[8], hWndInsertAfter, 0, 0, 0, 0, 0x13u);
    a4[35] = (HWND)v47;
    sub_4201D2((CString *)(a4 + 39), (int)&v48);
    *((_WORD *)a4 + 72) = (_WORD)v45;
    a4[37] = v44;
    a4[38] = v43;
  }
  if ( bstrStringa )
    SysFreeString(bstrStringa);
  if ( a4 )
    v8 = a4[8];
  LOBYTE(v49) = 0;
  CMemFile::~CMemFile((CMemFile *)v31);
  v49 = -1;
  sub_4200DD(&v48);
  return v8;
}


// ========== Function: sub_405A0D @ 0x405A0D ==========
_DWORD *sub_405A0D()
{
  _DWORD *result; // eax

  result = CNoTrackObject::operator new(4u);
  if ( !result )
    return 0;
  *result = &COccManager::`vftable';
  return result;
}


// ========== Function: sub_405A22 @ 0x405A22 ==========
HLOCAL __thiscall sub_405A22(HLOCAL hMem, char a2)
{
  nullsub_3();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_405A3D @ 0x405A3D ==========
int __stdcall sub_405A3D(int a1, int a2, int a3, RECT *lprcSrc, int a5, int a6, int a7, int a8, int a9)
{
  struct tagRECT rcDst; // [esp+4h] [ebp-20h] BYREF
  _DWORD v11[2]; // [esp+14h] [ebp-10h] BYREF
  _DWORD v12[2]; // [esp+1Ch] [ebp-8h] BYREF

  CopyRect(&rcDst, lprcSrc);
  v12[0] = rcDst.right - rcDst.left;
  v11[0] = rcDst.left;
  v11[1] = rcDst.top;
  v12[1] = rcDst.bottom - rcDst.top;
  return sub_405A9B(a1, a2, a3, v11, v12, a5, a6, a7, a8, a9);
}


// ========== Function: sub_405A9B @ 0x405A9B ==========
int __thiscall sub_405A9B(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  if ( a7 && sub_405AE4(a7) )
    return sub_405D53(this, a2, a3, a4, a5, a6, a8, a9, a10, a11, 0);
  else
    return 0;
}


// ========== Function: sub_405AE4 @ 0x405AE4 ==========
BOOL __thiscall sub_405AE4(_DWORD *this)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  HWND v3; // esi
  HWND Parent; // eax
  HWND v5; // eax
  HWND v7; // [esp-4h] [ebp-28h]
  int v8; // [esp+0h] [ebp-24h] BYREF
  _DWORD *v9; // [esp+10h] [ebp-14h]
  int *v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+20h] [ebp-4h]

  v11 = 0;
  v10 = &v8;
  v9 = this;
  if ( !this[13] )
  {
    ModuleState = AfxGetModuleState();
    this[13] = (*(int (__thiscall **)(_DWORD, _DWORD *))(**((_DWORD **)ModuleState + 1038) + 8))(
                 *((_DWORD *)ModuleState + 1038),
                 this);
  }
  v11 = -1;
  if ( this[13] )
  {
    v3 = (HWND)this;
    if ( this )
    {
      do
      {
        if ( ((_DWORD)v3[9] & 0x100) != 0 )
          break;
        v7 = (HWND)*((_DWORD *)v3 + 7);
        *((_DWORD *)v3 + 9) |= 0x100u;
        Parent = GetParent(v7);
        v5 = (HWND)sub_41D866(Parent);
        v3 = v5;
        if ( v5 )
          v5 = (HWND)*((_DWORD *)v5 + 7);
      }
      while ( (GetWindowLongA(v5, -16) & 0x40000000) != 0 && v3 );
    }
  }
  return this[13] != 0;
}


// ========== Function: sub_405B8D @ 0x405B8D ==========
_UNKNOWN **sub_405B8D()
{
  return &off_42A648;
}


// ========== Function: sub_405B93 @ 0x405B93 ==========
_UNKNOWN **sub_405B93()
{
  return &off_42A618;
}


// ========== Function: ??0COleControlContainer@@QAE@PAVCWnd@@@Z @ 0x405B99 ==========
COleControlContainer *__thiscall COleControlContainer::COleControlContainer(
        COleControlContainer *this,
        struct CWnd *a2)
{
  sub_41C5A3();
  *((_DWORD *)this + 7) = a2;
  sub_41BB56(10);
  *((_DWORD *)this + 15) = -1;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = &COleControlContainer::XOleIPFrame::`vftable';
  *((_DWORD *)this + 20) = &COleControlContainer::XOleContainer::`vftable';
  *(_DWORD *)this = &off_42A66C;
  return this;
}


// ========== Function: sub_405BF8 @ 0x405BF8 ==========
COleControlContainer *__thiscall sub_405BF8(COleControlContainer *lpMem, char a2)
{
  COleControlContainer::~COleControlContainer(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??1COleControlContainer@@UAE@XZ @ 0x405C14 ==========
void __thiscall COleControlContainer::~COleControlContainer(COleControlContainer *this)
{
  int v2; // eax
  bool v3; // zf
  int v4; // [esp+Ch] [ebp-18h] BYREF
  _DWORD *v5; // [esp+10h] [ebp-14h] BYREF
  int v6; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  *(_DWORD *)this = &off_42A66C;
  v2 = *((_DWORD *)this + 11);
  v7 = 1;
  v6 = -(v2 != 0);
  if ( v2 )
  {
    do
    {
      sub_41BD8F(&v6, &v4, &v5);
      if ( !v5[34] )
      {
        sub_41BD4D(v4);
        if ( v5 )
          (*(void (__thiscall **)(_DWORD *, int))(*v5 + 4))(v5, 1);
      }
    }
    while ( v6 );
  }
  v3 = *((_DWORD *)this + 11) == 0;
  v6 = -(*((_DWORD *)this + 11) != 0);
  if ( !v3 )
  {
    do
    {
      sub_41BD8F(&v6, &v4, &v5);
      if ( v5 )
        (*(void (__thiscall **)(_DWORD *, int))(*v5 + 4))(v5, 1);
    }
    while ( v6 );
  }
  sub_41BBDE((char *)this + 32);
  _AfxRelease((struct IUnknown **)this + 17);
  LOBYTE(v7) = 0;
  sub_41BC09((char *)this + 32);
  v7 = -1;
  sub_41C5BD(this);
}


// ========== Function: sub_405CF2 @ 0x405CF2 ==========
int __stdcall sub_405CF2(int a1, int a2, int a3, int a4, RECT *lprcSrc, int a6, int a7, int a8, int a9, int a10)
{
  struct tagRECT rcDst; // [esp+4h] [ebp-20h] BYREF
  _DWORD v12[2]; // [esp+14h] [ebp-10h] BYREF
  _DWORD v13[2]; // [esp+1Ch] [ebp-8h] BYREF

  CopyRect(&rcDst, lprcSrc);
  v13[0] = rcDst.right - rcDst.left;
  v12[0] = rcDst.left;
  v12[1] = rcDst.top;
  v13[1] = rcDst.bottom - rcDst.top;
  return sub_405D53(a1, a2, a3, a4, v12, v13, a6, a7, a8, a9, a10);
}


// ========== Function: sub_405D53 @ 0x405D53 ==========
BOOL __thiscall sub_405D53(
        void *this,
        int a2,
        IID *a3,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        ILockBytes *a9,
        IStorage *a10,
        unsigned __int16 *a11,
        _DWORD *a12)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  _DWORD *v13; // esi
  int v15; // eax
  BOOL v16; // edi
  int v17; // [esp+0h] [ebp-28h] BYREF
  int v18; // [esp+10h] [ebp-18h]
  void *v19; // [esp+14h] [ebp-14h]
  int *v20; // [esp+18h] [ebp-10h]
  int v21; // [esp+24h] [ebp-4h]

  v18 = 0;
  v21 = 0;
  v19 = this;
  v20 = &v17;
  ModuleState = AfxGetModuleState();
  v13 = (_DWORD *)(*(int (__thiscall **)(_DWORD, void *))(**((_DWORD **)ModuleState + 1038) + 12))(
                    *((_DWORD *)ModuleState + 1038),
                    v19);
  v21 = -1;
  if ( !v13 )
    return 0;
  v15 = sub_4071C2(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  v16 = v15 >= 0;
  if ( v15 < 0 )
  {
    (*(void (__thiscall **)(_DWORD *, int))(*v13 + 4))(v13, 1);
  }
  else
  {
    *(_DWORD *)sub_41BCFD(v13[8]) = v13;
    if ( a12 )
      *a12 = v13;
  }
  return v16;
}


// ========== Function: ?FindItem@COleControlContainer@@UBEPAVCOleControlSite@@I@Z @ 0x405E0E ==========
struct COleControlSite *__thiscall COleControlContainer::FindItem(COleControlContainer *this, unsigned int a2)
{
  bool v2; // zf
  _BYTE v4[4]; // [esp+4h] [ebp-Ch] BYREF
  int v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v2 = *((_DWORD *)this + 11) == 0;
  v6 = -(*((_DWORD *)this + 11) != 0);
  if ( v2 )
    return 0;
  while ( 1 )
  {
    sub_41BD8F(&v6, v4, &v5);
    if ( sub_4079C6(v5) == a2 )
      break;
    if ( !v6 )
      return 0;
  }
  return (struct COleControlSite *)v5;
}


// ========== Function: sub_405E58 @ 0x405E58 ==========
int __thiscall sub_405E58(int this, COleControlSite *a2, void *a3, _WORD *a4)
{
  void *v4; // edi
  _WORD *v6; // eax
  _WORD *v7; // eax
  _WORD *v8; // esi
  COLORREF BkColor; // eax
  _WORD *v10; // eax
  int v11; // esi
  struct CFont *Font; // eax
  _WORD *v13; // edi
  _WORD *v14; // esi
  COleControlSite *v15; // ecx
  _WORD *v16; // esi
  _WORD *v17; // esi
  void **v18; // ecx
  _WORD *v19; // esi
  int result; // eax
  HDC v21; // [esp-4h] [ebp-2Ch]
  _BYTE v22[4]; // [esp+8h] [ebp-20h] BYREF
  WPARAM wParam; // [esp+Ch] [ebp-1Ch]
  HDC hdc; // [esp+10h] [ebp-18h]
  int v25; // [esp+24h] [ebp-4h]

  v4 = a3;
  switch ( (unsigned int)a3 )
  {
    case 0xFFFFFD34:
      v8 = a4;
      *a4 = 2;
      v8[4] = dword_4392D4 || *(_DWORD *)(sub_425303() + 32);
      goto LABEL_22;
    case 0xFFFFFD35:
    case 0xFFFFFD36:
    case 0xFFFFFD3B:
    case 0xFFFFFD3E:
      v6 = a4;
      a4[4] = -1;
      *v6 = 11;
      goto LABEL_22;
    case 0xFFFFFD37:
      v14 = a4;
      v15 = a2;
      *a4 = 11;
      v14[4] = -(COleControlSite::IsDefaultButton(v15) != 0);
      goto LABEL_22;
    case 0xFFFFFD38:
    case 0xFFFFFD39:
    case 0xFFFFFD3A:
      v7 = a4;
      a4[4] = 0;
      *v7 = 11;
      goto LABEL_22;
    case 0xFFFFFD3D:
      a3 = off_433548;
      CString::LoadStringA((CString *)&a3, 0xF1C0u);
      v19 = a4;
      *a4 = 8;
      v25 = -1;
      *((_DWORD *)v19 + 2) = CString::AllocSysString((CString *)&a3);
      v18 = &a3;
      goto LABEL_21;
    case 0xFFFFFD3F:
      v16 = a4;
      *a4 = 3;
      *((_DWORD *)v16 + 2) = GetThreadLocale();
      goto LABEL_22;
    case 0xFFFFFD40:
    case 0xFFFFFD43:
      if ( *(_DWORD *)(this + 60) == -1 )
      {
        sub_4227D6(*(HWND *)(this + 28));
        SendMessageA(*(HWND *)(*(_DWORD *)(this + 28) + 28), 0x138u, wParam, *(_DWORD *)(*(_DWORD *)(this + 28) + 28));
        BkColor = GetBkColor(hdc);
        v21 = hdc;
        *(_DWORD *)(this + 60) = BkColor;
        *(_DWORD *)(this + 64) = GetTextColor(v21);
        sub_422848(v22);
      }
      v10 = a4;
      *a4 = 3;
      if ( v4 == (void *)-701 )
        v11 = *(_DWORD *)(this + 60);
      else
        v11 = *(_DWORD *)(this + 64);
      *((_DWORD *)v10 + 2) = v11;
      goto LABEL_22;
    case 0xFFFFFD41:
      if ( !*(_DWORD *)(this + 68) )
      {
        Font = CWnd::GetFont(*(CWnd **)(this + 28));
        sub_406060(Font);
        if ( !*(_DWORD *)(this + 68) )
          goto LABEL_23;
      }
      v13 = a4;
      *a4 = 9;
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(this + 68) + 4))(*(_DWORD *)(this + 68));
      *((_DWORD *)v13 + 2) = *(_DWORD *)(this + 68);
      goto LABEL_22;
    case 0xFFFFFD42:
      a2 = (COleControlSite *)off_433548;
      v17 = a4;
      *a4 = 8;
      v25 = -1;
      *((_DWORD *)v17 + 2) = CString::AllocSysString((CString *)&a2);
      v18 = (void **)&a2;
LABEL_21:
      sub_4200DD(v18);
LABEL_22:
      result = 1;
      break;
    default:
LABEL_23:
      result = 0;
      break;
  }
  return result;
}


// ========== Function: sub_406060 @ 0x406060 ==========
int __thiscall sub_406060(char *this, int a2)
{
  char *v2; // esi
  void ***v3; // eax
  int v4; // esi
  int v5; // eax
  void *v6; // esp
  int v7; // edi
  struct IUnknown **v8; // esi
  WCHAR v10[6]; // [esp+0h] [ebp-94h] BYREF
  int pv[4]; // [esp+Ch] [ebp-88h] BYREF
  SHORT v12; // [esp+1Ch] [ebp-78h]
  unsigned __int8 v13; // [esp+20h] [ebp-74h]
  unsigned __int8 v14; // [esp+21h] [ebp-73h]
  unsigned __int8 v15; // [esp+22h] [ebp-72h]
  unsigned __int8 v16; // [esp+23h] [ebp-71h]
  CHAR String[32]; // [esp+28h] [ebp-6Ch] BYREF
  tagFONTDESC FontDesc; // [esp+48h] [ebp-4Ch] BYREF
  char v19[8]; // [esp+68h] [ebp-2Ch] BYREF
  HDC hdc; // [esp+70h] [ebp-24h]
  void **v21; // [esp+7Ch] [ebp-18h] BYREF
  HGDIOBJ StockObject; // [esp+80h] [ebp-14h]
  char *v23; // [esp+84h] [ebp-10h]
  int v24; // [esp+90h] [ebp-4h]

  v2 = this;
  v23 = this;
  StockObject = 0;
  v21 = &CFont::`vftable';
  v3 = (void ***)a2;
  v24 = 0;
  if ( !a2 || !*(_DWORD *)(a2 + 4) )
  {
    StockObject = GetStockObject(17);
    if ( !StockObject )
    {
      StockObject = GetStockObject(13);
      if ( !StockObject )
      {
        *((_DWORD *)v2 + 17) = 0;
        v21 = &CGdiObject::`vftable';
        v24 = 1;
        return sub_422A21(&v21);
      }
    }
    v3 = &v21;
  }
  GetObjectA(v3[1], 60, pv);
  FontDesc.cbSizeofstruct = 32;
  if ( String )
  {
    v4 = lstrlenA(String) + 1;
    v5 = 2 * v4 + 3;
    LOBYTE(v5) = v5 & 0xFC;
    v6 = alloca(v5);
    v10[0] = 0;
    MultiByteToWideChar(0, 0, String, -1, v10, v4);
    v2 = v23;
    FontDesc.lpstrName = v10;
  }
  else
  {
    FontDesc.lpstrName = 0;
  }
  FontDesc.sWeight = v12;
  FontDesc.sCharset = v16;
  FontDesc.fItalic = v13;
  FontDesc.fUnderline = v14;
  FontDesc.fStrikethrough = v15;
  v7 = pv[0];
  if ( pv[0] < 0 )
    v7 = -pv[0];
  sub_4227D6(*((HWND *)v2 + 7));
  LOBYTE(v24) = 2;
  v8 = (struct IUnknown **)(v2 + 68);
  FontDesc.cySize.int64 = (unsigned int)(720000 * v7 / GetDeviceCaps(hdc, 90));
  _AfxRelease(v8);
  if ( OleCreateFontIndirect(&FontDesc, &stru_42C570, (LPVOID *)v8) < 0 )
    *v8 = 0;
  LOBYTE(v24) = 0;
  sub_422848(v19);
  v21 = &CGdiObject::`vftable';
  v24 = 3;
  return sub_422A21(&v21);
}


// ========== Function: sub_4061D9 @ 0x4061D9 ==========
LPVOID __thiscall sub_4061D9(LPVOID lpMem, char a2)
{
  sub_4061F5();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_4061F5 @ 0x4061F5 ==========
int __thiscall sub_4061F5(_DWORD *this)
{
  *this = &CGdiObject::`vftable';
  return sub_422A21(this);
}


// ========== Function: ?FreezeAllEvents@COleControlContainer@@QAEXH@Z @ 0x40621E ==========
void __thiscall COleControlContainer::FreezeAllEvents(COleControlContainer *this, int a2)
{
  bool v2; // zf
  _BYTE v3[4]; // [esp+0h] [ebp-Ch] BYREF
  COleControlSite *v4; // [esp+4h] [ebp-8h] BYREF
  int v5; // [esp+8h] [ebp-4h] BYREF

  v2 = *((_DWORD *)this + 11) == 0;
  v5 = -(*((_DWORD *)this + 11) != 0);
  if ( !v2 )
  {
    do
    {
      sub_41BD8F(&v5, v3, &v4);
      COleControlSite::FreezeEvents(v4, a2);
    }
    while ( v5 );
  }
}


// ========== Function: ?ScrollChildren@COleControlContainer@@UAEXHH@Z @ 0x40625F ==========
void __thiscall COleControlContainer::ScrollChildren(COleControlContainer *this, int a2, int dy)
{
  bool v3; // zf
  _BYTE v4[4]; // [esp+0h] [ebp-Ch] BYREF
  int v5; // [esp+4h] [ebp-8h] BYREF
  int v6; // [esp+8h] [ebp-4h] BYREF

  v3 = *((_DWORD *)this + 11) == 0;
  v5 = -(*((_DWORD *)this + 11) != 0);
  if ( !v3 )
  {
    do
    {
      sub_41BD8F(&v5, v4, &v6);
      OffsetRect((LPRECT)(v6 + 44), a2, dy);
      (*(void (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(v6 + 80) + 28))(*(_DWORD *)(v6 + 80), v6 + 44, v6 + 44);
    }
    while ( v5 );
  }
}


// ========== Function: ?OnUIActivate@COleControlContainer@@UAEXPAVCOleControlSite@@@Z @ 0x4062B9 ==========
void __thiscall COleControlContainer::OnUIActivate(COleControlContainer *this, struct COleControlSite *a2)
{
  int v3; // eax

  v3 = *((_DWORD *)this + 18);
  if ( v3 )
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(v3 + 80) + 24))(*(_DWORD *)(v3 + 80));
  *((_DWORD *)this + 18) = a2;
}


// ========== Function: sub_4062D7 @ 0x4062D7 ==========
int __thiscall sub_4062D7(_DWORD *this, int a2)
{
  int result; // eax

  result = this[18];
  if ( result == a2 )
    this[18] = 0;
  return result;
}


// ========== Function: sub_4062E7 @ 0x4062E7 ==========
LRESULT __thiscall sub_4062E7(void *this, int a2, WPARAM wParam)
{
  LRESULT result; // eax
  int v4; // ecx

  result = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 112))(this, a2);
  if ( result )
  {
    v4 = *(_DWORD *)(result + 56);
    if ( v4 )
      return (*(int (__cdecl **)(int, _DWORD, int, WPARAM))(*(_DWORD *)v4 + 108))(v4, 0, 3, wParam);
    else
      return SendMessageA(*(HWND *)(result + 28), 0xF1u, wParam, 0);
  }
  return result;
}


// ========== Function: sub_406324 @ 0x406324 ==========
int __thiscall sub_406324(void *this, int a2, int a3, int a4)
{
  int result; // eax

  while ( a2 <= a3 )
  {
    result = (*(int (__thiscall **)(void *, int, bool))(*(_DWORD *)this + 100))(this, a2, a2 == a4);
    ++a2;
  }
  return result;
}


// ========== Function: sub_40634C @ 0x40634C ==========
int __thiscall sub_40634C(void *this, void *a2)
{
  (*(void (__thiscall **)(void *, void *, void **))(*(_DWORD *)this + 108))(this, a2, &a2);
  return sub_41D866(a2);
}


// ========== Function: sub_406367 @ 0x406367 ==========
HWND *__thiscall sub_406367(_DWORD *this, int nIDDlgItem, HWND *a3)
{
  HWND v4; // eax
  HWND DlgItem; // edi
  int v6; // eax
  HWND *result; // eax

  v4 = (HWND)this[7];
  if ( v4 )
    v4 = (HWND)*((_DWORD *)v4 + 7);
  DlgItem = GetDlgItem(v4, nIDDlgItem);
  if ( !DlgItem )
  {
    v6 = (*(int (__thiscall **)(_DWORD *, int))(*this + 80))(this, nIDDlgItem);
    if ( v6 )
      DlgItem = *(HWND *)(v6 + 32);
  }
  result = a3;
  *a3 = DlgItem;
  return result;
}


// ========== Function: sub_4063A3 @ 0x4063A3 ==========
unsigned int __thiscall sub_4063A3(void *this, int a2, int *a3, int a4)
{
  CHAR *i; // esi
  int v6; // eax
  CHAR sz[256]; // [esp+0h] [ebp-100h] BYREF

  if ( !(*(int (__thiscall **)(void *, int, CHAR *, int))(*(_DWORD *)this + 120))(this, a2, sz, 256) )
  {
    if ( a3 )
      *a3 = 0;
    return 0;
  }
  for ( i = sz; _ismbcspace(*i); i = CharNextA(i) )
    ;
  if ( *i == 43 || *i == 45 )
    i = CharNextA(i);
  v6 = _ismbcdigit(*i);
  if ( a3 )
    *a3 = v6;
  if ( !v6 )
    return 0;
  if ( a4 )
    return strtol(sz, 0, 10);
  else
    return strtoul(sz, 0, 10);
}


// ========== Function: sub_406451 @ 0x406451 ==========
int __thiscall sub_406451(void *this, int a2, LPSTR lpString, int nMaxCount)
{
  int result; // eax

  result = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 112))(this, a2);
  if ( result )
    return sub_420518(lpString, nMaxCount);
  return result;
}


// ========== Function: sub_406470 @ 0x406470 ==========
LRESULT __thiscall sub_406470(void *this, int a2, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LRESULT result; // eax

  result = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 112))(this, a2);
  if ( result )
    return SendMessageA(*(HWND *)(result + 28), Msg, wParam, lParam);
  return result;
}


// ========== Function: ?SetDlgItemInt@COleControlContainer@@UAEXHIH@Z @ 0x406495 ==========
void __thiscall COleControlContainer::SetDlgItemInt(COleControlContainer *this, int a2, unsigned int Value, int a4)
{
  char Buffer[36]; // [esp+4h] [ebp-24h] BYREF

  if ( a4 )
    _ltoa(Value, Buffer, 10);
  else
    _ultoa(Value, Buffer, 10);
  (*(void (__thiscall **)(COleControlContainer *, int, char *))(*(_DWORD *)this + 132))(this, a2, Buffer);
}


// ========== Function: sub_4064D2 @ 0x4064D2 ==========
int __thiscall sub_4064D2(void *this, int a2, LPCSTR lpString)
{
  int result; // eax

  result = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 112))(this, a2);
  if ( result )
    return sub_4204F1(lpString);
  return result;
}


// ========== Function: sub_4064ED @ 0x4064ED ==========
LRESULT __thiscall sub_4064ED(int *this, LRESULT a2)
{
  int v2; // eax
  int v3; // eax
  LRESULT result; // eax
  int v5; // [esp+0h] [ebp-20h] BYREF
  int *v6; // [esp+10h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-4h]

  v2 = *this;
  v6 = &v5;
  v3 = (*(int (__thiscall **)(int *, LRESULT))(v2 + 112))(this, a2);
  if ( !v3 )
    return 0;
  if ( !*(_DWORD *)(v3 + 56) )
    return SendMessageA(*(HWND *)(v3 + 28), 0xF0u, 0, 0);
  v7 = 0;
  CWnd::GetProperty((CWnd *)v3, 0, 3u, &a2);
  result = a2;
  if ( a2 == 0xFFFF )
    return 1;
  return result;
}


// ========== Function: ?QueryInterface@XOleIPFrame@COleControlContainer@@UAGJABU_GUID@@PAPAX@Z @ 0x406569 ==========
unsigned int __stdcall COleControlContainer::XOleIPFrame::QueryInterface(
        COleControlContainer::XOleIPFrame *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::InternalQueryInterface((COleControlContainer::XOleIPFrame *)((char *)this - 76), a2, a3);
}


// ========== Function: unknown_libname_7 @ 0x406580 ==========
// MFC 3.1-14.0 32bit
LONG __stdcall unknown_libname_7(int a1)
{
  return InterlockedIncrement((volatile LONG *)(a1 - 72));
}


// ========== Function: ?Release@XOleIPFrame@COleControlContainer@@UAGKXZ @ 0x406591 ==========
int __stdcall COleControlContainer::XOleIPFrame::Release(COleControlContainer::XOleIPFrame *this)
{
  return sub_4259CA((char *)this - 76);
}


// ========== Function: ?GetWindow@XOleIPFrame@COleControlContainer@@UAGJPAPAUHWND__@@@Z @ 0x4065A0 ==========
int __stdcall COleControlContainer::XOleIPFrame::GetWindow(COleControlContainer::XOleIPFrame *this, HWND *a2)
{
  *a2 = *(HWND *)(*((_DWORD *)this - 12) + 28);
  return 0;
}


// ========== Function: sub_4065B5 @ 0x4065B5 ==========
int __stdcall sub_4065B5(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edi

  v3 = *(_DWORD *)(a1 - 4);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 84);
    if ( a2 )
      (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 4))(a2);
    *(_DWORD *)(*(_DWORD *)(a1 - 4) + 84) = a2;
    if ( v4 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
  }
  return 0;
}


// ========== Function: sub_4065EC @ 0x4065EC ==========
_UNKNOWN **sub_4065EC()
{
  return &off_42A600;
}


// ========== Function: ??1CEnumUnknown@@UAE@XZ @ 0x4065F2 ==========
void __thiscall CEnumUnknown::~CEnumUnknown(CEnumUnknown *this)
{
  unsigned int v2; // edi
  _DWORD *v3; // ebx

  *(_DWORD *)this = &CEnumUnknown::`vftable';
  v2 = 0;
  if ( !*((_DWORD *)this + 8) )
  {
    v3 = (_DWORD *)*((_DWORD *)this + 9);
    if ( *((_DWORD *)this + 11) )
    {
      do
      {
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v3 + 8))(*v3);
        ++v2;
        ++v3;
      }
      while ( v2 < *((_DWORD *)this + 11) );
    }
  }
  CEnumArray::~CEnumArray(this);
}


// ========== Function: sub_406648 @ 0x406648 ==========
CEnumUnknown *__thiscall sub_406648(CEnumUnknown *lpMem, char a2)
{
  CEnumUnknown::~CEnumUnknown(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ?OnNext@CEnumUnknown@@MAEHPAX@Z @ 0x406664 ==========
int __thiscall CEnumUnknown::OnNext(CEnumUnknown *this, _DWORD *a2)
{
  int result; // eax

  result = CEnumArray::OnNext(this, a2);
  if ( result )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*a2 + 4))(*a2);
    return 1;
  }
  return result;
}


// ========== Function: ?QueryInterface@XOleContainer@COleControlContainer@@UAGJABU_GUID@@PAPAX@Z @ 0x406682 ==========
unsigned int __stdcall COleControlContainer::XOleContainer::QueryInterface(
        COleControlContainer::XOleContainer *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::InternalQueryInterface((COleControlContainer::XOleContainer *)((char *)this - 80), a2, a3);
}


// ========== Function: ?Release@XOleContainer@COleControlContainer@@UAGKXZ @ 0x406699 ==========
int __stdcall COleControlContainer::XOleContainer::Release(COleControlContainer::XOleContainer *this)
{
  return sub_4259CA((char *)this - 80);
}


// ========== Function: ?AddRef@XOleContainer@COleControlContainer@@UAGKXZ @ 0x4066A8 ==========
LONG __stdcall COleControlContainer::XOleContainer::AddRef(COleControlContainer::XOleContainer *this)
{
  return InterlockedIncrement((volatile LONG *)this - 19);
}


// ========== Function: sub_4066B9 @ 0x4066B9 ==========
int __stdcall sub_4066B9(int a1, int a2, int a3, int a4, int a5)
{
  return -2147467263;
}


// ========== Function: sub_4066C1 @ 0x4066C1 ==========
int __stdcall sub_4066C1(_DWORD *a1, int a2, _DWORD *a3)
{
  bool v4; // zf
  int v5; // edi
  int v6; // eax
  CEnumArray *v7; // eax
  CEnumArray *v8; // esi
  _DWORD *v9; // esi
  unsigned int i; // edi
  _DWORD v12[5]; // [esp+0h] [ebp-38h] BYREF
  _BYTE v13[4]; // [esp+14h] [ebp-24h] BYREF
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch] BYREF
  int v16; // [esp+20h] [ebp-18h]
  unsigned int v17; // [esp+24h] [ebp-14h]
  _DWORD *v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+34h] [ebp-4h]
  _DWORD *v20; // [esp+40h] [ebp+8h]

  v4 = (a2 & 1) == 0;
  v18 = v12;
  *a3 = 0;
  v16 = 0;
  v14 = 0;
  v17 = 0;
  v20 = 0;
  v19 = 0;
  if ( !v4 )
  {
    v17 = *(a1 - 9);
    v20 = (_DWORD *)sub_41CA70(4 * v17);
    v5 = 0;
    v6 = -(*(a1 - 9) != 0);
    v15 = v6;
    while ( v6 )
    {
      sub_41BD8F(&v15, v13, &a2);
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a2 + 76) + 4))(*(_DWORD *)(a2 + 76));
      v20[v5] = *(_DWORD *)(a2 + 76);
      v6 = v15;
      ++v5;
    }
  }
  v7 = (CEnumArray *)sub_41CA70(0x38u);
  v8 = v7;
  v12[4] = v7;
  LOBYTE(v19) = 1;
  if ( v7 )
  {
    CEnumArray::CEnumArray(v7, 4u, v20, v17, 1);
    *(_DWORD *)v8 = &CEnumUnknown::`vftable';
  }
  else
  {
    v8 = 0;
  }
  v19 = -1;
  if ( v16 < 0 )
  {
    v9 = v20;
    if ( v20 )
    {
      for ( i = v17; i; --i )
      {
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v9 + 8))(*v9);
        ++v9;
      }
    }
  }
  else
  {
    *a3 = (char *)v8 + 52;
  }
  return v16;
}


// ========== Function: ?GetFont@CWnd@@QBEPAVCFont@@XZ @ 0x4067CF ==========
struct CFont *__thiscall CWnd::GetFont(HWND *this)
{
  void *v1; // eax

  v1 = (void *)SendMessageA(this[7], 0x31u, 0, 0);
  return (struct CFont *)sub_4229B5(v1);
}


// ========== Function: nullsub_3 @ 0x4067E5 ==========
void nullsub_3()
{
  ;
}


// ========== Function: sub_4067E6 @ 0x4067E6 ==========
LPVOID __thiscall sub_4067E6(LPVOID lpMem, char a2)
{
  sub_406802();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_406802 @ 0x406802 ==========
void __thiscall sub_406802(_DWORD *this)
{
  *this = &CFileException::`vftable';
  sub_4200DD(this + 4);
}


// ========== Function: sub_40682E @ 0x40682E ==========
int __thiscall sub_40682E(int this, LPCSTR lpString)
{
  return CString::operator=((CString *)(this + 12), lpString);
}


// ========== Function: sub_40683D @ 0x40683D ==========
CException *__thiscall sub_40683D(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CResourceException::`vftable';
  return this;
}


// ========== Function: sub_406867 @ 0x406867 ==========
LPVOID __thiscall sub_406867(LPVOID lpMem, char a2)
{
  sub_406883();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_406883 @ 0x406883 ==========
void __thiscall sub_406883(_DWORD *this)
{
  *this = &CResourceException::`vftable';
}


// ========== Function: sub_40688A @ 0x40688A ==========
CException *__thiscall sub_40688A(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CUserException::`vftable';
  return this;
}


// ========== Function: sub_4068B4 @ 0x4068B4 ==========
LPVOID __thiscall sub_4068B4(LPVOID lpMem, char a2)
{
  sub_4068D0();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_4068D0 @ 0x4068D0 ==========
void __thiscall sub_4068D0(_DWORD *this)
{
  *this = &CUserException::`vftable';
}


// ========== Function: sub_4068D7 @ 0x4068D7 ==========
BOOL __thiscall sub_4068D7(HDC *this, int x, int y)
{
  return PtVisible(this[1], x, y);
}


// ========== Function: sub_4068EB @ 0x4068EB ==========
BOOL __thiscall sub_4068EB(HDC *this, RECT *lprect)
{
  return RectVisible(this[1], lprect);
}


// ========== Function: sub_4068FB @ 0x4068FB ==========
BOOL __thiscall sub_4068FB(HDC *this, int x, int y, LPCSTR lpString, int c)
{
  return TextOutA(this[1], x, y, lpString, c);
}


// ========== Function: ?ExtTextOutA@CDC@@UAEHHHIPBUtagRECT@@PBDIPAH@Z @ 0x406917 ==========
BOOL __thiscall CDC::ExtTextOutA(
        HDC *this,
        int x,
        int y,
        UINT options,
        RECT *lprect,
        LPCSTR lpString,
        UINT c,
        int *lpDx)
{
  return ExtTextOutA(this[1], x, y, options, lprect, lpString, c, lpDx);
}


// ========== Function: ?TabbedTextOutA@CDC@@UAE?AVCSize@@HHPBDHHPAHH@Z @ 0x40693C ==========
_DWORD *__thiscall CDC::TabbedTextOutA(
        HDC *this,
        _DWORD *a2,
        int x,
        int y,
        const CHAR *lpString,
        int chCount,
        int nTabPositions,
        INT *lpnTabStopPositions,
        int nTabOrigin)
{
  LONG v9; // eax

  v9 = TabbedTextOutA(this[1], x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
  a2[1] = SHIWORD(v9);
  *a2 = (__int16)v9;
  return a2;
}


// ========== Function: sub_406974 @ 0x406974 ==========
int __thiscall sub_406974(HDC *this, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
  return DrawTextA(this[1], lpchText, cchText, lprc, format);
}


// ========== Function: ?GrayStringA@CDC@@UAEHPAVCBrush@@P6GHPAUHDC__@@JH@ZJHHHHH@Z @ 0x406990 ==========
BOOL __thiscall CDC::GrayStringA(
        HDC *this,
        HBRUSH hBrush,
        GRAYSTRINGPROC lpOutputFunc,
        LPARAM lpData,
        int nCount,
        int X,
        int Y,
        int nWidth,
        int nHeight)
{
  HBRUSH v9; // eax

  v9 = hBrush;
  if ( hBrush )
    v9 = (HBRUSH)*((_DWORD *)hBrush + 1);
  return GrayStringA(this[1], v9, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
}


// ========== Function: sub_4069C0 @ 0x4069C0 ==========
int __thiscall sub_4069C0(HDC *this, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
{
  return Escape(this[1], iEscape, cjIn, pvIn, pvOut);
}


// ========== Function: sub_4069DC @ 0x4069DC ==========
CException *__thiscall sub_4069DC(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CMemoryException::`vftable';
  return this;
}


// ========== Function: sub_406A06 @ 0x406A06 ==========
LPVOID __thiscall sub_406A06(LPVOID lpMem, char a2)
{
  sub_406A22();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_406A22 @ 0x406A22 ==========
void __thiscall sub_406A22(_DWORD *this)
{
  *this = &CMemoryException::`vftable';
}


// ========== Function: sub_406A29 @ 0x406A29 ==========
CException *__thiscall sub_406A29(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CNotSupportedException::`vftable';
  return this;
}


// ========== Function: sub_406A53 @ 0x406A53 ==========
LPVOID __thiscall sub_406A53(LPVOID lpMem, char a2)
{
  sub_406A6F();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_406A6F @ 0x406A6F ==========
void __thiscall sub_406A6F(_DWORD *this)
{
  *this = &CNotSupportedException::`vftable';
}


// ========== Function: sub_406A76 @ 0x406A76 ==========
LPVOID __thiscall sub_406A76(LPVOID lpMem, char a2)
{
  sub_406A92();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_406A92 @ 0x406A92 ==========
int __thiscall sub_406A92(_DWORD *this)
{
  *this = &CHandleMap::`vftable';
  sub_420FDB();
  sub_41BC09(this + 8);
  return sub_41BC09(this + 1);
}


// ========== Function: sub_406ADA @ 0x406ADA ==========
LPVOID __thiscall sub_406ADA(LPVOID lpMem, char a2)
{
  sub_406AF6();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_406AF6 @ 0x406AF6 ==========
int __thiscall sub_406AF6(_DWORD *this)
{
  *this = &CMenu::`vftable';
  return sub_4214DA(this);
}


// ========== Function: sub_406B1F @ 0x406B1F ==========
char *__thiscall sub_406B1F(char *this, int a2, int a3)
{
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 2) = 0;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 16));
  return this;
}


// ========== Function: sub_406B5B @ 0x406B5B ==========
void __thiscall sub_406B5B(int this)
{
  struct _RTL_CRITICAL_SECTION *v2; // edi

  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 16);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
  CPlex::FreeDataChain(*(CPlex **)(this + 8));
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  LeaveCriticalSection(v2);
}


// ========== Function: sub_406B83 @ 0x406B83 ==========
_DWORD *__thiscall sub_406B83(char *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // ebx
  _DWORD *v3; // eax
  int v4; // ecx
  _DWORD *v5; // edi
  unsigned int v7; // [esp-4h] [ebp-28h]
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  v8[4] = this;
  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 16);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
  if ( !*((_DWORD *)this + 3) )
  {
    v7 = *(_DWORD *)this;
    v8[8] = 0;
    v3 = (_DWORD *)((char *)CPlex::Create((struct CPlex **)this + 2, *((_DWORD *)this + 1), v7)
                  + *(_DWORD *)this * (*((_DWORD *)this + 1) - 1)
                  + 4);
    if ( *((_DWORD *)this + 1) - 1 >= 0 )
    {
      v4 = *((_DWORD *)this + 1);
      do
      {
        *v3 = *((_DWORD *)this + 3);
        *((_DWORD *)this + 3) = v3;
        v3 = (_DWORD *)((char *)v3 - *(_DWORD *)this);
        --v4;
      }
      while ( v4 );
    }
  }
  v5 = (_DWORD *)*((_DWORD *)this + 3);
  *((_DWORD *)this + 3) = *v5;
  LeaveCriticalSection(v2);
  return v5;
}


// ========== Function: sub_406C12 @ 0x406C12 ==========
void __thiscall sub_406C12(int this, _DWORD *a2)
{
  if ( a2 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
    *a2 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 12) = a2;
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 16));
  }
}


// ========== Function: sub_406C3E @ 0x406C3E ==========
BOOL __thiscall sub_406C3E(void *this, int a2, int a3, _DWORD *a4)
{
  int v5; // esi
  int v7; // edi
  int v8; // ecx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int (__thiscall *v13)(void *, int, int, _DWORD *); // esi
  int v14; // eax
  int v15; // eax
  bool v16; // zf
  int (__thiscall *v17)(void *); // esi
  int v18; // eax
  int (__thiscall *v19)(void *, _DWORD *); // esi
  int v20; // eax
  char *v21; // eax
  LPVOID *v22; // eax
  int *v23; // eax
  int v24; // [esp-Ch] [ebp-58h]
  int v25; // [esp-8h] [ebp-54h]
  int v26; // [esp+0h] [ebp-4Ch] BYREF
  struct tagVARIANT v27; // [esp+Ch] [ebp-40h] BYREF
  LPVOID lpMem[4]; // [esp+1Ch] [ebp-30h] BYREF
  int v29; // [esp+30h] [ebp-1Ch] BYREF
  BOOL v30; // [esp+34h] [ebp-18h]
  _DWORD v31[5]; // [esp+38h] [ebp-14h] BYREF
  int iVal; // [esp+5Ch] [ebp+10h]

  v31[0] = 0;
  v29 = -1;
  v31[1] = &v26;
  v5 = sub_406E50(this, a2, a3);
  if ( !v5 )
    return 0;
  if ( a4 )
  {
    *a4 = this;
    v7 = *(_DWORD *)a3;
    if ( *(int *)a3 >= 0 )
    {
      if ( v7 <= 1 )
      {
        v8 = *(_DWORD *)(v5 + 16);
        goto LABEL_9;
      }
      if ( v7 == 2 )
      {
        v8 = *(_DWORD *)(v5 + 20);
LABEL_9:
        a4[1] = v8;
      }
    }
    return a4[1] != 0;
  }
  v9 = *(_DWORD *)a3;
  v10 = *(_DWORD *)(v5 + 36) == -1;
  iVal = 0;
  v31[4] = 0;
  v30 = !v10;
  if ( !v9 )
  {
    AfxVariantInit(&v27);
    lpMem[0] = 0;
    if ( v30 )
    {
      memcpy(lpMem, *(const void **)(a3 + 8), sizeof(lpMem));
      lpMem[0] = (LPVOID)sub_41CA70(16 * (int)++lpMem[2]);
      memcpy(lpMem[0], **(const void ***)(a3 + 8), 16 * ((int)lpMem[2] + 0xFFFFFFF));
      v21 = (char *)lpMem[0] + 16 * (int)lpMem[2] - 16;
      *(_WORD *)v21 = 3;
      *((_DWORD *)v21 + 2) = a2;
      v22 = lpMem;
    }
    else
    {
      v22 = *(LPVOID **)(a3 + 8);
    }
    v31[0] = sub_426CDA((LPCSTR)v5, (VARIANTARG *)1, (int)&v27, (int)v22, (int)&v29);
    iVal = v27.iVal;
    if ( v30 )
      sub_41CA99(lpMem[0]);
    goto LABEL_33;
  }
  v11 = v9 - 1;
  if ( !v11 )
  {
    v19 = *(int (__thiscall **)(void *, _DWORD *))(v5 + 16);
    v31[0] = 1;
    if ( v10 )
      v20 = v19(this, v31);
    else
      v20 = ((int (__thiscall *)(void *, int, _DWORD *))v19)(this, a2, v31);
    iVal = v20;
    v15 = 0;
    v16 = v31[0] == 0;
    goto LABEL_27;
  }
  v12 = v11 - 1;
  if ( !v12 )
  {
    v17 = *(int (__thiscall **)(void *))(v5 + 20);
    if ( v10 )
      v18 = v17(this);
    else
      v18 = ((int (__thiscall *)(void *, int))v17)(this, a2);
    v31[0] = 0;
    iVal = v18;
    goto LABEL_37;
  }
  if ( v12 == 1 )
  {
    v13 = *(int (__thiscall **)(void *, int, int, _DWORD *))(v5 + 16);
    v25 = *(_DWORD *)(a3 + 32);
    v31[0] = 1;
    v24 = *(_DWORD *)(a3 + 28);
    if ( v10 )
      v14 = v13(this, v24, v25, v31);
    else
      v14 = ((int (__thiscall *)(void *, int, int, int, _DWORD *))v13)(this, a2, v24, v25, v31);
    iVal = v14;
    v15 = 0;
    v16 = v31[0] == 0;
LABEL_27:
    LOBYTE(v15) = v16;
    v31[0] = v15;
LABEL_33:
    if ( v31[0] < 0 )
    {
      v23 = *(int **)(a3 + 16);
      if ( v23 )
      {
        if ( v29 != -1 )
          *v23 = v29;
      }
    }
  }
LABEL_37:
  *(_DWORD *)(a3 + 24) = v31[0];
  return iVal;
}


// ========== Function: sub_406E50 @ 0x406E50 ==========
_DWORD *__stdcall sub_406E50(int a1, unsigned int a2, _DWORD *a3)
{
  _DWORD *i; // edx
  _DWORD *result; // eax
  unsigned int v5; // ecx
  int v6; // ecx

  for ( i = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)a1 + 60))(a1); i; i = (_DWORD *)*i )
  {
    for ( result = (_DWORD *)i[1]; result[6] != -1; result += 10 )
    {
      if ( result[1] == a3[1] && result[6] == (*a3 != 0) )
      {
        v5 = result[9];
        if ( v5 == -1 )
        {
          v6 = result[8];
          if ( v6 == -1 || v6 == a2 )
            return result;
        }
        else if ( result[8] <= a2 && a2 <= v5 )
        {
          return result;
        }
      }
    }
  }
  return 0;
}


// ========== Function: sub_406EC5 @ 0x406EC5 ==========
_UNKNOWN **sub_406EC5()
{
  return &off_42AFF8;
}


// ========== Function: ??0COleControlSite@@QAE@PAVCOleControlContainer@@@Z @ 0x406ECB ==========
COleControlSite *__thiscall COleControlSite::COleControlSite(COleControlSite *this, struct COleControlContainer *a2)
{
  sub_41C5A3();
  *((_DWORD *)this + 10) = -1;
  *((_DWORD *)this + 7) = a2;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 0;
  COleDispatchDriver::COleDispatchDriver((COleControlSite *)((char *)this + 88));
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 25) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_DWORD *)this + 35) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 37) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 39) = off_433548;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 41) = 0;
  *((_DWORD *)this + 46) = &COleControlSite::XOleClientSite::`vftable';
  *((_DWORD *)this + 47) = &COleControlSite::XOleIPSite::`vftable';
  *((_DWORD *)this + 48) = &COleControlSite::XOleControlSite::`vftable';
  *((_DWORD *)this + 49) = &COleControlSite::XAmbientProps::`vftable';
  *((_DWORD *)this + 50) = &COleControlSite::XPropertyNotifySink::`vftable';
  *((_DWORD *)this + 51) = &COleControlSite::XEventSink::`vftable';
  *((_DWORD *)this + 52) = &COleControlSite::XBoundObjectSite::`vftable';
  *((_DWORD *)this + 53) = &COleControlSite::XNotifyDBEvents::`vftable';
  *((_DWORD *)this + 54) = &COleControlSite::XRowsetNotify::`vftable';
  *(_DWORD *)this = &off_42B044;
  memset((char *)this + 168, 0, 0x10u);
  *((_WORD *)this + 84) = 0;
  return this;
}


// ========== Function: sub_406FD2 @ 0x406FD2 ==========
COleControlSite *__thiscall sub_406FD2(COleControlSite *lpMem, char a2)
{
  COleControlSite::~COleControlSite(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??1COleControlSite@@UAE@XZ @ 0x406FEE ==========
void __thiscall COleControlSite::~COleControlSite(COleControlSite *this)
{
  void *v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // ecx

  *(_DWORD *)this = &off_42B044;
  v2 = (void *)*((_DWORD *)this + 34);
  if ( v2 )
  {
    sub_408EAA(v2);
    sub_41CA99(v2);
  }
  sub_407E5B(this);
  COleControlSite::DisconnectSink(this, (const struct _GUID *)((char *)this + 60), *((_DWORD *)this + 24));
  COleControlSite::DisconnectSink(this, &stru_42C670, *((_DWORD *)this + 25));
  COleControlSite::DisconnectSink(this, &stru_42C620, *((_DWORD *)this + 33));
  v3 = *((_DWORD *)this + 20);
  if ( v3 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v3 + 20))(*((_DWORD *)this + 20));
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)this + 20) + 8))(*((_DWORD *)this + 20));
    *((_DWORD *)this + 20) = 0;
  }
  v4 = *((_DWORD *)this + 21);
  if ( v4 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v4 + 8))(*((_DWORD *)this + 21));
    *((_DWORD *)this + 21) = 0;
  }
  v5 = *((_DWORD *)this + 19);
  if ( v5 )
  {
    (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)v5 + 12))(v5, 0);
    (*(void (__stdcall **)(_DWORD, int))(**((_DWORD **)this + 19) + 24))(*((_DWORD *)this + 19), 1);
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)this + 19) + 8))(*((_DWORD *)this + 19));
    *((_DWORD *)this + 19) = 0;
  }
  VariantClear((VARIANTARG *)((char *)this + 168));
  COleControlSite::BindProperty(this, -1, 0);
  if ( *((_DWORD *)this + 37) )
  {
    v6 = *((_DWORD *)this + 36);
    if ( v6 )
    {
      v7 = *(_DWORD *)(v6 + 136);
      if ( v7 )
        (*(void (__thiscall **)(int, COleControlSite *, _DWORD))(*(_DWORD *)v7 + 8))(v7, this, 0);
    }
  }
  sub_4200DD((char *)this + 156);
  COleDispatchDriver::ReleaseDispatch((COleControlSite *)((char *)this + 88));
  sub_41C5BD(this);
}


// ========== Function: sub_40711A @ 0x40711A ==========
BOOL __thiscall sub_40711A(int this)
{
  LONG v2; // eax
  int v3; // edi
  _BYTE v5[20]; // [esp+8h] [ebp-28h] BYREF
  struct tagSIZE v6; // [esp+1Ch] [ebp-14h] BYREF
  int v7; // [esp+2Ch] [ebp-4h]

  v2 = *(_DWORD *)(this + 56) - *(_DWORD *)(this + 48);
  v6.cx = *(_DWORD *)(this + 52) - *(_DWORD *)(this + 44);
  v6.cy = v2;
  sub_422722(0);
  v7 = 0;
  sub_423B26((CDC *)v5, &v6);
  v3 = (*(int (__stdcall **)(_DWORD, int, struct tagSIZE *))(**(_DWORD **)(this + 76) + 68))(
         *(_DWORD *)(this + 76),
         1,
         &v6);
  if ( v3 >= 0
    && (*(int (__stdcall **)(_DWORD, int, struct tagSIZE *))(**(_DWORD **)(this + 76) + 72))(
         *(_DWORD *)(this + 76),
         1,
         &v6) >= 0 )
  {
    sub_423BB4((CDC *)v5, &v6);
    *(_DWORD *)(this + 52) = *(_DWORD *)(this + 44) + v6.cx;
    *(_DWORD *)(this + 56) = v6.cy + *(_DWORD *)(this + 48);
  }
  v7 = -1;
  sub_422794(v5);
  return v3 >= 0;
}


// ========== Function: sub_4071C2 @ 0x4071C2 ==========
int __thiscall sub_4071C2(
        int this,
        int a2,
        IID *rclsid,
        int a4,
        int a5,
        int *a6,
        _DWORD *a7,
        int a8,
        LPLOCKBYTES pplkbyt,
        IStorage *ppstgOpen,
        unsigned __int16 *ppv)
{
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  _DWORD *v19; // edi
  int v20; // eax
  int v21; // [esp-10h] [ebp-50h]
  _BYTE v22[20]; // [esp+8h] [ebp-38h] BYREF
  int v23; // [esp+1Ch] [ebp-24h]
  int v24; // [esp+20h] [ebp-20h]
  int v25; // [esp+24h] [ebp-1Ch]
  int v26; // [esp+28h] [ebp-18h]
  struct tagSIZE v27; // [esp+2Ch] [ebp-14h] BYREF
  int v28; // [esp+3Ch] [ebp-4h]
  int v29; // [esp+48h] [ebp+8h]

  *(_DWORD *)(this + 32) = 0;
  if ( a2 )
  {
    *(_DWORD *)(this + 36) = a2;
    *(_DWORD *)(a2 + 56) = this;
  }
  if ( !*((_DWORD *)AfxGetThreadState() + 69) && !AfxOleInit() )
    return -2147467259;
  v29 = sub_4076BC(rclsid, pplkbyt, ppstgOpen, ppv);
  if ( v29 >= 0 )
  {
    *(_DWORD *)(this + 40) = a8;
    if ( a7 )
    {
      v15 = *a6;
      v16 = a6[1];
      v17 = *a6 + *a7;
      v26 = v16 + a7[1];
      v23 = v15;
      v25 = v17;
      v24 = v16;
      *(_DWORD *)(this + 44) = v15;
      *(_DWORD *)(this + 48) = v24;
      *(_DWORD *)(this + 52) = v25;
      *(_DWORD *)(this + 56) = v26;
    }
    else
    {
      sub_422722(0);
      v13 = **(_DWORD **)(this + 76);
      v21 = *(_DWORD *)(this + 76);
      v28 = 0;
      (*(void (__stdcall **)(int, int, struct tagSIZE *))(v13 + 72))(v21, 1, &v27);
      sub_423BB4((CDC *)v22, &v27);
      v14 = a6[1];
      v23 = *a6;
      v25 = v27.cx + v23;
      v24 = v14;
      v26 = v14 + v27.cy;
      v28 = -1;
      *(_DWORD *)(this + 44) = v23;
      *(_DWORD *)(this + 48) = v24;
      *(_DWORD *)(this + 52) = v25;
      *(_DWORD *)(this + 56) = v26;
      sub_422794(v22);
    }
    v18 = *(_DWORD *)(this + 112);
    *(_DWORD *)(this + 104) = 196608;
    if ( (v18 & 0x1000) != 0 )
      *(_DWORD *)(this + 104) = 196609;
    if ( (v18 & 0x400) != 0 )
      HIBYTE(a5) &= ~0x10u;
    *(_DWORD *)(this + 108) = a5 & *(_DWORD *)(this + 104);
    if ( v29 != 1 )
    {
      *(_DWORD *)(this + 96) = COleControlSite::ConnectSink(
                                 (COleControlSite *)this,
                                 (const struct _GUID *)(this + 60),
                                 (struct IUnknown *)(this + 204));
      *(_DWORD *)(this + 100) = COleControlSite::ConnectSink(
                                  (COleControlSite *)this,
                                  &stru_42C670,
                                  (struct IUnknown *)(this + 200));
    }
    *(_DWORD *)(this + 132) = COleControlSite::ConnectSink(
                                (COleControlSite *)this,
                                &stru_42C620,
                                (struct IUnknown *)(this + 212));
    sub_40711A(this);
    v19 = (_DWORD *)(this + 80);
    v29 = (***(int (__stdcall ****)(_DWORD, void *, int))(this + 76))(*(_DWORD *)(this + 76), &unk_42C680, this + 80);
    if ( v29 < 0 )
      goto LABEL_24;
    if ( (a5 & 0x10000000) != 0 )
    {
      v29 = (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)this + 84))(this, -5, 0);
    }
    else
    {
      OffsetRect((LPRECT)(this + 44), -32000, -32000);
      v29 = (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)this + 84))(this, -5, 0);
      if ( v29 < 0 )
        goto LABEL_24;
      v29 = (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)this + 84))(this, -3, 0);
      if ( v29 < 0 )
        goto LABEL_24;
      OffsetRect((LPRECT)(this + 44), 32000, 32000);
      v29 = (*(int (__stdcall **)(_DWORD, int, int))(*(_DWORD *)*v19 + 28))(*v19, this + 44, this + 44);
    }
    if ( v29 >= 0 )
    {
      sub_407CAF(this);
      sub_407E1E(this);
      if ( a4 )
        (*(void (__thiscall **)(int, int))(*(_DWORD *)this + 128))(this, a4);
      (*(void (__thiscall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)this + 120))(
        this,
        0,
        *(_DWORD *)(this + 108) | a5 & 0x8800000,
        0);
      return v29;
    }
LABEL_24:
    if ( *v19 )
    {
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v19 + 8))(*v19);
      *v19 = 0;
    }
    COleControlSite::DisconnectSink((COleControlSite *)this, (const struct _GUID *)(this + 60), *(_DWORD *)(this + 96));
    COleControlSite::DisconnectSink((COleControlSite *)this, &stru_42C670, *(_DWORD *)(this + 100));
    COleControlSite::DisconnectSink((COleControlSite *)this, &stru_42C620, *(_DWORD *)(this + 132));
    v20 = *(_DWORD *)(this + 76);
    *(_DWORD *)(this + 96) = 0;
    *(_DWORD *)(this + 100) = 0;
    *(_DWORD *)(this + 132) = 0;
    (*(void (__stdcall **)(int))(*(_DWORD *)v20 + 8))(v20);
    *(_DWORD *)(this + 76) = 0;
  }
  return v29;
}


// ========== Function: sub_40745F @ 0x40745F ==========
int __thiscall sub_40745F(_DWORD *this)
{
  sub_41BD4D(this[8]);
  (*(void (__thiscall **)(_DWORD *, _DWORD))(*this + 160))(this, 0);
  if ( this )
    (*(void (__thiscall **)(_DWORD *, int))(*this + 4))(this, 1);
  return 1;
}


// ========== Function: ?CoCreateInstanceLic@@YAJABU_GUID@@PAUIUnknown@@K0PAPAXPAG@Z @ 0x40748E ==========
HRESULT __stdcall CoCreateInstanceLic(
        IID *rclsid,
        struct IUnknown *a2,
        DWORD dwClsContext,
        const struct _GUID *a4,
        void **a5,
        unsigned __int16 *ppv)
{
  HRESULT ClassObject; // esi
  unsigned __int16 *v7; // eax
  LPVOID v9; // [esp+8h] [ebp-4h] BYREF

  if ( ppv )
  {
    v9 = 0;
    ClassObject = CoGetClassObject(rclsid, dwClsContext, 0, &stru_42C690, &v9);
    if ( ClassObject >= 0 )
    {
      ClassObject = (*(int (__stdcall **)(LPVOID, struct IUnknown *, _DWORD, const struct _GUID *, unsigned __int16 *, void **))(*(_DWORD *)v9 + 28))(
                      v9,
                      a2,
                      0,
                      a4,
                      ppv,
                      a5);
      v7 = (unsigned __int16 *)v9;
      goto LABEL_6;
    }
  }
  else
  {
    ppv = 0;
    ClassObject = CoGetClassObject(rclsid, dwClsContext, 0, &riid, (LPVOID *)&ppv);
    if ( ClassObject >= 0 )
    {
      ClassObject = (*(int (__stdcall **)(unsigned __int16 *, struct IUnknown *, const struct _GUID *, void **))(*(_DWORD *)ppv + 12))(
                      ppv,
                      a2,
                      a4,
                      a5);
      v7 = ppv;
LABEL_6:
      (*(void (__stdcall **)(unsigned __int16 *))(*(_DWORD *)v7 + 8))(v7);
    }
  }
  return ClassObject;
}


// ========== Function: sub_40751B @ 0x40751B ==========
int __thiscall sub_40751B(_DWORD *this)
{
  int (__stdcall **v2)(_DWORD, void *, _DWORD *); // ecx
  int v3; // eax
  int v4; // edi
  _DWORD *v5; // ebx
  int (__stdcall ***v7)(_DWORD, void *, _DWORD *); // [esp-Ch] [ebp-90h]
  _DWORD v8[5]; // [esp+8h] [ebp-7Ch] BYREF
  int v9; // [esp+1Ch] [ebp-68h]
  LONG lVal; // [esp+20h] [ebp-64h]
  LONG v11; // [esp+24h] [ebp-60h]
  _DWORD v12[8]; // [esp+28h] [ebp-5Ch] BYREF
  _DWORD v13[6]; // [esp+48h] [ebp-3Ch] BYREF
  VARIANTARG pvarg; // [esp+60h] [ebp-24h] BYREF
  int v15; // [esp+70h] [ebp-14h]
  _DWORD v16[4]; // [esp+74h] [ebp-10h] BYREF

  v16[0] = 0;
  v7 = (int (__stdcall ***)(_DWORD, void *, _DWORD *))this[19];
  v2 = *v7;
  v15 = 0;
  if ( (*v2)(v7, &unk_42C6C0, v16) >= 0 )
  {
    v8[1] = this + 46;
    v8[3] = this + 50;
    v8[4] = this + 51;
    v8[0] = 64;
    v8[2] = 0;
    v12[1] = 0;
    v12[4] = 0;
    v12[5] = 0;
    AfxVariantInit(&pvarg);
    v3 = this[7];
    v16[3] = 0;
    v4 = *(_DWORD *)(v3 + 28);
    v9 = 0;
    v5 = &unk_42AFBC;
    do
    {
      (*(void (__thiscall **)(int, _DWORD *, _DWORD, VARIANTARG *))(*(_DWORD *)v4 + 148))(v4, this, *(v5 - 1), &pvarg);
      if ( pvarg.iVal )
        v9 |= *v5;
      v5 += 2;
    }
    while ( v5 < &off_42AFFC );
    (*(void (__thiscall **)(int, _DWORD *, int, VARIANTARG *))(*(_DWORD *)v4 + 148))(v4, this, -704, &pvarg);
    lVal = pvarg.lVal;
    (*(void (__thiscall **)(int, _DWORD *, int, VARIANTARG *))(*(_DWORD *)v4 + 148))(v4, this, -701, &pvarg);
    v11 = pvarg.lVal;
    (*(void (__thiscall **)(int, _DWORD *, int, VARIANTARG *))(*(_DWORD *)v4 + 148))(v4, this, -716, &pvarg);
    v12[2] = pvarg.iVal;
    (*(void (__thiscall **)(int, _DWORD *, int, VARIANTARG *))(*(_DWORD *)v4 + 148))(v4, this, -705, &pvarg);
    v12[3] = pvarg.lVal;
    (*(void (__thiscall **)(int, _DWORD *, int, VARIANTARG *))(*(_DWORD *)v4 + 148))(v4, this, -703, &pvarg);
    if ( (**(int (__stdcall ***)(LONG, void *, _DWORD *))pvarg.lVal)(pvarg.lVal, &unk_42C6B0, v12) < 0 )
      v12[0] = 0;
    v13[0] = 24;
    if ( (*(int (__stdcall **)(_DWORD, _DWORD *, _DWORD *))(*(_DWORD *)v16[0] + 12))(v16[0], v8, v13) >= 0 )
    {
      v15 = 1;
      this[28] = v13[1];
      this[24] = v13[3];
      this[25] = v13[4];
    }
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v16[0] + 8))(v16[0]);
    if ( v12[0] )
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v12[0] + 8))(v12[0]);
    VariantClear(&pvarg);
  }
  return v15;
}


// ========== Function: sub_4076BC @ 0x4076BC ==========
HRESULT __thiscall sub_4076BC(char *this, IID *rclsid, LPLOCKBYTES pplkbyt, IStorage *ppstgOpen, HRESULT ppv)
{
  _DWORD *v6; // edi
  HRESULT result; // eax
  LPLOCKBYTES v8; // esi
  struct ILockBytesVtbl *lpVtbl; // eax
  int v10; // eax
  unsigned __int16 *v11; // eax
  int v12; // eax
  LPLOCKBYTES v13; // eax
  IStorage *v14; // eax
  LPVOID v15; // eax
  unsigned int v16[17]; // [esp+Ch] [ebp-70h] BYREF
  _BYTE v17[8]; // [esp+50h] [ebp-2Ch] BYREF
  char *v18; // [esp+58h] [ebp-24h]
  int v19; // [esp+5Ch] [ebp-20h]
  LPLOCKBYTES plkbyt; // [esp+60h] [ebp-1Ch] BYREF
  IStorage *v21; // [esp+64h] [ebp-18h] BYREF
  int v22; // [esp+68h] [ebp-14h] BYREF
  int v23; // [esp+6Ch] [ebp-10h] BYREF
  int v24; // [esp+78h] [ebp-4h]

  v6 = this + 76;
  v18 = this;
  result = CoCreateInstanceLic(rclsid, 0, 3u, &stru_42C700, (void **)this + 19, (unsigned __int16 *)ppv);
  ppv = result;
  if ( result < 0 )
    return result;
  v23 = 0;
  v22 = 0;
  rclsid = 0;
  sub_407B35(this + 60);
  v19 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 188))(this);
  if ( !v19 )
  {
    (*(void (__stdcall **)(_DWORD, int, char *))(*(_DWORD *)*v6 + 88))(*v6, 1, this + 112);
    if ( (this[114] & 2) != 0 )
    {
      ppv = (*(int (__stdcall **)(_DWORD, char *))(*(_DWORD *)*v6 + 12))(*v6, this + 184);
      if ( ppv < 0 )
        goto LABEL_41;
    }
  }
  v8 = pplkbyt;
  if ( !pplkbyt )
  {
    if ( ppstgOpen )
      goto LABEL_16;
    goto LABEL_11;
  }
  if ( ppstgOpen )
    goto LABEL_16;
  if ( (**(int (__stdcall ***)(_DWORD, void *, IID **))*v6)(*v6, &unk_42C6F0, &rclsid) < 0
    || !((int (__thiscall *)(LPLOCKBYTES, int, _DWORD, _DWORD, _DWORD))v8->lpVtbl[2].QueryInterface)(v8, 3, 0, 0, 0) )
  {
LABEL_11:
    if ( (**(int (__stdcall ***)(_DWORD, void *, int *))*v6)(*v6, &unk_42C6E0, &v23) >= 0 )
    {
      if ( v8 )
      {
        sub_422C33(v8, 1, 4096, 0);
        v24 = 0;
        std::locale::facet::facet((std::locale::facet *)v17, (unsigned int)v16);
        v11 = (unsigned __int16 *)(*(int (__stdcall **)(int, _BYTE *))(*(_DWORD *)v23 + 20))(v23, v17);
        v24 = -1;
        ppv = (HRESULT)v11;
        CArchive::~CArchive((CArchive *)v16);
      }
      else
      {
        ppv = (*(int (__stdcall **)(int))(*(_DWORD *)v23 + 32))(v23);
      }
      v12 = v23;
      goto LABEL_35;
    }
LABEL_16:
    if ( (**(int (__stdcall ***)(_DWORD, void *, int *))*v6)(*v6, &unk_42C6D0, &v22) < 0 )
      goto LABEL_40;
    if ( v8 )
    {
      if ( !ppstgOpen )
      {
        ppv = -2147418113;
        goto LABEL_34;
      }
      pplkbyt = (LPLOCKBYTES)((int (__thiscall *)(LPLOCKBYTES))v8->lpVtbl[1].Release)(v8);
      v14 = (IStorage *)GlobalAlloc(0, (SIZE_T)pplkbyt);
      ppstgOpen = v14;
      if ( v14 && (v15 = GlobalLock(v14)) != 0 )
      {
        ((void (__thiscall *)(LPLOCKBYTES, LPVOID, LPLOCKBYTES))v8->lpVtbl[1].ReadAt)(v8, v15, pplkbyt);
        GlobalUnlock(ppstgOpen);
      }
      else
      {
        ppv = -2147024882;
        ppstgOpen = 0;
      }
      plkbyt = 0;
      if ( !ppstgOpen )
        goto LABEL_34;
      ppv = CreateILockBytesOnHGlobal(ppstgOpen, 1, &plkbyt);
      if ( ppv < 0 )
        goto LABEL_34;
      v21 = 0;
      ppv = StgOpenStorageOnILockBytes(plkbyt, 0, 0x12u, 0, 0, &v21);
      if ( ppv >= 0 )
      {
        ppv = (*(int (__stdcall **)(int, IStorage *))(*(_DWORD *)v22 + 24))(v22, v21);
        v21->lpVtbl->Release(v21);
      }
      v13 = plkbyt;
    }
    else
    {
      pplkbyt = 0;
      ppv = CreateILockBytesOnHGlobal(0, 1, &pplkbyt);
      if ( ppv < 0 )
      {
LABEL_34:
        v12 = v22;
LABEL_35:
        (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
        goto LABEL_36;
      }
      ppstgOpen = 0;
      ppv = StgCreateDocfileOnILockBytes(pplkbyt, 0x1012u, 0, &ppstgOpen);
      if ( ppv >= 0 )
      {
        ppv = (*(int (__stdcall **)(int, IStorage *))(*(_DWORD *)v22 + 20))(v22, ppstgOpen);
        ppstgOpen->lpVtbl->Release(ppstgOpen);
      }
      v13 = pplkbyt;
    }
    v13->lpVtbl->Release(v13);
    goto LABEL_34;
  }
  lpVtbl = v8->lpVtbl;
  ppstgOpen = 0;
  v10 = ((int (__thiscall *)(LPLOCKBYTES, _DWORD, int, IStorage **, LPLOCKBYTES *))lpVtbl[2].QueryInterface)(
          v8,
          0,
          -1,
          &ppstgOpen,
          &pplkbyt);
  ppv = (*(int (__stdcall **)(IID *, IStorage *, int))(rclsid->Data1 + 20))(rclsid, ppstgOpen, v10);
  (*(void (__stdcall **)(IID *))(rclsid->Data1 + 8))(rclsid);
  rclsid = 0;
LABEL_36:
  if ( ppv < 0 )
    goto LABEL_41;
  if ( !v19 && (v18[114] & 2) == 0 )
    ppv = (*(int (__stdcall **)(_DWORD, char *))(*(_DWORD *)*v6 + 12))(*v6, v18 + 184);
LABEL_40:
  if ( ppv < 0 )
  {
LABEL_41:
    if ( *v6 )
    {
      (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)*v6 + 24))(*v6, 1);
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v6 + 8))(*v6);
      *v6 = 0;
    }
  }
  if ( rclsid )
    (*(void (__stdcall **)(IID *))(rclsid->Data1 + 8))(rclsid);
  if ( v19 )
  {
    if ( ppv >= 0 )
      return 1;
  }
  return ppv;
}


// ========== Function: sub_4079C6 @ 0x4079C6 ==========
int __thiscall sub_4079C6(_DWORD *this)
{
  return this[10];
}


// ========== Function: ?DoVerb@COleControlSite@@UAEJJPAUtagMSG@@@Z @ 0x4079CA ==========
int __thiscall COleControlSite::DoVerb(COleControlSite *this, int a2, struct tagMSG *a3)
{
  return (*(int (__stdcall **)(_DWORD, int, struct tagMSG *, char *, _DWORD, _DWORD, char *))(**((_DWORD **)this + 19)
                                                                                            + 44))(
           *((_DWORD *)this + 19),
           a2,
           a3,
           (char *)this + 184,
           0,
           *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 7) + 28) + 28),
           (char *)this + 44);
}


// ========== Function: ?IsDefaultButton@COleControlSite@@QAEHXZ @ 0x4079F6 ==========
int __thiscall COleControlSite::IsDefaultButton(COleControlSite *this)
{
  int result; // eax

  if ( (*((_BYTE *)this + 113) & 0x10) == 0 )
    return 0;
  result = 1;
  if ( (*((_BYTE *)this + 108) & 1) == 0 )
    return 0;
  return result;
}


// ========== Function: sub_407A1F @ 0x407A1F ==========
void __thiscall sub_407A1F(int this, int a2)
{
  int v2; // eax

  if ( (*(_BYTE *)(this + 113) & 0x10) != 0 )
  {
    v2 = *(_DWORD *)(this + 108);
    if ( (v2 & 1) != a2 )
    {
      a2 = 0;
      *(_DWORD *)(this + 108) = v2 ^ 1;
      if ( (***(int (__stdcall ****)(_DWORD, void *, int *))(this + 76))(*(_DWORD *)(this + 76), &unk_42C710, &a2) >= 0 )
      {
        (*(void (__stdcall **)(int, int))(*(_DWORD *)a2 + 20))(a2, -713);
        (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 8))(a2);
      }
    }
  }
}


// ========== Function: ?ConnectSink@COleControlSite@@IAEKABU_GUID@@PAUIUnknown@@@Z @ 0x407A6F ==========
int __thiscall COleControlSite::ConnectSink(COleControlSite *this, const struct _GUID *a2, struct IUnknown *a3)
{
  int (__stdcall ***v3)(_DWORD, void *, int *); // eax
  int v5; // [esp+0h] [ebp-Ch] BYREF
  int v6; // [esp+4h] [ebp-8h] BYREF
  int v7; // [esp+8h] [ebp-4h] BYREF

  v3 = (int (__stdcall ***)(_DWORD, void *, int *))*((_DWORD *)this + 19);
  if ( !v3 || (**v3)(v3, &unk_42C720, &v6) < 0 )
    return 0;
  v7 = 0;
  v5 = 0;
  if ( (*(int (__stdcall **)(int, const struct _GUID *, int *))(*(_DWORD *)v6 + 16))(v6, a2, &v7) >= 0 )
  {
    (*(void (__stdcall **)(int, struct IUnknown *, int *))(*(_DWORD *)v7 + 20))(v7, a3, &v5);
    (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v6 + 8))(v6);
  return v5;
}


// ========== Function: ?DisconnectSink@COleControlSite@@IAEXABU_GUID@@K@Z @ 0x407AD7 ==========
void __thiscall COleControlSite::DisconnectSink(COleControlSite *this, const struct _GUID *a2, unsigned int a3)
{
  int (__stdcall ***v3)(_DWORD, void *, int *); // eax
  int v4; // [esp+0h] [ebp-8h] BYREF
  int v5; // [esp+4h] [ebp-4h] BYREF

  if ( a3 )
  {
    v3 = (int (__stdcall ***)(_DWORD, void *, int *))*((_DWORD *)this + 19);
    if ( v3 )
    {
      if ( (**v3)(v3, &unk_42C720, &v4) >= 0 )
      {
        v5 = 0;
        if ( (*(int (__stdcall **)(int, const struct _GUID *, int *))(*(_DWORD *)v4 + 16))(v4, a2, &v5) >= 0 )
        {
          (*(void (__stdcall **)(int, unsigned int))(*(_DWORD *)v5 + 24))(v5, a3);
          (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
      }
    }
  }
}


// ========== Function: sub_407B35 @ 0x407B35 ==========
BOOL __thiscall sub_407B35(_DWORD *this, _DWORD *Buf1)
{
  int (__stdcall ***v3)(_DWORD, void *, int *); // eax
  int v4; // esi
  _DWORD *v5; // esi
  int v6; // eax
  _DWORD *v8; // [esp-4h] [ebp-30h]
  int v9; // [esp+Ch] [ebp-20h] BYREF
  int v10; // [esp+10h] [ebp-1Ch] BYREF
  _DWORD *v11; // [esp+14h] [ebp-18h] BYREF
  int v12; // [esp+18h] [ebp-14h] BYREF
  int v13; // [esp+1Ch] [ebp-10h] BYREF
  int v14; // [esp+20h] [ebp-Ch] BYREF
  int v15; // [esp+24h] [ebp-8h] BYREF
  int v16; // [esp+28h] [ebp-4h] BYREF

  *Buf1 = dword_42C750[0];
  Buf1[1] = dword_42C750[1];
  Buf1[2] = dword_42C750[2];
  Buf1[3] = dword_42C750[3];
  v3 = (int (__stdcall ***)(_DWORD, void *, int *))this[19];
  v14 = 0;
  if ( (**v3)(v3, &unk_42C740, &v14) >= 0 )
  {
    (*(void (__stdcall **)(int, int, _DWORD *))(*(_DWORD *)v14 + 16))(v14, 1, Buf1);
    (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
  }
  v12 = 0;
  if ( !memcmp(Buf1, dword_42C750, 0x10u)
    && (**(int (__stdcall ***)(_DWORD, void *, int *))this[19])(this[19], &unk_42C730, &v12) >= 0 )
  {
    v16 = 0;
    if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)v12 + 12))(v12, &v16) >= 0 )
    {
      if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)v16 + 12))(v16, &v13) >= 0 )
      {
        v4 = 0;
        if ( *(_WORD *)(v13 + 48) )
        {
          while ( (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)v16 + 36))(v16, v4, &v10) < 0 || (v10 & 7) != 3 )
          {
            if ( ++v4 >= (unsigned int)*(unsigned __int16 *)(v13 + 48) )
              goto LABEL_17;
          }
          v15 = 0;
          if ( (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)v16 + 32))(v16, v4, &v9) >= 0
            && (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)v16 + 56))(v16, v9, &v15) >= 0 )
          {
            if ( (*(int (__stdcall **)(int, _DWORD **))(*(_DWORD *)v15 + 12))(v15, &v11) >= 0 )
            {
              v5 = v11;
              *Buf1 = *v11;
              Buf1[1] = *++v5;
              ++v5;
              v6 = v15;
              v8 = v11;
              Buf1[2] = *v5;
              Buf1[3] = v5[1];
              (*(void (__stdcall **)(int, _DWORD *))(*(_DWORD *)v6 + 76))(v6, v8);
            }
            (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
          }
        }
LABEL_17:
        (*(void (__stdcall **)(int, int))(*(_DWORD *)v16 + 76))(v16, v13);
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
    }
    (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
  }
  return memcmp(Buf1, dword_42C750, 0x10u) != 0;
}


// ========== Function: sub_407CAF @ 0x407CAF ==========
int __thiscall sub_407CAF(_DWORD *this)
{
  _DWORD *v2; // esi
  int (__stdcall ***v3)(_DWORD, void *, int *); // edi
  int result; // eax
  int v5; // [esp+8h] [ebp-4h] BYREF

  v2 = this + 29;
  memset(this + 29, 0, 0x10u);
  v3 = (int (__stdcall ***)(_DWORD, void *, int *))this[19];
  v5 = 0;
  *v2 = 16;
  result = (**v3)(v3, &unk_42C710, &v5);
  if ( result >= 0 )
  {
    (*(void (__stdcall **)(int, _DWORD *))(*(_DWORD *)v5 + 12))(v5, v2);
    return (*(int (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
  }
  return result;
}


// ========== Function: sub_407CFD @ 0x407CFD ==========
int __thiscall sub_407CFD(int this, int a2)
{
  unsigned __int16 v3; // ax
  struct tagACCEL *v4; // edi
  int v5; // eax
  struct tagACCEL *v7; // ecx
  int v8; // esi
  int v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]
  int v12; // [esp+18h] [ebp+8h]

  v3 = *(_WORD *)(this + 124);
  if ( !v3 || !*(_DWORD *)(this + 120) )
    return 0;
  v4 = (struct tagACCEL *)sub_41CA70(6 * v3);
  v5 = CopyAcceleratorTableA(*(HACCEL *)(this + 120), v4, *(unsigned __int16 *)(this + 124));
  v10 = 0;
  v11 = 0;
  if ( v5 > 0 )
  {
    v7 = v4;
    v8 = *(_DWORD *)(a2 + 4);
    while ( 1 )
    {
      v12 = v8 == 262 ? 16 : 0;
      if ( (v7->fVirt & 0xFD) == v12 && v7->key == *(_WORD *)(a2 + 8) )
        break;
      ++v11;
      ++v7;
      if ( v11 >= v5 )
        goto LABEL_13;
    }
    v10 = 1;
  }
LABEL_13:
  sub_41CA99(v4);
  return v10;
}


// ========== Function: sub_407DA0 @ 0x407DA0 ==========
int __thiscall sub_407DA0(_BYTE *this, int a2)
{
  int (__stdcall ***v3)(_DWORD, void *, int *); // eax
  int result; // eax
  int v5; // [esp+4h] [ebp-4h] BYREF

  if ( (this[113] & 0x40) == 0 )
    (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 172))(this);
  v3 = (int (__stdcall ***)(_DWORD, void *, int *))*((_DWORD *)this + 19);
  v5 = 0;
  result = (**v3)(v3, &unk_42C710, &v5);
  if ( result >= 0 )
  {
    (*(void (__stdcall **)(int, int))(*(_DWORD *)v5 + 16))(v5, a2);
    return (*(int (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
  }
  return result;
}


// ========== Function: ?FreezeEvents@COleControlSite@@QAEXH@Z @ 0x407DE8 ==========
void __thiscall COleControlSite::FreezeEvents(COleControlSite *this, int a2)
{
  int (__stdcall ***v2)(_DWORD, void *, int *); // eax
  int v3; // [esp+0h] [ebp-4h] BYREF

  v2 = (int (__stdcall ***)(_DWORD, void *, int *))*((_DWORD *)this + 19);
  v3 = 0;
  if ( (**v2)(v2, &unk_42C710, &v3) >= 0 )
  {
    (*(void (__stdcall **)(int, int))(*(_DWORD *)v3 + 24))(v3, a2);
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  }
}


// ========== Function: sub_407E1E @ 0x407E1E ==========
int __thiscall sub_407E1E(int this)
{
  int result; // eax
  int v3; // ecx
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = 0;
  result = (*(int (__stdcall **)(_DWORD, int *))(**(_DWORD **)(this + 80) + 12))(*(_DWORD *)(this + 80), &v4);
  if ( result >= 0 )
  {
    result = v4;
    if ( *(_DWORD *)(this + 32) != v4 )
    {
      v3 = *(_DWORD *)(this + 36);
      *(_DWORD *)(this + 32) = v4;
      if ( v3 )
      {
        sub_41D8AB(result);
        result = *(_DWORD *)(this + 36);
        *(_DWORD *)(result + 56) = this;
      }
    }
  }
  return result;
}


// ========== Function: sub_407E5B @ 0x407E5B ==========
void __thiscall sub_407E5B(_DWORD *this)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edi

  v2 = (_DWORD *)this[9];
  this[8] = 0;
  if ( v2 )
  {
    if ( v2[7] )
    {
      v3 = (_DWORD *)(*(int (__thiscall **)(_DWORD *))(*v2 + 128))(v2);
      if ( IsWindow(*(HWND *)(this[9] + 28)) )
      {
        if ( *v3 )
          sub_41FE1B(this[9]);
      }
      sub_41D8E4(this[9]);
    }
    *(_DWORD *)(this[9] + 56) = 0;
  }
}


// ========== Function: sub_407EA9 @ 0x407EA9 ==========
int __thiscall sub_407EA9(_DWORD *this, int a2)
{
  int v3; // ecx

  v3 = this[9];
  if ( v3 && (*(int (__thiscall **)(int, _DWORD, int, int, _DWORD))(*(_DWORD *)v3 + 12))(v3, this[10], -2, a2, 0) )
    return 1;
  else
    return (*(int (__thiscall **)(_DWORD, _DWORD, int, int, _DWORD))(**(_DWORD **)(this[7] + 28) + 12))(
             *(_DWORD *)(this[7] + 28),
             this[10],
             -2,
             a2,
             0);
}


// ========== Function: ?InvokeHelperV@COleControlSite@@UAEXJGGPAXPBEPAD@Z @ 0x407EE6 ==========
void __thiscall COleControlSite::InvokeHelperV(
        COleControlSite *this,
        int a2,
        int a3,
        VARTYPE vt,
        void *a5,
        const CHAR *lpString,
        char *a7)
{
  COleDispatchDriver *v7; // esi
  int (__stdcall ***v8)(_DWORD, void *, struct IDispatch **); // ecx
  struct IDispatch *v9; // [esp+4h] [ebp-4h] BYREF

  v7 = (COleControlSite *)((char *)this + 88);
  if ( *((_DWORD *)this + 22) )
    goto LABEL_6;
  v8 = (int (__stdcall ***)(_DWORD, void *, struct IDispatch **))*((_DWORD *)this + 19);
  if ( v8 )
  {
    if ( (**v8)(v8, &unk_42C530, &v9) >= 0 )
      COleDispatchDriver::AttachDispatch(v7, v9, 1);
  }
  if ( *(_DWORD *)v7 )
LABEL_6:
    sub_4264A8(a2, a3, vt, (int)a5, lpString, (int)a7);
}


// ========== Function: sub_407F3C @ 0x407F3C ==========
int __thiscall sub_407F3C(int *this, int a2, int a3, int a4)
{
  __int16 v4; // ax
  int v5; // edx
  int v6; // esi

  v4 = a3;
  if ( (a3 & 0x4000) != 0 )
  {
    HIBYTE(v4) = BYTE1(a3) & 0xBF;
    LOBYTE(v4) = a3 | 0x40;
  }
  v5 = 8;
  if ( v4 == 8 )
    v4 = 14;
  if ( v4 >= 0 )
    v5 = v4 != 9 ? 4 : 8;
  v6 = *this;
  HIWORD(a3) = (unsigned __int8)v4;
  return (*(int (__thiscall **)(int *, int, int, _DWORD, _DWORD, char *, int))(v6 + 88))(
           this,
           a2,
           v5,
           0,
           0,
           (char *)&a3 + 2,
           a4);
}


// ========== Function: sub_407F97 @ 0x407F97 ==========
int sub_407F97(int a1, int a2, int a3, int a4, int a5, int a6, ...)
{
  va_list va; // [esp+20h] [ebp+20h] BYREF

  va_start(va, a6);
  return (*(int (__thiscall **)(int, int, int, int, int, int, char *))(*(_DWORD *)a1 + 88))(a1, a2, a3, a4, a5, a6, va);
}


// ========== Function: sub_407FB7 @ 0x407FB7 ==========
int __thiscall sub_407FB7(void *this, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(void *, int, int, int, int, _DWORD))(*(_DWORD *)this + 96))(this, a2, 2, a3, a4, 0);
}


// ========== Function: sub_407FD3 @ 0x407FD3 ==========
int sub_407FD3(int a1, int a2, int a3, ...)
{
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, a3);
  return (*(int (__thiscall **)(int, int, int, char *))(*(_DWORD *)a1 + 92))(a1, a2, a3, va);
}


// ========== Function: sub_407FEA @ 0x407FEA ==========
int sub_407FEA(int *a1, int a2, int a3, ...)
{
  int v3; // eax
  int v5; // [esp+0h] [ebp-20h] BYREF
  int *v6; // [esp+10h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-4h]
  va_list va; // [esp+34h] [ebp+14h] BYREF

  va_start(va, a3);
  v3 = *a1;
  v6 = &v5;
  v7 = 0;
  (*(void (__stdcall **)(int, int, char *))(v3 + 92))(a2, a3, va);
  return 1;
}


// ========== Function: sub_40803D @ 0x40803D ==========
int __thiscall sub_40803D(_DWORD *this)
{
  LONG WindowLongA; // eax
  LONG v3; // edi
  int v4; // eax
  int v5; // edi
  int v6; // edx
  HWND v8; // [esp-8h] [ebp-34h]
  int v9; // [esp+0h] [ebp-2Ch] BYREF
  _DWORD *v10; // [esp+10h] [ebp-1Ch]
  int v11; // [esp+14h] [ebp-18h] BYREF
  int v12; // [esp+18h] [ebp-14h]
  int *v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+28h] [ebp-4h]

  v13 = &v9;
  v8 = (HWND)this[8];
  v10 = this;
  WindowLongA = GetWindowLongA(v8, -16);
  v14 = 0;
  v3 = WindowLongA;
  v4 = *this;
  v5 = this[27] | v3 & 0x10000000;
  v12 = v5;
  v11 = 1;
  (*(void (__thiscall **)(_DWORD *, int, int, int *))(v4 + 100))(this, -514, 11, &v11);
  if ( !v11 )
    v12 = v5 | 0x8000000;
  v6 = *this;
  v11 = 0;
  v14 = 2;
  (*(void (__thiscall **)(_DWORD *, int, int, int *))(v6 + 100))(this, -504, 2, &v11);
  if ( (_WORD)v11 == 1 )
    BYTE2(v12) |= 0x80u;
  return v12;
}


// ========== Function: sub_4080F3 @ 0x4080F3 ==========
LONG __thiscall sub_4080F3(HWND *this)
{
  LONG WindowLongA; // eax
  int v4; // [esp+0h] [ebp-28h] BYREF
  int v5; // [esp+10h] [ebp-18h] BYREF
  LONG v6; // [esp+14h] [ebp-14h]
  int *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+24h] [ebp-4h]

  v7 = &v4;
  WindowLongA = GetWindowLongA(this[8], -20);
  v8 = 0;
  v5 = 0;
  v6 = WindowLongA;
  (*((void (__thiscall **)(HWND *, int, int, int *))*this + 25))(this, -520, 2, &v5);
  if ( (_WORD)v5 == 1 )
    BYTE1(v6) |= 2u;
  return v6;
}


// ========== Function: sub_40815B @ 0x40815B ==========
int __thiscall sub_40815B(void *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned int v6; // edi

  v4 = a2;
  v6 = a3;
  *((_DWORD *)this + 27) = *((_DWORD *)this + 26) & (a3 | *((_DWORD *)this + 27) & ~a2);
  if ( ((a2 & 0x8000000) != 0 || (a3 & 0x8000000) != 0)
    && (*(int (__cdecl **)(void *, int, int, unsigned int))(*(_DWORD *)this + 108))(this, -514, 11, ~a3 & 0x8000000) )
  {
    v4 = a2 & 0xF7FFFFFF;
    v6 = a3 & 0xF7FFFFFF;
  }
  if ( (v4 & 0x800000) != 0 || (v6 & 0x800000) != 0 )
  {
    if ( (*(int (__cdecl **)(void *, int, int, unsigned int))(*(_DWORD *)this + 108))(this, -504, 2, v6 & 0x800000) )
    {
      v4 &= ~0x800000u;
      v6 &= ~0x800000u;
    }
  }
  return CWnd::ModifyStyle(*((HWND *)this + 8), v4, v6, a4);
}


// ========== Function: sub_4081EB @ 0x4081EB ==========
int __thiscall sub_4081EB(HWND *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // edi

  v4 = a3;
  if ( (a2 & 0x200) != 0 || (a3 & 0x200) != 0 )
  {
    if ( (*((int (__cdecl **)(HWND *, int, int, unsigned int))*this + 27))(this, -520, 2, a3 & 0x200) )
    {
      a2 &= ~0x200u;
      v4 = a3 & 0xFFFFFDFF;
    }
  }
  return CWnd::ModifyStyleEx(this[8], a2, v4, a4);
}


// ========== Function: sub_40823B @ 0x40823B ==========
int __thiscall sub_40823B(void *this, int a2)
{
  int result; // eax

  result = (*(int (__cdecl **)(void *, int, int, int))(*(_DWORD *)this + 108))(this, -518, 8, a2);
  if ( !result )
    return (*(int (__cdecl **)(void *, int, int, int))(*(_DWORD *)this + 108))(this, -517, 8, a2);
  return result;
}


// ========== Function: sub_40826E @ 0x40826E ==========
int __thiscall sub_40826E(_DWORD *this, int a2)
{
  int v2; // eax
  int v4; // [esp+0h] [ebp-24h] BYREF
  _DWORD *v5; // [esp+10h] [ebp-14h]
  int *v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+20h] [ebp-4h]

  v2 = *this;
  v7 = 0;
  v6 = &v4;
  v5 = this;
  return (*(int (__stdcall **)(int, int, int))(v2 + 100))(-518, 8, a2);
}


// ========== Function: sub_4082DD @ 0x4082DD ==========
int __thiscall sub_4082DD(int *this, LPSTR lpString1, int iMaxLength)
{
  int v3; // eax
  int v4; // eax
  int v5; // esi
  LPCSTR lpString2; // [esp+4h] [ebp-10h] BYREF
  int v8; // [esp+10h] [ebp-4h]

  lpString2 = (LPCSTR)off_433548;
  v3 = *this;
  v8 = 0;
  (*(void (__thiscall **)(int *, LPCSTR *))(v3 + 136))(this, &lpString2);
  lstrcpynA(lpString1, lpString2, iMaxLength);
  v4 = lstrlenA(lpString1);
  v8 = -1;
  v5 = v4;
  sub_4200DD(&lpString2);
  return v5;
}


// ========== Function: sub_408338 @ 0x408338 ==========
int __thiscall sub_408338(int *this)
{
  int v1; // eax
  int v2; // esi
  _DWORD *v4; // [esp+4h] [ebp-10h] BYREF
  int v5; // [esp+10h] [ebp-4h]

  v4 = off_433548;
  v1 = *this;
  v5 = 0;
  (*(void (__thiscall **)(int *, _DWORD **))(v1 + 136))(this, &v4);
  v5 = -1;
  v2 = *(v4 - 2);
  sub_4200DD(&v4);
  return v2;
}


// ========== Function: ?SetDlgCtrlID@COleControlSite@@UAEHH@Z @ 0x40837D ==========
int __thiscall COleControlSite::SetDlgCtrlID(COleControlSite *this, int a2)
{
  int result; // eax

  result = *((_DWORD *)this + 10);
  *((_DWORD *)this + 10) = a2;
  return result;
}


// ========== Function: ?MoveWindow@COleControlSite@@UAEXHHHHH@Z @ 0x40838A ==========
void __thiscall COleControlSite::MoveWindow(COleControlSite *this, int xLeft, int yTop, int a4, int a5, int a6)
{
  struct tagRECT *v6; // ebx
  LONG v7; // [esp+Ch] [ebp-14h]
  LONG v8; // [esp+10h] [ebp-10h]
  LONG v9; // [esp+14h] [ebp-Ch]
  LONG v10; // [esp+18h] [ebp-8h]

  v6 = (struct tagRECT *)((char *)this + 44);
  v7 = *((_DWORD *)this + 11);
  v8 = *((_DWORD *)this + 12);
  v9 = *((_DWORD *)this + 13);
  v10 = *((_DWORD *)this + 14);
  SetRect((LPRECT)((char *)this + 44), xLeft, yTop, xLeft + a4, yTop + a5);
  if ( sub_40711A((int)this) )
  {
    SetRect(v6, xLeft, yTop, xLeft + v6->right - v6->left, yTop + v6->bottom - v6->top);
    (*(void (__stdcall **)(_DWORD, struct tagRECT *, struct tagRECT *))(**((_DWORD **)this + 20) + 28))(
      *((_DWORD *)this + 20),
      v6,
      v6);
  }
  else
  {
    v6->left = v7;
    v6->top = v8;
    v6->right = v9;
    v6->bottom = v10;
  }
}


// ========== Function: sub_408404 @ 0x408404 ==========
BOOL __thiscall sub_408404(HWND *this, HWND hWndInsertAfter, int X, int Y, int a5, int cy, int a7)
{
  int v7; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  HWND v12; // eax
  UINT v13; // ebx
  int v15; // [esp+8h] [ebp-4h]
  int v16; // [esp+28h] [ebp+1Ch]

  v7 = a7;
  if ( (a7 & 0x80u) != 0 )
    (*((void (__thiscall **)(HWND *, _DWORD))*this + 40))(this, 0);
  if ( (a7 & 3) != 3 )
  {
    if ( (a7 & 2) != 0 )
    {
      v15 = (int)this[11];
      v9 = (int)this[12];
    }
    else
    {
      v15 = X;
      v9 = Y;
    }
    v16 = v9;
    if ( (v7 & 1) != 0 )
    {
      v10 = (char *)this[13] - (char *)this[11];
      v11 = (char *)this[14] - (char *)this[12];
    }
    else
    {
      v10 = a5;
      v11 = cy;
    }
    (*((void (__thiscall **)(HWND *, int, int, int, int, unsigned int))*this + 38))(
      this,
      v15,
      v16,
      v10,
      v11,
      ((unsigned int)~v7 >> 3) & 1);
  }
  if ( (v7 & 0x40) != 0 )
    (*((void (__thiscall **)(HWND *, int))*this + 40))(this, 5);
  v12 = hWndInsertAfter;
  LOBYTE(v7) = v7 & 0x3F;
  v13 = v7 | 3;
  if ( hWndInsertAfter )
    v12 = (HWND)*((_DWORD *)hWndInsertAfter + 7);
  return SetWindowPos(this[8], v12, X, Y, a5, cy, v13);
}


// ========== Function: sub_4084B9 @ 0x4084B9 ==========
BOOL __thiscall sub_4084B9(HWND *this, int a2)
{
  BOOL v3; // edi
  int v4; // eax

  v3 = IsWindowVisible(this[8]);
  if ( !a2 )
  {
    v4 = -3;
    goto LABEL_7;
  }
  if ( a2 == 1 || a2 > 3 && a2 <= 5 )
  {
    v4 = -1;
LABEL_7:
    (*((void (__thiscall **)(HWND *, int, _DWORD))*this + 21))(this, v4, 0);
  }
  return v3;
}


// ========== Function: sub_4084F8 @ 0x4084F8 ==========
int __thiscall sub_4084F8(int *this)
{
  int v1; // eax
  int v3; // [esp+0h] [ebp-24h] BYREF
  _DWORD v4[5]; // [esp+10h] [ebp-14h] BYREF

  v1 = *this;
  v4[4] = 0;
  v4[1] = &v3;
  v4[0] = 1;
  (*(void (__stdcall **)(int, int, _DWORD *))(v1 + 100))(-514, 11, v4);
  return v4[0];
}


// ========== Function: sub_408546 @ 0x408546 ==========
BOOL __thiscall sub_408546(int *this, int a2)
{
  int v3; // eax
  int v5; // [esp+0h] [ebp-24h] BYREF
  _DWORD v6[5]; // [esp+10h] [ebp-14h] BYREF

  v6[4] = 0;
  v3 = *this;
  v6[1] = &v5;
  (*(void (__thiscall **)(int *, int, int, _DWORD *))(v3 + 100))(this, -514, 11, v6);
  (*(void (__cdecl **)(int *, int, int, int))(*this + 104))(this, -514, 11, a2);
  return v6[0] == 0;
}


// ========== Function: ?SetFocus@COleControlSite@@UAEPAVCWnd@@XZ @ 0x4085AF ==========
struct CWnd *__thiscall COleControlSite::SetFocus(HWND *this)
{
  HWND v2; // eax
  HWND Focus; // eax
  int v5; // edi

  if ( (*((_BYTE *)this + 113) & 0x40) != 0 )
  {
    v2 = SetFocus(this[8]);
    return (struct CWnd *)sub_41D866(v2);
  }
  else
  {
    Focus = GetFocus();
    v5 = sub_41D866(Focus);
    (*((void (__thiscall **)(HWND *, int, _DWORD))*this + 21))(this, -4, 0);
    return (struct CWnd *)v5;
  }
}


// ========== Function: sub_4085E8 @ 0x4085E8 ==========
void *__thiscall sub_4085E8(struct COleControlSite *this)
{
  void *result; // eax
  CDataSourceControl *v3; // ecx
  CDataSourceControl *v4; // eax

  result = &loc_4280EE;
  if ( !*((_DWORD *)this + 34) )
  {
    v3 = (CDataSourceControl *)sub_41CA70(0x5Cu);
    if ( v3 )
      v4 = CDataSourceControl::CDataSourceControl(v3, this);
    else
      v4 = 0;
    *((_DWORD *)this + 34) = v4;
    return (void *)sub_4091E5(v4);
  }
  return result;
}


// ========== Function: sub_40863C @ 0x40863C ==========
int __thiscall sub_40863C(_DWORD *this, int a2, unsigned __int16 a3, LPCSTR lpString, int a5)
{
  int result; // eax
  int v7; // esi

  result = this[36];
  if ( result )
  {
    (*(void (__thiscall **)(_DWORD, _DWORD *, _DWORD))(**(_DWORD **)(result + 136) + 8))(
      *(_DWORD *)(result + 136),
      this,
      0);
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this[36] + 136) + 12))(*(_DWORD *)(this[36] + 136));
    this[36] = 0;
  }
  if ( a5 )
  {
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a5 + 56) + 176))(*(_DWORD *)(a5 + 56));
    this[36] = *(_DWORD *)(a5 + 56);
    this[37] = a2;
    this[38] = a3;
    CString::operator=((CString *)(this + 39), lpString);
    result = (*(int (__thiscall **)(_DWORD, _DWORD *, int))(**(_DWORD **)(this[36] + 136) + 8))(
               *(_DWORD *)(this[36] + 136),
               this,
               1);
    v7 = this[36];
    if ( v7 )
      return (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v7 + 136) + 12))(*(_DWORD *)(v7 + 136));
  }
  return result;
}


// ========== Function: ?BindProperty@COleControlSite@@UAEXJPAVCWnd@@@Z @ 0x4086DE ==========
void __thiscall COleControlSite::BindProperty(COleControlSite *this, int a2, struct CWnd *a3)
{
  CDataBoundProperty *v4; // ecx
  CDataBoundProperty *v5; // eax
  _DWORD *v6; // edi
  int v7; // ebx
  int v8; // eax
  int v9; // ecx

  if ( !a3 || a2 == -1 )
  {
    v6 = (_DWORD *)*((_DWORD *)this + 35);
    if ( v6 )
    {
      do
      {
        v7 = sub_40B52C(v6);
        if ( (a2 == -1 || v6[2] == a2) && (!a3 || *((_DWORD *)a3 + 14) == v6[3]) )
        {
          *((_DWORD *)this + 35) = v7;
          v8 = v6[3];
          if ( v8 )
          {
            v9 = *(_DWORD *)(v8 + 136);
            if ( v9 )
              (*(void (__thiscall **)(int, _DWORD *, _DWORD))(*(_DWORD *)v9 + 4))(v9, v6, 0);
          }
          if ( v6 )
            sub_41CA99(v6);
        }
        v6 = (_DWORD *)v7;
      }
      while ( v7 );
    }
  }
  else
  {
    v4 = (CDataBoundProperty *)sub_41CA70(0x1Cu);
    if ( v4 )
      v5 = CDataBoundProperty::CDataBoundProperty(v4, *((struct CDataBoundProperty **)this + 35), a2, 0);
    else
      v5 = 0;
    *((_DWORD *)this + 35) = v5;
    *((_DWORD *)v5 + 3) = *((_DWORD *)a3 + 14);
    **((_DWORD **)this + 35) = this;
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(*((_DWORD *)this + 35) + 12) + 176))(*(_DWORD *)(*((_DWORD *)this + 35)
                                                                                                  + 12));
    (*(void (__thiscall **)(_DWORD, _DWORD, int))(**(_DWORD **)(*(_DWORD *)(*((_DWORD *)this + 35) + 12) + 136) + 4))(
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 35) + 12) + 136),
      *((_DWORD *)this + 35),
      1);
  }
}


// ========== Function: ?AddRef@XOleClientSite@COleControlSite@@UAGKXZ @ 0x4087F4 ==========
LONG __stdcall COleControlSite::XOleClientSite::AddRef(COleControlSite::XOleClientSite *this)
{
  return InterlockedIncrement((volatile LONG *)this - 45);
}


// ========== Function: ?Release@XOleClientSite@COleControlSite@@UAGKXZ @ 0x408807 ==========
int __stdcall COleControlSite::XOleClientSite::Release(COleControlSite::XOleClientSite *this)
{
  return sub_4259CA((char *)this - 184);
}


// ========== Function: ?QueryInterface@XOleClientSite@COleControlSite@@UAGJABU_GUID@@PAPAX@Z @ 0x408819 ==========
unsigned int __stdcall COleControlSite::XOleClientSite::QueryInterface(
        COleControlSite::XOleClientSite *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::InternalQueryInterface((COleControlSite::XOleClientSite *)((char *)this - 184), a2, a3);
}


// ========== Function: sub_408833 @ 0x408833 ==========
int __stdcall sub_408833(int a1)
{
  return -2147467263;
}


// ========== Function: sub_40883B @ 0x40883B ==========
int __stdcall sub_40883B(int a1, int a2, int a3, int a4)
{
  return -2147467263;
}


// ========== Function: ?GetContainer@XOleClientSite@COleControlSite@@UAGJPAPAUIOleContainer@@@Z @ 0x408843 ==========
unsigned int __stdcall COleControlSite::XOleClientSite::GetContainer(CCmdTarget **this, struct IOleContainer **a2)
{
  return CCmdTarget::InternalQueryInterface(*(this - 39), &unk_42C550, (void **)a2);
}


// ========== Function: ?ShowObject@XOleClientSite@COleControlSite@@UAGJXZ @ 0x40885E ==========
int __stdcall COleControlSite::XOleClientSite::ShowObject(COleControlSite::XOleClientSite *this)
{
  sub_407E1E((int)this - 184);
  return 0;
}


// ========== Function: ?AddRef@XOleIPSite@COleControlSite@@UAGKXZ @ 0x408872 ==========
LONG __stdcall COleControlSite::XOleIPSite::AddRef(COleControlSite::XOleIPSite *this)
{
  return InterlockedIncrement((volatile LONG *)this - 46);
}


// ========== Function: ?Release@XOleIPSite@COleControlSite@@UAGKXZ @ 0x408885 ==========
int __stdcall COleControlSite::XOleIPSite::Release(COleControlSite::XOleIPSite *this)
{
  return sub_4259CA((char *)this - 188);
}


// ========== Function: ?QueryInterface@XOleIPSite@COleControlSite@@UAGJABU_GUID@@PAPAX@Z @ 0x408897 ==========
unsigned int __stdcall COleControlSite::XOleIPSite::QueryInterface(
        COleControlSite::XOleIPSite *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::InternalQueryInterface((COleControlSite::XOleIPSite *)((char *)this - 188), a2, a3);
}


// ========== Function: ?GetWindow@XOleIPSite@COleControlSite@@UAGJPAPAUHWND__@@@Z @ 0x4088B1 ==========
int __stdcall COleControlSite::XOleIPSite::GetWindow(COleControlSite::XOleIPSite *this, HWND *a2)
{
  HWND v2; // eax

  v2 = *(HWND *)(*((_DWORD *)this - 40) + 28);
  if ( v2 )
    v2 = (HWND)*((_DWORD *)v2 + 7);
  *a2 = v2;
  return v2 != 0 ? 0 : -2147467259;
}


// ========== Function: sub_4088DC @ 0x4088DC ==========
int __stdcall sub_4088DC(int a1, int a2)
{
  return -2147467263;
}


// ========== Function: sub_4088E4 @ 0x4088E4 ==========
int __stdcall sub_4088E4(int a1)
{
  (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 - 188 + 28) + 92))(*(_DWORD *)(a1 - 188 + 28), a1 - 188);
  return 0;
}


// ========== Function: ?GetWindowContext@XOleIPSite@COleControlSite@@UAGJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagRECT@@2PAUtagOIFI@@@Z @ 0x4088FB ==========
int __stdcall COleControlSite::XOleIPSite::GetWindowContext(
        CCmdTarget **this,
        struct IOleInPlaceFrame **a2,
        struct IOleInPlaceUIWindow **a3,
        LPRECT lprcDst,
        LPRECT lpRect,
        struct tagOIFI *a6)
{
  HWND v7; // esi

  if ( a3 )
    *a3 = 0;
  if ( (CCmdTarget::InternalQueryInterface(*(this - 40), &unk_42C560, (void **)a2) & 0x80000000) != 0 )
    return -2147467259;
  v7 = (HWND)*((_DWORD *)*(this - 40) + 7);
  CopyRect(lprcDst, (const RECT *)this - 9);
  GetClientRect(*((HWND *)v7 + 7), lpRect);
  a6->fMDIApp = 0;
  if ( v7 )
    v7 = (HWND)*((_DWORD *)v7 + 7);
  a6->haccel = 0;
  a6->cAccelEntries = 0;
  a6->hwndFrame = v7;
  return 0;
}


// ========== Function: _DllMain@12 @ 0x408973 ==========
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  return 1;
}


// ========== Function: sub_408979 @ 0x408979 ==========
int __stdcall sub_408979(int a1, int a2)
{
  (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 - 188 + 28) + 96))(*(_DWORD *)(a1 - 188 + 28), a1 - 188);
  return 0;
}


// ========== Function: ?OnInPlaceDeactivate@XOleIPSite@COleControlSite@@UAGJXZ @ 0x408990 ==========
int __stdcall COleControlSite::XOleIPSite::OnInPlaceDeactivate(COleControlSite::XOleIPSite *this)
{
  sub_407E5B((_DWORD *)this - 47);
  return 0;
}


// ========== Function: ?DeactivateAndUndo@XOleIPSite@COleControlSite@@UAGJXZ @ 0x4089A4 ==========
int __stdcall COleControlSite::XOleIPSite::DeactivateAndUndo(COleControlSite::XOleIPSite *this)
{
  (*(void (__stdcall **)(_DWORD))(**((_DWORD **)this - 27) + 24))(*((_DWORD *)this - 27));
  return 0;
}


// ========== Function: ?OnPosRectChange@XOleIPSite@COleControlSite@@UAGJPBUtagRECT@@@Z @ 0x4089B6 ==========
int __stdcall COleControlSite::XOleIPSite::OnPosRectChange(struct tagRECT *this, RECT *lprcSrc)
{
  LONG top; // ebx
  struct tagRECT Rect; // [esp+Ch] [ebp-20h] BYREF
  struct tagRECT rcDst; // [esp+1Ch] [ebp-10h] BYREF

  GetClientRect(*(HWND *)(*(_DWORD *)(this[-10].left + 28) + 28), &Rect);
  CopyRect(&rcDst, lprcSrc);
  top = this[-7].top;
  this[-9] = rcDst;
  return (*(int (__stdcall **)(LONG, struct tagRECT *, struct tagRECT *))(*(_DWORD *)top + 28))(top, this - 9, &Rect);
}


// ========== Function: ?AddRef@XOleControlSite@COleControlSite@@UAGKXZ @ 0x408A09 ==========
LONG __stdcall COleControlSite::XOleControlSite::AddRef(COleControlSite::XOleControlSite *this)
{
  return InterlockedIncrement((volatile LONG *)this - 47);
}


// ========== Function: ?Release@XOleControlSite@COleControlSite@@UAGKXZ @ 0x408A1C ==========
int __stdcall COleControlSite::XOleControlSite::Release(COleControlSite::XOleControlSite *this)
{
  return sub_4259CA((char *)this - 192);
}


// ========== Function: ?QueryInterface@XOleControlSite@COleControlSite@@UAGJABU_GUID@@PAPAX@Z @ 0x408A2E ==========
unsigned int __stdcall COleControlSite::XOleControlSite::QueryInterface(
        COleControlSite::XOleControlSite *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::InternalQueryInterface((COleControlSite::XOleControlSite *)((char *)this - 192), a2, a3);
}


// ========== Function: ?OnControlInfoChanged@XOleControlSite@COleControlSite@@UAGJXZ @ 0x408A48 ==========
int __stdcall COleControlSite::XOleControlSite::OnControlInfoChanged(COleControlSite::XOleControlSite *this)
{
  sub_407CAF((_DWORD *)this - 48);
  return 0;
}


// ========== Function: ?TransformCoords@XOleControlSite@COleControlSite@@UAGJPAU_POINTL@@PAUtagPOINTF@@K@Z @ 0x408A5C ==========
int __stdcall COleControlSite::XOleControlSite::TransformCoords(
        COleControlSite::XOleControlSite *this,
        struct _POINTL *a2,
        struct tagPOINTF *a3,
        char a4)
{
  HDC DC; // edi
  LONG v5; // ecx
  struct tagPOINTF *v6; // eax
  double v7; // st7
  double y; // st7
  struct _POINTL *v9; // eax
  int v10; // ecx
  HWND v12; // [esp-4h] [ebp-24h]
  struct tagPOINT pt; // [esp+Ch] [ebp-14h] BYREF
  LONG x; // [esp+14h] [ebp-Ch]
  LONG v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]
  struct tagPOINTF *v17; // [esp+30h] [ebp+10h]

  v12 = (HWND)*((_DWORD *)this - 40);
  v16 = 0;
  DC = GetDC(v12);
  SetMapMode(DC, 3);
  pt.x = 0;
  pt.y = 0;
  if ( (a4 & 4) == 0 )
  {
    if ( (a4 & 8) != 0 )
    {
      y = a3->y;
      x = (__int64)a3->x;
      v15 = (__int64)y;
      DPtoLP(DC, &pt, 2);
      if ( (a4 & 2) != 0 )
      {
        v9 = a2;
        a2->x = x - pt.x;
        v10 = pt.y - v15;
      }
      else
      {
        if ( (a4 & 1) == 0 )
          goto LABEL_13;
        v9 = a2;
        a2->x = x;
        v10 = v15;
      }
      v9->y = v10;
      goto LABEL_14;
    }
LABEL_13:
    v16 = -2147024809;
    goto LABEL_14;
  }
  v5 = a2->x;
  v15 = a2->y;
  x = v5;
  LPtoDP(DC, &pt, 2);
  if ( (a4 & 2) == 0 )
  {
    if ( (a4 & 1) != 0 )
    {
      v6 = a3;
      a3->x = (float)x;
      v7 = (double)v15;
      goto LABEL_6;
    }
    goto LABEL_13;
  }
  v6 = a3;
  v17 = (struct tagPOINTF *)(pt.y - v15);
  v6->x = (float)(x - pt.x);
  v7 = (double)(int)v17;
LABEL_6:
  v6->y = v7;
LABEL_14:
  ReleaseDC(*((HWND *)this - 40), DC);
  return v16;
}


// ========== Function: sub_408B5E @ 0x408B5E ==========
int __stdcall sub_408B5E(int a1, int a2, int a3)
{
  return -2147467263;
}


// ========== Function: sub_408B66 @ 0x408B66 ==========
int __stdcall sub_408B66(int a1, int a2)
{
  return 0;
}


// ========== Function: unknown_libname_8 @ 0x408B6B ==========
// MFC 3.1-14.0 32bit
LONG __stdcall unknown_libname_8(int a1)
{
  return InterlockedIncrement((volatile LONG *)(a1 - 192));
}


// ========== Function: ?Release@XAmbientProps@COleControlSite@@UAGKXZ @ 0x408B7E ==========
int __stdcall COleControlSite::XAmbientProps::Release(COleControlSite::XAmbientProps *this)
{
  return sub_4259CA((char *)this - 196);
}


// ========== Function: ?QueryInterface@XAmbientProps@COleControlSite@@UAGJABU_GUID@@PAPAX@Z @ 0x408B90 ==========
unsigned int __stdcall COleControlSite::XAmbientProps::QueryInterface(
        COleControlSite::XAmbientProps *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::InternalQueryInterface((COleControlSite::XAmbientProps *)((char *)this - 196), a2, a3);
}


// ========== Function: sub_408BAA @ 0x408BAA ==========
int __stdcall sub_408BAA(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // ecx

  v9 = *(_DWORD *)(*(_DWORD *)(a1 - 196 + 28) + 28);
  return (*(int (__thiscall **)(int, int, int, int))(*(_DWORD *)v9 + 148))(v9, a1 - 196, a2, a7) != 0 ? 0 : -2147352573;
}


// ========== Function: sub_408BDB @ 0x408BDB ==========
int __stdcall sub_408BDB(int a1, void *Buf1, _DWORD *a3)
{
  if ( memcmp(Buf1, &dword_42C760, 0x10u) && memcmp(Buf1, &stru_42C670, 0x10u) )
    return -2147467262;
  *a3 = a1;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}


// ========== Function: sub_408C25 @ 0x408C25 ==========
int __stdcall sub_408C25(int a1)
{
  return 1;
}


// ========== Function: sub_408C2B @ 0x408C2B ==========
int __stdcall sub_408C2B(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  int result; // eax
  int (__stdcall ***v5)(_DWORD, void *, int *); // eax
  int v6; // [esp+Ch] [ebp-38h] BYREF
  _DWORD v7[8]; // [esp+10h] [ebp-34h] BYREF
  _BYTE v8[16]; // [esp+30h] [ebp-14h] BYREF
  _BYTE v9[4]; // [esp+40h] [ebp-4h] BYREF

  v2 = a1 - 200;
  if ( *(_DWORD *)(a1 - 200 + 160) )
    return 0;
  v3 = a2;
  if ( *(_DWORD *)(v2 + 136)
    || (v6 = 2,
        v7[0] = a2,
        memset(&v7[1], 0, 12),
        memset(&v7[5], 0, 12),
        sub_407EA9((_DWORD *)(a1 - 200), (int)&v6),
        (result = v7[5]) == 0) )
  {
    if ( *(_DWORD *)(v2 + 148) == v3 )
    {
      VariantClear((VARIANTARG *)(v2 + 168));
      v5 = *(int (__stdcall ****)(_DWORD, void *, int *))(v2 + 76);
      a1 = 0;
      if ( (**v5)(v5, &unk_42C530, &a1) >= 0 )
      {
        memset(v7, 0, sizeof(v7));
        memset(v8, 0, sizeof(v8));
        a2 = (*(int (__stdcall **)(int, int, _DWORD *, _DWORD, int, _BYTE *, int, _DWORD *, _BYTE *))(*(_DWORD *)a1 + 24))(
               a1,
               v3,
               dword_42C750,
               0,
               2,
               v8,
               v2 + 168,
               v7,
               v9);
        if ( v7[1] )
          SysFreeString((BSTR)v7[1]);
        if ( v7[2] )
          SysFreeString((BSTR)v7[2]);
        if ( v7[3] )
          SysFreeString((BSTR)v7[3]);
        (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 8))(a1);
        if ( a2 >= 0 )
          *(_DWORD *)(v2 + 164) = 1;
      }
    }
    return 0;
  }
  return result;
}


// ========== Function: ?OnRequestEdit@XPropertyNotifySink@COleControlSite@@UAGJJ@Z @ 0x408D41 ==========
int __stdcall COleControlSite::XPropertyNotifySink::OnRequestEdit(COleControlSite::XPropertyNotifySink *this, int a2)
{
  _DWORD *v2; // ecx
  int result; // eax
  _DWORD v4[6]; // [esp+4h] [ebp-24h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  v2 = (_DWORD *)((char *)this - 200);
  if ( *((_DWORD *)this - 10) )
    return 0;
  if ( v2[34] )
    return 0;
  v4[0] = 1;
  v4[1] = a2;
  memset(&v4[2], 0, 12);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  sub_407EA9(v2, (int)v4);
  result = v5;
  if ( !v5 )
    return 0;
  return result;
}


// ========== Function: sub_408D96 @ 0x408D96 ==========
int __stdcall sub_408D96(int a1)
{
  return 0;
}


// ========== Function: sub_408D9B @ 0x408D9B ==========
int __stdcall sub_408D9B(int a1, void *Buf1, _DWORD *a3)
{
  if ( memcmp(Buf1, &dword_42C760, 0x10u)
    && memcmp(Buf1, &unk_42C530, 0x10u)
    && memcmp(Buf1, (const void *)(a1 - 144), 0x10u) )
  {
    return -2147467262;
  }
  *a3 = a1;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}


// ========== Function: sub_408DFF @ 0x408DFF ==========
int __stdcall sub_408DFF(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return -2147467263;
}


// ========== Function: ?Invoke@XEventSink@COleControlSite@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z @ 0x408E07 ==========
int __stdcall COleControlSite::XEventSink::Invoke(
        COleControlSite::XEventSink *this,
        int a2,
        const struct _GUID *a3,
        unsigned int a4,
        unsigned __int16 a5,
        struct tagDISPPARAMS *a6,
        VARIANTARG *pvarg,
        struct tagEXCEPINFO *a8,
        unsigned int *a9)
{
  _DWORD v10[6]; // [esp+4h] [ebp-24h] BYREF
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h]

  v10[1] = a2;
  v10[2] = a6;
  v10[3] = a8;
  v10[4] = a9;
  v10[0] = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  sub_407EA9((_DWORD *)this - 51, (int)v10);
  if ( pvarg )
    VariantClear(pvarg);
  return v11;
}


// ========== Function: ??0CDataSourceControl@@QAE@PAVCOleControlSite@@@Z @ 0x408E5C ==========
CDataSourceControl *__thiscall CDataSourceControl::CDataSourceControl(
        CDataSourceControl *this,
        struct COleControlSite *a2)
{
  *((_DWORD *)this + 1) = a2;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  sub_41B980(10);
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 22) = 0;
  *(_DWORD *)this = &CDataSourceControl::`vftable';
  return this;
}


// ========== Function: sub_408EAA @ 0x408EAA ==========
int __thiscall sub_408EAA(char *this)
{
  int v2; // ebx
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  int v5; // edi
  bool v6; // zf
  int v7; // eax
  int v8; // eax
  bool v9; // cc
  int v10; // edi
  _DWORD *v11; // eax
  _DWORD *v12; // ecx
  int v13; // ecx
  void *v14; // edi
  void *v15; // edi
  int v16; // eax
  int v17; // esi
  char *v19; // [esp+Ch] [ebp-1Ch]
  int v20; // [esp+10h] [ebp-18h] BYREF
  int v21; // [esp+14h] [ebp-14h]
  int v22; // [esp+18h] [ebp-10h] BYREF
  int v23; // [esp+24h] [ebp-4h]

  *(_DWORD *)this = &CDataSourceControl::`vftable';
  v2 = 0;
  v6 = *((_DWORD *)this + 22) == 0;
  v23 = 0;
  if ( !v6 )
  {
    v3 = (_DWORD *)*((_DWORD *)this + 20);
    if ( v3 )
    {
      if ( (**(int (__stdcall ***)(_DWORD, void *, int *))*v3)(*v3, &unk_42C720, &v20) >= 0 )
      {
        v22 = 0;
        if ( (*(int (__stdcall **)(int, void *, int *))(*(_DWORD *)v20 + 16))(v20, &unk_42C5E0, &v22) >= 0 )
        {
          (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)v22 + 24))(v22, *((_DWORD *)this + 22));
          (*(void (__stdcall **)(int))(*(_DWORD *)v22 + 8))(v22);
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)v20 + 8))(v20);
      }
    }
  }
  while ( *((_DWORD *)this + 9) )
  {
    v4 = *(_DWORD **)(*((_DWORD *)this + 7) + 8);
    (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)*v4 + 184))(*v4, v4[2], 0);
    *(_DWORD *)(*v4 + 144) = 0;
  }
  v19 = this + 24;
  ((void (*)(void))sub_41B9BF)();
  if ( *((_DWORD *)this + 16) )
  {
    v5 = 0;
    v6 = *((_DWORD *)this + 14) == 0;
    if ( *((int *)this + 14) > 0 )
    {
      do
      {
        VariantClear((VARIANTARG *)(*((_DWORD *)this + 16) + v2));
        ++v5;
        v2 += 16;
      }
      while ( v5 < *((_DWORD *)this + 14) );
      v6 = *((_DWORD *)this + 14) == 0;
    }
    if ( !v6 )
    {
      sub_41CA99(*((LPVOID *)this + 15));
      sub_41CA99(*((LPVOID *)this + 16));
    }
  }
  v7 = *((_DWORD *)this + 2);
  if ( v7 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*((_DWORD *)this + 2));
  v8 = *((_DWORD *)this + 3);
  if ( v8 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 8))(*((_DWORD *)this + 3));
  if ( *((_DWORD *)this + 5) )
  {
    v9 = *((_DWORD *)this + 4) <= 0;
    v21 = 0;
    if ( !v9 )
    {
      v10 = 0;
      do
      {
        v11 = *(_DWORD **)(*(_DWORD *)(*((_DWORD *)this + 5) + v10 + 36) + 4);
        while ( v11 )
        {
          v12 = v11;
          v11 = (_DWORD *)*v11;
          *(_DWORD *)(v12[2] + 144) = 0;
        }
        sub_41B9BF(*(_DWORD *)(*((_DWORD *)this + 5) + v10 + 36));
        v13 = *(_DWORD *)(*((_DWORD *)this + 5) + v10 + 36);
        if ( v13 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v13 + 4))(v13, 1);
        ++v21;
        v10 += 40;
      }
      while ( v21 < *((_DWORD *)this + 4) );
    }
    CoTaskMemFree(*((LPVOID *)this + 5));
  }
  if ( *((_DWORD *)this + 13) )
    CoTaskMemFree(*((LPVOID *)this + 13));
  if ( *((_DWORD *)this + 21) )
  {
    sub_40908A(**((_DWORD **)this + 20));
    sub_4091AB(*((_DWORD *)this + 21));
  }
  v14 = (void *)*((_DWORD *)this + 21);
  if ( v14 )
  {
    sub_4091AB(*((_DWORD *)this + 21));
    sub_41CA99(v14);
  }
  v15 = (void *)*((_DWORD *)this + 20);
  if ( v15 )
  {
    sub_409111(*((_DWORD *)this + 20));
    sub_41CA99(v15);
  }
  v16 = *((_DWORD *)this + 19);
  if ( v16 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v16 + 8))(*((_DWORD *)this + 19));
  v17 = *((_DWORD *)this + 18);
  if ( v17 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
  v23 = -1;
  return sub_41B9DF(v19);
}


// ========== Function: sub_40908A @ 0x40908A ==========
int __thiscall sub_40908A(void **this, int (__stdcall ***a2)(_DWORD, void *, int *))
{
  int (__stdcall **v3)(_DWORD, void *, int *); // ecx
  unsigned int v4; // edi
  int v5; // eax
  bool v6; // zf
  void *v8; // [esp-8h] [ebp-24h]
  int v9; // [esp+8h] [ebp-14h]
  int v10; // [esp+Ch] [ebp-10h] BYREF
  int v11; // [esp+18h] [ebp-4h]

  v9 = 0;
  if ( this[1] )
  {
    v10 = 0;
    v3 = *a2;
    v11 = 0;
    v9 = (*v3)(a2, &unk_42C610, &v10);
    if ( v9 >= 0 )
    {
      v4 = 0;
      if ( this[1] )
      {
        do
          (*(void (__stdcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v10 + 24))(v10, *((_DWORD *)*this + 2 * v4++), 0);
        while ( v4 < (unsigned int)this[1] );
      }
    }
    v8 = *this;
    this[1] = 0;
    sub_41CA99(v8);
    v5 = v10;
    v11 = -1;
    v6 = v10 == 0;
    *this = 0;
    if ( !v6 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
  }
  return v9;
}


// ========== Function: sub_409111 @ 0x409111 ==========
int __thiscall sub_409111(int *this)
{
  int result; // eax
  int v3; // esi

  sub_40915C();
  result = this[1];
  if ( result )
    result = (*(int (__stdcall **)(int))(*(_DWORD *)result + 8))(result);
  v3 = *this;
  if ( v3 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}


// ========== Function: sub_40915C @ 0x40915C ==========
void __thiscall sub_40915C(int *this)
{
  int v2; // eax
  int v3; // eax

  if ( *this )
  {
    sub_40918B();
    v2 = *this;
    if ( *this )
    {
      *this = 0;
      (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
    }
    v3 = this[1];
    if ( v3 )
    {
      this[1] = 0;
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
    }
  }
}


// ========== Function: sub_40918B @ 0x40918B ==========
int __thiscall sub_40918B(_DWORD *this)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = this + 3;
  result = 0;
  if ( this[3] )
  {
    result = (*(int (__stdcall **)(_DWORD, int, _DWORD *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)*this + 24))(
               *this,
               1,
               v1,
               0,
               0,
               0);
    *v1 = 0;
  }
  return result;
}


// ========== Function: sub_4091AB @ 0x4091AB ==========
int __thiscall sub_4091AB(int this)
{
  int result; // eax

  if ( *(_DWORD *)(this + 16) )
  {
    CoTaskMemFree(*(LPVOID *)(this + 16));
    *(_DWORD *)(this + 16) = 0;
  }
  if ( *(_DWORD *)(this + 20) )
  {
    CoTaskMemFree(*(LPVOID *)(this + 20));
    *(_DWORD *)(this + 20) = 0;
  }
  result = sub_41CA99(*(LPVOID *)(this + 8));
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  return result;
}


// ========== Function: sub_4091E5 @ 0x4091E5 ==========
int __thiscall sub_4091E5(int this)
{
  HWND *v2; // edi
  BOOL v3; // eax
  HWND DesktopWindow; // eax
  int v5; // eax
  int v6; // eax
  bool v7; // zf
  int result; // eax
  int v9; // esi
  struct tagRECT Rect; // [esp+Ch] [ebp-34h] BYREF
  struct tagRECT v11; // [esp+1Ch] [ebp-24h] BYREF
  BOOL v12; // [esp+2Ch] [ebp-14h]
  int v13; // [esp+30h] [ebp-10h] BYREF
  int v14; // [esp+34h] [ebp-Ch] BYREF
  CWnd *v15; // [esp+38h] [ebp-8h]
  int v16; // [esp+3Ch] [ebp-4h]

  v2 = (HWND *)sub_41ED38(*(_DWORD *)(*(_DWORD *)(this + 4) + 36));
  v15 = (CWnd *)v2;
  v3 = IsWindowVisible(v2[7]);
  v12 = !v3;
  if ( !v3 )
  {
    DesktopWindow = GetDesktopWindow();
    v5 = sub_41D866(DesktopWindow);
    GetWindowRect(*(HWND *)(v5 + 28), &Rect);
    GetWindowRect(v2[7], &v11);
    CWnd::MoveWindow((CWnd *)v2, (Rect.right - Rect.left) / 2, (Rect.bottom - Rect.top) / 2, 0, 0, 0);
    sub_4205F2(1);
  }
  if ( (***(int (__stdcall ****)(_DWORD, void *, int))(*(_DWORD *)(this + 4) + 76))(
         *(_DWORD *)(*(_DWORD *)(this + 4) + 76),
         &unk_42AF98,
         this + 72) >= 0 )
  {
    v6 = (*(int (__stdcall **)(_DWORD, _DWORD, void *, int))(**(_DWORD **)(this + 72) + 12))(
           *(_DWORD *)(this + 72),
           0,
           &unk_42C5F0,
           this + 76);
    v7 = *(_DWORD *)(this + 76) == 0;
    v16 = v6;
    if ( v7 )
      v16 = -2147467261;
    if ( v16 < 0 )
    {
      if ( v12 )
      {
        CWnd::MoveWindow(v15, v11.left, v11.top, v11.right - v11.left, v11.bottom - v11.top, 0);
        sub_4205F2(0);
      }
      return v16;
    }
    goto LABEL_15;
  }
  result = (***(int (__stdcall ****)(_DWORD, void *, int *))(*(_DWORD *)(this + 4) + 76))(
             *(_DWORD *)(*(_DWORD *)(this + 4) + 76),
             &unk_42AFA8,
             &v14);
  if ( result < 0 )
    return result;
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)v14 + 20))(v14, &v13);
  (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
  if ( !v13 )
    return -2147467259;
  v16 = (**(int (__stdcall ***)(int, void *, int))v13)(v13, &unk_42C780, this + 8);
  (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
  result = v16;
  if ( v16 >= 0 )
  {
    (***(void (__stdcall ****)(_DWORD, void *, int))(this + 8))(*(_DWORD *)(this + 8), &unk_42C770, this + 12);
LABEL_15:
    v9 = sub_4093F0(this);
    if ( v12 )
    {
      CWnd::MoveWindow(v15, v11.left, v11.top, v11.right - v11.left, v11.bottom - v11.top, 0);
      sub_4205F2(0);
    }
    return v9;
  }
  return result;
}


// ========== Function: sub_409387 @ 0x409387 ==========
int __thiscall sub_409387(_DWORD *this)
{
  int v1; // edx
  int (__stdcall ***v3)(_DWORD, void *, int *); // eax
  int v4; // [esp+0h] [ebp-8h] BYREF
  int v5; // [esp+4h] [ebp-4h] BYREF

  v1 = this[18];
  if ( v1 )
    return this[20] != 0 ? v1 : 0;
  v3 = (int (__stdcall ***)(_DWORD, void *, int *))this[2];
  if ( v3 )
  {
    if ( (**v3)(v3, &unk_42C790, &v5) >= 0 )
      return v5;
  }
  else if ( (***(int (__stdcall ****)(_DWORD, void *, int *))(this[1] + 76))(
              *(_DWORD *)(this[1] + 76),
              &unk_42AFA8,
              &v4) >= 0 )
  {
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v4 + 20))(v4, &v5);
    (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
    return v5;
  }
  return 0;
}


// ========== Function: sub_4093F0 @ 0x4093F0 ==========
int __thiscall sub_4093F0(int this)
{
  bool v2; // zf
  int result; // eax
  int v4; // eax
  _DWORD *v5; // eax
  size_t *v6; // ecx
  int v7; // eax
  void *v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // eax
  bool v14; // cc
  int v15; // ebx
  int v16; // eax
  int v17; // ecx
  _DWORD *v18; // ebx
  _DWORD *v19; // eax
  _BYTE v20[24]; // [esp+Ch] [ebp-A4h] BYREF
  int v21; // [esp+24h] [ebp-8Ch]
  int v22; // [esp+28h] [ebp-88h]
  int v23; // [esp+2Ch] [ebp-84h]
  int v24; // [esp+30h] [ebp-80h]
  int v25; // [esp+34h] [ebp-7Ch]
  int v26; // [esp+38h] [ebp-78h]
  _BYTE v27[24]; // [esp+3Ch] [ebp-74h] BYREF
  int v28; // [esp+54h] [ebp-5Ch]
  int v29; // [esp+58h] [ebp-58h]
  int v30; // [esp+5Ch] [ebp-54h]
  int v31; // [esp+60h] [ebp-50h]
  int v32; // [esp+64h] [ebp-4Ch]
  int v33; // [esp+68h] [ebp-48h]
  _DWORD v34[2]; // [esp+6Ch] [ebp-44h] BYREF
  int v35; // [esp+74h] [ebp-3Ch]
  int v36; // [esp+78h] [ebp-38h]
  int v37; // [esp+7Ch] [ebp-34h]
  void *v38; // [esp+80h] [ebp-30h]
  int v39; // [esp+84h] [ebp-2Ch]
  LPVOID pv; // [esp+88h] [ebp-28h]
  LPVOID lpMem; // [esp+8Ch] [ebp-24h] BYREF
  int v42; // [esp+90h] [ebp-20h]
  int v43; // [esp+94h] [ebp-1Ch] BYREF
  int v44; // [esp+98h] [ebp-18h] BYREF
  int v45; // [esp+9Ch] [ebp-14h] BYREF
  _DWORD *v46; // [esp+A0h] [ebp-10h] BYREF
  int v47; // [esp+ACh] [ebp-4h]

  v2 = *(_DWORD *)(this + 72) == 0;
  pv = *(LPVOID *)(this + 20);
  v39 = *(_DWORD *)(this + 16);
  if ( !v2 )
  {
    result = (*(int (__stdcall **)(_DWORD, void *, int *))(**(_DWORD **)(this + 76) + 20))(
               *(_DWORD *)(this + 76),
               &unk_42C600,
               &v45);
    v42 = result;
    if ( result < 0 )
      return result;
    if ( (**(int (__stdcall ***)(int, void *, int *))v45)(v45, &unk_42C720, &v44) >= 0 )
    {
      v46 = 0;
      if ( (*(int (__stdcall **)(int, void *, _DWORD **))(*(_DWORD *)v44 + 16))(v44, &unk_42C5E0, &v46) >= 0 )
      {
        (*(void (__stdcall **)(_DWORD *, int, int))(*v46 + 20))(v46, *(_DWORD *)(this + 4) + 216, this + 88);
        (*(void (__stdcall **)(_DWORD *))(*v46 + 8))(v46);
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)v44 + 8))(v44);
    }
    lpMem = (LPVOID)sub_41CA70(0x10u);
    v47 = 0;
    if ( lpMem )
      v4 = sub_409710(v45);
    else
      v4 = 0;
    v47 = -1;
    *(_DWORD *)(this + 80) = v4;
    (*(void (__stdcall **)(int))(*(_DWORD *)v45 + 8))(v45);
    ATL::CRowset<ATL::CAccessorBase>::SetupOptionalRowsetInterfaces(*(_DWORD *)(this + 80));
    v5 = (_DWORD *)sub_41CA70(0x1Cu);
    if ( v5 )
    {
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
      v5[3] = 0;
      v5[4] = 0;
      v5[5] = 0;
    }
    else
    {
      v5 = 0;
    }
    v6 = *(size_t **)(this + 80);
    *(_DWORD *)(this + 84) = v5;
    sub_409849(*v6);
    *(_DWORD *)(*(_DWORD *)(this + 80) + 8) = *(_DWORD *)(this + 84);
    v7 = *(_DWORD *)(*(_DWORD *)(this + 84) + 12);
    *(_DWORD *)(this + 16) = v7;
    v8 = CoTaskMemAlloc(40 * v7);
    v9 = *(_DWORD *)(this + 16);
    *(_DWORD *)(this + 20) = v8;
    memset(v8, 0, 40 * v9);
    sub_409761(*(_DWORD *)(this + 80));
    sub_40918B(*(_DWORD **)(this + 80));
    goto LABEL_22;
  }
  v10 = *(_DWORD *)(this + 8);
  if ( !v10 )
    return 0;
  result = (*(int (__stdcall **)(int, void *, int *, LPVOID *))(*(_DWORD *)v10 + 12))(v10, &unk_42C790, &v43, &lpMem);
  if ( result >= 0 )
  {
    CDataSourceControl::CopyColumnID(
      (CDataSourceControl *)this,
      (struct tagDBCOLUMNID *)v20,
      (const struct tagDBCOLUMNID *)&unk_42C860);
    v23 = -1;
    v21 = 0;
    v22 = 0;
    v24 = 24;
    v25 = 0;
    v26 = 507;
    CDataSourceControl::CopyColumnID(
      (CDataSourceControl *)this,
      (struct tagDBCOLUMNID *)v27,
      (const struct tagDBCOLUMNID *)&unk_42C938);
    v30 = -1;
    v28 = 28;
    v29 = 0;
    v31 = 32;
    v32 = 0;
    v33 = 30;
    v11 = (*(int (__stdcall **)(int, int, _BYTE *, int, _DWORD))(*(_DWORD *)v43 + 16))(v43, 2, v20, 40, 0);
    if ( v11 < 0 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)v43 + 8))(v43);
      return v11;
    }
    v34[0] = lpMem;
    v34[1] = 1;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v42 = (*(int (__stdcall **)(int, _DWORD, _DWORD, _DWORD *))(*(_DWORD *)v43 + 24))(v43, 0, 0, v34);
    if ( v42 < 0 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)v43 + 8))(v43);
      return v42;
    }
    v12 = v36;
    *(_DWORD *)(this + 20) = v35;
    lpMem = v38;
    *(_DWORD *)(this + 16) = v38;
    v13 = v43;
    *(_DWORD *)(this + 52) = v12;
    (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
LABEL_22:
    v14 = *(_DWORD *)(this + 16) <= 0;
    v45 = 0;
    if ( !v14 )
    {
      v15 = 0;
      do
      {
        v44 = sub_41CA70(0x1Cu);
        v47 = 1;
        if ( v44 )
          v16 = sub_41B980(10);
        else
          v16 = 0;
        v17 = *(_DWORD *)(this + 20);
        v47 = -1;
        ++v45;
        *(_DWORD *)(v15 + v17 + 36) = v16;
        v15 += 40;
      }
      while ( v45 < *(_DWORD *)(this + 16) );
    }
    if ( pv )
    {
      if ( v39 > 0 )
      {
        v44 = v39;
        v46 = (char *)pv + 36;
        do
        {
          v18 = *(_DWORD **)(*v46 + 4);
          while ( v18 )
          {
            v19 = v18;
            v18 = (_DWORD *)*v18;
            (*(void (__thiscall **)(int, _DWORD, int))(*(_DWORD *)this + 8))(this, v19[2], 1);
          }
          sub_41B9BF(*v46);
          if ( *v46 )
            (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v46 + 4))(*v46, 1);
          v46 += 10;
          --v44;
        }
        while ( v44 );
      }
      CoTaskMemFree(pv);
    }
    return v42;
  }
  return result;
}


// ========== Function: sub_409710 @ 0x409710 ==========
_DWORD *__thiscall sub_409710(_DWORD *this, int a2)
{
  int v4[5]; // [esp+8h] [ebp-20h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  v4[4] = (int)this;
  *this = 0;
  v5 = 0;
  this[1] = 0;
  LOBYTE(v5) = 1;
  sub_40BBBE(this, a2);
  memset(v4, 0, 16);
  sub_409111(v4);
  return this;
}


// ========== Function: sub_409761 @ 0x409761 ==========
int __thiscall sub_409761(_DWORD *this)
{
  int result; // eax

  sub_40918B(this);
  result = (*(int (__stdcall **)(_DWORD, _DWORD))(*(_DWORD *)*this + 28))(*this, 0);
  if ( result >= 0 )
    return sub_409784(0, 1);
  return result;
}


// ========== Function: sub_409784 @ 0x409784 ==========
int __thiscall sub_409784(_DWORD *this, int a2, char a3)
{
  int result; // eax
  int v5; // edi
  int v6; // [esp+4h] [ebp-8h] BYREF
  _DWORD *v7; // [esp+8h] [ebp-4h] BYREF

  v6 = 0;
  sub_40918B(this);
  v7 = this + 3;
  result = (*(int (__stdcall **)(_DWORD, _DWORD, int, int, int *, _DWORD **))(*(_DWORD *)*this + 20))(
             *this,
             0,
             a2,
             a3 != 0 ? 1 : -1,
             &v6,
             &v7);
  if ( !result )
  {
    v5 = sub_4097DD(this);
    if ( v5 < 0 )
      sub_40918B(this);
    return v5;
  }
  return result;
}


// ========== Function: sub_4097DD @ 0x4097DD ==========
int __thiscall sub_4097DD(_DWORD *this)
{
  int result; // eax
  unsigned int v3; // edi
  unsigned int v4; // ebx

  result = 0;
  v3 = 0;
  v4 = *(_DWORD *)(this[2] + 4);
  if ( v4 )
  {
    do
    {
      if ( *(_BYTE *)(*(_DWORD *)this[2] + 8 * v3 + 4) )
      {
        result = sub_409811(v3);
        if ( result < 0 )
          break;
      }
      ++v3;
    }
    while ( v3 < v4 );
  }
  return result;
}


// ========== Function: sub_409811 @ 0x409811 ==========
int __thiscall sub_409811(_DWORD *this, int a2)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)*this + 16))(
           *this,
           this[3],
           *(_DWORD *)(*(_DWORD *)this[2] + 8 * a2),
           *(_DWORD *)(this[2] + 8));
}


// ========== Function: ?SetupOptionalRowsetInterfaces@?$CRowset@VCAccessorBase@ATL@@@ATL@@QAEXXZ @ 0x409834 ==========
int (__stdcall ***__thiscall ATL::CRowset<ATL::CAccessorBase>::SetupOptionalRowsetInterfaces(
        _DWORD *this))(_DWORD, void *, int)
{
  int (__stdcall ***result)(_DWORD, void *, int); // eax

  result = (int (__stdcall ***)(_DWORD, void *, int))*this;
  if ( *this )
    return (int (__stdcall ***)(_DWORD, void *, int))(**result)(result, &unk_433E28, (int)(this + 1));
  return result;
}


// ========== Function: sub_409849 @ 0x409849 ==========
int __thiscall sub_409849(_DWORD *this, int (__stdcall ***Size)(_DWORD, void *, int *))
{
  int (__stdcall **v4)(_DWORD, void *, int *); // eax
  int (__stdcall **v6)(_DWORD, void *, int *); // eax
  int v7; // esi
  int v8; // eax
  int v9; // eax
  unsigned int v10; // esi
  int v11; // eax
  bool v12; // zf
  int v13; // esi
  int v14; // eax
  _DWORD *v15; // edx
  _DWORD *v16; // eax
  int v17; // eax
  __int16 v18; // cx
  int v19; // eax
  size_t v20; // ecx
  size_t v21; // edi
  int v22; // eax
  size_t v23; // [esp-8h] [ebp-40h]
  _DWORD v24[5]; // [esp+0h] [ebp-38h] BYREF
  char *v25; // [esp+14h] [ebp-24h]
  unsigned int v26; // [esp+18h] [ebp-20h]
  int v27; // [esp+1Ch] [ebp-1Ch] BYREF
  LPVOID lpMem; // [esp+20h] [ebp-18h]
  _DWORD v29[2]; // [esp+24h] [ebp-14h] BYREF
  int v30; // [esp+34h] [ebp-4h]
  signed int Sizea; // [esp+40h] [ebp+8h]
  size_t Sizeb; // [esp+40h] [ebp+8h]

  v29[1] = v24;
  v24[4] = this;
  v29[0] = 0;
  v4 = *Size;
  v30 = 0;
  Sizea = (*v4)(Size, &unk_433E48, v29);
  if ( Sizea < 0 )
  {
    v30 = -1;
    if ( v29[0] )
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v29[0] + 8))(v29[0]);
    return Sizea;
  }
  Sizeb = 0;
  if ( this[4] )
  {
    *((_BYTE *)this + 24) = 1;
  }
  else
  {
    v27 = 0;
    v6 = *Size;
    LOBYTE(v30) = 1;
    v7 = (*v6)(Size, &unk_433E38, &v27);
    if ( v7 < 0
      || (v7 = (*(int (__stdcall **)(int, _DWORD *, _DWORD *, _DWORD *))(*(_DWORD *)v27 + 12))(
                 v27,
                 this + 3,
                 this + 4,
                 this + 5),
          v7 < 0) )
    {
      LOBYTE(v30) = 0;
      if ( v27 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v27 + 8))(v27);
LABEL_37:
      v30 = -1;
      if ( v29[0] )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v29[0] + 8))(v29[0]);
      return v7;
    }
    v8 = v27;
    *((_BYTE *)this + 24) = 0;
    LOBYTE(v30) = 0;
    if ( v8 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
  }
  v9 = this[3];
  lpMem = 0;
  LOBYTE(v30) = 2;
  lpMem = (LPVOID)sub_41CA70(52 * v9);
  v10 = 0;
  v30 = 0;
  if ( lpMem )
  {
    v25 = (char *)lpMem;
    v26 = 0;
    while ( v10 < this[3] )
    {
      v13 = 48 * v10;
      v14 = v13 + this[4];
      if ( *(_DWORD *)(v14 + 16) > 0x400u || *(_WORD *)(v14 + 20) == 13 )
      {
        v24[3] = 0;
        LOBYTE(v30) = 4;
        v16 = (_DWORD *)sub_41CA70(0x14u);
        v15 = v16;
        v30 = 0;
        if ( !v16 )
          goto LABEL_32;
        *v16 = 0;
        v16[1] = dword_42CB28[0];
        v16[2] = dword_42CB28[1];
        v16[3] = dword_42CB28[2];
        v16[4] = dword_42CB28[3];
        v13 = 48 * v26;
        *(_WORD *)(this[4] + v13 + 20) = 13;
        *(_DWORD *)(this[4] + v13 + 16) = 4;
      }
      else
      {
        v15 = 0;
      }
      v17 = v13 + this[4];
      v18 = *(_WORD *)(v17 + 20);
      if ( v18 == 129 || v18 == 130 )
        ++*(_DWORD *)(v17 + 16);
      v19 = v13 + this[4];
      v20 = Sizeb + *(_DWORD *)(v19 + 16) + (*(_DWORD *)(v19 + 16) & 3);
      v21 = v20 + 4;
      v23 = v20 + 4;
      LOWORD(v20) = *(_WORD *)(v19 + 20);
      sub_409BA0(
        v25,
        *(_DWORD *)(v19 + 8),
        v20,
        *(_DWORD *)(v19 + 16),
        *(_BYTE *)(v19 + 22),
        *(_BYTE *)(v19 + 23),
        0,
        Sizeb,
        Sizeb + *(_DWORD *)(v19 + 16) + (*(_DWORD *)(v19 + 16) & 3),
        v23,
        v15);
      v22 = this[4];
      v25 += 52;
      ++v26;
      *(_DWORD *)(v22 + v13 + 4) = Sizeb;
      v10 = v26;
      Sizeb = v21 + 4;
    }
    if ( !*this )
    {
      v7 = sub_409AFA(1);
      if ( v7 < 0 )
      {
        sub_41CA99(lpMem);
        goto LABEL_37;
      }
      *(_BYTE *)(*this + 4) = 1;
    }
    this[2] = 0;
    LOBYTE(v30) = 6;
    this[2] = sub_41CA70(Sizeb);
    v30 = 0;
    if ( !this[2] )
    {
      sub_41CA99(lpMem);
LABEL_32:
      v11 = v29[0];
      v30 = -1;
      v12 = v29[0] == 0;
      goto LABEL_33;
    }
    v7 = sub_409B56(lpMem, this[3], *this, Sizeb, v29[0]);
    sub_41CA99(lpMem);
    goto LABEL_37;
  }
  v11 = v29[0];
  v30 = -1;
  v12 = v29[0] == 0;
LABEL_33:
  if ( !v12 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
  return -2147024882;
}


// ========== Function: sub_409AFA @ 0x409AFA ==========
int __thiscall sub_409AFA(_DWORD *this, int a2)
{
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[7] = 0;
  v4[4] = v4;
  v4[3] = this;
  *this = 0;
  this[1] = a2;
  *this = sub_41CA70(8 * a2);
  return *this != 0 ? 0 : -2147024882;
}


// ========== Function: sub_409B56 @ 0x409B56 ==========
int __cdecl sub_409B56(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // ebx
  LPVOID *v7; // esi

  v5 = a2;
  v6 = (*(int (__stdcall **)(int, int, int, int, int, int, _DWORD))(*(_DWORD *)a5 + 16))(
         a5,
         *(_DWORD *)(a1 + 36) != 0 ? 4 : 2,
         a2,
         a1,
         a4,
         a3,
         0);
  if ( a2 > 0 )
  {
    v7 = (LPVOID *)(a1 + 20);
    do
    {
      sub_41CA99(*v7);
      v7 += 13;
      --v5;
    }
    while ( v5 );
  }
  return v6;
}


// ========== Function: sub_409BA0 @ 0x409BA0 ==========
int __cdecl sub_409BA0(int a1, int a2, __int16 a3, int a4, char a5, char a6, int a7, int a8, int a9, int a10, int a11)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 32) = (a3 & 0x4000) != 0;
  *(_WORD *)(a1 + 48) = a3;
  *(_DWORD *)(a1 + 20) = a11;
  *(_BYTE *)(a1 + 50) = a5;
  *(_DWORD *)(a1 + 36) = a7;
  *(_BYTE *)(a1 + 51) = a6;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a8;
  *(_DWORD *)(a1 + 40) = a4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if ( a9 )
  {
    *(_DWORD *)(a1 + 28) = 3;
    *(_DWORD *)(a1 + 8) = a9;
  }
  if ( a10 )
  {
    *(_DWORD *)(a1 + 28) |= 4u;
    *(_DWORD *)(a1 + 12) = a10;
  }
  return result;
}


// ========== Function: ?CopyColumnID@CDataSourceControl@@QAEHPAUtagDBCOLUMNID@@PBU2@@Z @ 0x409C1F ==========
int __thiscall CDataSourceControl::CopyColumnID(
        CDataSourceControl *this,
        struct tagDBCOLUMNID *a2,
        const struct tagDBCOLUMNID *a3)
{
  int v3; // eax
  int v4; // eax
  size_t v5; // eax
  int result; // eax

  *((_DWORD *)a2 + 4) = *((_DWORD *)a3 + 4);
  v3 = *((_DWORD *)a3 + 4);
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( !v4 )
    {
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *((_DWORD *)a2 + 1) = *((_DWORD *)a3 + 1);
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)a2 + 5) = *((_DWORD *)a3 + 5);
      return 1;
    }
    if ( v4 != 1 )
      return 1;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)a3;
    *((_DWORD *)a2 + 1) = *((_DWORD *)a3 + 1);
    *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
    *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
  }
  v5 = wcslen(*((const wchar_t **)a3 + 5));
  result = (int)CoTaskMemAlloc(2 * v5 + 2);
  *((_DWORD *)a2 + 5) = result;
  if ( !result )
    return result;
  wcscpy((wchar_t *)result, *((const wchar_t **)a3 + 5));
  return 1;
}


// ========== Function: sub_409C8B @ 0x409C8B ==========
_DWORD *__thiscall sub_409C8B(int *this, int a2, int a3)
{
  int v4; // ebx
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  wchar_t *v8; // eax
  bool v9; // bl
  _DWORD *result; // eax
  int v11; // edi
  int v12; // ecx
  int i; // edi
  _DWORD *v14; // edx
  _DWORD *v15; // ebx
  int v16; // [esp+Ch] [ebp-8h]
  unsigned __int8 *Str2; // [esp+10h] [ebp-4h] BYREF

  v4 = 0;
  v5 = *this;
  if ( a3 )
  {
    (*(void (__stdcall **)(int, _DWORD))(v5 + 8))(a2, 0);
    if ( this[18] )
    {
      v6 = 0;
      if ( this[4] > 0 )
      {
        do
        {
          v7 = this[21];
          v16 = v6 + 1;
          a3 = v6 + 1;
          v8 = (unsigned __int8)sub_409DC7(&a3) ? *(wchar_t **)(48 * a3 + *(_DWORD *)(v7 + 16)) : 0;
          sub_420159(v8);
          v9 = _mbscmp(*(const unsigned __int8 **)(a2 + 156), Str2) == 0;
          sub_4200DD(&Str2);
          if ( v9 )
            return (_DWORD *)sub_41BA79(a2);
          ++v6;
        }
        while ( v16 < this[4] );
      }
    }
    else
    {
      v11 = 0;
      if ( this[4] > 0 )
      {
        while ( !*(_DWORD *)(v4 + this[5] + 28)
             || _mbscmp(*(const unsigned __int8 **)(a2 + 156), *(const unsigned __int8 **)(v4 + this[5] + 28)) )
        {
          ++v11;
          v4 += 40;
          if ( v11 >= this[4] )
            goto LABEL_9;
        }
        return (_DWORD *)sub_41BA79(a2);
      }
    }
LABEL_9:
    result = (_DWORD *)a2;
    *(_DWORD *)(a2 + 144) = 0;
    return result;
  }
  (*(void (__thiscall **)(int *))(v5 + 20))(this);
  v12 = 0;
  a3 = this[4];
  result = (_DWORD *)a3;
  if ( a3 > 0 )
  {
    for ( i = this[5] + 36; ; i += 40 )
    {
      result = *(_DWORD **)(*(_DWORD *)i + 4);
      if ( result )
        break;
LABEL_21:
      if ( ++v12 >= a3 )
        return result;
    }
    while ( 1 )
    {
      v14 = result;
      v15 = result;
      result = (_DWORD *)*result;
      if ( v14[2] == a2 )
        return (_DWORD *)sub_41BAC6(v15);
      if ( !result )
        goto LABEL_21;
    }
  }
  return result;
}


// ========== Function: sub_409DC7 @ 0x409DC7 ==========
char __thiscall sub_409DC7(int this, _DWORD *a2)
{
  unsigned int v2; // esi
  int v3; // edi
  _DWORD *i; // ecx
  int v6; // edx

  if ( *(_BYTE *)(this + 24) )
  {
    v2 = *(_DWORD *)(this + 12);
    v3 = 0;
    if ( v2 )
    {
      for ( i = (_DWORD *)(*(_DWORD *)(this + 16) + 8); *i != *a2; i += 12 )
      {
        if ( ++v3 >= v2 )
          return 0;
      }
      *a2 = v3;
      return 1;
    }
    return 0;
  }
  v6 = *(_DWORD *)(*(_DWORD *)(this + 16) + 8);
  if ( *a2 > (unsigned int)(*(_DWORD *)(this + 12) + v6 - 1) )
    return 0;
  *a2 -= v6;
  return 1;
}


// ========== Function: ?BindProp@CDataSourceControl@@UAEXPAVCDataBoundProperty@@H@Z @ 0x409E1A ==========
void __thiscall CDataSourceControl::BindProp(CDataSourceControl *this, struct CDataBoundProperty *a2, int a3)
{
  int v3; // eax
  int v4; // eax

  v3 = *(_DWORD *)this;
  if ( a3 )
  {
    (*(void (__stdcall **)(struct CDataBoundProperty *, _DWORD))(v3 + 4))(a2, 0);
    sub_41BA79(a2);
  }
  else
  {
    (*(void (__thiscall **)(CDataSourceControl *))(v3 + 20))(this);
    v4 = sub_41BAFD(a2, 0);
    if ( v4 )
      sub_41BAC6(v4);
  }
}


// ========== Function: sub_409E62 @ 0x409E62 ==========
int __thiscall sub_409E62(CDataSourceControl *this)
{
  int v2; // edi
  int v4; // ebx
  int v5; // ecx
  int *v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edi
  _DWORD *v10; // ebx
  int v11; // edi
  _DWORD *v12; // eax
  int v13; // eax
  int v14; // ebx
  int i; // edi
  int v16; // [esp+8h] [ebp-10h]
  int v17; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]
  int v19; // [esp+14h] [ebp-4h]

  v2 = 0;
  if ( *((_DWORD *)this + 18) )
  {
    sub_40A00C(this);
    return (*(int (__thiscall **)(CDataSourceControl *))(*(_DWORD *)this + 16))(this);
  }
  else
  {
    if ( *((_DWORD *)this + 16) )
    {
      if ( *((int *)this + 14) > 0 )
      {
        v4 = 0;
        do
        {
          VariantClear((VARIANTARG *)(*((_DWORD *)this + 16) + v4));
          ++v2;
          v4 += 16;
        }
        while ( v2 < *((_DWORD *)this + 14) );
      }
      if ( *((int *)this + 14) > 0 )
      {
        sub_41CA99(*((LPVOID *)this + 16));
        sub_41CA99(*((LPVOID *)this + 15));
      }
      *((_DWORD *)this + 16) = 0;
    }
    v5 = *((_DWORD *)this + 4);
    *((_DWORD *)this + 14) = 0;
    if ( v5 > 0 )
    {
      v6 = (int *)(*((_DWORD *)this + 5) + 36);
      do
      {
        v7 = *v6;
        v6 += 10;
        *((_DWORD *)this + 14) += *(_DWORD *)(v7 + 12);
        --v5;
      }
      while ( v5 );
    }
    v8 = *((_DWORD *)this + 14);
    if ( v8 > 0 )
      *((_DWORD *)this + 15) = sub_41CA70(48 * v8);
    v9 = 0;
    v19 = 0;
    v17 = 0;
    if ( *((int *)this + 4) > 0 )
    {
      v18 = 0;
      do
      {
        v10 = *(_DWORD **)(*(_DWORD *)(v18 + *((_DWORD *)this + 5) + 36) + 4);
        if ( v10 )
        {
          v11 = 48 * v9;
          do
          {
            v12 = v10;
            v10 = (_DWORD *)*v10;
            v16 = v12[2];
            CDataSourceControl::CopyColumnID(
              this,
              (struct tagDBCOLUMNID *)(v11 + *((_DWORD *)this + 15)),
              (const struct tagDBCOLUMNID *)(*((_DWORD *)this + 5) + v18));
            *(_DWORD *)(*((_DWORD *)this + 15) + v11 + 24) = 16 * v19;
            *(_DWORD *)(*((_DWORD *)this + 15) + v11 + 28) = 0;
            *(_DWORD *)(*((_DWORD *)this + 15) + v11 + 36) = -1;
            *(_DWORD *)(*((_DWORD *)this + 15) + v11 + 32) = -1;
            ++v19;
            *(_DWORD *)(*((_DWORD *)this + 15) + v11 + 40) = 1;
            *(_DWORD *)(*((_DWORD *)this + 15) + v11 + 44) = *(_DWORD *)(v16 + 152);
            v11 += 48;
          }
          while ( v10 );
          v9 = v19;
        }
        ++v17;
        v18 += 40;
      }
      while ( v17 < *((_DWORD *)this + 4) );
    }
    (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, int, _DWORD))(**((_DWORD **)this + 2) + 16))(
      *((_DWORD *)this + 2),
      *((_DWORD *)this + 14),
      *((_DWORD *)this + 15),
      16 * *((_DWORD *)this + 14),
      0);
    v13 = *((_DWORD *)this + 14);
    v14 = 0;
    if ( v13 )
      *((_DWORD *)this + 16) = sub_41CA70(16 * v13);
    for ( i = 0; i < *((_DWORD *)this + 14); v14 += 16 )
    {
      memset((void *)(*((_DWORD *)this + 16) + v14), 0, 0x10u);
      *(_WORD *)(v14 + *((_DWORD *)this + 16)) = 0;
      ++i;
    }
    sub_40A00C(this);
    return (*(int (__thiscall **)(CDataSourceControl *))(*(_DWORD *)this + 16))(this);
  }
}


// ========== Function: sub_40A00C @ 0x40A00C ==========
int __thiscall sub_40A00C(_DWORD *this)
{
  _DWORD *v1; // ecx
  int v3; // eax
  int v4; // ecx
  _DWORD v5[6]; // [esp+0h] [ebp-18h] BYREF

  if ( this[18] )
  {
    v1 = (_DWORD *)this[20];
    if ( v1 && v1[3] )
      return sub_4097DD(v1);
    return 0;
  }
  if ( !this[14] )
    return 0;
  v3 = this[16];
  v4 = this[2];
  v5[2] = v3;
  v5[3] = 0;
  v5[4] = 0;
  v5[0] = 1;
  v5[1] = 0;
  return (*(int (__stdcall **)(int, int, void *, _DWORD, _DWORD, _DWORD *))(*(_DWORD *)v4 + 32))(
           v4,
           1,
           &unk_42CB1C,
           0,
           0,
           v5);
}


// ========== Function: sub_40A069 @ 0x40A069 ==========
struct tagVARIANT *__thiscall sub_40A069(_DWORD *this, struct tagVARIANT *a2, int a3)
{
  int v4; // edi
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // esi
  DOUBLE *v13; // eax
  DOUBLE v14; // st7
  VARIANTARG *p_pvargSrc; // eax
  int v16; // esi
  unsigned int *v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // eax
  int v20; // esi
  DOUBLE *v21; // eax
  DOUBLE v22; // st7
  int v23; // esi
  float *v24; // eax
  double v25; // st7
  int v26; // esi
  int *v27; // eax
  VARIANTARG *v28; // eax
  int v29; // esi
  __int16 *v30; // eax
  VARIANTARG *v31; // eax
  int v32; // esi
  BYTE *v33; // eax
  BYTE v34; // al
  int v35; // esi
  VARIANTARG *v36; // eax
  VARIANTARG *v37; // eax
  int v38; // esi
  __int16 *v39; // eax
  VARIANTARG *v40; // eax
  int v41; // esi
  const CHAR *v42; // eax
  VARIANTARG *v43; // eax
  char *v44; // ecx
  int v45; // eax
  int v46; // eax
  int v47; // eax
  int v48; // eax
  int v49; // esi
  _DWORD *v50; // esi
  int v51; // esi
  int v52; // ecx
  int v53; // eax
  int v54; // esi
  int *v55; // eax
  int v56; // esi
  int v57; // eax
  DOUBLE v58; // st7
  char v59; // al
  int v61; // esi
  wchar_t *v62; // eax
  VARIANTARG *v63; // eax
  const CHAR *v65; // [esp-8h] [ebp-154h]
  const CHAR *v66; // [esp-8h] [ebp-154h]
  VARIANTARG v67; // [esp+Ch] [ebp-140h] BYREF
  struct tagVARIANT v68; // [esp+1Ch] [ebp-130h] BYREF
  VARIANTARG v69; // [esp+2Ch] [ebp-120h] BYREF
  _BYTE v70[16]; // [esp+3Ch] [ebp-110h] BYREF
  _BYTE v71[16]; // [esp+4Ch] [ebp-100h] BYREF
  _BYTE v72[16]; // [esp+5Ch] [ebp-F0h] BYREF
  DOUBLE v73; // [esp+6Ch] [ebp-E0h]
  VARIANTARG v74; // [esp+78h] [ebp-D4h] BYREF
  VARIANTARG pvargSrc; // [esp+88h] [ebp-C4h] BYREF
  VARIANTARG v76; // [esp+98h] [ebp-B4h] BYREF
  VARIANTARG v77; // [esp+A8h] [ebp-A4h] BYREF
  VARIANTARG v78; // [esp+B8h] [ebp-94h] BYREF
  VARIANTARG v79; // [esp+C8h] [ebp-84h] BYREF
  VARIANTARG v80; // [esp+D8h] [ebp-74h] BYREF
  VARIANTARG v81; // [esp+E8h] [ebp-64h] BYREF
  VARIANTARG v82; // [esp+F8h] [ebp-54h] BYREF
  char v83; // [esp+108h] [ebp-44h] BYREF
  char v84; // [esp+10Ch] [ebp-40h] BYREF
  int v85; // [esp+110h] [ebp-3Ch] BYREF
  _BYTE v86[12]; // [esp+114h] [ebp-38h]
  int v87; // [esp+120h] [ebp-2Ch]
  __int16 v88; // [esp+124h] [ebp-28h]
  char v89; // [esp+126h] [ebp-26h]
  int v90; // [esp+128h] [ebp-24h]
  unsigned __int16 v91; // [esp+12Ch] [ebp-20h]
  VARIANTARG pvarg; // [esp+130h] [ebp-1Ch] BYREF
  int v93; // [esp+148h] [ebp-4h]

  v85 = 0;
  AfxVariantInit(&pvarg);
  v4 = a3;
  v93 = 0;
  sub_40A7E5(a3, &v85);
  if ( v85 != 3 )
  {
    v5 = this[21];
    a3 = v4;
    if ( sub_409DC7(v5, &a3) )
    {
      v6 = *(unsigned __int16 *)(*(_DWORD *)(v5 + 16) + 48 * a3 + 20);
      if ( (unsigned __int16)v6 > 0x81u )
      {
        v45 = (unsigned __int16)v6 - 130;
        if ( v45 )
        {
          v46 = v45 - 1;
          if ( v46 )
          {
            v47 = v46 - 2;
            if ( v47 )
            {
              v48 = v47 - 1;
              if ( v48 )
              {
                if ( v48 != 1 )
                  goto LABEL_84;
                v49 = this[21];
                a3 = v4;
                if ( !sub_409DC7(v49, &a3) )
                  goto LABEL_84;
                v50 = (_DWORD *)(*(_DWORD *)(v49 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v49 + 16) + 4));
                *(_DWORD *)v86 = *v50++;
                *(_DWORD *)&v86[4] = *v50++;
                *(_DWORD *)&v86[8] = *v50;
                v87 = v50[1];
                sub_40C8AA(
                  *(__int16 *)v86,
                  *(unsigned __int16 *)&v86[2],
                  *(unsigned __int16 *)&v86[4],
                  *(unsigned __int16 *)&v86[6],
                  *(unsigned __int16 *)&v86[8],
                  *(unsigned __int16 *)&v86[10]);
                v74.vt = 7;
                v74.dblVal = v73;
                LOBYTE(v93) = 17;
                sub_40C740(&pvarg, &v74);
                LOBYTE(v93) = 0;
                p_pvargSrc = &v74;
              }
              else
              {
                v51 = this[21];
                a3 = v4;
                if ( !sub_409DC7(v51, &a3) )
                  goto LABEL_84;
                v52 = *(_DWORD *)(v51 + 16);
                v87 = 0;
                v53 = *(_DWORD *)(v51 + 8) + *(_DWORD *)(48 * a3 + v52 + 4);
                *(double *)&v86[4] = 0.0;
                v90 = *(_DWORD *)v53;
                v91 = *(_WORD *)(v53 + 4);
                sub_40C8AA(1899, 12, 30, (unsigned __int16)v90, HIWORD(v90), v91);
                v77.vt = 7;
                v77.dblVal = *(double *)&v86[4];
                LOBYTE(v93) = 16;
                sub_40C740(&pvarg, &v77);
                LOBYTE(v93) = 0;
                p_pvargSrc = &v77;
              }
            }
            else
            {
              v54 = this[21];
              a3 = v4;
              if ( !sub_409DC7(v54, &a3) )
                goto LABEL_84;
              v55 = (int *)sub_40A829(a3);
              v90 = *v55;
              *(double *)&v86[4] = 0.0;
              v91 = *((_WORD *)v55 + 2);
              v87 = 0;
              sub_40C8AA((__int16)v90, HIWORD(v90), v91, 0, 0, 0);
              v80.vt = 7;
              v80.dblVal = *(double *)&v86[4];
              LOBYTE(v93) = 15;
              sub_40C740(&pvarg, &v80);
              LOBYTE(v93) = 0;
              p_pvargSrc = &v80;
            }
          }
          else
          {
            v56 = this[21];
            a3 = v4;
            if ( !sub_409DC7(v56, &a3) )
              goto LABEL_84;
            v57 = sub_40A829(a3);
            *(_QWORD *)v86 = *(_QWORD *)v57;
            *(_DWORD *)&v86[8] = *(_DWORD *)(v57 + 8);
            v87 = *(_DWORD *)(v57 + 12);
            v88 = *(_WORD *)(v57 + 16);
            v89 = *(_BYTE *)(v57 + 18);
            v58 = (double)*(__int64 *)&v86[3];
            v59 = v86[1];
            while ( v59-- )
              v58 = v58 * 0.1;
            if ( !v86[2] )
              v58 = -v58;
            v79.dblVal = v58;
            v79.vt = 5;
            LOBYTE(v93) = 14;
            sub_40C740(&pvarg, &v79);
            LOBYTE(v93) = 0;
            p_pvargSrc = &v79;
          }
          goto LABEL_67;
        }
      }
      else
      {
        if ( (unsigned __int16)v6 == 129 )
        {
          v41 = this[21];
          a3 = v4;
          if ( sub_409DC7(v41, &a3) )
            v42 = (const CHAR *)(*(_DWORD *)(v41 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v41 + 16) + 4));
          else
            v42 = 0;
          v65 = *(const CHAR **)sub_420107(v42);
          LOBYTE(v93) = 2;
          v43 = (VARIANTARG *)sub_40C622(v65, 8);
          LOBYTE(v93) = 3;
          sub_40C740(&pvarg, v43);
          VariantClear(&v69);
          LOBYTE(v93) = 0;
          v44 = &v83;
          goto LABEL_83;
        }
        if ( (unsigned __int16)v6 > 8u )
        {
          if ( (unsigned __int16)v6 == 11 )
          {
            v38 = this[21];
            a3 = v4;
            if ( sub_409DC7(v38, &a3) )
              v39 = (__int16 *)(*(_DWORD *)(v38 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v38 + 16) + 4));
            else
              v39 = 0;
            v40 = (VARIANTARG *)COleVariant::COleVariant((COleVariant *)v71, *v39, 0xBu);
            LOBYTE(v93) = 11;
            sub_40C740(&pvarg, v40);
            LOBYTE(v93) = 0;
            p_pvargSrc = (VARIANTARG *)v71;
            goto LABEL_67;
          }
          if ( (unsigned __int16)v6 == 12 )
          {
            v35 = this[21];
            a3 = v4;
            if ( sub_409DC7(v35, &a3) )
              v36 = (VARIANTARG *)(*(_DWORD *)(v35 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v35 + 16) + 4));
            else
              v36 = 0;
            v37 = (VARIANTARG *)sub_40C602(&v68, v36);
            LOBYTE(v93) = 1;
            sub_40C740(&pvarg, v37);
            LOBYTE(v93) = 0;
            p_pvargSrc = &v68;
            goto LABEL_67;
          }
          if ( (unsigned __int16)v6 <= 0xFu )
            goto LABEL_84;
          if ( (unsigned __int16)v6 <= 0x11u )
          {
            v32 = this[21];
            a3 = v4;
            if ( sub_409DC7(v32, &a3) )
              v33 = (BYTE *)(*(_DWORD *)(v32 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v32 + 16) + 4));
            else
              v33 = 0;
            v34 = *v33;
            v76.vt = 17;
            v76.bVal = v34;
            LOBYTE(v93) = 6;
            sub_40C740(&pvarg, &v76);
            LOBYTE(v93) = 0;
            p_pvargSrc = &v76;
            goto LABEL_67;
          }
          if ( (unsigned __int16)v6 != 18 )
          {
            if ( (unsigned __int16)v6 != 19 )
              goto LABEL_84;
            goto LABEL_36;
          }
LABEL_40:
          v29 = this[21];
          a3 = v4;
          if ( sub_409DC7(v29, &a3) )
            v30 = (__int16 *)(*(_DWORD *)(v29 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v29 + 16) + 4));
          else
            v30 = 0;
          v31 = (VARIANTARG *)COleVariant::COleVariant((COleVariant *)v70, *v30, 2u);
          LOBYTE(v93) = 7;
          sub_40C740(&pvarg, v31);
          LOBYTE(v93) = 0;
          p_pvargSrc = (VARIANTARG *)v70;
          goto LABEL_67;
        }
        if ( v6 != 8 )
        {
          v7 = (unsigned __int16)v6 - 2;
          if ( v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              v9 = v8 - 1;
              if ( !v9 )
              {
                v23 = this[21];
                a3 = v4;
                if ( sub_409DC7(v23, &a3) )
                  v24 = (float *)(*(_DWORD *)(v23 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v23 + 16) + 4));
                else
                  v24 = 0;
                v25 = *v24;
                v81.vt = 4;
                v81.fltVal = v25;
                LOBYTE(v93) = 9;
                sub_40C740(&pvarg, &v81);
                LOBYTE(v93) = 0;
                p_pvargSrc = &v81;
                goto LABEL_67;
              }
              v10 = v9 - 1;
              if ( !v10 )
              {
                v20 = this[21];
                a3 = v4;
                if ( sub_409DC7(v20, &a3) )
                  v21 = (DOUBLE *)(*(_DWORD *)(v20 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v20 + 16) + 4));
                else
                  v21 = 0;
                v22 = *v21;
                v78.vt = 5;
                v78.dblVal = v22;
                LOBYTE(v93) = 10;
                sub_40C740(&pvarg, &v78);
                LOBYTE(v93) = 0;
                p_pvargSrc = &v78;
                goto LABEL_67;
              }
              v11 = v10 - 1;
              if ( !v11 )
              {
                v16 = this[21];
                a3 = v4;
                if ( sub_409DC7(v16, &a3) )
                  v17 = (unsigned int *)(*(_DWORD *)(v16 + 8) + *(_DWORD *)(*(_DWORD *)(v16 + 16) + 48 * a3 + 4));
                else
                  v17 = 0;
                v18 = *v17;
                v19 = v17[1];
                v82.vt = 6;
                v82.llVal = __PAIR64__(v19, v18);
                LOBYTE(v93) = 13;
                sub_40C740(&pvarg, &v82);
                LOBYTE(v93) = 0;
                p_pvargSrc = &v82;
                goto LABEL_67;
              }
              if ( v11 == 1 )
              {
                v12 = this[21];
                a3 = v4;
                if ( sub_409DC7(v12, &a3) )
                  v13 = (DOUBLE *)(*(_DWORD *)(v12 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v12 + 16) + 4));
                else
                  v13 = 0;
                v14 = *v13;
                pvargSrc.vt = 7;
                pvargSrc.dblVal = v14;
                LOBYTE(v93) = 12;
                sub_40C740(&pvarg, &pvargSrc);
                LOBYTE(v93) = 0;
                p_pvargSrc = &pvargSrc;
LABEL_67:
                VariantClear(p_pvargSrc);
              }
LABEL_84:
              sub_40C602(a2, &pvarg);
              VariantClear(&pvarg);
              return a2;
            }
LABEL_36:
            v26 = this[21];
            a3 = v4;
            if ( sub_409DC7(v26, &a3) )
              v27 = (int *)(*(_DWORD *)(v26 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v26 + 16) + 4));
            else
              v27 = 0;
            v28 = (VARIANTARG *)COleVariant::COleVariant((COleVariant *)v72, *v27, 3u);
            LOBYTE(v93) = 8;
            sub_40C740(&pvarg, v28);
            LOBYTE(v93) = 0;
            p_pvargSrc = (VARIANTARG *)v72;
            goto LABEL_67;
          }
          goto LABEL_40;
        }
      }
      v61 = this[21];
      a3 = v4;
      if ( sub_409DC7(v61, &a3) )
        v62 = (wchar_t *)(*(_DWORD *)(v61 + 8) + *(_DWORD *)(48 * a3 + *(_DWORD *)(v61 + 16) + 4));
      else
        v62 = 0;
      v66 = *(const CHAR **)sub_420159(v62);
      LOBYTE(v93) = 4;
      v63 = (VARIANTARG *)sub_40C622(v66, 8);
      LOBYTE(v93) = 5;
      sub_40C740(&pvarg, v63);
      VariantClear(&v67);
      LOBYTE(v93) = 0;
      v44 = &v84;
LABEL_83:
      sub_4200DD(v44);
      goto LABEL_84;
    }
  }
  sub_40C602(a2, &pvarg);
  VariantClear(&pvarg);
  return a2;
}


// ========== Function: sub_40A7E5 @ 0x40A7E5 ==========
char __thiscall sub_40A7E5(_DWORD *this, int a2, _DWORD *a3)
{
  if ( !sub_409DC7((int)this, &a2) )
    return 0;
  *a3 = *(_DWORD *)(this[2]
                  + (*(_DWORD *)(this[4] + 48 * a2 + 16) & 3)
                  + *(_DWORD *)(this[4] + 48 * a2 + 4)
                  + *(_DWORD *)(this[4] + 48 * a2 + 16)
                  + 4);
  return 1;
}


// ========== Function: sub_40A829 @ 0x40A829 ==========
int __thiscall sub_40A829(_DWORD *this, int a2)
{
  return this[2] + *(_DWORD *)(48 * a2 + this[4] + 4);
}


// ========== Function: sub_40A840 @ 0x40A840 ==========
int __thiscall sub_40A840(_DWORD *this)
{
  int v2; // ecx
  bool v3; // cc
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  VARIANTARG *v6; // eax
  VARIANTARG *p_pvargDest; // eax
  int (__stdcall ***v8)(_DWORD, void *, int *); // eax
  BSTR v10[8]; // [esp+4h] [ebp-78h] BYREF
  VARIANTARG pvarg; // [esp+24h] [ebp-58h] BYREF
  _DWORD v12[4]; // [esp+34h] [ebp-48h] BYREF
  VARIANTARG pvargDest; // [esp+44h] [ebp-38h] BYREF
  _BYTE v14[4]; // [esp+54h] [ebp-28h] BYREF
  int v15; // [esp+58h] [ebp-24h] BYREF
  _DWORD *v16; // [esp+5Ch] [ebp-20h]
  int v17; // [esp+60h] [ebp-1Ch] BYREF
  int v18; // [esp+64h] [ebp-18h]
  int v19; // [esp+68h] [ebp-14h]
  int v20; // [esp+6Ch] [ebp-10h]
  int v21; // [esp+78h] [ebp-4h]

  v2 = 0;
  v3 = this[4] <= 0;
  this[17] = 1;
  v20 = 0;
  v18 = 0;
  if ( !v3 )
  {
    do
    {
      v4 = *(_DWORD **)(*(_DWORD *)(this[5] + 40 * v2 + 36) + 4);
      if ( v4 )
      {
        v19 = 16 * v20;
        while ( 1 )
        {
          v5 = (_DWORD *)v4[2];
          v16 = (_DWORD *)*v4;
          v15 = -3;
          memset(v10, 0, sizeof(v10));
          AfxVariantInit(&pvargDest);
          v21 = 0;
          if ( this[18] )
          {
            v6 = sub_40A069(this, &pvarg, v18 + 1);
            LOBYTE(v21) = 1;
            sub_40C740(&pvargDest, v6);
            LOBYTE(v21) = 0;
            VariantClear(&pvarg);
            p_pvargDest = &pvargDest;
          }
          else
          {
            p_pvargDest = (VARIANTARG *)(v19 + this[16]);
          }
          v12[0] = p_pvargDest;
          v12[1] = &v15;
          v12[2] = 1;
          v12[3] = 1;
          v5[40] = 1;
          v8 = (int (__stdcall ***)(_DWORD, void *, int *))v5[19];
          if ( v8 && (**v8)(v8, &unk_42C530, &v17) >= 0 )
          {
            (*(void (__stdcall **)(int, _DWORD, _DWORD *, _DWORD, int, _DWORD *, _DWORD, BSTR *, _BYTE *))(*(_DWORD *)v17 + 24))(
              v17,
              v5[37],
              dword_42C750,
              0,
              4,
              v12,
              0,
              v10,
              v14);
            (*(void (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
            v5[40] = 0;
            if ( v10[1] )
              SysFreeString(v10[1]);
            if ( v10[2] )
              SysFreeString(v10[2]);
            if ( v10[3] )
              SysFreeString(v10[3]);
            VariantClear(&pvargDest);
            ++v20;
            v19 += 16;
          }
          v21 = -1;
          VariantClear(&pvargDest);
          if ( !v16 )
            break;
          v4 = v16;
        }
        v2 = v18;
      }
      v3 = ++v2 < this[4];
      v18 = v2;
    }
    while ( v3 );
  }
  this[17] = 0;
  return 0;
}


// ========== Function: sub_40A9D5 @ 0x40A9D5 ==========
int __thiscall sub_40A9D5(_DWORD *this)
{
  bool v2; // zf
  int v3; // esi
  bool v4; // cc
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  LONGLONG *v17; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // eax
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  BYTE *v29; // eax
  BYTE v30; // cl
  int v31; // ecx
  int v32; // ecx
  int v33; // edx
  int *v34; // esi
  int *v35; // eax
  int v36; // ecx
  CHAR *v37; // eax
  int v38; // edx
  int *v39; // esi
  wchar_t *v40; // eax
  int result; // eax
  _DWORD *v42; // eax
  int v43; // edx
  _DWORD *v44; // ecx
  int v45; // esi
  unsigned int v46; // eax
  int v47; // eax
  int v48; // ecx
  int v49; // ecx
  _DWORD *v50; // esi
  int (__stdcall ***v51)(_DWORD, void *, int *); // eax
  int v52; // esi
  __int64 vtime; // [esp+0h] [ebp-D8h]
  VARIANTARG *v54; // [esp+8h] [ebp-D0h]
  _QWORD v55[2]; // [esp+18h] [ebp-C0h] BYREF
  _DWORD v56[12]; // [esp+28h] [ebp-B0h] BYREF
  _DWORD v57[2]; // [esp+58h] [ebp-80h] BYREF
  int v58; // [esp+60h] [ebp-78h] BYREF
  int v59; // [esp+64h] [ebp-74h]
  int v60; // [esp+68h] [ebp-70h]
  struct _SYSTEMTIME *p_SystemTime; // [esp+6Ch] [ebp-6Ch]
  _DWORD v62[4]; // [esp+70h] [ebp-68h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+80h] [ebp-58h] BYREF
  VARIANTARG *pvarg; // [esp+90h] [ebp-48h]
  _DWORD *v65; // [esp+94h] [ebp-44h] BYREF
  int v66; // [esp+98h] [ebp-40h]
  _DWORD *v67; // [esp+9Ch] [ebp-3Ch] BYREF
  BYTE bVal; // [esp+A3h] [ebp-35h]
  int v69; // [esp+A4h] [ebp-34h]
  VARIANTARG pvargDest; // [esp+A8h] [ebp-30h] BYREF
  int v71; // [esp+B8h] [ebp-20h]
  int v72; // [esp+BCh] [ebp-1Ch]
  int v73; // [esp+C0h] [ebp-18h]
  int v74; // [esp+C4h] [ebp-14h]
  int v75; // [esp+C8h] [ebp-10h] BYREF
  int v76; // [esp+D4h] [ebp-4h]

  v2 = this[18] == 0;
  v66 = 0;
  v73 = 0;
  if ( !v2 )
  {
    if ( !this[21] )
      return 0;
    v3 = 1;
    v4 = this[4] < 1;
    v69 = 1;
    if ( v4 )
      return 0;
    v71 = 48;
    v72 = 40;
    while ( 1 )
    {
      v5 = *(_DWORD **)(*(_DWORD *)(v72 + this[5] - 4) + 4);
      while ( v5 )
      {
        v6 = v5;
        v5 = (_DWORD *)*v5;
        v65 = v5;
        v7 = v6[2];
        if ( !*(_DWORD *)(v7 + 164) )
          goto LABEL_78;
        ++v73;
        *(_DWORD *)(v7 + 164) = 0;
        if ( v73 == 1 )
          this[17] = 1;
        pvarg = (VARIANTARG *)(v7 + 168);
        sub_40C602(&pvargDest, (VARIANTARG *)(v7 + 168));
        v76 = 0;
        memset(v56, 0, 20);
        v56[7] = 0;
        v56[9] = 0;
        v8 = this[21];
        LOBYTE(v76) = 1;
        v74 = v8;
        v75 = v3;
        if ( sub_409DC7(v8, &v75) )
          v9 = *(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4);
        else
          v9 = 0;
        sub_40B386(1, v9, *(_DWORD *)(*(_DWORD *)(this[21] + 16) + v71 + 16));
        v74 = this[21];
        v75 = v3;
        if ( sub_409DC7(v74, &v75) )
          v10 = *(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4);
        else
          v10 = 0;
        vtime = (unsigned int)v10;
        v11 = v71 + *(_DWORD *)(this[21] + 16);
        LOWORD(v10) = *(_WORD *)(v11 + 20);
        sub_40B3FD(*(_DWORD *)(v11 + 8), v10, *(_DWORD *)(v11 + 16), vtime, HIDWORD(vtime), 0);
        sub_40B451(*(_DWORD *)this[20]);
        v12 = this[21];
        v75 = v3;
        v74 = v12;
        if ( sub_409DC7(v12, &v75) )
          LOWORD(v67) = *(_WORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 20);
        if ( (unsigned __int16)v67 > 0x81u )
        {
          if ( (unsigned __int16)v67 == 130 )
          {
LABEL_73:
            COleVariant::ChangeType(&pvargDest, 8u, 0);
            v74 = this[21];
            v75 = v3;
            if ( sub_409DC7(v74, &v75) )
              v40 = (wchar_t *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4));
            else
              v40 = 0;
            wcsncpy(v40, pvargDest.bstrVal, *(_DWORD *)(*(_DWORD *)(this[21] + 16) + v71 + 16));
            goto LABEL_77;
          }
          if ( (unsigned __int16)v67 == 135 )
          {
            COleVariant::ChangeType(&pvargDest, 7u, 0);
            memset(v62, 0, sizeof(v62));
            VariantTimeToSystemTime(pvargDest.dblVal, &SystemTime);
            v62[0] = *(_DWORD *)&SystemTime.wYear;
            v62[1] = *(_DWORD *)&SystemTime.wDay;
            v62[2] = *(_DWORD *)&SystemTime.wMinute;
            v75 = v3;
            v74 = this[21];
            v62[3] = SystemTime.wMilliseconds / 1000000;
            if ( sub_409DC7(v74, &v75) )
            {
              v58 = v62[0];
              v38 = *(_DWORD *)(v74 + 16);
              v59 = v62[1];
              v60 = v62[2];
              p_SystemTime = (struct _SYSTEMTIME *)v62[3];
              v34 = &v58;
              v35 = (int *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + v38 + 4));
              goto LABEL_72;
            }
          }
        }
        else
        {
          if ( (unsigned __int16)v67 == 129 )
          {
            COleVariant::ChangeType(&pvargDest, 8u, 0);
            v74 = this[21];
            v75 = v3;
            if ( sub_409DC7(v74, &v75) )
              v37 = (CHAR *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4));
            else
              v37 = 0;
            WideCharToMultiByte(
              0,
              0,
              pvargDest.bstrVal,
              -1,
              v37,
              *(_DWORD *)(*(_DWORD *)(this[21] + 16) + v71 + 16),
              0,
              0);
            goto LABEL_77;
          }
          if ( (unsigned __int16)v67 > 8u )
          {
            switch ( (unsigned __int16)v67 )
            {
              case 0xBu:
                COleVariant::ChangeType(&pvargDest, 0xBu, 0);
                v36 = this[21];
                v75 = v3;
                v74 = v36;
                if ( !sub_409DC7(v36, &v75) )
                  break;
                v24 = v74;
                v25 = 48 * v75;
                goto LABEL_54;
              case 0xEu:
                COleVariant::ChangeType(&pvargDest, 0xEu, 0);
                v32 = this[21];
                v75 = v3;
                v74 = v32;
                if ( sub_409DC7(v32, &v75) )
                {
                  v55[0] = *(_QWORD *)&pvargDest.vt;
                  v33 = *(_DWORD *)(v74 + 16);
                  v55[1] = pvargDest.llVal;
                  v34 = (int *)v55;
                  v35 = (int *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + v33 + 4));
LABEL_72:
                  *v35 = *v34;
                  v39 = v34 + 1;
                  v35[1] = *v39++;
                  v35[2] = *v39;
                  v35[3] = v39[1];
                  v3 = v69;
                }
                break;
              case 0x10u:
                COleVariant::ChangeType(&pvargDest, 0x10u, 0);
                v31 = this[21];
                bVal = pvargDest.bVal;
                v75 = v3;
                v74 = v31;
                if ( sub_409DC7(v31, &v75) )
                {
                  v29 = (BYTE *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4));
                  v30 = bVal;
                  goto LABEL_59;
                }
                break;
              case 0x11u:
                COleVariant::ChangeType(&pvargDest, 0x11u, 0);
                v28 = this[21];
                v75 = v3;
                v74 = v28;
                if ( sub_409DC7(v28, &v75) )
                {
                  v29 = (BYTE *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4));
                  v30 = pvargDest.bVal;
LABEL_59:
                  *v29 = v30;
                }
                break;
              case 0x12u:
                COleVariant::ChangeType(&pvargDest, 0x12u, 0);
                v27 = this[21];
                v75 = v3;
                v74 = v27;
                if ( sub_409DC7(v27, &v75) )
                {
                  v24 = v74;
                  v25 = 48 * v75;
                  goto LABEL_54;
                }
                break;
              case 0x13u:
                COleVariant::ChangeType(&pvargDest, 0x13u, 0);
                v26 = this[21];
                v75 = v3;
                v74 = v26;
                if ( !sub_409DC7(v26, &v75) )
                  break;
                v20 = v74;
                v21 = 48 * v75;
                goto LABEL_51;
              default:
                break;
            }
          }
          else
          {
            switch ( (unsigned __int16)v67 )
            {
              case 8u:
                goto LABEL_73;
              case 2u:
                COleVariant::ChangeType(&pvargDest, 2u, 0);
                v23 = this[21];
                v75 = v3;
                v74 = v23;
                if ( sub_409DC7(v23, &v75) )
                {
                  v24 = v74;
                  v25 = 48 * v75;
LABEL_54:
                  *(_WORD *)(*(_DWORD *)(v24 + 8) + *(_DWORD *)(v25 + *(_DWORD *)(v24 + 16) + 4)) = pvargDest.iVal;
                }
                break;
              case 3u:
                COleVariant::ChangeType(&pvargDest, 3u, 0);
                v22 = this[21];
                v75 = v3;
                v74 = v22;
                if ( sub_409DC7(v22, &v75) )
                {
                  v20 = v74;
                  v21 = 48 * v75;
                  goto LABEL_51;
                }
                break;
              case 4u:
                COleVariant::ChangeType(&pvargDest, 4u, 0);
                v19 = this[21];
                v75 = v3;
                v74 = v19;
                if ( sub_409DC7(v19, &v75) )
                {
                  v20 = v74;
                  v21 = 48 * v75;
LABEL_51:
                  *(_DWORD *)(*(_DWORD *)(v20 + 8) + *(_DWORD *)(v21 + *(_DWORD *)(v20 + 16) + 4)) = pvargDest.lVal;
                }
                break;
              case 5u:
                COleVariant::ChangeType(&pvargDest, 5u, 0);
                v18 = this[21];
                v75 = v3;
                v74 = v18;
                if ( !sub_409DC7(v18, &v75) )
                  break;
                v14 = v74;
                v15 = 48 * v75;
                goto LABEL_30;
              case 6u:
                COleVariant::ChangeType(&pvargDest, 6u, 0);
                v16 = this[21];
                v75 = v3;
                v74 = v16;
                if ( sub_409DC7(v16, &v75) )
                  v17 = (LONGLONG *)(*(_DWORD *)(v74 + 8) + *(_DWORD *)(48 * v75 + *(_DWORD *)(v74 + 16) + 4));
                else
                  v17 = 0;
                *v17 = pvargDest.llVal;
                break;
              case 7u:
                COleVariant::ChangeType(&pvargDest, 7u, 0);
                v13 = this[21];
                v75 = v3;
                v74 = v13;
                if ( sub_409DC7(v13, &v75) )
                {
                  v14 = v74;
                  v15 = 48 * v75;
LABEL_30:
                  *(double *)(*(_DWORD *)(v14 + 8) + *(_DWORD *)(v15 + *(_DWORD *)(v14 + 16) + 4)) = pvargDest.dblVal;
                }
                break;
            }
          }
        }
LABEL_77:
        *(_DWORD *)(this[20] + 8) = v56;
        sub_40B318(this[20]);
        v54 = pvarg;
        *(_DWORD *)(this[20] + 8) = this[21];
        VariantClear(v54);
        LOBYTE(v76) = 0;
        ATL::CManualAccessor::~CManualAccessor((ATL::CManualAccessor *)v56);
        v76 = -1;
        VariantClear(&pvargDest);
        v5 = v65;
LABEL_78:
        ++v66;
      }
      v72 += 40;
      v71 += 48;
      v4 = ++v3 <= this[4];
      v69 = v3;
      if ( !v4 )
      {
        if ( v73 > 0 )
          this[17] = 0;
        return 0;
      }
    }
  }
  if ( !this[3] && (**(int (__stdcall ***)(_DWORD, void *, int))this[2])(this[2], &unk_42C770, (int)(this + 3)) < 0 )
    return 0;
  v4 = this[4] <= 0;
  v71 = 0;
  if ( !v4 )
  {
    v69 = 0;
    while ( 1 )
    {
      v42 = *(_DWORD **)(*(_DWORD *)(v69 + this[5] + 36) + 4);
      if ( v42 )
        break;
LABEL_106:
      ++v71;
      v69 += 40;
      if ( v71 >= this[4] )
        goto LABEL_107;
    }
    v43 = 48 * v66;
    v72 = 48 * v66;
    while ( 1 )
    {
      v44 = v42;
      v42 = (_DWORD *)*v42;
      v67 = v42;
      v75 = v44[2];
      if ( *(_DWORD *)(v75 + 164) )
        break;
LABEL_105:
      ++v66;
      v43 += 48;
      v72 = v43;
      if ( !v42 )
        goto LABEL_106;
    }
    ++v73;
    *(_DWORD *)(v75 + 164) = 0;
    if ( v73 == 1 )
    {
      result = (*(int (__stdcall **)(_DWORD, _DWORD **))(*(_DWORD *)this[3] + 24))(this[3], &v65);
      if ( result < 0 )
        return result;
      if ( v65 == (_DWORD *)1 )
      {
        result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this[3] + 12))(this[3], 1);
        if ( result < 0 )
          return result;
      }
      this[17] = 1;
    }
    v45 = 16;
    AfxVariantInit((struct tagVARIANT *)&SystemTime);
    v76 = 2;
    pvarg = (VARIANTARG *)(v75 + 168);
    v46 = *(unsigned __int16 *)(v75 + 168);
    if ( v46 > 1 )
    {
      if ( v46 == 8 )
      {
        if ( !**(_WORD **)(v75 + 176) )
        {
          v45 = -1;
LABEL_104:
          v47 = v72 + this[15];
          v57[0] = 0;
          v57[1] = 1;
          v48 = *(_DWORD *)(v47 + 44);
          v60 = v45;
          v58 = v48;
          p_SystemTime = &SystemTime;
          v49 = this[3];
          v59 = 0;
          (*(void (__stdcall **)(int, int, _DWORD *))(*(_DWORD *)v49 + 16))(v49, v47, v57);
          VariantClear(pvarg);
          v76 = -1;
          VariantClear((VARIANTARG *)&SystemTime);
          v42 = v67;
          v43 = v72;
          goto LABEL_105;
        }
LABEL_103:
        sub_40C740((VARIANTARG *)&SystemTime, (VARIANTARG *)(v75 + 168));
        goto LABEL_104;
      }
      if ( v46 != 10 )
        goto LABEL_103;
    }
    v45 = -1;
    goto LABEL_103;
  }
LABEL_107:
  v72 = this[7];
  while ( v72 )
  {
    v50 = *(_DWORD **)(v72 + 8);
    v72 = *(_DWORD *)v72;
    v51 = *(int (__stdcall ****)(_DWORD, void *, int *))(*v50 + 76);
    if ( v51 && (**v51)(v51, &unk_42CB38, &v75) >= 0 )
    {
      if ( !(*(int (__stdcall **)(int, _DWORD))(*(_DWORD *)v75 + 16))(v75, v50[2]) && ++v73 == 1 )
      {
        result = (*(int (__stdcall **)(_DWORD, _DWORD **))(*(_DWORD *)this[3] + 24))(this[3], &v67);
        if ( result < 0 )
          return result;
        if ( v67 == (_DWORD *)1 )
        {
          result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this[3] + 12))(this[3], 1);
          if ( result < 0 )
            return result;
        }
        this[17] = 1;
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)v75 + 8))(v75);
    }
  }
  if ( v73 <= 0 )
    return 0;
  v52 = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this[3] + 28))(this[3], 0, 0, 0);
  this[17] = 0;
  if ( v52 >= 0 )
    return 0;
  (*(void (__thiscall **)(_DWORD *))(*this + 16))(this);
  return v52;
}


// ========== Function: sub_40B318 @ 0x40B318 ==========
int __thiscall sub_40B318(_DWORD *this)
{
  int result; // eax
  unsigned int v2; // ebx
  unsigned int v3; // edi

  result = 0;
  v2 = 0;
  v3 = *(_DWORD *)(this[2] + 4);
  if ( v3 )
  {
    do
    {
      result = sub_40B340(v2);
      if ( result < 0 )
        break;
      ++v2;
    }
    while ( v2 < v3 );
  }
  return result;
}


// ========== Function: sub_40B340 @ 0x40B340 ==========
int __thiscall sub_40B340(int this, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(this + 4);
  if ( v2 )
    return (*(int (__stdcall **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v2 + 16))(
             v2,
             *(_DWORD *)(this + 12),
             *(_DWORD *)(**(_DWORD **)(this + 8) + 8 * a2),
             *(_DWORD *)(*(_DWORD *)(this + 8) + 8));
  else
    return -2147467262;
}


// ========== Function: ??1CManualAccessor@ATL@@QAE@XZ @ 0x40B36F ==========
void __thiscall ATL::CManualAccessor::~CManualAccessor(LPVOID *this)
{
  sub_41CA99(this[3]);
  sub_41CA99(this[9]);
}


// ========== Function: sub_40B386 @ 0x40B386 ==========
int __thiscall sub_40B386(_DWORD *this, int a2, int a3, int a4)
{
  void *v6; // [esp-4h] [ebp-24h]
  _DWORD v7[8]; // [esp+0h] [ebp-20h] BYREF

  v7[4] = v7;
  v6 = (void *)this[3];
  this[2] = a3;
  v7[3] = this;
  this[6] = a4;
  this[4] = a2;
  this[5] = 0;
  sub_41CA99(v6);
  this[3] = 0;
  v7[7] = 0;
  this[3] = sub_41CA70(52 * a2);
  return this[3] != 0 ? 0 : -2147024882;
}


// ========== Function: sub_40B3FD @ 0x40B3FD ==========
int __thiscall sub_40B3FD(_DWORD *this, int a2, __int16 a3, int a4, int a5, int a6, int a7)
{
  int v8; // eax
  int v9; // ecx

  if ( a7 )
    v8 = a7 - this[2];
  else
    v8 = 0;
  if ( a6 )
    v9 = a6 - this[2];
  else
    v9 = 0;
  return sub_409BA0(this[3] + 52 * this[5]++, a2, a3, a4, 0, 0, 0, a5 - this[2], v9, v8, 0);
}


// ========== Function: sub_40B451 @ 0x40B451 ==========
int __thiscall sub_40B451(int *this, int (__stdcall ***a2)(_DWORD, void *, int *))
{
  int v3; // ebx
  int v5; // eax
  int v6; // esi
  int v7; // [esp+8h] [ebp-10h] BYREF
  int v8; // [esp+14h] [ebp-4h]

  v7 = 0;
  v8 = 0;
  v3 = (**a2)(a2, &unk_433E48, &v7);
  if ( v3 < 0 )
  {
LABEL_4:
    v8 = -1;
    if ( v7 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
    return v3;
  }
  if ( !*this )
  {
    v3 = sub_409AFA(this, 1);
    if ( v3 < 0 )
      goto LABEL_4;
    *(_BYTE *)(*this + 4) = 1;
  }
  v5 = sub_409B56(this[3], this[4], *this, this[6], v7);
  v8 = -1;
  v6 = v5;
  if ( v7 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  return v6;
}


// ========== Function: ??0CDataBoundProperty@@QAE@PAV0@JG@Z @ 0x40B4E9 ==========
CDataBoundProperty *__thiscall CDataBoundProperty::CDataBoundProperty(
        CDataBoundProperty *this,
        struct CDataBoundProperty *a2,
        int a3,
        unsigned __int16 a4)
{
  CDataBoundProperty *result; // eax

  result = this;
  *(_DWORD *)this = 0;
  *((_WORD *)this + 2) = a4;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 6) = a2;
  return result;
}


// ========== Function: unknown_libname_9 @ 0x40B50F ==========
// MFC 3.1-14.0 32bit
int __thiscall unknown_libname_9(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  *this = a2;
  return result;
}


// ========== Function: ?SetDSCSite@CDataBoundProperty@@QAEXPAVCOleControlSite@@@Z @ 0x40B518 ==========
void __thiscall CDataBoundProperty::SetDSCSite(CDataBoundProperty *this, struct COleControlSite *a2)
{
  if ( *((struct COleControlSite **)this + 3) != a2 )
  {
    *((_DWORD *)this + 3) = a2;
    sub_40B530();
  }
}


// ========== Function: sub_40B52C @ 0x40B52C ==========
int __thiscall sub_40B52C(_DWORD *this)
{
  return this[6];
}


// ========== Function: sub_40B530 @ 0x40B530 ==========
void __thiscall sub_40B530(_DWORD *this)
{
  int v2; // eax
  int v3; // edx
  int v4; // [esp+4h] [ebp-4h] BYREF

  if ( this[2] != -2147418111 && *this )
  {
    if ( (***(int (__stdcall ****)(_DWORD, void *, int *))(*this + 76))(*(_DWORD *)(*this + 76), &unk_42CB38, &v4) < 0 )
    {
      v2 = sub_40B5B3(this);
      if ( v2 )
      {
        v3 = 13;
        if ( *(_DWORD *)(this[3] + 136) )
          v3 = 32781;
        (*(void (__cdecl **)(_DWORD, _DWORD, int, int))(*(_DWORD *)*this + 104))(*this, this[2], v3, v2);
      }
    }
    else
    {
      (*(void (__stdcall **)(int, _DWORD, bool, _DWORD *))(*(_DWORD *)v4 + 12))(v4, this[2], this[3] != 0, this + 4);
      (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
    }
  }
}


// ========== Function: sub_40B5B3 @ 0x40B5B3 ==========
int __thiscall sub_40B5B3(_DWORD *this)
{
  int v2; // ecx

  v2 = this[3];
  if ( !v2 )
    return 0;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 176))(v2);
  (*(void (__thiscall **)(_DWORD, _DWORD *, int))(**(_DWORD **)(this[3] + 136) + 4))(
    *(_DWORD *)(this[3] + 136),
    this,
    1);
  return (***(int (__thiscall ****)(_DWORD))(this[3] + 136))(*(_DWORD *)(this[3] + 136));
}


// ========== Function: ?GetCursor@COleControlSite@@IAEJJPAPAUICursor@@PAPAX@Z @ 0x40B5E9 ==========
int __thiscall COleControlSite::GetCursor(COleControlSite *this, int a2, struct ICursor **a3, void **a4)
{
  _DWORD *i; // ecx

  if ( a4 )
    *a4 = 0;
  for ( i = (_DWORD *)*((_DWORD *)this + 35); i; i = (_DWORD *)sub_40B52C(i) )
  {
    if ( i[2] == a2 )
    {
      *a3 = (struct ICursor *)sub_40B5B3(i);
      return 0;
    }
  }
  return 0;
}


// ========== Function: sub_40B620 @ 0x40B620 ==========
unsigned int __stdcall sub_40B620(int a1)
{
  return CCmdTarget::ExternalAddRef((CCmdTarget *)(a1 - 208));
}


// ========== Function: sub_40B632 @ 0x40B632 ==========
unsigned int __stdcall sub_40B632(int a1)
{
  return CCmdTarget::ExternalRelease((CCmdTarget *)(a1 - 208));
}


// ========== Function: ?QueryInterface@XBoundObjectSite@COleControlSite@@UAGJABU_GUID@@PAPAX@Z @ 0x40B644 ==========
unsigned int __stdcall COleControlSite::XBoundObjectSite::QueryInterface(
        COleControlSite::XBoundObjectSite *this,
        const struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::ExternalQueryInterface((COleControlSite::XBoundObjectSite *)((char *)this - 208), a2, a3);
}


// ========== Function: ?GetCursor@XBoundObjectSite@COleControlSite@@UAGJJPAPAUICursor@@PAPAX@Z @ 0x40B65E ==========
int __stdcall COleControlSite::XBoundObjectSite::GetCursor(
        COleControlSite::XBoundObjectSite *this,
        int a2,
        struct ICursor **a3,
        void **a4)
{
  return COleControlSite::GetCursor((COleControlSite::XBoundObjectSite *)((char *)this - 208), a2, a3, a4);
}


// ========== Function: sub_40B67C @ 0x40B67C ==========
int __stdcall sub_40B67C(int a1, void *Buf1, _DWORD *a3)
{
  if ( memcmp(Buf1, &dword_42C760, 0x10u) && memcmp(Buf1, &stru_42C620, 0x10u) )
    return -2147467262;
  *a3 = a1;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}


// ========== Function: ?OKToDo@XNotifyDBEvents@COleControlSite@@UAGJKKQAUtagDBNOTIFYREASON@@@Z @ 0x40B6C6 ==========
int __stdcall COleControlSite::XNotifyDBEvents::OKToDo(
        COleControlSite::XNotifyDBEvents *this,
        char a2,
        unsigned int a3,
        struct tagDBNOTIFYREASON *const a4)
{
  int result; // eax
  int v5; // esi
  int v6; // ecx

  result = sub_40B883(a2, a3, a4, 1);
  if ( result >= 0 )
  {
    v5 = *(_DWORD *)a4;
    if ( *(_DWORD *)a4 != 30
      && v5 != 2
      && v5 != 3
      && ((a2 & 1) != 0 || v5 == 1 || v5 == 20)
      && (v6 = *((_DWORD *)this - 19)) != 0
      && (a2 & 1) != 0 )
    {
      return (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 20))(v6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}


// ========== Function: ?Cancelled@XNotifyDBEvents@COleControlSite@@UAGJKKQAUtagDBNOTIFYREASON@@@Z @ 0x40B722 ==========
int __stdcall COleControlSite::XNotifyDBEvents::Cancelled(
        COleControlSite::XNotifyDBEvents *this,
        char a2,
        unsigned int a3,
        struct tagDBNOTIFYREASON *const a4)
{
  int result; // eax

  result = sub_40B883(a2, a3, a4, 2);
  if ( result >= 0 )
    return 0;
  return result;
}


// ========== Function: ?SyncBefore@XNotifyDBEvents@COleControlSite@@UAGJKKQAUtagDBNOTIFYREASON@@@Z @ 0x40B742 ==========
int __stdcall COleControlSite::XNotifyDBEvents::SyncBefore(
        COleControlSite::XNotifyDBEvents *this,
        char a2,
        unsigned int a3,
        struct tagDBNOTIFYREASON *const a4)
{
  int result; // eax
  int v5; // esi
  int v6; // ecx

  result = sub_40B883(a2, a3, a4, 3);
  if ( result >= 0 )
  {
    v5 = *(_DWORD *)a4;
    if ( *(_DWORD *)a4 == 2 || v5 == 3 || v5 == 20 )
    {
      v6 = *((_DWORD *)this - 19);
      if ( v6 )
      {
        if ( a2 < 0 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 20))(v6);
      }
    }
    return 0;
  }
  return result;
}


// ========== Function: ?AboutToDo@XNotifyDBEvents@COleControlSite@@UAGJKKQAUtagDBNOTIFYREASON@@@Z @ 0x40B78C ==========
int __stdcall COleControlSite::XNotifyDBEvents::AboutToDo(
        COleControlSite::XNotifyDBEvents *this,
        char a2,
        unsigned int a3,
        struct tagDBNOTIFYREASON *const a4)
{
  int result; // eax

  result = sub_40B883(a2, a3, a4, 4);
  if ( result >= 0 )
    return 0;
  return result;
}


// ========== Function: ?FailedToDo@XNotifyDBEvents@COleControlSite@@UAGJKKQAUtagDBNOTIFYREASON@@@Z @ 0x40B7AC ==========
int __stdcall COleControlSite::XNotifyDBEvents::FailedToDo(
        COleControlSite::XNotifyDBEvents *this,
        char a2,
        unsigned int a3,
        struct tagDBNOTIFYREASON *const a4)
{
  int result; // eax

  result = sub_40B883(a2, a3, a4, 5);
  if ( result >= 0 )
    return 0;
  return result;
}


// ========== Function: sub_40B7CC @ 0x40B7CC ==========
int __stdcall sub_40B7CC(int a1, char a2, int a3, int *a4)
{
  int result; // eax
  int v5; // eax
  int *v6; // esi
  _DWORD *v7; // ecx
  int v8; // eax

  result = sub_40B883(a2, a3, a4, 6);
  if ( result >= 0 )
  {
    v5 = *a4;
    v6 = *(int **)(a1 - 76);
    if ( v6 && !v6[17] && v5 != 31 && v5 != 30 && (a2 & 3) != 0 && v5 != 2 && v5 != 3 )
    {
      v7 = *(_DWORD **)(a1 - 76);
      v6[17] = 1;
      sub_40A00C(v7);
      v8 = *v6;
      v6[17] = 0;
      (*(void (__thiscall **)(int *))(v8 + 16))(v6);
    }
    return 0;
  }
  return result;
}


// ========== Function: sub_40B835 @ 0x40B835 ==========
int __stdcall sub_40B835(int a1, char a2, int a3, int a4)
{
  int result; // eax
  int *v5; // esi
  int v6; // edi
  int v7; // eax

  result = sub_40B883(a2, a3, a4, 7);
  if ( result >= 0 )
  {
    v5 = *(int **)(a1 - 76);
    if ( v5 )
    {
      if ( a2 < 0 )
      {
        v6 = v5[17];
        v5[17] = 1;
        sub_40A00C(v5);
        v7 = *v5;
        v5[17] = v6;
        (*(void (__thiscall **)(int *))(v7 + 16))(v5);
      }
    }
    return 0;
  }
  return result;
}


// ========== Function: sub_40B883 @ 0x40B883 ==========
int __thiscall sub_40B883(char *this, char a2, unsigned int a3, _DWORD *a4, int a5)
{
  char *v5; // edi
  unsigned int v6; // edx
  int v8; // esi
  int v10; // [esp-4h] [ebp-30h]
  _BYTE v11[24]; // [esp+8h] [ebp-24h] BYREF
  int v12; // [esp+20h] [ebp-Ch]
  int v13; // [esp+24h] [ebp-8h]
  int v14; // [esp+28h] [ebp-4h]

  v5 = this - 212;
  if ( (a2 & 3) == 0 )
    return 0;
  v6 = 0;
  if ( !a3 )
    return 0;
  while ( 2 )
  {
    switch ( *a4 )
    {
      case 1:
        v10 = 3;
        break;
      case 2:
      case 0x14:
        v10 = 5;
        break;
      case 3:
      case 9:
      case 0xA:
      case 0x17:
        v10 = 6;
        break;
      case 6:
      case 7:
      case 8:
      case 0xB:
      case 0xC:
      case 0xF:
      case 0x10:
      case 0x13:
      case 0x15:
        v10 = 7;
        break;
      case 0x18:
        v10 = 2;
        break;
      case 0x19:
        v10 = 1;
        break;
      case 0x1F:
        v10 = 4;
        break;
      default:
        ++v6;
        a4 += 9;
        if ( v6 < a3 )
          continue;
        return 0;
    }
    break;
  }
  v8 = v10;
  AFX_EVENT::AFX_EVENT((AFX_EVENT *)v11, 3);
  v13 = a5;
  v14 = v8;
  sub_407EA9(v5, (int)v11);
  return v12;
}


// ========== Function: sub_40B947 @ 0x40B947 ==========
int __stdcall sub_40B947(int a1, void *Buf1, _DWORD *a3)
{
  if ( memcmp(Buf1, &dword_42C760, 0x10u) && memcmp(Buf1, &unk_42C5E0, 0x10u) )
    return -2147467262;
  *a3 = a1;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}


// ========== Function: sub_40B991 @ 0x40B991 ==========
int __stdcall sub_40B991(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *v8; // edi
  int v9; // ebx
  int *v10; // esi
  _DWORD *v12; // ecx
  int v13; // eax
  int v14; // [esp-4h] [ebp-34h]
  _BYTE v15[24]; // [esp+Ch] [ebp-24h] BYREF
  int v16; // [esp+24h] [ebp-Ch]
  int v17; // [esp+28h] [ebp-8h]
  int v18; // [esp+2Ch] [ebp-4h]

  v8 = (_DWORD *)(a1 - 216);
  v9 = 0;
  switch ( a7 )
  {
    case 0:
      v14 = 1;
      goto LABEL_11;
    case 1:
      v14 = 4;
      goto LABEL_11;
    case 2:
      v14 = 6;
      goto LABEL_11;
    case 3:
      v14 = 5;
LABEL_11:
      v9 = v14;
      break;
    case 4:
      v10 = (int *)v8[34];
      v9 = 7;
      if ( !v10 )
        return 0;
      if ( !v10[17] )
      {
        v12 = (_DWORD *)v8[34];
        v10[17] = 1;
        sub_40A00C(v12);
        v13 = *v10;
        v10[17] = 0;
        (*(void (__thiscall **)(int *))(v13 + 16))(v10);
      }
      break;
  }
  AFX_EVENT::AFX_EVENT((AFX_EVENT *)v15, 3);
  v17 = v9;
  v18 = 6;
  sub_407EA9(v8, (int)v15);
  return v16;
}


// ========== Function: sub_40BA22 @ 0x40BA22 ==========
int __stdcall sub_40BA22(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // ebx
  _DWORD *v9; // esi
  int v10; // edi
  int result; // eax
  int v12; // [esp-4h] [ebp-38h]
  _BYTE v13[24]; // [esp+Ch] [ebp-28h] BYREF
  int v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+28h] [ebp-Ch]
  int v16; // [esp+2Ch] [ebp-8h]
  _DWORD *v17; // [esp+30h] [ebp-4h]
  int v18; // [esp+3Ch] [ebp+8h]

  v7 = a1 - 216;
  v8 = 0;
  v17 = (_DWORD *)(a1 - 216);
  v18 = 0;
  if ( a6 )
  {
    switch ( a6 )
    {
      case 1:
        v18 = 4;
        break;
      case 2:
        v18 = 6;
        break;
      case 3:
        v18 = 5;
        break;
      case 4:
        v18 = 7;
        break;
    }
  }
  else
  {
    v18 = 1;
  }
  switch ( a5 )
  {
    case 4:
      v8 = 7;
      break;
    case 6:
      v12 = 3;
      goto LABEL_17;
    case 8:
      v12 = 5;
LABEL_17:
      v8 = v12;
      break;
    case 13:
      v8 = 2;
      break;
  }
  v9 = *(_DWORD **)(v7 + 136);
  if ( !v9 )
    return 0;
  if ( v8 == 2 )
  {
    if ( v18 == 4 )
    {
      (*(void (__thiscall **)(_DWORD *))(*v9 + 20))(v9);
      goto LABEL_31;
    }
  }
  else if ( v8 == 7 && a3 == 1 )
  {
    goto LABEL_28;
  }
  if ( v18 == 6 && v8 == 5 )
  {
LABEL_28:
    (*(void (__thiscall **)(_DWORD *))(*v9 + 20))(v9);
    *(_DWORD *)(v9[20] + 12) = *a4;
    v10 = v9[17];
    v9[17] = 1;
    sub_40A00C(v9);
    v9[17] = v10;
    if ( !v10 )
      (*(void (__thiscall **)(_DWORD *))(*v9 + 16))(v9);
  }
  if ( v8 )
  {
LABEL_31:
    AFX_EVENT::AFX_EVENT((AFX_EVENT *)v13, 3);
    v15 = v18;
    v16 = v8;
    sub_407EA9(v17, (int)v13);
    result = v14;
    if ( v14 < 0 )
      return result;
  }
  return 0;
}


// ========== Function: sub_40BB37 @ 0x40BB37 ==========
int __stdcall sub_40BB37(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // eax
  void *v7; // eax
  void *v9; // [esp-4h] [ebp-8h]

  if ( a3 == 14 )
  {
    v5 = *(_DWORD *)(a1 - 80);
    if ( v5 )
    {
      sub_40908A(*(void ***)(v5 + 84), **(int (__stdcall *****)(_DWORD, void *, int *))(v5 + 80));
      sub_4091AB(*(_DWORD *)(v5 + 84));
      sub_409849(*(_DWORD **)(v5 + 84), **(int (__stdcall *****)(_DWORD, void *, int *))(v5 + 80));
      v6 = *(_DWORD *)(*(_DWORD *)(v5 + 84) + 12);
      if ( *(_DWORD *)(v5 + 16) != v6 )
      {
        v9 = *(void **)(v5 + 20);
        *(_DWORD *)(v5 + 16) = v6;
        CoTaskMemFree(v9);
        v7 = CoTaskMemAlloc(40 * *(_DWORD *)(v5 + 16));
        *(_DWORD *)(v5 + 20) = v7;
        memset(v7, 0, 40 * *(_DWORD *)(v5 + 16));
      }
    }
  }
  return 0;
}


// ========== Function: sub_40BBBE @ 0x40BBBE ==========
int __stdcall sub_40BBBE(_DWORD *a1, int a2)
{
  if ( a2 )
    (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 4))(a2);
  if ( *a1 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*a1 + 8))(*a1);
  *a1 = a2;
  return a2;
}


// ========== Function: j_?ReleaseDispatch@COleDispatchDriver@@QAEXXZ @ 0x40BBE7 ==========
// attributes: thunk
void __thiscall COleDispatchDriver::ReleaseDispatch(COleDispatchDriver *this)
{
  ?ReleaseDispatch@COleDispatchDriver@@QAEXXZ(this);
}


// ========== Function: ??0AFX_EVENT@@QAE@H@Z @ 0x40BBF4 ==========
AFX_EVENT *__thiscall AFX_EVENT::AFX_EVENT(AFX_EVENT *this, int a2)
{
  AFX_EVENT *result; // eax

  result = this;
  *((_DWORD *)this + 1) = -1;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  return result;
}


// ========== Function: ?_AfxGetDlgCode@@YGKPAVCWnd@@PAUtagMSG@@@Z @ 0x40BC17 ==========
LRESULT __stdcall _AfxGetDlgCode(HWND *a1, LPARAM lParam)
{
  WPARAM v3; // eax

  if ( !a1 )
    return 0;
  if ( lParam )
    v3 = *(_DWORD *)(lParam + 8);
  else
    v3 = 0;
  return SendMessageA(a1[7], 0x87u, v3, lParam);
}


// ========== Function: ?_AfxDlgSetFocus@@YGXPAVCWnd@@@Z @ 0x40BC45 ==========
void __stdcall _AfxDlgSetFocus(HWND *a1)
{
  if ( (_AfxGetDlgCode(a1, 0) & 8) != 0 )
    SendMessageA(a1[7], 0xB1u, 0, -1);
  sub_42065B(a1);
}


// ========== Function: sub_40BC73 @ 0x40BC73 ==========
int __stdcall sub_40BC73(int a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  HWND Parent; // eax

  v2 = a2;
  v3 = 0;
  while ( v2 )
  {
    if ( (GetWindowLongA(*(HWND *)(v2 + 28), -16) & 0xC0000000) != 0x40000000 )
      break;
    if ( v2 == a1 )
      break;
    v3 = v2;
    Parent = GetParent(*(HWND *)(v2 + 28));
    v2 = sub_41D866(Parent);
    if ( (GetWindowLongA(*(HWND *)(v2 + 28), -20) & 0x10000) != 0 )
      break;
  }
  return v3;
}


// ========== Function: sub_40BCCC @ 0x40BCCC ==========
int __stdcall sub_40BCCC(int a1, int a2, int a3)
{
  int v3; // esi
  HWND Window; // eax
  int v5; // ebp
  HWND Parent; // eax
  int v7; // eax
  int v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  int v11; // esi
  HWND TopWindow; // eax

  v3 = a2;
  if ( a2 )
  {
    Window = GetWindow(*(HWND *)(a2 + 28), 2u);
    v5 = a1;
    if ( sub_41D866(Window) )
    {
LABEL_6:
      v10 = GetWindow(*(HWND *)(v3 + 28), 2u);
      v11 = sub_41D866(v10);
      goto LABEL_7;
    }
    while ( 1 )
    {
      Parent = GetParent(*(HWND *)(v3 + 28));
      v7 = sub_41D866(Parent);
      v8 = sub_40BC73(a1, v7);
      v3 = v8;
      if ( !v8 || v8 == a1 )
        break;
      v9 = GetWindow(*(HWND *)(v8 + 28), 2u);
      if ( sub_41D866(v9) )
        goto LABEL_6;
    }
  }
  else
  {
    v5 = a1;
  }
  TopWindow = GetTopWindow(*(HWND *)(v5 + 28));
  v11 = sub_41D866(TopWindow);
  if ( !v11 )
    return v5;
LABEL_7:
  if ( (GetWindowLongA(*(HWND *)(v11 + 28), -20) & 0x10000) != 0 )
  {
    if ( ((a3 & 1) == 0 || IsWindowVisible(*(HWND *)(v11 + 28))) && ((a3 & 2) == 0 || sub_420619(v11)) )
      return sub_40BCCC(v11, 0, a3);
    else
      return sub_40BCCC(v5, v11, a3);
  }
  return v11;
}


// ========== Function: ?IsMatchingMnemonic@COccManager@@SAHPAVCWnd@@PAUtagMSG@@@Z @ 0x40BDA8 ==========
BOOL __cdecl COccManager::IsMatchingMnemonic(struct CWnd *a1, struct tagMSG *a2)
{
  int v2; // ecx

  v2 = *((_DWORD *)a1 + 14);
  return v2 && sub_407CFD(v2, (int)a2);
}


// ========== Function: sub_40BDC7 @ 0x40BDC7 ==========
BOOL __stdcall sub_40BDC7(int a1, struct CWnd *a2, struct tagMSG *a3)
{
  int v3; // ebx
  HWND v4; // esi
  HWND NextDlgGroupItem; // eax
  struct CWnd *v6; // eax
  BOOL result; // eax
  int v8; // ebx

  v3 = 0;
  v4 = (HWND)sub_40BC73(a1, (int)a2);
  while ( 1 )
  {
    if ( v4 )
      v4 = (HWND)*((_DWORD *)v4 + 7);
    NextDlgGroupItem = GetNextDlgGroupItem(*(HWND *)(a1 + 28), v4, 0);
    v6 = (struct CWnd *)sub_41D866(NextDlgGroupItem);
    v4 = (HWND)v6;
    if ( !v6 )
      break;
    ++v3;
    if ( v6 == a2 || v3 > 60 )
      break;
    if ( COccManager::IsMatchingMnemonic(v6, a3) )
      return (BOOL)v4;
  }
  v8 = sub_40BC73(a1, (int)a2);
  v4 = (HWND)v8;
  while ( 1 )
  {
    v4 = (HWND)sub_40BCCC(a1, (int)v4, 3);
    result = COccManager::IsMatchingMnemonic((struct CWnd *)v4, a3);
    if ( result )
      break;
    if ( v4 == (HWND)v8 )
      return result;
  }
  return (BOOL)v4;
}


// ========== Function: ?IsLabelControl@COccManager@@SAHPAVCWnd@@@Z @ 0x40BE4C ==========
BOOL __cdecl COccManager::IsLabelControl(struct CWnd *a1)
{
  int v1; // eax
  BOOL result; // eax

  result = 0;
  if ( sub_420619(a1) )
  {
    v1 = *((_DWORD *)a1 + 14);
    if ( v1 )
    {
      if ( (*(_BYTE *)(v1 + 113) & 0x20) != 0 )
        return 1;
    }
  }
  return result;
}


// ========== Function: sub_40BE72 @ 0x40BE72 ==========
HWND *__stdcall sub_40BE72(int a1, HWND *a2, struct tagMSG *a3)
{
  HWND *v4; // ebx
  struct CWnd *v5; // eax
  HWND NextDlgTabItem; // eax
  int v8; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v8 = 0;
  while ( 1 )
  {
    v5 = (struct CWnd *)sub_40BDC7(a1, (struct CWnd *)a2, a3);
    a2 = (HWND *)v5;
    if ( !v5 )
      return 0;
    if ( COccManager::IsLabelControl(v5) )
    {
      NextDlgTabItem = GetNextDlgTabItem(*(HWND *)(a1 + 28), a2[7], 0);
      a2 = (HWND *)sub_41D866(NextDlgTabItem);
      if ( !a2 )
        return 0;
    }
    if ( sub_420619(a2) )
      break;
    if ( a2 != v4 )
    {
      if ( !v4 )
        v4 = a2;
      if ( ++v8 < 512 )
        continue;
    }
    return 0;
  }
  return a2;
}


// ========== Function: ?UIActivateControl@COccManager@@KAXPAVCWnd@@@Z @ 0x40BEE7 ==========
void __cdecl COccManager::UIActivateControl(struct CWnd *a1)
{
  struct CWnd *v1; // eax
  int v2; // esi
  int v3; // edi
  HWND Parent; // eax
  HWND Focus; // eax

  if ( a1 )
  {
    v1 = a1;
    v2 = 0;
    do
    {
      v3 = *((_DWORD *)v1 + 13);
      if ( v3 )
        break;
      v2 = *((_DWORD *)v1 + 14);
      if ( v2 )
        break;
      Parent = GetParent(*((HWND *)v1 + 7));
      v1 = (struct CWnd *)sub_41D866(Parent);
    }
    while ( v1 );
    if ( v1 && !v3 )
    {
      (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 172))(v2);
      Focus = GetFocus();
      if ( (struct CWnd *)sub_41D866(Focus) != a1 )
        sub_42065B(a1);
    }
  }
}


// ========== Function: sub_40BF44 @ 0x40BF44 ==========
void __cdecl sub_40BF44(int a1, int a2)
{
  HWND i; // eax
  int v3; // eax
  _DWORD *v4; // edi
  int v5; // eax
  int v6; // eax

  if ( a1 && IsWindow(*(HWND *)(a1 + 28)) )
  {
    for ( i = GetParent(*(HWND *)(a1 + 28)); ; i = GetParent(*(HWND *)(v3 + 28)) )
    {
      v3 = sub_41D866(i);
      if ( !v3 )
        break;
      v4 = *(_DWORD **)(v3 + 52);
      if ( v4 )
      {
        v5 = v4[18];
        if ( v5 )
        {
          v6 = sub_41D866(*(void **)(v5 + 32));
          if ( v6 )
          {
            if ( a2 != v6 && (!a2 || !IsChild(*(HWND *)(v6 + 28), *(HWND *)(a2 + 28))) )
              (*(void (__thiscall **)(_DWORD *, _DWORD))(*v4 + 92))(v4, 0);
          }
        }
        return;
      }
    }
  }
}


// ========== Function: sub_40BFB7 @ 0x40BFB7 ==========
int __stdcall sub_40BFB7(int a1, int nIDDlgItem)
{
  int result; // eax
  int v3; // eax
  int v4; // edi
  int v5; // esi
  int i; // ecx
  int v7; // eax

  result = sub_420432(nIDDlgItem);
  if ( !result )
  {
    v3 = sub_40BCCC(a1, 0, 1);
    v4 = v3;
    if ( v3 == a1 )
    {
      return 0;
    }
    else
    {
      v5 = v3;
      for ( i = v3; sub_420547(i) != nIDDlgItem; i = v7 )
      {
        v7 = sub_40BCCC(a1, v5, 1);
        v5 = v7;
        if ( !v7 || v7 == v4 )
          return 0;
      }
      return v5;
    }
  }
  return result;
}


// ========== Function: sub_40C00E @ 0x40C00E ==========
void __cdecl sub_40C00E(struct CWnd *a1, int a2)
{
  int v2; // ecx

  v2 = *((_DWORD *)a1 + 14);
  if ( v2 )
  {
    sub_407A1F(v2, a2);
  }
  else if ( (_AfxGetDlgCode((HWND *)a1, 0) & (a2 != 0 ? 32 : 16)) != 0 )
  {
    SendMessageA(*((HWND *)a1 + 7), 0xF4u, a2 != 0, 1);
  }
}


// ========== Function: sub_40C05B @ 0x40C05B ==========
struct CWnd *__cdecl sub_40C05B(struct CWnd *a1)
{
  int v1; // eax
  struct CWnd *result; // eax
  int v3; // ecx

  result = a1;
  if ( a1 )
  {
    v3 = *((_DWORD *)a1 + 14);
    if ( v3 )
    {
      if ( (*(_BYTE *)(v3 + 113) & 0x10) != 0 )
      {
        v1 = -((*(_DWORD *)(v3 + 108) & 1) != 0);
        LOBYTE(v1) = v1 & 0xF0;
        return (struct CWnd *)(v1 + 32);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return (struct CWnd *)(_AfxGetDlgCode((HWND *)a1, 0) & 0x30);
    }
  }
  return result;
}


// ========== Function: ?_AfxRemoveDefaultButton@@YGXPAVCWnd@@0@Z @ 0x40C07C ==========
void __stdcall _AfxRemoveDefaultButton(struct CWnd *a1, HWND *a2)
{
  int v2; // eax
  int v3; // edi
  struct CWnd *v4; // esi
  int v5; // eax

  if ( !a2 || (GetWindowLongA(a2[7], -20) & 0x10000) != 0 )
    v2 = sub_40BCCC((int)a1, 0, 3);
  else
    v2 = sub_40BC73((int)a1, (int)a2);
  v3 = v2;
  if ( v2 )
  {
    v4 = (struct CWnd *)v2;
    do
    {
      sub_40C00E(v4, 0);
      v5 = sub_40BCCC((int)a1, (int)v4, 0);
      v4 = (struct CWnd *)v5;
    }
    while ( v5 && v5 != v3 );
  }
}


// ========== Function: sub_40C0DE @ 0x40C0DE ==========
LRESULT __stdcall sub_40C0DE(int a1)
{
  LRESULT result; // eax

  result = SendMessageA(*(HWND *)(a1 + 28), 0x400u, 0, 0);
  if ( HIWORD(result) == 21323 )
    return (unsigned __int16)result;
  else
    return 1;
}


// ========== Function: sub_40C10B @ 0x40C10B ==========
void __stdcall sub_40C10B(HWND *a1, struct CWnd *a2, struct CWnd *a3)
{
  HWND v3; // eax
  LRESULT v4; // eax
  struct CWnd *v5; // eax
  HWND *v6; // esi
  LRESULT v7; // eax
  struct CWnd *v8; // esi
  struct CWnd *v9; // [esp+Ch] [ebp-4h]

  v9 = 0;
  if ( a3 )
    v3 = (HWND)*((_DWORD *)a3 + 7);
  else
    v3 = 0;
  if ( IsChild(a1[7], v3) )
  {
    if ( a3 )
    {
      if ( (GetWindowLongA(*((HWND *)a3 + 7), -20) & 0x10000) != 0 )
        return;
      v9 = sub_40C05B(a3);
    }
    if ( a2 == a3 )
    {
      if ( ((unsigned __int8)v9 & 0x20) == 0 )
        return;
      if ( !a2 )
        goto LABEL_21;
      v4 = sub_40C0DE((int)a1);
      v5 = (struct CWnd *)sub_40BFB7((int)a1, v4);
      v6 = (HWND *)v5;
      if ( !v5 || v5 == a3 || ((unsigned __int8)sub_40C05B(v5) & 0x10) == 0 )
        goto LABEL_21;
      _AfxRemoveDefaultButton((struct CWnd *)a1, v6);
    }
    else if ( a2 && sub_40C05B(a2) || a3 && v9 )
    {
      _AfxRemoveDefaultButton((struct CWnd *)a1, (HWND *)a3);
    }
    if ( ((unsigned __int8)v9 & 0x30) != 0 )
    {
LABEL_21:
      sub_40C00E(a3, 1);
      return;
    }
    v7 = sub_40C0DE((int)a1);
    v8 = (struct CWnd *)sub_40BFB7((int)a1, v7);
    if ( ((unsigned __int8)sub_40C05B(v8) & 0x20) != 0 )
    {
      if ( sub_420619(v8) )
        sub_40C00E(v8, 1);
    }
  }
}


// ========== Function: sub_40C1F8 @ 0x40C1F8 ==========
BOOL __stdcall sub_40C1F8(struct CWnd *a1, LPMSG lpMsg)
{
  HWND Focus; // eax
  HWND v3; // eax
  UINT v4; // ebx
  HWND v5; // esi
  HWND Parent; // eax
  HWND v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // esi
  __int16 wParam; // ax
  HWND v13; // edi
  HWND v14; // esi
  int v15; // ebx
  LPMSG v16; // esi
  char v17; // al
  __int16 v18; // cx
  HWND *v19; // eax
  _BYTE *v20; // eax
  char DlgCode; // al
  unsigned int wParam_low; // ecx
  BOOL v23; // edi
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  struct CWnd *v27; // eax
  HWND v28; // eax
  int v29; // eax
  HWND v30; // eax
  struct CWnd *v31; // eax
  BOOL v32; // eax
  HWND NextDlgTabItem; // eax
  HWND *v34; // eax
  int v35; // esi
  LRESULT v36; // eax
  HWND v37; // eax
  HWND NextDlgGroupItem; // eax
  int v39; // eax
  int v40; // [esp+0h] [ebp-30h] BYREF
  HWND v41; // [esp+Ch] [ebp-24h]
  HWND hWnd; // [esp+10h] [ebp-20h]
  BOOL bPrevious; // [esp+14h] [ebp-1Ch]
  UINT message; // [esp+18h] [ebp-18h]
  HWND hCtl; // [esp+1Ch] [ebp-14h]
  int *v46; // [esp+20h] [ebp-10h]
  int v47; // [esp+2Ch] [ebp-4h]

  v46 = &v40;
  Focus = GetFocus();
  v3 = (HWND)sub_41D866(Focus);
  hCtl = v3;
  if ( v3 )
    hWnd = (HWND)*((_DWORD *)v3 + 7);
  else
    hWnd = 0;
  if ( a1 )
    v41 = (HWND)*((_DWORD *)a1 + 7);
  else
    v41 = 0;
  message = lpMsg->message;
  v4 = message;
  if ( message >= 0x100 && message <= 0x108 || message >= 0x200 && message <= 0x209 )
  {
    v5 = v3;
    if ( v3 )
    {
      do
      {
        if ( *((_DWORD *)v5 + 14) )
          break;
        Parent = GetParent(*((HWND *)v5 + 7));
        if ( (struct CWnd *)sub_41D866(Parent) == a1 )
          break;
        v7 = GetParent(*((HWND *)v5 + 7));
        v5 = (HWND)sub_41D866(v7);
      }
      while ( v5 );
      if ( v5 )
      {
        v8 = *((_DWORD *)v5 + 14);
        if ( v8 )
        {
          v9 = *(_DWORD *)(v8 + 84);
          if ( v9 )
          {
            if ( !(*(int (__stdcall **)(int, LPMSG))(*(_DWORD *)v9 + 20))(v9, lpMsg) )
              return 1;
          }
        }
      }
    }
    if ( v4 == 257 || v4 == 256 || v4 == 258 )
    {
      if ( v5 )
      {
        v10 = *((_DWORD *)v5 + 14);
        if ( v10 )
        {
          wParam = lpMsg->wParam;
          if ( wParam == 13 && (*(_BYTE *)(v10 + 128) & 1) != 0 )
            return 0;
          if ( wParam == 27 && (*(_BYTE *)(v10 + 128) & 2) != 0 )
            return 0;
        }
      }
    }
  }
  v13 = (HWND)sub_41D866(lpMsg->hwnd);
  v14 = 0;
  bPrevious = 0;
  v15 = 2;
  if ( message == 256 )
  {
    DlgCode = _AfxGetDlgCode((HWND *)v13, (LPARAM)lpMsg);
    wParam_low = LOWORD(lpMsg->wParam);
    if ( wParam_low <= 0x1B )
    {
      if ( wParam_low == 27 || wParam_low == 3 )
        goto LABEL_72;
      if ( wParam_low == 9 )
      {
        if ( (DlgCode & 2) == 0 )
        {
          v32 = GetKeyState(16) < 0;
          if ( v13 )
            v13 = (HWND)*((_DWORD *)v13 + 7);
          NextDlgTabItem = GetNextDlgTabItem(*((HWND *)a1 + 7), v13, v32);
          v34 = (HWND *)sub_41D866(NextDlgTabItem);
          v35 = (int)v34;
          if ( v34 )
          {
            _AfxDlgSetFocus(v34);
            sub_40BF44((int)hCtl, v35);
          }
          goto LABEL_77;
        }
        goto LABEL_52;
      }
      if ( wParam_low != 13 )
        goto LABEL_52;
LABEL_68:
      if ( ((unsigned __int8)sub_40C05B((struct CWnd *)hCtl) & 0x10) != 0 )
      {
        v14 = hCtl;
        v36 = sub_420547(hCtl);
      }
      else
      {
        v36 = sub_40C0DE((int)a1);
      }
      v15 = v36;
      if ( v14 )
      {
LABEL_73:
        if ( sub_420619(v14) )
        {
          if ( *((_DWORD *)v14 + 14) )
          {
            v47 = 0;
            sub_42067C(v14, -551, 1, 0, 0, 0);
            v47 = -1;
            goto LABEL_77;
          }
        }
        else
        {
          MessageBeep(0);
        }
        goto LABEL_52;
      }
LABEL_72:
      v14 = (HWND)sub_40BFB7((int)a1, v15);
      if ( !v14 )
        goto LABEL_52;
      goto LABEL_73;
    }
    if ( LOWORD(lpMsg->wParam) < 0x25u )
      goto LABEL_52;
    if ( LOWORD(lpMsg->wParam) <= 0x26u )
    {
      bPrevious = 1;
    }
    else if ( LOWORD(lpMsg->wParam) > 0x28u )
    {
      if ( wParam_low != 43 )
        goto LABEL_52;
      goto LABEL_68;
    }
    if ( (_AfxGetDlgCode((HWND *)hCtl, (LPARAM)lpMsg) & 1) == 0 )
    {
      v37 = hCtl;
      if ( hCtl )
        v37 = (HWND)*((_DWORD *)hCtl + 7);
      NextDlgGroupItem = GetNextDlgGroupItem(*((HWND *)a1 + 7), v37, bPrevious);
      v39 = sub_41D866(NextDlgGroupItem);
      if ( v39 )
      {
        if ( *(_DWORD *)(v39 + 56) )
        {
          _AfxDlgSetFocus((HWND *)v39);
          goto LABEL_77;
        }
      }
    }
    goto LABEL_52;
  }
  if ( message == 258 )
  {
    v16 = lpMsg;
    goto LABEL_37;
  }
  if ( message != 262 || !hCtl && GetKeyState(18) >= 0 || (v16 = lpMsg, LOWORD(lpMsg->wParam) == 32) )
  {
LABEL_52:
    v23 = IsDialogMessageA(*((HWND *)a1 + 7), lpMsg);
    if ( v23 )
    {
      v24 = GetFocus();
      v25 = (HWND)sub_41D866(v24);
      if ( v25 != hCtl )
      {
        v26 = GetFocus();
        v27 = (struct CWnd *)sub_41D866(v26);
        COccManager::UIActivateControl(v27);
      }
    }
    goto LABEL_55;
  }
LABEL_37:
  if ( v13 == (HWND)a1 )
    return 1;
  v17 = _AfxGetDlgCode((HWND *)v13, (LPARAM)v16);
  if ( message == 258 && (v17 & 0x84) != 0 )
    goto LABEL_52;
  v18 = v16->wParam;
  if ( v18 == 9 && (v17 & 2) != 0 )
    goto LABEL_52;
  if ( v18 == 32 )
    return 1;
  v19 = sub_40BE72((int)a1, (HWND *)v13, v16);
  if ( !v19 )
    goto LABEL_52;
  v20 = v19[14];
  if ( !v20 )
    goto LABEL_52;
  sub_407DA0(v20, (int)v16);
LABEL_77:
  v23 = 1;
LABEL_55:
  if ( IsWindow(hWnd) )
  {
    v28 = GetFocus();
    v29 = sub_41D866(v28);
    sub_40BF44((int)hCtl, v29);
    if ( IsWindow(v41) )
    {
      v30 = GetFocus();
      v31 = (struct CWnd *)sub_41D866(v30);
      sub_40C10B((HWND *)a1, (struct CWnd *)hCtl, v31);
    }
  }
  return v23;
}


// ========== Function: ?CheckError@@YGXJ@Z @ 0x40C5E3 ==========
void __stdcall CheckError(CHAR *lpString1)
{
  if ( (int)lpString1 < 0 )
  {
    if ( lpString1 == (CHAR *)-2147024882 )
      sub_41B4F7();
    AfxThrowOleException(lpString1);
  }
}


// ========== Function: sub_40C602 @ 0x40C602 ==========
// ??0COleVariant@@QAE@ABUtagVARIANT@@@Z
// doubtful name
struct tagVARIANT *__thiscall sub_40C602(struct tagVARIANT *this, VARIANTARG *pvargSrc)
{
  CHAR *v3; // eax

  AfxVariantInit(this);
  v3 = (CHAR *)VariantCopy(this, pvargSrc);
  CheckError(v3);
  return this;
}


// ========== Function: sub_40C622 @ 0x40C622 ==========
_DWORD *__thiscall sub_40C622(_DWORD *this, LPCSTR lpString, __int16 a3)
{
  UINT v4; // eax
  BSTR v5; // eax
  int v6; // esi
  int v7; // eax
  void *v8; // esp
  WCHAR v10[6]; // [esp+0h] [ebp-Ch] BYREF

  this[2] = 0;
  *(_WORD *)this = 8;
  if ( lpString )
  {
    if ( a3 == 14 )
    {
      v4 = lstrlenA(lpString);
      v5 = SysAllocStringByteLen(lpString, v4);
    }
    else
    {
      v6 = lstrlenA(lpString) + 1;
      v7 = 2 * v6 + 3;
      LOBYTE(v7) = v7 & 0xFC;
      v8 = alloca(v7);
      v10[0] = 0;
      MultiByteToWideChar(0, 0, lpString, -1, v10, v6);
      v5 = SysAllocString(v10);
    }
    this[2] = v5;
    if ( !v5 )
      sub_41B4F7();
  }
  return this;
}


// ========== Function: ??0COleVariant@@QAE@FG@Z @ 0x40C69D ==========
COleVariant *__thiscall COleVariant::COleVariant(COleVariant *this, __int16 a2, unsigned __int16 a3)
{
  COleVariant *result; // eax

  result = this;
  if ( a3 == 11 )
  {
    *(_WORD *)this = 11;
    if ( a2 )
      *((_WORD *)this + 4) = -1;
    else
      *((_WORD *)this + 4) = 0;
  }
  else
  {
    *(_WORD *)this = 2;
    *((_WORD *)this + 4) = a2;
  }
  return result;
}


// ========== Function: ??0COleVariant@@QAE@JG@Z @ 0x40C6D3 ==========
COleVariant *__thiscall COleVariant::COleVariant(COleVariant *this, int a2, unsigned __int16 a3)
{
  COleVariant *result; // eax

  result = this;
  if ( a3 == 10 )
  {
    *(_WORD *)this = 10;
LABEL_8:
    *((_DWORD *)this + 2) = a2;
    return result;
  }
  if ( a3 != 11 )
  {
    *(_WORD *)this = 3;
    goto LABEL_8;
  }
  *(_WORD *)this = 11;
  if ( a2 )
    *((_WORD *)this + 4) = -1;
  else
    *((_WORD *)this + 4) = 0;
  return result;
}


// ========== Function: ?ChangeType@COleVariant@@QAEXGPAUtagVARIANT@@@Z @ 0x40C715 ==========
void __thiscall COleVariant::ChangeType(VARIANTARG *pvargDest, VARTYPE vt, VARIANTARG *pvarSrc)
{
  VARIANTARG *v3; // edx
  CHAR *v4; // eax

  v3 = pvarSrc;
  if ( !pvarSrc )
    v3 = pvargDest;
  if ( v3 != pvargDest || vt != pvargDest->vt )
  {
    v4 = (CHAR *)VariantChangeType(pvargDest, v3, 0, vt);
    CheckError(v4);
  }
}


// ========== Function: sub_40C740 @ 0x40C740 ==========
// ??4COleSafeArray@@QAEAAV0@ABV0@@Z
// doubtful name
VARIANTARG *__thiscall sub_40C740(VARIANTARG *pvargDest, VARIANTARG *pvargSrc)
{
  CHAR *v3; // eax

  v3 = (CHAR *)VariantCopy(pvargDest, pvargSrc);
  CheckError(v3);
  return pvargDest;
}


// ========== Function: ?AfxVariantInit@@YGXPAUtagVARIANT@@@Z @ 0x40C75A ==========
void __stdcall AfxVariantInit(struct tagVARIANT *a1)
{
  memset(a1, 0, sizeof(struct tagVARIANT));
}


// ========== Function: sub_40C76D @ 0x40C76D ==========
int __stdcall sub_40C76D(
        unsigned __int16 a1,
        unsigned __int16 a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int16 a5,
        unsigned __int16 a6,
        double *a7)
{
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  double v10; // st7
  int v12; // [esp+Ch] [ebp-4h]

  if ( a1 > 0x270Fu || !a2 || a2 > 0xCu )
    return 0;
  if ( (a1 & 3) != 0 || !(a1 % 100) && a1 % 400 )
  {
    v12 = 0;
  }
  else
  {
    v12 = 1;
    if ( a3 == 29 && a2 == 2 )
    {
      v7 = 1;
      goto LABEL_12;
    }
  }
  v7 = 0;
  if ( !a3 )
    return 0;
LABEL_12:
  v8 = dword_433F54[a2];
  if ( a3 > dword_433F58[a2] + v7 - v8 || a4 > 0x17u || a5 > 0x3Bu || a6 > 0x3Bu )
    return 0;
  v9 = v8 + a3 + 365 * a1 + a1 / 400 + (a1 >> 2) - a1 / 100;
  if ( a2 <= 2u && v12 )
    --v9;
  v10 = (double)(a6 + 60 * (a5 + 60 * a4)) * 0.00001157407407407407;
  if ( v9 - 693959 < 0 )
    v10 = -v10;
  *a7 = (double)(v9 - 693959) + v10;
  return 1;
}


// ========== Function: sub_40C8AA @ 0x40C8AA ==========
BOOL __thiscall sub_40C8AA(
        int this,
        unsigned __int16 a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int16 a5,
        unsigned __int16 a6,
        unsigned __int16 a7)
{
  BOOL result; // eax

  result = sub_40C76D(a2, a3, a4, a5, a6, a7, (double *)this) == 0;
  *(_DWORD *)(this + 8) = result;
  return result;
}


// ========== Function: sub_40C8D5 @ 0x40C8D5 ==========
LPVOID __thiscall sub_40C8D5(LPVOID lpMem, char a2)
{
  sub_40C8F1();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_40C8F1 @ 0x40C8F1 ==========
void __thiscall sub_40C8F1(_DWORD *this)
{
  *this = &COleException::`vftable';
}


// ========== Function: ?AfxOleUnlockAllControls@@YGXXZ @ 0x40C8F8 ==========
void __stdcall AfxOleUnlockAllControls()
{
  struct AFX_MODULE_STATE *ModuleState; // esi
  _DWORD *v1; // edi
  void (__thiscall ***v2)(_DWORD, int); // esi

  ModuleState = AfxGetModuleState();
  sub_4250E4(11);
  v1 = (_DWORD *)((char *)ModuleState + 4156);
  while ( 1 )
  {
    v2 = (void (__thiscall ***)(_DWORD, int))*v1;
    if ( !*v1 )
      break;
    sub_424938(*v1);
    (**v2)(v2, 1);
  }
  AfxUnlockGlobals(11);
}


// ========== Function: __onexit @ 0x40C934 ==========
_onexit_t __cdecl _onexit(_onexit_t Func)
{
  unsigned int v1; // eax
  _onexit_t *v2; // ecx
  int v3; // eax
  char *v4; // eax
  int (__cdecl *v5)(); // esi
  int v6; // ecx

  _lockexit();
  v1 = sub_40F381(dword_43AAF4);
  v2 = (_onexit_t *)dword_43AAF0;
  if ( v1 >= dword_43AAF0 - (int)dword_43AAF4 + 4 )
    goto LABEL_5;
  v3 = sub_40F381(dword_43AAF4);
  v4 = (char *)sub_40F8ED((LPVOID)dword_43AAF4, v3 + 16);
  if ( v4 )
  {
    v6 = dword_43AAF0 - (_DWORD)dword_43AAF4;
    dword_43AAF4 = v4;
    v2 = (_onexit_t *)&v4[4 * (v6 >> 2)];
    dword_43AAF0 = (int)v2;
LABEL_5:
    *v2 = Func;
    dword_43AAF0 += 4;
    v5 = Func;
    goto LABEL_6;
  }
  v5 = 0;
LABEL_6:
  _unlockexit();
  return v5;
}


// ========== Function: _atexit @ 0x40C9B2 ==========
int __cdecl atexit(void (__cdecl *Func)())
{
  return (_onexit((_onexit_t)Func) != 0) - 1;
}


// ========== Function: ___onexitinit @ 0x40C9C4 ==========
LPCVOID __onexitinit()
{
  _DWORD *v0; // eax
  LPCVOID result; // eax

  v0 = malloc(0x80u);
  dword_43AAF4 = v0;
  if ( !v0 )
    _amsg_exit(0x18u);
  *v0 = 0;
  result = dword_43AAF4;
  dword_43AAF0 = (int)dword_43AAF4;
  return result;
}


// ========== Function: ??_M@YGXPAXIHP6EX0@Z@Z @ 0x40C9F3 ==========
void __stdcall `eh vector destructor iterator'(char *a1, unsigned int a2, int a3, void (__thiscall *a4)(void *))
{
  char *i; // [esp+30h] [ebp+8h]

  for ( i = &a1[a3 * a2]; --a3 >= 0; a4(i) )
    i -= a2;
}


// ========== Function: ?__ArrayUnwind@@YGXPAXIHP6EX0@Z@Z @ 0x40CA73 ==========
void __stdcall __ArrayUnwind(char *a1, unsigned int a2, int a3, void (*a4)(void))
{
  while ( --a3 >= 0 )
  {
    a1 -= a2;
    a4();
  }
}


// ========== Function: unknown_libname_3 @ 0x40CAD1 ==========
// Microsoft VisualC 2-14/net runtime
int __cdecl unknown_libname_3(_DWORD **a1)
{
  if ( **a1 == -529697949 )
    terminate();
  return 0;
}


// ========== Function: ?_JumpToContinuation@@YGXPAXPAUEHRegistrationNode@@@Z @ 0x40CAE7 ==========
void __stdcall _JumpToContinuation(
        void (__stdcall *a1)(void *, struct EHRegistrationNode *),
        struct EHRegistrationNode *a2)
{
  a1(a1, a2);
}


// ========== Function: sub_40CB1B @ 0x40CB1B ==========
// ?_CallMemberFunction0@@YGXPAX0@Z
// doubtful name
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_40CB1B(int a1, int a2)
{
  __int32 v3; // [esp-8h] [ebp-8h]
  _UNKNOWN *retaddr; // [esp+0h] [ebp+0h] BYREF

  return ((int (*)(void))_InterlockedExchange((volatile __int32 *)&retaddr, v3))();
}


// ========== Function: sub_40CB22 @ 0x40CB22 ==========
// ?_CallMemberFunction0@@YGXPAX0@Z
// doubtful name
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_40CB22(int a1, int a2)
{
  __int32 v3; // [esp-8h] [ebp-8h]
  _UNKNOWN *retaddr; // [esp+0h] [ebp+0h] BYREF

  return ((int (*)(void))_InterlockedExchange((volatile __int32 *)&retaddr, v3))();
}


// ========== Function: ?_UnwindNestedFrames@@YGXPAUEHRegistrationNode@@PAUEHExceptionRecord@@@Z @ 0x40CB29 ==========
void __userpurge _UnwindNestedFrames(
        struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>,
        PVOID TargetFrame,
        PEXCEPTION_RECORD ExceptionRecord)
{
  DWORD ExceptionFlags; // eax

  RtlUnwind(TargetFrame, &_ReturnPoint_16567, ExceptionRecord, 0);
  ExceptionFlags = ExceptionRecord->ExceptionFlags;
  LOBYTE(ExceptionFlags) = ExceptionFlags & 0xFD;
  ExceptionRecord->ExceptionFlags = ExceptionFlags;
  *a1 = NtCurrentTeb()->NtTib.ExceptionList;
}


// ========== Function: ___CxxFrameHandler @ 0x40CB78 ==========
int __usercall __CxxFrameHandler@<eax>(
        struct _s_FuncInfo *a1@<eax>,
        struct EHExceptionRecord *a2,
        struct EHRegistrationNode *a3,
        struct _CONTEXT *a4,
        void *a5)
{
  return __InternalCxxFrameHandler(a2, a3, a4, a5, a1, 0, 0, 0);
}


// ========== Function: ?_CallCatchBlock2@@YAPAXPAUEHRegistrationNode@@PBU_s_FuncInfo@@PAXHK@Z @ 0x40CBAE ==========
void *__cdecl _CallCatchBlock2(
        struct EHRegistrationNode *a1,
        const struct _s_FuncInfo *a2,
        void *a3,
        int a4,
        unsigned int a5)
{
  return (void *)_CallSettingFrame(a3, a1, a5);
}


// ========== Function: ?CatchGuardHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAUEHExceptionRecord@@PAUCatchGuardRN@@PAX2@Z @ 0x40CC02 ==========
enum _EXCEPTION_DISPOSITION __cdecl CatchGuardHandler(
        struct EHExceptionRecord *a1,
        struct CatchGuardRN *a2,
        struct _CONTEXT *a3)
{
  return __InternalCxxFrameHandler(
           a1,
           *((struct EHRegistrationNode **)a2 + 3),
           a3,
           0,
           *((struct _s_FuncInfo **)a2 + 2),
           *((_DWORD *)a2 + 4),
           (struct EHRegistrationNode *)a2,
           0);
}


// ========== Function: ?_CallSETranslator@@YAHPAUEHExceptionRecord@@PAUEHRegistrationNode@@PAX2PBU_s_FuncInfo@@H1@Z @ 0x40CC27 ==========
int __cdecl _CallSETranslator(
        struct EHExceptionRecord *a1,
        struct EHRegistrationNode *a2,
        void *a3,
        void *a4,
        const struct _s_FuncInfo *a5,
        int a6,
        struct EHRegistrationNode *a7)
{
  int v7; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ebx
  int v10; // [esp+0h] [ebp-40h] BYREF
  int v11; // [esp+Ch] [ebp-34h]
  _DWORD v12[11]; // [esp+10h] [ebp-30h] BYREF
  int v13; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v12[3] = TranslatorGuardHandler;
  v12[4] = a5;
  v12[5] = a2;
  v12[6] = a6;
  v12[7] = a7;
  v13 = 0;
  v12[8] = &_ExceptionContinuation_16750;
  v12[9] = &v10;
  v12[10] = &savedregs;
  v12[2] = NtCurrentTeb()->NtTib.ExceptionList;
  v11 = 1;
  v12[0] = a1;
  v12[1] = a3;
  v7 = _getptd(a1->ExceptionCode, v12);
  (*(void (**)(void))(v7 + 104))();
  v11 = 0;
  if ( v13 )
  {
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    ExceptionList->Next = ExceptionList->Next;
  }
  return v11;
}


// ========== Function: ?TranslatorGuardHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAUEHExceptionRecord@@PAUTranslatorGuardRN@@PAX2@Z @ 0x40CCDD ==========
int __usercall TranslatorGuardHandler@<eax>(
        struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>,
        struct EHExceptionRecord *ExceptionRecord,
        PVOID TargetFrame,
        struct _CONTEXT *a4)
{
  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )
  {
    *((_DWORD *)TargetFrame + 9) = 1;
    return 1;
  }
  else
  {
    __InternalCxxFrameHandler(
      ExceptionRecord,
      *((struct EHRegistrationNode **)TargetFrame + 3),
      a4,
      0,
      *((struct _s_FuncInfo **)TargetFrame + 2),
      *((_DWORD *)TargetFrame + 4),
      *((struct EHRegistrationNode **)TargetFrame + 5),
      1);
    if ( !*((_DWORD *)TargetFrame + 9) )
      _UnwindNestedFrames(a1, TargetFrame, (PEXCEPTION_RECORD)ExceptionRecord);
    return (*((int (**)(void))TargetFrame + 6))();
  }
}


// ========== Function: ?_GetRangeOfTrysToCheck@@YAPBU_s_TryBlockMapEntry@@PBU_s_FuncInfo@@HHPAI1@Z @ 0x40CD52 ==========
TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(
        const struct _s_FuncInfo *a1,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int *a5)
{
  unsigned int nTryBlocks; // esi
  TryBlockMapEntry *pTryBlockMap; // ebx
  unsigned int v8; // eax
  unsigned int v9; // esi
  unsigned int v11; // [esp+Ch] [ebp-4h]
  const struct _s_FuncInfo *v12; // [esp+18h] [ebp+8h]

  nTryBlocks = a1->nTryBlocks;
  pTryBlockMap = a1->pTryBlockMap;
  v8 = nTryBlocks;
  v12 = (const struct _s_FuncInfo *)nTryBlocks;
  v11 = nTryBlocks;
  if ( a2 >= 0 )
  {
    do
    {
      if ( nTryBlocks == -1 )
        sub_4101B9();
      if ( pTryBlockMap[--nTryBlocks].tryHigh < a3 && a3 <= pTryBlockMap[nTryBlocks].catchHigh || nTryBlocks == -1 )
      {
        --a2;
        v11 = (unsigned int)v12;
        v12 = (const struct _s_FuncInfo *)nTryBlocks;
      }
    }
    while ( a2 >= 0 );
    v8 = v11;
  }
  v9 = nTryBlocks + 1;
  *a4 = v9;
  *a5 = v8;
  if ( v8 > a1->nTryBlocks || v9 > v8 )
    sub_4101B9();
  return &pTryBlockMap[v9];
}


// ========== Function: __global_unwind2 @ 0x40CDD0 ==========
void __cdecl _global_unwind2(PVOID TargetFrame)
{
  RtlUnwind(TargetFrame, &gu_return, 0, 0);
}


// ========== Function: __unwind_handler @ 0x40CDF0 ==========
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    return 3;
  }
  return result;
}


// ========== Function: __local_unwind2 @ 0x40CE12 ==========
int __cdecl _local_unwind2(int a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v7)(int, int, int, _DWORD *); // [esp-4h] [ebp-18h]

  v7 = _unwind_handler;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  while ( 1 )
  {
    result = a1;
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 == -1 || v4 == a2 )
      break;
    v5 = 3 * v4;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(v3 + 4 * v5);
    if ( !*(_DWORD *)(v3 + 4 * v5 + 4) )
    {
      _NLG_Notify(257);
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, int, int, _DWORD *)))(v3 + 4 * v5 + 8))(
        ExceptionList,
        v7);
    }
  }
  return result;
}


// ========== Function: __abnormal_termination @ 0x40CE7A ==========
int __cdecl _abnormal_termination()
{
  int result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx

  result = 0;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  if ( (int (__cdecl *)(int, int, int, _DWORD *))ExceptionList->Handler == _unwind_handler )
    return ExceptionList[1].Next == (struct _EXCEPTION_REGISTRATION_RECORD *)*((_DWORD *)ExceptionList[1].Handler + 3);
  return result;
}


// ========== Function: __NLG_Notify1 @ 0x40CE9D ==========
void __stdcall _NLG_Notify1(int a1)
{
  JUMPOUT(0x40CEB0);
}


// ========== Function: __NLG_Notify @ 0x40CEA6 ==========
int __userpurge _NLG_Notify@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_4340D8[2] = *(_DWORD *)(a2 + 8);
  dword_4340D8[1] = result;
  dword_4340D8[3] = a2;
  return result;
}


// ========== Function: ??_L@YGXPAXIHP6EX0@Z1@Z @ 0x40CEBE ==========
void __stdcall `eh vector constructor iterator'(
        char *a1,
        unsigned int a2,
        int a3,
        void (__thiscall *a4)(void *),
        void (__thiscall *a5)(void *))
{
  int i; // [esp+10h] [ebp-1Ch]

  for ( i = 0; i < a3; ++i )
  {
    a4(a1);
    a1 += a2;
  }
}


// ========== Function: _atol @ 0x40CF40 ==========
int __cdecl atol(const char *String)
{
  int v3; // esi
  const char *v4; // edi
  int v5; // ebp
  int v6; // ebx
  int result; // eax

  while ( cbMultiByte <= 1
        ? *((_BYTE *)off_434474 + 2 * *(unsigned __int8 *)String) & 8
        : _isctype(*(unsigned __int8 *)String, 8) )
    ++String;
  v3 = *(unsigned __int8 *)String;
  v4 = String + 1;
  v5 = v3;
  if ( v3 == 45 || v3 == 43 )
    v3 = *(unsigned __int8 *)v4++;
  v6 = 0;
  while ( cbMultiByte <= 1 ? *((_BYTE *)off_434474 + 2 * v3) & 4 : _isctype(v3, 4) )
  {
    v6 = v3 + 10 * v6 - 48;
    v3 = *(unsigned __int8 *)v4++;
  }
  result = v6;
  if ( v5 == 45 )
    return -v6;
  return result;
}


// ========== Function: _atoi @ 0x40CFCB ==========
int __cdecl atoi(const char *String)
{
  return atol(String);
}


// ========== Function: __mbscmp @ 0x40CFD6 ==========
int __cdecl _mbscmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2)
{
  const unsigned __int8 *v3; // esi
  const unsigned __int8 *v4; // edi
  unsigned __int16 v5; // cx
  unsigned __int8 v6; // al
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // bx
  unsigned __int8 v9; // al
  unsigned __int16 v10; // cx
  unsigned __int16 Str2a; // [esp+18h] [ebp+Ch]

  if ( !dword_43A8DC )
    return strcmp((const char *)Str1, (const char *)Str2);
  _lock(25);
  v3 = Str2;
  v4 = Str1;
  do
  {
    v5 = *v4++;
    Str2a = v5;
    if ( (byte_43A9E1[(unsigned __int8)v5] & 4) != 0 )
    {
      v6 = *v4;
      if ( *v4 )
      {
        ++v4;
        HIBYTE(v7) = v5;
        LOBYTE(v7) = v6;
        Str2a = v7;
      }
      else
      {
        Str2a = 0;
      }
    }
    v8 = *v3++;
    if ( (byte_43A9E1[(unsigned __int8)v8] & 4) != 0 )
    {
      v9 = *v3;
      if ( *v3 )
      {
        ++v3;
        HIBYTE(v10) = v8;
        LOBYTE(v10) = v9;
        v8 = v10;
      }
      else
      {
        v8 = 0;
      }
    }
    if ( Str2a != v8 )
    {
      _unlock(25);
      return v8 < Str2a ? 1 : -1;
    }
  }
  while ( Str2a );
  _unlock(25);
  return 0;
}


// ========== Function: start @ 0x40D085 ==========
void __noreturn start()
{
  DWORD Version; // eax
  int wShowWindow; // eax
  HMODULE ModuleHandleA; // eax
  int v3; // [esp-4h] [ebp-78h]
  CHAR *lpCmdLine; // [esp+10h] [ebp-64h]
  int v5; // [esp+14h] [ebp-60h]
  _STARTUPINFOA StartupInfo; // [esp+18h] [ebp-5Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+5Ch] [ebp-18h]

  Version = GetVersion();
  dword_4393C0 = BYTE1(Version);
  dword_4393BC = (unsigned __int8)Version;
  dword_4393B8 = BYTE1(Version) + ((unsigned __int8)Version << 8);
  dword_4393B4 = HIWORD(Version);
  if ( !sub_41163D(1) )
    fast_error_exit(0x1Cu);
  if ( !_mtinit() )
    fast_error_exit(0x10u);
  ms_exc.registration.TryLevel = 0;
  _ioinit();
  dword_43AAF8 = (int)GetCommandLineA();
  Source = (char *)__crtGetEnvironmentStringsA();
  _setargv();
  _setenvp();
  _cinit();
  StartupInfo.dwFlags = 0;
  GetStartupInfoA(&StartupInfo);
  lpCmdLine = (CHAR *)_wincmdln();
  if ( (StartupInfo.dwFlags & 1) != 0 )
    wShowWindow = StartupInfo.wShowWindow;
  else
    wShowWindow = 10;
  v3 = wShowWindow;
  ModuleHandleA = GetModuleHandleA(0);
  v5 = WinMain(ModuleHandleA, 0, lpCmdLine, v3);
  exit(v5);
}


// ========== Function: __amsg_exit @ 0x40D18D ==========
void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_4393AC == 1 )
    _FF_MSGBANNER();
  sub_4116D3(NumberOfBytesWritten);
  off_4340E8(255);
}


// ========== Function: _fast_error_exit @ 0x40D1B2 ==========
void __cdecl __noreturn fast_error_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_4393AC == 1 )
    _FF_MSGBANNER();
  sub_4116D3(NumberOfBytesWritten);
  ExitProcess(0xFFu);
}


// ========== Function: nullsub_7 @ 0x40D1D5 ==========
void nullsub_7()
{
  ;
}


// ========== Function: ??1type_info@@UAE@XZ @ 0x40D1D6 ==========
void __thiscall type_info::~type_info(type_info *this)
{
  void *v2; // esi

  *(_DWORD *)this = &type_info::`vftable';
  _lock(27);
  v2 = (void *)*((_DWORD *)this + 1);
  if ( v2 )
    sub_40D386(v2);
  _unlock(27);
}


// ========== Function: ??_Gtype_info@@UAEPAXI@Z @ 0x40D1FF ==========
type_info *__thiscall type_info::`scalar deleting destructor'(type_info *this, char a2)
{
  type_info::~type_info(this);
  if ( (a2 & 1) != 0 )
    sub_41CA99(this);
  return this;
}


// ========== Function: __EH_prolog @ 0x40D21C ==========
void _EH_prolog()
{
  __asm { retn }
}


// ========== Function: __strdup @ 0x40D23B ==========
char *__cdecl _strdup(const char *Source)
{
  size_t v1; // eax
  char *v2; // eax

  if ( Source && (v1 = strlen(Source), (v2 = (char *)malloc(v1 + 1)) != 0) )
    return strcpy(v2, Source);
  else
    return 0;
}


// ========== Function: __cinit @ 0x40D266 ==========
void _cinit()
{
  if ( off_434128 )
    off_434128();
  _initterm(&First, &Last);
  _initterm(&dword_433000, &dword_433084);
}


// ========== Function: _exit @ 0x40D293 ==========
void __cdecl __noreturn exit(int Code)
{
  doexit(Code, 0, 0);
}


// ========== Function: __exit @ 0x40D2A4 ==========
void __cdecl __noreturn _exit(int Code)
{
  doexit(Code, 1, 0);
}


// ========== Function: _doexit @ 0x40D2B5 ==========
int __cdecl doexit(UINT uExitCode, int a2, int a3)
{
  HANDLE CurrentProcess; // eax
  void (**v4)(void); // esi

  _lockexit();
  if ( dword_4393F0 == 1 )
  {
    CurrentProcess = GetCurrentProcess();
    TerminateProcess(CurrentProcess, uExitCode);
  }
  dword_4393EC = 1;
  byte_4393E8 = a3;
  if ( !a2 )
  {
    if ( dword_43AAF4 )
    {
      v4 = (void (**)(void))(dword_43AAF0 - 4);
      if ( dword_43AAF0 - 4 >= (unsigned int)dword_43AAF4 )
      {
        do
        {
          if ( *v4 )
            (*v4)();
          --v4;
        }
        while ( v4 >= dword_43AAF4 );
      }
    }
    _initterm(&dword_4330A0, &dword_4330A8);
  }
  _initterm(&dword_4330AC, &dword_4330B4);
  if ( !a3 )
  {
    dword_4393F0 = 1;
    ExitProcess(uExitCode);
  }
  return _unlockexit();
}


// ========== Function: __lockexit @ 0x40D35A ==========
int _lockexit()
{
  return _lock(13);
}


// ========== Function: __unlockexit @ 0x40D363 ==========
int _unlockexit()
{
  return _unlock(13);
}


// ========== Function: __initterm @ 0x40D36C ==========
void __cdecl _initterm(_PVFV *First, _PVFV *Last)
{
  while ( First < Last )
  {
    if ( *First )
      (*First)();
    ++First;
  }
}


// ========== Function: sub_40D386 @ 0x40D386 ==========
void __cdecl sub_40D386(LPVOID lpMem)
{
  int block; // eax
  bool v2; // zf
  int v3; // eax
  int v4; // [esp+Ch] [ebp-28h] BYREF
  int v5; // [esp+10h] [ebp-24h]
  int v6; // [esp+14h] [ebp-20h] BYREF
  int v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  if ( lpMem )
  {
    if ( dword_43A7A4 == 3 )
    {
      _lock(9);
      ms_exc.registration.TryLevel = 0;
      block = __sbh_find_block(lpMem);
      v7 = block;
      if ( block )
        sub_411993(block, lpMem);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v7 == 0;
    }
    else
    {
      if ( dword_43A7A4 != 2 )
      {
LABEL_11:
        HeapFree(hHeap, 0, lpMem);
        return;
      }
      _lock(9);
      ms_exc.registration.TryLevel = 1;
      v3 = sub_4126C3(lpMem, &v4, &v6);
      v5 = v3;
      if ( v3 )
        sub_41271A(v4, v6, v3);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v5 == 0;
    }
    if ( !v2 )
      return;
    goto LABEL_11;
  }
}


// ========== Function: _memset @ 0x40D470 ==========
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  size_t v3; // edx
  int v4; // eax
  _BYTE *v5; // edi
  int v6; // ecx
  size_t v7; // ecx
  unsigned int v8; // ecx

  v3 = Size;
  if ( !Size )
    return a1;
  LOBYTE(v4) = Val;
  v5 = a1;
  if ( Size < 4 )
    goto LABEL_13;
  v6 = -(int)a1 & 3;
  if ( v6 )
  {
    v3 = Size - v6;
    do
    {
      *v5++ = Val;
      --v6;
    }
    while ( v6 );
  }
  v4 = 16843009 * (unsigned __int8)Val;
  v7 = v3;
  v3 &= 3u;
  v8 = v7 >> 2;
  if ( !v8 || (memset32(v5, v4, v8), v5 += 4 * v8, v3) )
  {
LABEL_13:
    do
    {
      *v5++ = v4;
      --v3;
    }
    while ( v3 );
  }
  return a1;
}


// ========== Function: _memcmp @ 0x40D4D0 ==========
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  int result; // eax
  char *v4; // esi
  char *v5; // edi
  bool v6; // cf
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // dl
  bool v9; // zf
  size_t v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // edx
  unsigned int v13; // ecx
  unsigned int v14; // edx
  int v15; // edx
  int v16; // ecx
  unsigned int v17; // ecx
  unsigned int v18; // edx

  result = Size;
  if ( !Size )
    return result;
  v4 = (char *)Buf1;
  v5 = (char *)Buf2;
  if ( (((unsigned __int8)Buf2 | (unsigned __int8)Buf1) & 3) == 0 )
  {
    result = Size & 3;
    v10 = Size >> 2;
    v9 = Size >> 2 == 0;
    if ( !(Size >> 2) )
      goto tail_loop_start;
    do
    {
      if ( !v10 )
        break;
      v9 = *(_DWORD *)v4 == *(_DWORD *)v5;
      v4 += 4;
      v5 += 4;
      --v10;
    }
    while ( v9 );
    if ( v9 )
    {
tail_loop_start:
      if ( (Size & 3) == 0 )
        return result;
      v15 = *(_DWORD *)v4;
      v16 = *(_DWORD *)v5;
      v6 = (unsigned __int8)*(_DWORD *)v4 < (unsigned __int8)*(_DWORD *)v5;
      if ( (unsigned __int8)*(_DWORD *)v4 == (unsigned __int8)*(_DWORD *)v5 )
      {
        if ( !--result )
          return result;
        v6 = BYTE1(v15) < BYTE1(v16);
        if ( BYTE1(v15) == BYTE1(v16) )
        {
          if ( !--result )
            return result;
          v17 = v16 & 0xFF0000;
          v18 = v15 & 0xFF0000;
          v6 = v18 < v17;
          if ( v18 == v17 )
            return --result;
        }
      }
    }
    else
    {
      v11 = *((_DWORD *)v4 - 1);
      v12 = *((_DWORD *)v5 - 1);
      v6 = (unsigned __int8)v11 < (unsigned __int8)v12;
      if ( (_BYTE)v11 == (_BYTE)v12 )
      {
        v6 = BYTE1(v11) < BYTE1(v12);
        if ( BYTE1(v11) == BYTE1(v12) )
        {
          v13 = HIWORD(v11);
          v14 = HIWORD(v12);
          v6 = (unsigned __int8)v13 < (unsigned __int8)v14;
          if ( (_BYTE)v13 == (_BYTE)v14 )
            v6 = BYTE1(v13) < BYTE1(v14);
        }
      }
    }
    return -v6 - (v6 - 1);
  }
  if ( (Size & 1) == 0 )
  {
main_loop:
    while ( 1 )
    {
      v6 = (unsigned __int8)*v4 < (unsigned __int8)*v5;
      if ( *v4 != *v5 )
        break;
      v7 = v4[1];
      v8 = v5[1];
      v6 = v7 < v8;
      if ( v7 != v8 )
        break;
      v5 += 2;
      v4 += 2;
      result -= 2;
      if ( !result )
        return result;
    }
    return -v6 - (v6 - 1);
  }
  v6 = *(_BYTE *)Buf1 < *(_BYTE *)Buf2;
  if ( *(_BYTE *)Buf1 != *(_BYTE *)Buf2 )
    return -v6 - (v6 - 1);
  v4 = (char *)Buf1 + 1;
  v5 = (char *)Buf2 + 1;
  result = Size - 1;
  if ( Size != 1 )
    goto main_loop;
  return result;
}


// ========== Function: _malloc @ 0x40D57C ==========
void *__cdecl malloc(size_t Size)
{
  return (void *)_nh_malloc(Size, dword_4395B0);
}


// ========== Function: __nh_malloc @ 0x40D58E ==========
int __cdecl _nh_malloc(size_t Size, int a2)
{
  int result; // eax

  if ( Size > 0xFFFFFFE0 )
    return 0;
  while ( 1 )
  {
    result = sub_40D5BA(Size);
    if ( result || !a2 )
      break;
    if ( !_callnewh(Size) )
      return 0;
  }
  return result;
}


// ========== Function: sub_40D5BA @ 0x40D5BA ==========
LPVOID __cdecl sub_40D5BA(unsigned int a1)
{
  LPVOID result; // eax
  SIZE_T v2; // esi
  int v3; // eax
  SIZE_T v4; // eax
  void *v5; // [esp+Ch] [ebp-1Ch]
  void *v6; // [esp+Ch] [ebp-1Ch]

  if ( dword_43A7A4 == 3 )
  {
    if ( a1 <= dword_43A79C )
    {
      _lock(9);
      v5 = (void *)__sbh_alloc_block(a1);
      _unlock(9);
      result = v5;
      if ( v5 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_43A7A4 != 2 )
  {
LABEL_12:
    v3 = a1;
    if ( !a1 )
      v3 = 1;
    v4 = v3 + 15;
    LOBYTE(v4) = v4 & 0xF0;
    return HeapAlloc(hHeap, 0, v4);
  }
  if ( a1 )
    v2 = (a1 + 15) & 0xFFFFFFF0;
  else
    v2 = 16;
  if ( v2 > dword_4368B4 )
    return HeapAlloc(hHeap, 0, v2);
  _lock(9);
  v6 = (void *)sub_41275F(v2 >> 4);
  _unlock(9);
  result = v6;
  if ( !v6 )
    return HeapAlloc(hHeap, 0, v2);
  return result;
}


// ========== Function: __CxxThrowException@8 @ 0x40D6B6 ==========
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  DWORD dwExceptionCode[8]; // [esp+8h] [ebp-20h] BYREF

  qmemcpy(dwExceptionCode, &unk_42BD90, sizeof(dwExceptionCode));
  dwExceptionCode[6] = (DWORD)pExceptionObject;
  dwExceptionCode[7] = (DWORD)pThrowInfo;
  RaiseException(dwExceptionCode[0], dwExceptionCode[1], dwExceptionCode[4], &dwExceptionCode[5]);
}


// ========== Function: _memcpy @ 0x40D6F0 ==========
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  char *v3; // esi
  char *v4; // edi
  size_t v5; // ecx
  void *result; // eax
  char *v7; // esi
  char *v8; // edi
  size_t v9; // ecx

  v3 = (char *)Src;
  v4 = (char *)a1;
  if ( a1 > Src && a1 < (char *)Src + Size )
  {
    v7 = (char *)Src + Size - 4;
    v8 = (char *)a1 + Size - 4;
    if ( ((unsigned __int8)v8 & 3) == 0 )
    {
      v9 = Size >> 2;
      if ( Size >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( Size & 3 )
        {
          case 0u:
            goto TrailDown0;
          case 1u:
            goto TrailDown1;
          case 2u:
            goto TrailDown2;
          case 3u:
            goto TrailDown3;
        }
      }
      switch ( Size & 3 )
      {
        case 0u:
          goto TrailDown0;
        case 1u:
          goto TrailDown1;
        case 2u:
          goto TrailDown2;
        case 3u:
          goto TrailDown3;
      }
    }
    switch ( Size )
    {
      case 0u:
TrailDown0:
        result = a1;
        break;
      case 1u:
TrailDown1:
        v8[3] = v7[3];
        result = a1;
        break;
      case 2u:
TrailDown2:
        v8[3] = v7[3];
        v8[2] = v7[2];
        result = a1;
        break;
      case 3u:
TrailDown3:
        v8[3] = v7[3];
        v8[2] = v7[2];
        v8[1] = v7[1];
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr ds:loc_40D8D4+4[eax*4] }
        return result;
    }
  }
  else
  {
    if ( ((unsigned __int8)a1 & 3) != 0 )
    {
      if ( Size >= 4 )
        __asm { jmp     dword ptr ds:loc_40D74C+4[eax*4] }
      __asm { jmp     dword ptr ds:TrailUp0[ecx*4]; jumptable 0040D725 case 0 }
    }
    v5 = Size >> 2;
    switch ( v5 )
    {
      case 0u:
        goto UnwindUp0;
      case 1u:
        goto UnwindUp1;
      case 2u:
        goto UnwindUp2;
      case 3u:
        goto UnwindUp3;
      case 4u:
        goto UnwindUp4;
      case 5u:
        goto UnwindUp5;
      case 6u:
        goto UnwindUp6;
      case 7u:
        *((_DWORD *)a1 + v5 - 7) = *((_DWORD *)Src + v5 - 7);
UnwindUp6:
        *((_DWORD *)a1 + v5 - 6) = *((_DWORD *)Src + v5 - 6);
UnwindUp5:
        *((_DWORD *)a1 + v5 - 5) = *((_DWORD *)Src + v5 - 5);
UnwindUp4:
        *((_DWORD *)a1 + v5 - 4) = *((_DWORD *)Src + v5 - 4);
UnwindUp3:
        *((_DWORD *)a1 + v5 - 3) = *((_DWORD *)Src + v5 - 3);
UnwindUp2:
        *((_DWORD *)a1 + v5 - 2) = *((_DWORD *)Src + v5 - 2);
UnwindUp1:
        *((_DWORD *)a1 + v5 - 1) = *((_DWORD *)Src + v5 - 1);
        v3 = (char *)Src + 4 * v5;
        v4 = (char *)a1 + 4 * v5;
UnwindUp0:
        switch ( Size & 3 )
        {
          case 0u:
            goto TrailUp0;
          case 1u:
            goto TrailUp1;
          case 2u:
            goto TrailUp2;
          case 3u:
            goto TrailUp3;
        }
      default:
        qmemcpy(a1, Src, 4 * v5);
        v3 = (char *)Src + 4 * v5;
        v4 = (char *)a1 + 4 * v5;
        switch ( Size & 3 )
        {
          case 0u:
TrailUp0:
            result = a1;
            break;
          case 1u:
TrailUp1:
            *v4 = *v3;
            result = a1;
            break;
          case 2u:
TrailUp2:
            *v4 = *v3;
            v4[1] = v3[1];
            result = a1;
            break;
          case 3u:
TrailUp3:
            *v4 = *v3;
            v4[1] = v3[1];
            v4[2] = v3[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}


// ========== Function: _wcslen @ 0x40DA25 ==========
size_t __cdecl wcslen(const wchar_t *String)
{
  const wchar_t *v1; // eax

  v1 = String + 1;
  if ( *String )
  {
    while ( *v1++ )
      ;
  }
  return v1 - String - 1;
}


// ========== Function: __mbschr @ 0x40DA42 ==========
unsigned __int8 *__cdecl _mbschr(const unsigned __int8 *Str, unsigned int C)
{
  const unsigned __int8 *i; // esi
  unsigned __int16 v4; // bx
  unsigned __int8 v5; // al

  if ( !dword_43A8DC )
    return (unsigned __int8 *)strchr((const char *)Str, C);
  _lock(25);
  for ( i = Str; ; ++i )
  {
    v4 = *i;
    if ( !*i )
      break;
    if ( (byte_43A9E1[(unsigned __int8)v4] & 4) != 0 )
    {
      v5 = *++i;
      if ( !v5 )
      {
        _unlock(25);
        return 0;
      }
      if ( C == (v5 | (v4 << 8)) )
      {
        _unlock(25);
        return (unsigned __int8 *)(i - 1);
      }
    }
    else if ( C == *i )
    {
      break;
    }
  }
  _unlock(25);
  return v4 == C ? (unsigned __int8 *)i : 0;
}


// ========== Function: __mbsinc @ 0x40DAD9 ==========
unsigned __int8 *__cdecl _mbsinc(const unsigned __int8 *Ptr)
{
  unsigned __int8 *result; // eax

  result = (unsigned __int8 *)(Ptr + 1);
  if ( (byte_43A9E1[*Ptr] & 4) != 0 )
    return (unsigned __int8 *)(Ptr + 2);
  return result;
}


// ========== Function: _memcpy_0 @ 0x40DAF0 ==========
void *__cdecl memcpy_0(void *a1, const void *Src, size_t Size)
{
  char *v3; // esi
  char *v4; // edi
  size_t v5; // ecx
  void *result; // eax
  char *v7; // esi
  char *v8; // edi
  size_t v9; // ecx

  v3 = (char *)Src;
  v4 = (char *)a1;
  if ( a1 > Src && a1 < (char *)Src + Size )
  {
    v7 = (char *)Src + Size - 4;
    v8 = (char *)a1 + Size - 4;
    if ( ((unsigned __int8)v8 & 3) == 0 )
    {
      v9 = Size >> 2;
      if ( Size >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( Size & 3 )
        {
          case 0u:
            goto TrailDown0_0;
          case 1u:
            goto TrailDown1_0;
          case 2u:
            goto TrailDown2_0;
          case 3u:
            goto TrailDown3_0;
        }
      }
      switch ( Size & 3 )
      {
        case 0u:
          goto TrailDown0_0;
        case 1u:
          goto TrailDown1_0;
        case 2u:
          goto TrailDown2_0;
        case 3u:
          goto TrailDown3_0;
      }
    }
    switch ( Size )
    {
      case 0u:
TrailDown0_0:
        result = a1;
        break;
      case 1u:
TrailDown1_0:
        v8[3] = v7[3];
        result = a1;
        break;
      case 2u:
TrailDown2_0:
        v8[3] = v7[3];
        v8[2] = v7[2];
        result = a1;
        break;
      case 3u:
TrailDown3_0:
        v8[3] = v7[3];
        v8[2] = v7[2];
        v8[1] = v7[1];
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr ds:loc_40DCD4+4[eax*4] }
        return result;
    }
  }
  else
  {
    if ( ((unsigned __int8)a1 & 3) != 0 )
    {
      if ( Size >= 4 )
        __asm { jmp     dword ptr ds:loc_40DB4C+4[eax*4] }
      __asm { jmp     dword ptr ds:TrailUp0_0[ecx*4]; jumptable 0040DB25 case 0 }
    }
    v5 = Size >> 2;
    switch ( v5 )
    {
      case 0u:
        goto UnwindUp0_0;
      case 1u:
        goto UnwindUp1_0;
      case 2u:
        goto UnwindUp2_0;
      case 3u:
        goto UnwindUp3_0;
      case 4u:
        goto UnwindUp4_0;
      case 5u:
        goto UnwindUp5_0;
      case 6u:
        goto UnwindUp6_0;
      case 7u:
        *((_DWORD *)a1 + v5 - 7) = *((_DWORD *)Src + v5 - 7);
UnwindUp6_0:
        *((_DWORD *)a1 + v5 - 6) = *((_DWORD *)Src + v5 - 6);
UnwindUp5_0:
        *((_DWORD *)a1 + v5 - 5) = *((_DWORD *)Src + v5 - 5);
UnwindUp4_0:
        *((_DWORD *)a1 + v5 - 4) = *((_DWORD *)Src + v5 - 4);
UnwindUp3_0:
        *((_DWORD *)a1 + v5 - 3) = *((_DWORD *)Src + v5 - 3);
UnwindUp2_0:
        *((_DWORD *)a1 + v5 - 2) = *((_DWORD *)Src + v5 - 2);
UnwindUp1_0:
        *((_DWORD *)a1 + v5 - 1) = *((_DWORD *)Src + v5 - 1);
        v3 = (char *)Src + 4 * v5;
        v4 = (char *)a1 + 4 * v5;
UnwindUp0_0:
        switch ( Size & 3 )
        {
          case 0u:
            goto TrailUp0_0;
          case 1u:
            goto TrailUp1_0;
          case 2u:
            goto TrailUp2_0;
          case 3u:
            goto TrailUp3_0;
        }
      default:
        qmemcpy(a1, Src, 4 * v5);
        v3 = (char *)Src + 4 * v5;
        v4 = (char *)a1 + 4 * v5;
        switch ( Size & 3 )
        {
          case 0u:
TrailUp0_0:
            result = a1;
            break;
          case 1u:
TrailUp1_0:
            *v4 = *v3;
            result = a1;
            break;
          case 2u:
TrailUp2_0:
            *v4 = *v3;
            v4[1] = v3[1];
            result = a1;
            break;
          case 3u:
TrailUp3_0:
            *v4 = *v3;
            v4[1] = v3[1];
            v4[2] = v3[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}


// ========== Function: __mbsstr @ 0x40DE25 ==========
unsigned __int8 *__cdecl _mbsstr(const unsigned __int8 *Str, const unsigned __int8 *Substr)
{
  unsigned __int8 *v3; // esi
  const unsigned __int8 *v4; // edi
  const unsigned __int8 *v5; // edi
  const unsigned __int8 *v6; // eax
  int v7; // edx

  if ( !dword_43A8DC )
    return (unsigned __int8 *)strstr((const char *)Str, (const char *)Substr);
  v3 = (unsigned __int8 *)Str;
  v4 = &Str[-strlen((const char *)Substr)];
  v5 = &v4[strlen((const char *)Str)];
  while ( *v3 && v3 <= v5 )
  {
    v6 = Substr;
    if ( *v3 )
    {
      v7 = v3 - Substr;
      do
      {
        if ( !*v6 )
          break;
        if ( v6[v7] != *v6 )
          break;
        ++v6;
      }
      while ( v6[v7] );
    }
    if ( !*v6 )
      return v3;
    v3 = _mbsinc(v3);
  }
  return 0;
}


// ========== Function: __mbsrchr @ 0x40DE9B ==========
unsigned __int8 *__cdecl _mbsrchr(const unsigned __int8 *String, unsigned int C)
{
  unsigned __int8 *v2; // esi
  const unsigned __int8 *v4; // ecx
  unsigned __int8 v5; // dl
  int v6; // eax
  bool v7; // zf

  v2 = 0;
  if ( !dword_43A8DC )
    return (unsigned __int8 *)strrchr((const char *)String, C);
  _lock(25);
  v4 = String;
  do
  {
    v5 = *v4;
    v6 = *v4;
    if ( (byte_43A9E1[(unsigned __int8)v6] & 4) != 0 )
    {
      v5 = *++v4;
      if ( v5 )
      {
        if ( C == (v5 | (v6 << 8)) )
          v2 = (unsigned __int8 *)(v4 - 1);
        goto LABEL_12;
      }
      v7 = v2 == 0;
    }
    else
    {
      v7 = C == v6;
    }
    if ( v7 )
      v2 = (unsigned __int8 *)v4;
LABEL_12:
    ++v4;
  }
  while ( v5 );
  _unlock(25);
  return v2;
}


// ========== Function: _vsprintf @ 0x40DF0D ==========
int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList)
{
  int v3; // eax
  bool v4; // sf
  int v5; // esi
  FILE File; // [esp+4h] [ebp-20h] BYREF

  File._base = Buffer;
  File._ptr = Buffer;
  File._flag = 66;
  File._cnt = 0x7FFFFFFF;
  v3 = sub_41328F(&File, (int)Format, (int)ArgList);
  v4 = --File._cnt < 0;
  v5 = v3;
  if ( v4 )
    _flsbuf(0, &File);
  else
    *File._ptr = 0;
  return v5;
}


// ========== Function: __mbclen @ 0x40DF5E ==========
size_t __cdecl _mbclen(const unsigned __int8 *String)
{
  return ((byte_43A9E1[*String] & 4) != 0) + 1;
}


// ========== Function: _strlen @ 0x40DF80 ==========
size_t __cdecl strlen(const char *Str)
{
  const char *v1; // ecx
  int v3; // eax
  int v4; // eax

  v1 = Str;
  if ( ((unsigned __int8)Str & 3) == 0 )
    goto main_loop_0;
  do
  {
    if ( !*v1++ )
      return v1 - 1 - Str;
  }
  while ( ((unsigned __int8)v1 & 3) != 0 );
  while ( 1 )
  {
    do
    {
main_loop_0:
      v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
      v1 += 4;
    }
    while ( (v3 & 0x81010100) == 0 );
    v4 = *((_DWORD *)v1 - 1);
    if ( !(_BYTE)v4 )
      break;
    if ( !BYTE1(v4) )
      return v1 - 3 - Str;
    if ( (v4 & 0xFF0000) == 0 )
      return v1 - 2 - Str;
    if ( (v4 & 0xFF000000) == 0 )
      return v1 - 1 - Str;
  }
  return v1 - 4 - Str;
}


// ========== Function: _sprintf @ 0x40DFFB ==========
int sprintf(char *const Buffer, const char *const Format, ...)
{
  int v2; // eax
  bool v3; // sf
  int v4; // esi
  FILE File; // [esp+4h] [ebp-20h] BYREF
  va_list va; // [esp+34h] [ebp+10h] BYREF

  va_start(va, Format);
  File._base = Buffer;
  File._ptr = Buffer;
  File._flag = 66;
  File._cnt = 0x7FFFFFFF;
  v2 = sub_41328F(&File, (int)Format, (int)va);
  v3 = --File._cnt < 0;
  v4 = v2;
  if ( v3 )
    _flsbuf(0, &File);
  else
    *File._ptr = 0;
  return v4;
}


// ========== Function: __mbsnbcmp @ 0x40E04D ==========
int __cdecl _mbsnbcmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount)
{
  const unsigned __int8 *v4; // esi
  const unsigned __int8 *v5; // edi
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // bx
  unsigned __int8 v8; // al
  unsigned __int16 v9; // dx
  unsigned __int8 v10; // al
  unsigned __int16 v11; // cx
  unsigned __int16 Str2a; // [esp+18h] [ebp+Ch]
  size_t MaxCounta; // [esp+1Ch] [ebp+10h]

  if ( MaxCount )
  {
    if ( !dword_43A8DC )
      return strncmp((const char *)Str1, (const char *)Str2, MaxCount);
    _lock(25);
    MaxCounta = MaxCount - 1;
    v4 = Str2;
    v5 = Str1;
    while ( 1 )
    {
      v6 = *v5++;
      Str2a = v6;
      if ( (byte_43A9E1[(unsigned __int8)v6] & 4) != 0 )
      {
        if ( !MaxCounta )
        {
          Str2a = 0;
          if ( (byte_43A9E1[*v4] & 4) != 0 )
            goto LABEL_22;
          v7 = *v4;
          goto LABEL_17;
        }
        v8 = *v5;
        if ( *v5 )
        {
          ++v5;
          HIBYTE(v9) = v6;
          LOBYTE(v9) = v8;
          Str2a = v9;
        }
        else
        {
          Str2a = 0;
        }
      }
      v7 = *v4++;
      if ( (byte_43A9E1[(unsigned __int8)v7] & 4) != 0 )
      {
        if ( MaxCounta && (v10 = *v4, --MaxCounta, *v4) )
        {
          ++v4;
          HIBYTE(v11) = v7;
          LOBYTE(v11) = v10;
          v7 = v11;
        }
        else
        {
          v7 = 0;
        }
      }
LABEL_17:
      if ( Str2a != v7 )
      {
        _unlock(25);
        return v7 < Str2a ? 1 : -1;
      }
      if ( Str2a )
      {
        if ( MaxCounta-- )
          continue;
      }
LABEL_22:
      _unlock(25);
      return 0;
    }
  }
  return 0;
}


// ========== Function: __ismbcdigit @ 0x40E13C ==========
int __cdecl _ismbcdigit(unsigned int C)
{
  int v1; // ecx
  int CharType; // [esp+0h] [ebp-4h] BYREF

  CharType = v1;
  if ( C <= 0xFF )
  {
    if ( cbMultiByte <= 1 )
      return *((_BYTE *)off_434474 + 2 * C) & 4;
    else
      return _isctype(C, 4);
  }
  else
  {
    CharType = 0;
    BYTE2(C) = BYTE1(C);
    HIBYTE(C) = C;
    return dword_43A8DC
        && __crtGetStringTypeA(1u, (LPCSTR)&C + 2, 2, (LPWORD)&CharType, CodePage, Locale, 1)
        && !HIWORD(CharType)
        && (CharType & 4) != 0;
  }
}


// ========== Function: __fpmath @ 0x40E1CB ==========
int _fpmath()
{
  int result; // eax

  _cfltcvt_init();
  dword_4393F8 = _ms_p5_mp_test_fdiv();
  result = _setdefaultprecision();
  __asm { fnclex }
  return result;
}


// ========== Function: nullsub_8 @ 0x40E1E2 ==========
void nullsub_8()
{
  ;
}


// ========== Function: __cfltcvt_init @ 0x40E1E3 ==========
int (__cdecl *_cfltcvt_init())(int, void *Src, int, size_t Size, int)
{
  int (__cdecl *result)(int, void *, int, size_t, int); // eax

  result = _cfltcvt;
  off_4368D4[0] = (void (__noreturn *)())_cropzeros;
  off_4368D0[0] = (void (__noreturn *)())_cfltcvt;
  off_4368D8[0] = (void (__noreturn *)())_fassign;
  off_4368DC[0] = (void (__noreturn *)())_forcdecpt;
  off_4368E0[0] = (void (__noreturn *)())_positive;
  off_4368E4 = (void (__noreturn *)())_cfltcvt;
  return result;
}


// ========== Function: __alloca_probe @ 0x40E220 ==========
void __usercall _alloca_probe(unsigned int a1@<eax>, char a2)
{
  char *i; // ecx

  for ( i = &a2; a1 >= 0x1000; a1 -= 4096 )
    i -= 4096;
  __asm { retn }
}


// ========== Function: __ismbcspace @ 0x40E24F ==========
int __cdecl _ismbcspace(unsigned int C)
{
  int v1; // ecx
  int CharType; // [esp+0h] [ebp-4h] BYREF

  CharType = v1;
  if ( C <= 0xFF )
  {
    if ( cbMultiByte <= 1 )
      return *((_BYTE *)off_434474 + 2 * C) & 8;
    else
      return _isctype(C, 8);
  }
  else
  {
    CharType = 0;
    BYTE2(C) = BYTE1(C);
    HIBYTE(C) = C;
    return dword_43A8DC
        && __crtGetStringTypeA(1u, (LPCSTR)&C + 2, 2, (LPWORD)&CharType, CodePage, Locale, 1)
        && !HIWORD(CharType)
        && (CharType & 8) != 0;
  }
}


// ========== Function: _strtol @ 0x40E2DE ==========
int __cdecl strtol(const char *String, char **EndPtr, int Radix)
{
  return strtoxl(String, EndPtr, Radix, 0);
}


// ========== Function: _strtoxl @ 0x40E2F5 ==========
int __cdecl strtoxl(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  unsigned __int8 v4; // bl
  unsigned __int8 *i; // esi
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  unsigned __int8 *v10; // eax
  unsigned int v12; // [esp+Ch] [ebp-Ch]
  unsigned int v13; // [esp+10h] [ebp-8h]
  unsigned __int8 *v14; // [esp+14h] [ebp-4h]
  unsigned __int8 *v15; // [esp+14h] [ebp-4h]

  v13 = 0;
  v4 = *a1;
  for ( i = a1 + 1; cbMultiByte <= 1 ? *((_BYTE *)off_434474 + 2 * v4) & 8 : _isctype(v4, 8); ++i )
    v4 = *i;
  v14 = i;
  if ( v4 == 45 )
  {
    a4 |= 2u;
LABEL_10:
    v4 = *i++;
    v14 = i;
    goto LABEL_11;
  }
  if ( v4 == 43 )
    goto LABEL_10;
LABEL_11:
  if ( a3 >= 0 && a3 != 1 && a3 <= 36 )
  {
    if ( !a3 )
    {
      if ( v4 != 48 )
      {
        a3 = 10;
LABEL_26:
        v12 = 0xFFFFFFFF / a3;
        while ( 1 )
        {
          if ( cbMultiByte <= 1 )
            v7 = *((_BYTE *)off_434474 + 2 * v4) & 4;
          else
            v7 = _isctype(v4, 4);
          if ( v7 )
          {
            v8 = (char)v4 - 48;
          }
          else
          {
            if ( cbMultiByte <= 1 )
              v9 = *((_WORD *)off_434474 + v4) & 0x103;
            else
              v9 = _isctype(v4, 259);
            if ( !v9 )
            {
LABEL_44:
              v15 = v14 - 1;
              if ( (a4 & 8) != 0 )
              {
                if ( (a4 & 4) != 0
                  || (a4 & 1) == 0 && ((a4 & 2) != 0 && v13 > 0x80000000 || (a4 & 2) == 0 && v13 > 0x7FFFFFFF) )
                {
                  *_errno() = 34;
                  if ( (a4 & 1) != 0 )
                    v13 = -1;
                  else
                    v13 = ((a4 & 2) != 0) + 0x7FFFFFFF;
                }
              }
              else
              {
                if ( a2 )
                  v15 = a1;
                v13 = 0;
              }
              if ( a2 )
                *a2 = v15;
              if ( (a4 & 2) != 0 )
                return -v13;
              return v13;
            }
            v8 = toupper((char)v4) - 55;
          }
          if ( v8 >= a3 )
            goto LABEL_44;
          a4 |= 8u;
          if ( v13 < v12 || v13 == v12 && v8 <= 0xFFFFFFFF % a3 )
            v13 = v8 + a3 * v13;
          else
            a4 |= 4u;
          v10 = v14++;
          v4 = *v10;
        }
      }
      if ( *i != 120 && *i != 88 )
      {
        a3 = 8;
        goto LABEL_26;
      }
      a3 = 16;
    }
    if ( a3 == 16 && v4 == 48 && (*i == 120 || *i == 88) )
    {
      v4 = i[1];
      v14 = i + 2;
    }
    goto LABEL_26;
  }
  if ( a2 )
    *a2 = a1;
  return 0;
}


// ========== Function: _strtoul @ 0x40E4FA ==========
unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix)
{
  return strtoxl((unsigned __int8 *)String, (unsigned __int8 **)EndPtr, Radix, 1);
}


// ========== Function: _xtoa @ 0x40E511 ==========
char __cdecl xtoa(unsigned int a1, char *a2, unsigned int a3, int a4)
{
  char *v4; // ecx
  unsigned int v5; // esi
  char *v6; // edi
  int v7; // ebx
  bool v8; // cc
  char v9; // bl
  char *v10; // ecx
  char result; // al

  v4 = a2;
  if ( a4 )
  {
    *a2 = 45;
    v4 = a2 + 1;
    v5 = -a1;
  }
  else
  {
    v5 = a1;
  }
  v6 = v4;
  do
  {
    v7 = v5 % a3;
    v8 = v5 % a3 <= 9;
    v5 /= a3;
    if ( v8 )
      v9 = v7 + 48;
    else
      v9 = v7 + 87;
    *v4++ = v9;
  }
  while ( v5 );
  *v4 = 0;
  v10 = v4 - 1;
  do
  {
    result = *v10;
    *v10 = *v6;
    *v6 = result;
    --v10;
    ++v6;
  }
  while ( v6 < v10 );
  return result;
}


// ========== Function: __ltoa @ 0x40E56D ==========
char *__cdecl _ltoa(int Value, char *Buffer, int Radix)
{
  BOOL v3; // eax

  v3 = 0;
  if ( Radix == 10 )
    v3 = Value < 0;
  xtoa(Value, Buffer, Radix, v3);
  return Buffer;
}


// ========== Function: __ultoa @ 0x40E597 ==========
char *__cdecl _ultoa(unsigned int Value, char *Buffer, int Radix)
{
  xtoa(Value, Buffer, Radix, 0);
  return Buffer;
}


// ========== Function: __alloc_osfhnd @ 0x40E5B2 ==========
int _alloc_osfhnd()
{
  int v0; // edi
  int v1; // ebx
  int *v2; // ebp
  unsigned int v3; // esi
  unsigned int i; // eax
  char *v5; // eax
  unsigned int v6; // edx
  int v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v0 = -1;
  _lock(18);
  v1 = 0;
  v8 = 0;
  v9 = 0;
  v2 = dword_43A7C0;
  while ( 1 )
  {
    v3 = *v2;
    if ( !*v2 )
      break;
    for ( i = v3 + 1152; v3 < i; i = *v2 + 1152 )
    {
      if ( (*(_BYTE *)(v3 + 4) & 1) == 0 )
      {
        if ( !*(_DWORD *)(v3 + 8) )
        {
          _lock(17);
          if ( !*(_DWORD *)(v3 + 8) )
          {
            InitializeCriticalSection((LPCRITICAL_SECTION)(v3 + 12));
            ++*(_DWORD *)(v3 + 8);
          }
          _unlock(17);
        }
        EnterCriticalSection((LPCRITICAL_SECTION)(v3 + 12));
        if ( (*(_BYTE *)(v3 + 4) & 1) == 0 )
        {
          *(_DWORD *)v3 = -1;
          v0 = v9 + (int)(v3 - *v2) / 36;
          if ( v0 != -1 )
            goto LABEL_22;
          v1 = v8;
          break;
        }
        LeaveCriticalSection((LPCRITICAL_SECTION)(v3 + 12));
        v1 = v8;
      }
      v3 += 36;
    }
    v9 += 32;
    ++v2;
    v8 = ++v1;
    if ( (int)v2 >= (int)&uNumber )
      goto LABEL_22;
  }
  v5 = (char *)malloc(0x480u);
  if ( v5 )
  {
    uNumber += 32;
    v6 = (unsigned int)(v5 + 1152);
    dword_43A7C0[v1] = (int)v5;
    while ( (unsigned int)v5 < v6 )
    {
      v5[4] = 0;
      *(_DWORD *)v5 = -1;
      *((_DWORD *)v5 + 2) = 0;
      v5[5] = 10;
      v5 += 36;
      v6 = dword_43A7C0[v1] + 1152;
    }
    v0 = 32 * v1;
    _lock_fhandle(32 * v1);
  }
LABEL_22:
  _unlock(18);
  return v0;
}


// ========== Function: __set_osfhnd @ 0x40E6D5 ==========
int __cdecl _set_osfhnd(int a1, HANDLE hHandle)
{
  if ( a1 < uNumber && *(_DWORD *)(dword_43A7C0[a1 >> 5] + 36 * (a1 & 0x1F)) == -1 )
  {
    if ( dword_4340EC == 1 )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          SetStdHandle(0xFFFFFFF5, hHandle);
        }
        else if ( a1 == 2 )
        {
          SetStdHandle(0xFFFFFFF4, hHandle);
        }
      }
      else
      {
        SetStdHandle(0xFFFFFFF6, hHandle);
      }
    }
    *(_DWORD *)(dword_43A7C0[a1 >> 5] + 36 * (a1 & 0x1F)) = hHandle;
    return 0;
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
}


// ========== Function: __free_osfhnd @ 0x40E751 ==========
int __cdecl _free_osfhnd(int a1)
{
  int v1; // eax

  if ( a1 >= uNumber
    || (v1 = 36 * (a1 & 0x1F) + dword_43A7C0[a1 >> 5], (*(_BYTE *)(v1 + 4) & 1) == 0)
    || *(_DWORD *)v1 == -1 )
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
  else
  {
    if ( dword_4340EC == 1 )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          SetStdHandle(0xFFFFFFF5, 0);
        }
        else if ( a1 == 2 )
        {
          SetStdHandle(0xFFFFFFF4, 0);
        }
      }
      else
      {
        SetStdHandle(0xFFFFFFF6, 0);
      }
    }
    *(_DWORD *)(dword_43A7C0[a1 >> 5] + 36 * (a1 & 0x1F)) = -1;
    return 0;
  }
}


// ========== Function: __get_osfhandle @ 0x40E7D0 ==========
intptr_t __cdecl _get_osfhandle(int FileHandle)
{
  int v1; // eax

  if ( FileHandle < uNumber )
  {
    v1 = dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F);
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 )
      return *(_DWORD *)v1;
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}


// ========== Function: __open_osfhandle @ 0x40E812 ==========
int __cdecl _open_osfhandle(intptr_t OSFileHandle, int Flags)
{
  char v2; // bl
  DWORD FileType; // eax
  DWORD LastError; // eax
  int v5; // eax
  int v6; // esi

  v2 = 0;
  if ( (Flags & 8) != 0 )
    v2 = 32;
  if ( (Flags & 0x4000) != 0 )
    v2 |= 0x80u;
  if ( (Flags & 0x80u) != 0 )
    v2 |= 0x10u;
  FileType = GetFileType((HANDLE)OSFileHandle);
  switch ( FileType )
  {
    case 0u:
      LastError = GetLastError();
      sub_40E93A(LastError);
      return -1;
    case 2u:
      v2 |= 0x40u;
      break;
    case 3u:
      v2 |= 8u;
      break;
  }
  v5 = _alloc_osfhnd();
  v6 = v5;
  if ( v5 == -1 )
  {
    *_errno() = 24;
    *__doserrno() = 0;
    return -1;
  }
  _set_osfhnd(v5, (HANDLE)OSFileHandle);
  *(_BYTE *)(dword_43A7C0[v6 >> 5] + 36 * (v6 & 0x1F) + 4) = v2 | 1;
  _unlock_fhandle(v6);
  return v6;
}


// ========== Function: __lock_fhandle @ 0x40E8B9 ==========
void __cdecl _lock_fhandle(int a1)
{
  int v1; // edi
  int v2; // esi

  v1 = 36 * (a1 & 0x1F);
  v2 = v1 + dword_43A7C0[a1 >> 5];
  if ( !*(_DWORD *)(v2 + 8) )
  {
    _lock(17);
    if ( !*(_DWORD *)(v2 + 8) )
    {
      InitializeCriticalSection((LPCRITICAL_SECTION)(v2 + 12));
      ++*(_DWORD *)(v2 + 8);
    }
    _unlock(17);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(dword_43A7C0[a1 >> 5] + v1 + 12));
}


// ========== Function: __unlock_fhandle @ 0x40E918 ==========
void __cdecl _unlock_fhandle(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_43A7C0[a1 >> 5] + 36 * (a1 & 0x1F) + 12));
}


// ========== Function: sub_40E93A @ 0x40E93A ==========
int *__cdecl sub_40E93A(unsigned int a1)
{
  int v1; // esi
  char *v2; // eax
  int *result; // eax

  v1 = 0;
  *__doserrno() = a1;
  v2 = (char *)&unk_434140;
  do
  {
    if ( a1 == *(_DWORD *)v2 )
    {
      result = _errno();
      *result = dword_434144[2 * v1];
      return result;
    }
    v2 += 8;
    ++v1;
  }
  while ( v2 < &byte_4342A8 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || a1 > 0xCA )
    {
      result = _errno();
      *result = 22;
    }
    else
    {
      result = _errno();
      *result = 8;
    }
  }
  else
  {
    result = _errno();
    *result = 13;
  }
  return result;
}


// ========== Function: __errno @ 0x40E9AD ==========
int *__cdecl _errno()
{
  return _getptd() + 2;
}


// ========== Function: ___doserrno @ 0x40E9B6 ==========
unsigned int *__cdecl __doserrno()
{
  return _getptd() + 3;
}


// ========== Function: __fdopen @ 0x40E9BF ==========
FILE *__cdecl _fdopen(int FileHandle, const char *Mode)
{
  int v2; // esi
  const char *v3; // ecx
  char v4; // al
  int v5; // edi
  int v6; // edx
  char v7; // al
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int Modea; // [esp+14h] [ebp+Ch]

  if ( FileHandle >= uNumber )
    return 0;
  if ( (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) == 0 )
    return 0;
  v2 = _getstream();
  if ( !v2 )
    return 0;
  v3 = Mode;
  v4 = *Mode;
  if ( *Mode == 97 )
    goto LABEL_9;
  if ( v4 != 114 )
  {
    if ( v4 != 119 )
    {
      v2 = 0;
      goto LABEL_29;
    }
LABEL_9:
    *(_DWORD *)(v2 + 12) = 2;
    goto LABEL_10;
  }
  *(_DWORD *)(v2 + 12) = 1;
LABEL_10:
  v5 = 0;
  v6 = 1;
  Modea = 0;
  *(_DWORD *)(v2 + 12) |= dword_4395C8;
  while ( 1 )
  {
    v7 = *++v3;
    if ( !v7 || !v6 )
      break;
    v8 = v7 - 43;
    if ( v8 )
    {
      v9 = v8 - 55;
      if ( !v9 )
        goto LABEL_23;
      v10 = v9 - 1;
      if ( v10 )
      {
        v11 = v10 - 11;
        if ( v11 )
        {
          if ( v11 == 6 )
          {
LABEL_23:
            if ( Modea )
              goto LABEL_26;
            Modea = 1;
          }
          else
          {
LABEL_26:
            v6 = 0;
          }
        }
        else
        {
          if ( v5 )
            goto LABEL_26;
          *(_BYTE *)(v2 + 13) &= ~0x40u;
          v5 = 1;
        }
      }
      else
      {
        if ( v5 )
          goto LABEL_26;
        *(_BYTE *)(v2 + 13) |= 0x40u;
        v5 = 1;
      }
    }
    else
    {
      v12 = *(_DWORD *)(v2 + 12);
      if ( (v12 & 0x80u) != 0 )
        goto LABEL_26;
      LOBYTE(v12) = v12 & 0x7C | 0x80;
      *(_DWORD *)(v2 + 12) = v12;
    }
  }
  ++dword_4395C4;
  *(_DWORD *)(v2 + 16) = FileHandle;
LABEL_29:
  _unlock_file((FILE *)v2);
  return (FILE *)v2;
}


// ========== Function: _clearerr @ 0x40EAB2 ==========
void __cdecl clearerr(FILE *Stream)
{
  int file; // eax
  _BYTE *v2; // eax

  _lock_file(Stream);
  file = Stream->_file;
  Stream->_flag &= 0xFFFFFFCF;
  if ( file == -1 )
    v2 = &unk_4347D8;
  else
    v2 = (_BYTE *)(dword_43A7C0[file >> 5] + 36 * (file & 0x1F));
  v2[4] &= ~2u;
  _unlock_file(Stream);
}


// ========== Function: sub_40EAF3 @ 0x40EAF3 ==========
size_t __cdecl sub_40EAF3(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // esi

  _lock_file(Stream);
  v4 = fread(Buffer, ElementSize, ElementCount, Stream);
  _unlock_file(Stream);
  return v4;
}


// ========== Function: _fread @ 0x40EB22 ==========
size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // edi
  size_t v6; // ecx
  unsigned int cnt; // eax
  size_t v10; // edi
  unsigned int v11; // eax
  int v12; // eax
  int v13; // eax
  size_t Buffera; // [esp+18h] [ebp+8h]
  unsigned int Streama; // [esp+24h] [ebp+14h]

  v4 = ElementCount * ElementSize;
  v6 = ElementCount * ElementSize;
  Buffera = ElementCount * ElementSize;
  if ( !(ElementCount * ElementSize) )
    return 0;
  if ( (Stream->_flag & 0x10C) != 0 )
    Streama = Stream->_bufsiz;
  else
    Streama = 4096;
  while ( 1 )
  {
    if ( (Stream->_flag & 0x10C) != 0 )
    {
      cnt = Stream->_cnt;
      if ( cnt )
      {
        v10 = v6;
        if ( v6 >= cnt )
          v10 = Stream->_cnt;
        memcpy(Buffer, Stream->_ptr, v10);
        Buffera -= v10;
        Stream->_cnt -= v10;
        Stream->_ptr += v10;
        Buffer = (char *)Buffer + v10;
        v4 = ElementCount * ElementSize;
        goto LABEL_20;
      }
    }
    if ( v6 >= Streama )
      break;
    v13 = _filbuf(Stream);
    if ( v13 == -1 )
      return (v4 - Buffera) / ElementSize;
    *(_BYTE *)Buffer = v13;
    Buffer = (char *)Buffer + 1;
    --Buffera;
    Streama = Stream->_bufsiz;
LABEL_20:
    if ( !Buffera )
      return ElementCount;
    v6 = Buffera;
  }
  v11 = v6;
  if ( Streama )
    v11 = v6 - v6 % Streama;
  v12 = _read(Stream->_file, Buffer, v11);
  if ( !v12 )
  {
    Stream->_flag |= 0x10u;
    return (v4 - Buffera) / ElementSize;
  }
  if ( v12 != -1 )
  {
    Buffera -= v12;
    Buffer = (char *)Buffer + v12;
    goto LABEL_20;
  }
  Stream->_flag |= 0x20u;
  return (v4 - Buffera) / ElementSize;
}


// ========== Function: sub_40EC0A @ 0x40EC0A ==========
size_t __cdecl sub_40EC0A(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // esi

  _lock_file(Stream);
  v4 = fwrite(Buffer, ElementSize, ElementCount, Stream);
  _unlock_file(Stream);
  return v4;
}


// ========== Function: _fwrite @ 0x40EC39 ==========
size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // edi
  size_t v5; // ebx
  unsigned int cnt; // eax
  size_t v9; // edi
  unsigned int v10; // edi
  unsigned int v11; // eax
  size_t v12; // eax
  int Streama; // [esp+24h] [ebp+14h]

  v4 = ElementCount * ElementSize;
  v5 = ElementCount * ElementSize;
  if ( !(ElementCount * ElementSize) )
    return 0;
  if ( (Stream->_flag & 0x10C) != 0 )
    Streama = Stream->_bufsiz;
  else
    Streama = 4096;
  while ( 1 )
  {
    if ( (Stream->_flag & 0x108) != 0 )
    {
      cnt = Stream->_cnt;
      if ( cnt )
      {
        v9 = v5;
        if ( v5 >= cnt )
          v9 = Stream->_cnt;
        memcpy(Stream->_ptr, Buffer, v9);
        Stream->_cnt -= v9;
        Stream->_ptr += v9;
        v5 -= v9;
        Buffer = (char *)Buffer + v9;
LABEL_19:
        v4 = ElementCount * ElementSize;
        goto LABEL_23;
      }
    }
    if ( v5 >= Streama )
      break;
    if ( _flsbuf(*(char *)Buffer, Stream) == -1 )
      goto LABEL_26;
    Buffer = (char *)Buffer + 1;
    --v5;
    Streama = Stream->_bufsiz;
    if ( Streama <= 0 )
      Streama = 1;
LABEL_23:
    if ( !v5 )
      return ElementCount;
  }
  if ( (Stream->_flag & 0x108) == 0 || !_flush(Stream) )
  {
    if ( Streama )
      v10 = v5 - v5 % Streama;
    else
      v10 = v5;
    v11 = _write(Stream->_file, Buffer, v10);
    if ( v11 == -1 || (Buffer = (char *)Buffer + v11, v5 -= v11, v11 < v10) )
    {
      Stream->_flag |= 0x20u;
      v12 = ElementCount * ElementSize;
      return (v12 - v5) / ElementSize;
    }
    goto LABEL_19;
  }
LABEL_26:
  v12 = v4;
  return (v12 - v5) / ElementSize;
}


// ========== Function: _fputs @ 0x40ED43 ==========
int __cdecl fputs(const char *Buffer, FILE *Stream)
{
  size_t v2; // edi
  int v3; // ebx
  const char *Buffera; // [esp+14h] [ebp+8h]

  v2 = strlen(Buffer);
  _lock_file(Stream);
  v3 = _stbuf(Stream);
  Buffera = (const char *)fwrite(Buffer, 1u, v2, Stream);
  _ftbuf(v3, Stream);
  _unlock_file(Stream);
  return (Buffera == (const char *)v2) - 1;
}


// ========== Function: _fgets @ 0x40ED91 ==========
char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream)
{
  char *v3; // ebx
  char *v4; // edi
  int v7; // eax

  v3 = Buffer;
  v4 = Buffer;
  if ( MaxCount <= 0 )
    return 0;
  _lock_file(Stream);
  do
  {
    if ( !--MaxCount )
      break;
    if ( --Stream->_cnt < 0 )
      v7 = _filbuf(Stream);
    else
      v7 = *(unsigned __int8 *)Stream->_ptr++;
    if ( v7 == -1 )
    {
      if ( v4 == Buffer )
      {
        v3 = 0;
        goto LABEL_14;
      }
      break;
    }
    *v4++ = v7;
  }
  while ( (_BYTE)v7 != 10 );
  *v4 = 0;
LABEL_14:
  _unlock_file(Stream);
  return v3;
}


// ========== Function: _ftell @ 0x40EDF3 ==========
int __cdecl ftell(FILE *Stream)
{
  int v1; // edi

  _lock_file(Stream);
  v1 = _ftell_lk(Stream);
  _unlock_file(Stream);
  return v1;
}


// ========== Function: __ftell_lk @ 0x40EE15 ==========
int __cdecl _ftell_lk(int a1)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  unsigned int v6; // eax
  int v7; // edx
  _BYTE *i; // ecx
  int v9; // ecx
  _DWORD *v10; // ebx
  int v11; // esi
  _BYTE *v12; // eax
  _BYTE *v13; // ecx
  bool v14; // zf
  int v15; // eax
  int v16; // ecx
  int FileHandle; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]
  int Offset; // [esp+14h] [ebp-4h]
  unsigned int v20; // [esp+20h] [ebp+8h]

  v2 = *(_DWORD *)(a1 + 16);
  FileHandle = v2;
  if ( *(int *)(a1 + 4) < 0 )
    *(_DWORD *)(a1 + 4) = 0;
  v3 = _lseek(v2, 0, 1);
  Offset = v3;
  if ( v3 < 0 )
    return -1;
  v4 = *(_DWORD *)(a1 + 12);
  if ( (v4 & 0x108) == 0 )
    return v3 - *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  v18 = *(_DWORD *)a1 - v7;
  if ( (v4 & 3) != 0 )
  {
    if ( *(char *)(dword_43A7C0[v2 >> 5] + 36 * (v2 & 0x1F) + 4) < 0 )
    {
      for ( i = *(_BYTE **)(a1 + 8); (unsigned int)i < v6; ++i )
      {
        if ( *i == 10 )
          ++v18;
      }
    }
    goto LABEL_16;
  }
  if ( (v4 & 0x80u) == 0 )
  {
    *_errno() = 22;
    return -1;
  }
LABEL_16:
  if ( !Offset )
    return v18;
  if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    if ( v9 )
    {
      v20 = v9 + v6 - v7;
      v10 = (_DWORD *)(4 * (v2 >> 5) + 4433856);
      v11 = 36 * (v2 & 0x1F);
      if ( *(char *)(v11 + *v10 + 4) < 0 )
      {
        if ( _lseek(FileHandle, 0, 2) == Offset )
        {
          v12 = *(_BYTE **)(a1 + 8);
          v13 = &v12[v20];
          while ( v12 < v13 )
          {
            if ( *v12 == 10 )
              ++v20;
            ++v12;
          }
          v14 = (*(_BYTE *)(a1 + 13) & 0x20) == 0;
        }
        else
        {
          _lseek(FileHandle, Offset, 0);
          v15 = 512;
          if ( v20 > 0x200 || (v16 = *(_DWORD *)(a1 + 12), (v16 & 8) == 0) || (v16 & 0x400) != 0 )
            v15 = *(_DWORD *)(a1 + 24);
          v20 = v15;
          v14 = (*(_BYTE *)(v11 + *v10 + 4) & 4) == 0;
        }
        if ( !v14 )
          ++v20;
      }
      Offset -= v20;
    }
    else
    {
      v18 = 0;
    }
  }
  return Offset + v18;
}


// ========== Function: _fseek @ 0x40EF76 ==========
int __cdecl fseek(FILE *Stream, int Offset, int Origin)
{
  int v3; // esi

  _lock_file(Stream);
  v3 = _fseek_lk((int)Stream, Offset, Origin);
  _unlock_file(Stream);
  return v3;
}


// ========== Function: __fseek_lk @ 0x40EFA2 ==========
int __cdecl _fseek_lk(_DWORD *a1, int Offset, unsigned int Origin)
{
  int v3; // eax
  int v4; // edi
  int v5; // eax

  v3 = a1[3];
  if ( (v3 & 0x83) != 0 && (v4 = Origin, Origin <= 2) )
  {
    LOBYTE(v3) = v3 & 0xEF;
    a1[3] = v3;
    if ( Origin == 1 )
    {
      Offset += _ftell_lk((int)a1);
      v4 = 0;
    }
    _flush(a1);
    v5 = a1[3];
    if ( (v5 & 0x80u) == 0 )
    {
      if ( (v5 & 1) != 0 && (v5 & 8) != 0 && (v5 & 0x400) == 0 )
        a1[6] = 512;
    }
    else
    {
      LOBYTE(v5) = v5 & 0xFC;
      a1[3] = v5;
    }
    return (_lseek(a1[4], Offset, v4) != -1) - 1;
  }
  else
  {
    *_errno() = 22;
    return -1;
  }
}


// ========== Function: _fflush @ 0x40F02F ==========
int __cdecl fflush(FILE *Stream)
{
  int v2; // edi

  if ( !Stream )
    return flsall(0);
  _lock_file(Stream);
  v2 = _fflush_lk(Stream);
  _unlock_file(Stream);
  return v2;
}


// ========== Function: __fflush_lk @ 0x40F05E ==========
int __cdecl _fflush_lk(int a1)
{
  if ( _flush(a1) )
    return -1;
  if ( (*(_BYTE *)(a1 + 13) & 0x40) != 0 )
    return -(_commit(*(_DWORD *)(a1 + 16)) != 0);
  return 0;
}


// ========== Function: __flush @ 0x40F08C ==========
int __cdecl _flush(_DWORD *a1)
{
  int v1; // ebx
  const void *v2; // eax
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( (a1[3] & 3) == 2 && (a1[3] & 0x108) != 0 )
  {
    v2 = (const void *)a1[2];
    if ( *a1 - (int)v2 > 0 )
    {
      v3 = *a1 - (_DWORD)v2;
      if ( _write(a1[4], v2, v3) == v3 )
      {
        v4 = a1[3];
        if ( (v4 & 0x80u) != 0 )
        {
          LOBYTE(v4) = v4 & 0xFD;
          a1[3] = v4;
        }
      }
      else
      {
        a1[3] |= 0x20u;
        v1 = -1;
      }
    }
  }
  v5 = a1[2];
  a1[1] = 0;
  *a1 = v5;
  return v1;
}


// ========== Function: sub_40F0E8 @ 0x40F0E8 ==========
int sub_40F0E8()
{
  return flsall(1);
}


// ========== Function: _flsall @ 0x40F0F1 ==========
int __cdecl flsall(int a1)
{
  int v1; // ebx
  int v2; // edi
  int i; // esi
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int result; // eax

  v1 = 0;
  v2 = 0;
  _lock(2);
  for ( i = 0; i < dword_43A780; ++i )
  {
    v4 = *(_DWORD *)(dword_439778 + 4 * i);
    if ( v4 && (*(_BYTE *)(v4 + 12) & 0x83) != 0 )
    {
      _lock_file2(i, *(_DWORD *)(dword_439778 + 4 * i));
      v5 = *(_DWORD *)(dword_439778 + 4 * i);
      v6 = *(_DWORD *)(v5 + 12);
      if ( (v6 & 0x83) != 0 )
      {
        if ( a1 == 1 )
        {
          if ( _fflush_lk(v5) != -1 )
            ++v1;
        }
        else if ( !a1 && (v6 & 2) != 0 && _fflush_lk(*(_DWORD *)(dword_439778 + 4 * i)) == -1 )
        {
          v2 = -1;
        }
      }
      _unlock_file2(i, *(_DWORD *)(dword_439778 + 4 * i));
    }
  }
  _unlock(2);
  result = v1;
  if ( a1 != 1 )
    return v2;
  return result;
}


// ========== Function: _fclose @ 0x40F195 ==========
int __cdecl fclose(FILE *Stream)
{
  int v1; // edi

  v1 = -1;
  if ( (Stream->_flag & 0x40) != 0 )
  {
    Stream->_flag = 0;
  }
  else
  {
    _lock_file(Stream);
    v1 = _fclose_lk(Stream);
    _unlock_file(Stream);
  }
  return v1;
}


// ========== Function: __fclose_lk @ 0x40F1C6 ==========
int __cdecl _fclose_lk(int a1)
{
  int v1; // edi

  v1 = -1;
  if ( (*(_BYTE *)(a1 + 12) & 0x83) != 0 )
  {
    v1 = _flush((_DWORD *)a1);
    _freebuf(a1);
    if ( _close(*(_DWORD *)(a1 + 16)) >= 0 )
    {
      if ( *(_DWORD *)(a1 + 28) )
      {
        sub_40D386(*(LPVOID *)(a1 + 28));
        *(_DWORD *)(a1 + 28) = 0;
      }
    }
    else
    {
      v1 = -1;
    }
  }
  *(_DWORD *)(a1 + 12) = 0;
  return v1;
}


// ========== Function: _abs @ 0x40F212 ==========
int __cdecl abs(int Number)
{
  int result; // eax

  result = Number;
  if ( Number < 0 )
    return -Number;
  return result;
}


// ========== Function: sub_40F21D @ 0x40F21D ==========
LPVOID __cdecl sub_40F21D(LPVOID lpMem, unsigned int a2)
{
  unsigned int v2; // esi
  int block; // eax
  SIZE_T v5; // esi
  int v6; // eax
  int v7; // [esp+Ch] [ebp-2Ch] BYREF
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h] BYREF
  int v10; // [esp+18h] [ebp-20h]
  LPVOID v11; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h] BYREF

  v2 = a2;
  if ( a2 > 0xFFFFFFE0 )
    return 0;
  if ( dword_43A7A4 == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    block = __sbh_find_block(lpMem);
    v10 = block;
    if ( block )
    {
      v11 = 0;
      if ( a2 <= dword_43A79C )
      {
        if ( __sbh_resize_block(block, lpMem, a2) )
          v11 = lpMem;
      }
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    if ( v10 )
      return v11;
    goto LABEL_20;
  }
  if ( dword_43A7A4 != 2 )
  {
LABEL_20:
    if ( !a2 )
      v2 = 1;
    v5 = (v2 + 15) & 0xFFFFFFF0;
    return HeapReAlloc(hHeap, 0x10u, lpMem, v5);
  }
  if ( !a2 )
    v2 = 1;
  v5 = (v2 + 15) & 0xFFFFFFF0;
  _lock(9);
  ms_exc.registration.TryLevel = 1;
  v6 = sub_4126C3(lpMem, &v7, &v9);
  v8 = v6;
  if ( v6 )
  {
    v11 = 0;
    if ( v5 <= dword_4368B4 && sub_412A8B(v7, v9, v6, v5 >> 4) )
      v11 = lpMem;
    _local_unwind2((int)&ms_exc.registration, -1);
    return v11;
  }
  ms_exc.registration.TryLevel = -1;
  _unlock(9);
  if ( !v8 )
    return HeapReAlloc(hHeap, 0x10u, lpMem, v5);
  return v11;
}


// ========== Function: sub_40F381 @ 0x40F381 ==========
SIZE_T __cdecl sub_40F381(_DWORD *lpMem)
{
  int v1; // esi
  bool v2; // zf
  unsigned __int8 *v3; // eax
  _BYTE v5[4]; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned __int8 *v6; // [esp+10h] [ebp-28h]
  _BYTE v7[4]; // [esp+14h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-20h]
  int block; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( dword_43A7A4 == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    block = __sbh_find_block(lpMem);
    if ( block )
    {
      v1 = *(lpMem - 1) - 9;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = block == 0;
  }
  else
  {
    if ( dword_43A7A4 != 2 )
      return HeapSize(hHeap, 0, lpMem);
    _lock(9);
    ms_exc.registration.TryLevel = 1;
    v3 = (unsigned __int8 *)sub_4126C3(lpMem, v5, v7);
    v6 = v3;
    if ( v3 )
    {
      v1 = 16 * *v3;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = v6 == 0;
  }
  if ( v2 )
    return HeapSize(hHeap, 0, lpMem);
  return v1;
}


// ========== Function: __setmbcp @ 0x40F46F ==========
int __cdecl _setmbcp(int CodePage)
{
  UINT SystemCP; // eax
  UINT v2; // ebx
  int v3; // esi
  int v4; // edx
  _DWORD *v5; // eax
  bool v6; // cc
  BYTE *v7; // ecx
  BYTE v8; // dl
  unsigned int i; // eax
  int v10; // esi
  char *v11; // ebx
  unsigned __int8 *v12; // ecx
  unsigned __int8 v13; // dl
  unsigned int v14; // eax
  unsigned int v15; // edi
  char v16; // dl
  LCID v17; // eax
  _DWORD *v18; // esi
  unsigned int j; // eax
  _cpinfo CPInfo; // [esp+Ch] [ebp-18h] BYREF
  unsigned int v22; // [esp+20h] [ebp-4h]
  int CodePagea; // [esp+2Ch] [ebp+8h]

  _lock(25);
  SystemCP = getSystemCP(CodePage);
  v2 = SystemCP;
  CodePagea = SystemCP;
  if ( SystemCP == ::CodePage )
  {
LABEL_2:
    v3 = 0;
    goto LABEL_34;
  }
  if ( !SystemCP )
  {
LABEL_31:
    setSBCS();
LABEL_32:
    setSBUpLow();
    goto LABEL_2;
  }
  v4 = 0;
  v5 = &unk_4342B0;
  do
  {
    if ( *v5 == v2 )
    {
      v22 = 0;
      memset(&unk_43A9E0, 0, 0x100u);
      v10 = 48 * v4;
      *((_BYTE *)&unk_43A9E0 + 256) = 0;
      v11 = (char *)&unk_4342C0 + 48 * v4;
      do
      {
        v12 = (unsigned __int8 *)v11;
        if ( *v11 )
        {
          do
          {
            v13 = v12[1];
            if ( !v13 )
              break;
            v14 = *v12;
            v15 = v13;
            if ( v14 <= v13 )
            {
              v16 = byte_4342A8[v22];
              do
                byte_43A9E1[v14++] |= v16;
              while ( v14 <= v15 );
            }
            v12 += 2;
          }
          while ( *v12 );
        }
        ++v22;
        v11 += 8;
      }
      while ( v22 < 4 );
      dword_43A8DC = 1;
      ::CodePage = CodePagea;
      v17 = CPtoLCID(CodePagea);
      v18 = (_DWORD *)((char *)&unk_4342B4 + v10);
      dword_43A8D0[0] = *v18++;
      dword_43A8D0[1] = *v18;
      Locale = v17;
      dword_43A8D0[2] = v18[1];
      goto LABEL_32;
    }
    v5 += 12;
    ++v4;
  }
  while ( v5 < dword_4343A0 );
  if ( GetCPInfo(v2, &CPInfo) )
  {
    Locale = 0;
    v6 = CPInfo.MaxCharSize <= 1;
    memset(&unk_43A9E0, 0, 0x100u);
    *((_BYTE *)&unk_43A9E0 + 256) = 0;
    ::CodePage = v2;
    if ( v6 )
    {
      dword_43A8DC = 0;
    }
    else
    {
      if ( CPInfo.LeadByte[0] )
      {
        v7 = &CPInfo.LeadByte[1];
        do
        {
          v8 = *v7;
          if ( !*v7 )
            break;
          for ( i = *(v7 - 1); i <= v8; ++i )
            byte_43A9E1[i] |= 4u;
          v7 += 2;
        }
        while ( *(v7 - 1) );
      }
      for ( j = 1; j < 0xFF; ++j )
        byte_43A9E1[j] |= 8u;
      Locale = CPtoLCID(v2);
      dword_43A8DC = 1;
    }
    dword_43A8D0[0] = 0;
    dword_43A8D0[1] = 0;
    dword_43A8D0[2] = 0;
    goto LABEL_32;
  }
  if ( dword_4393FC )
    goto LABEL_31;
  v3 = -1;
LABEL_34:
  _unlock(25);
  return v3;
}


// ========== Function: _getSystemCP @ 0x40F61C ==========
UINT __cdecl getSystemCP(UINT a1)
{
  UINT result; // eax

  result = a1;
  dword_4393FC = 0;
  switch ( a1 )
  {
    case 0xFFFFFFFE:
      dword_4393FC = 1;
      return GetOEMCP();
    case 0xFFFFFFFD:
      dword_4393FC = 1;
      return GetACP();
    case 0xFFFFFFFC:
      result = dword_4395EC;
      dword_4393FC = 1;
      break;
  }
  return result;
}


// ========== Function: _CPtoLCID @ 0x40F666 ==========
int __cdecl CPtoLCID(int a1)
{
  switch ( a1 )
  {
    case 932:
      return 1041;
    case 936:
      return 2052;
    case 949:
      return 1042;
    case 950:
      return 1028;
  }
  return 0;
}


// ========== Function: _setSBCS @ 0x40F699 ==========
int setSBCS()
{
  int result; // eax

  memset(&unk_43A9E0, 0, 0x100u);
  *((_BYTE *)&unk_43A9E0 + 256) = 0;
  result = 0;
  CodePage = 0;
  dword_43A8DC = 0;
  Locale = 0;
  dword_43A8D0[0] = 0;
  dword_43A8D0[1] = 0;
  dword_43A8D0[2] = 0;
  return result;
}


// ========== Function: _setSBUpLow @ 0x40F6C2 ==========
unsigned int setSBUpLow()
{
  unsigned int i; // eax
  BYTE v1; // al
  BYTE *v2; // edx
  unsigned int v3; // ecx
  unsigned int result; // eax
  WORD *j; // ecx
  char v6; // dl
  char v7; // cl
  WORD CharType[256]; // [esp+4h] [ebp-514h] BYREF
  CHAR v9[256]; // [esp+204h] [ebp-314h] BYREF
  CHAR DestStr[256]; // [esp+304h] [ebp-214h] BYREF
  CHAR SrcStr[256]; // [esp+404h] [ebp-114h] BYREF
  struct _cpinfo CPInfo; // [esp+504h] [ebp-14h] BYREF

  if ( GetCPInfo(CodePage, &CPInfo) )
  {
    for ( i = 0; i < 0x100; ++i )
      SrcStr[i] = i;
    v1 = CPInfo.LeadByte[0];
    SrcStr[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v2 = &CPInfo.LeadByte[1];
      do
      {
        v3 = *v2;
        if ( v1 <= v3 )
          memset(&SrcStr[v1], 0x20u, v3 - v1 + 1);
        v2 += 2;
        v1 = *(v2 - 1);
      }
      while ( v1 );
    }
    __crtGetStringTypeA(1u, SrcStr, 256, CharType, CodePage, Locale, 0);
    __crtLCMapStringA(Locale, 0x100u, SrcStr, 256, DestStr, 256, CodePage, 0);
    __crtLCMapStringA(Locale, 0x200u, SrcStr, 256, v9, 256, CodePage, 0);
    result = 0;
    for ( j = CharType; ; ++j )
    {
      if ( (*j & 1) != 0 )
      {
        byte_43A9E1[result] |= 0x10u;
        v6 = DestStr[result];
      }
      else
      {
        if ( (*j & 2) == 0 )
        {
          byte_43A8E0[result] = 0;
          goto LABEL_16;
        }
        byte_43A9E1[result] |= 0x20u;
        v6 = v9[result];
      }
      byte_43A8E0[result] = v6;
LABEL_16:
      if ( ++result >= 0x100 )
        return result;
    }
  }
  for ( result = 0; result < 0x100; ++result )
  {
    if ( result >= 0x41 && result <= 0x5A )
    {
      byte_43A9E1[result] |= 0x10u;
      v7 = result + 32;
LABEL_22:
      byte_43A8E0[result] = v7;
      continue;
    }
    if ( result >= 0x61 && result <= 0x7A )
    {
      byte_43A9E1[result] |= 0x20u;
      v7 = result - 32;
      goto LABEL_22;
    }
    byte_43A8E0[result] = 0;
  }
  return result;
}


// ========== Function: ___initmbctable @ 0x40F847 ==========
int __initmbctable()
{
  int result; // eax

  if ( !dword_43AAEC )
  {
    result = _setmbcp(-3);
    dword_43AAEC = 1;
  }
  return result;
}


// ========== Function: __ftol @ 0x40F864 ==========
__int64 __usercall _ftol@<edx:eax>(double a1@<st0>)
{
  return (__int64)a1;
}


// ========== Function: _wcscpy @ 0x40F88B ==========
wchar_t *__cdecl wcscpy(wchar_t *Destination, const wchar_t *Source)
{
  const wchar_t *v2; // ecx
  wchar_t *result; // eax
  wchar_t v4; // dx
  wchar_t *v5; // esi

  v2 = Source;
  result = Destination;
  v4 = *Source;
  v5 = Destination + 1;
  *Destination = *Source;
  while ( 1 )
  {
    ++v2;
    if ( !v4 )
      break;
    v4 = *v2;
    *v5++ = *v2;
  }
  return result;
}


// ========== Function: _wcsncpy @ 0x40F8B0 ==========
wchar_t *__cdecl wcsncpy(wchar_t *Destination, const wchar_t *Source, size_t Count)
{
  size_t v3; // ecx
  wchar_t *v4; // edi
  wchar_t v6; // ax
  size_t v7; // ecx
  char v8; // cf
  size_t v9; // ecx
  wchar_t *v10; // edi
  int i; // ecx

  v3 = Count;
  v4 = Destination;
  if ( Count )
  {
    do
    {
      v6 = *Source;
      *v4++ = *Source++;
      if ( !v6 )
        break;
      --v3;
    }
    while ( v3 );
    if ( v3 )
    {
      v7 = v3 - 1;
      if ( v7 )
      {
        v8 = v7 & 1;
        v9 = v7 >> 1;
        memset(v4, 0, 4 * v9);
        v10 = &v4[2 * v9];
        for ( i = v8; i; --i )
          *v10++ = 0;
      }
    }
  }
  return Destination;
}


// ========== Function: sub_40F8ED @ 0x40F8ED ==========
void *__cdecl sub_40F8ED(LPVOID lpMem, SIZE_T dwBytes)
{
  void *v2; // ebx
  void *result; // eax
  SIZE_T v4; // esi
  int block; // eax
  size_t v6; // eax
  size_t v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // edi
  size_t v10; // eax
  size_t v11; // eax
  int v12; // [esp+Ch] [ebp-38h] BYREF
  size_t v13; // [esp+10h] [ebp-34h]
  unsigned __int8 *v14; // [esp+14h] [ebp-30h]
  int v15; // [esp+18h] [ebp-2Ch] BYREF
  int v16; // [esp+1Ch] [ebp-28h]
  void *v17; // [esp+20h] [ebp-24h]
  size_t v18; // [esp+24h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

  v2 = lpMem;
  if ( !lpMem )
    return malloc(dwBytes);
  v4 = dwBytes;
  if ( dwBytes )
  {
    if ( dword_43A7A4 == 3 )
    {
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 0;
          block = __sbh_find_block(lpMem);
          v16 = block;
          if ( block )
          {
            if ( v4 <= dword_43A79C )
            {
              if ( __sbh_resize_block(block, lpMem, v4) )
              {
                v17 = lpMem;
              }
              else
              {
                v17 = (void *)__sbh_alloc_block(v4);
                if ( v17 )
                {
                  v6 = *((_DWORD *)lpMem - 1) - 1;
                  v18 = v6;
                  if ( v6 >= v4 )
                    v6 = v4;
                  memcpy(v17, lpMem, v6);
                  v16 = __sbh_find_block(lpMem);
                  sub_411993(v16, lpMem);
                }
              }
            }
            if ( !v17 )
            {
              if ( !v4 )
                v4 = 1;
              v4 = (v4 + 15) & 0xFFFFFFF0;
              v17 = HeapAlloc(hHeap, 0, v4);
              if ( v17 )
              {
                v7 = *((_DWORD *)lpMem - 1) - 1;
                v18 = v7;
                if ( v7 >= v4 )
                  v7 = v4;
                memcpy(v17, lpMem, v7);
                sub_411993(v16, lpMem);
              }
            }
          }
          ms_exc.registration.TryLevel = -1;
          _unlock(9);
          if ( !v16 )
          {
            if ( !v4 )
              v4 = 1;
            v4 = (v4 + 15) & 0xFFFFFFF0;
            v17 = HeapReAlloc(hHeap, 0, lpMem, v4);
          }
        }
        result = v17;
        if ( v17 || !dword_4395B0 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
    else if ( dword_43A7A4 == 2 )
    {
      if ( dwBytes <= 0xFFFFFFE0 )
        v4 = (dwBytes + 15) & 0xFFFFFFF0;
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 1;
          v8 = (unsigned __int8 *)sub_4126C3(v2, &v12, &v15);
          v9 = v8;
          v14 = v8;
          if ( v8 )
          {
            if ( v4 < dword_4368B4 )
            {
              if ( sub_412A8B(v12, v15, v8, v4 >> 4) )
              {
                v17 = lpMem;
              }
              else
              {
                v17 = (void *)sub_41275F(v4 >> 4);
                if ( v17 )
                {
                  v10 = 16 * *v9;
                  v13 = v10;
                  if ( v10 >= v4 )
                    v10 = v4;
                  memcpy(v17, lpMem, v10);
                  sub_41271A(v12, v15, v9);
                }
              }
              v2 = lpMem;
            }
            if ( !v17 )
            {
              v17 = HeapAlloc(hHeap, 0, v4);
              if ( v17 )
              {
                v11 = 16 * *v9;
                v13 = v11;
                if ( v11 >= v4 )
                  v11 = v4;
                memcpy(v17, v2, v11);
                sub_41271A(v12, v15, v9);
              }
            }
          }
          else
          {
            v17 = HeapReAlloc(hHeap, 0, v2, v4);
          }
          ms_exc.registration.TryLevel = -1;
          _unlock(9);
        }
        result = v17;
        if ( v17 || !dword_4395B0 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
    else
    {
      while ( 1 )
      {
        result = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          if ( !v4 )
            v4 = 1;
          v4 = (v4 + 15) & 0xFFFFFFF0;
          result = HeapReAlloc(hHeap, 0, lpMem, v4);
        }
        if ( result || !dword_4395B0 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
  }
  else
  {
    sub_40D386(lpMem);
    return 0;
  }
  return result;
}


// ========== Function: _localtime @ 0x40FC1C ==========
struct tm *__cdecl localtime(const __time32_t *const Time)
{
  const __time32_t *v1; // esi
  int v3; // eax
  struct tm *v4; // eax
  struct tm *v5; // esi
  bool v6; // zf
  int tm_sec; // eax
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  bool v12; // sf
  int tm_mday; // eax

  v1 = Time;
  if ( *Time < 0 )
    return 0;
  __tzset();
  v3 = *v1;
  if ( *v1 > 259200 && v3 < 2147224447 )
  {
    Time = (const __time32_t *const)(v3 - dword_436C88);
    v4 = gmtime((const __time32_t *const)&Time);
    v5 = v4;
    if ( dword_436C8C )
    {
      if ( _isindst(v4) )
      {
        Time = (const __time32_t *const)((char *)Time - dword_436C90);
        v5 = gmtime((const __time32_t *const)&Time);
        v5->tm_isdst = 1;
      }
    }
    return v5;
  }
  v5 = gmtime(v1);
  v6 = _isindst(v5) == 0;
  tm_sec = v5->tm_sec;
  if ( !v6 )
    tm_sec -= dword_436C90;
  Time = (const __time32_t *const)(tm_sec - dword_436C88);
  v8 = (tm_sec - dword_436C88) % 60;
  v5->tm_sec = v8;
  if ( v8 < 0 )
  {
    v5->tm_sec = v8 + 60;
    Time -= 15;
  }
  Time = (const __time32_t *const)(v5->tm_min + (int)Time / 60);
  v9 = (int)Time % 60;
  v12 = (int)Time % 60 < 0;
  v5->tm_min = (int)Time % 60;
  if ( v12 )
  {
    v5->tm_min = v9 + 60;
    Time -= 15;
  }
  Time = (const __time32_t *const)(v5->tm_hour + (int)Time / 60);
  v10 = (int)Time % 24;
  v12 = (int)Time % 24 < 0;
  v5->tm_hour = (int)Time % 24;
  if ( v12 )
  {
    v5->tm_hour = v10 + 24;
    Time -= 6;
  }
  v11 = (int)Time / 24;
  v12 = (int)Time / 24 < 0;
  Time = (const __time32_t *const)((int)Time / 24);
  if ( (int)Time <= 0 )
  {
    if ( !v12 )
      return v5;
    v5->tm_wday = (v5->tm_wday + v11 + 7) % 7;
    v5->tm_mday += (int)Time;
    tm_mday = v5->tm_mday;
    if ( tm_mday <= 0 )
    {
      --v5->tm_year;
      v5->tm_mday = tm_mday + 31;
      v5->tm_yday = 364;
      v5->tm_mon = 11;
      return v5;
    }
  }
  else
  {
    v5->tm_wday = (v11 + v5->tm_wday) % 7;
    v5->tm_mday += (int)Time;
  }
  v5->tm_yday += (int)Time;
  return v5;
}


// ========== Function: _mktime @ 0x40FD7C ==========
__time32_t __cdecl mktime(struct tm *const Tm)
{
  return _make_time_t((__time32_t)Tm, 1);
}


// ========== Function: __make_time_t @ 0x40FD8A ==========
int __cdecl _make_time_t(int *Time, int a2)
{
  int *v2; // edi
  int v3; // ecx
  signed int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // esi
  int v10; // ecx
  BOOL v11; // eax
  int v12; // eax
  int v13; // esi
  int v14; // ecx
  BOOL v15; // eax
  int v16; // eax
  int v17; // esi
  int v18; // ecx
  BOOL v19; // eax
  int v20; // eax
  int v21; // edx
  struct tm *v22; // eax
  int v23; // ecx
  struct tm *v24; // esi
  int result; // eax

  v2 = Time;
  v3 = Time[5];
  if ( v3 < 69 || v3 > 139 )
    return -1;
  v4 = Time[4];
  if ( (unsigned int)v4 >= 0xC )
  {
    v3 += v4 / 12;
    Time[4] = v4 % 12;
    if ( v4 % 12 < 0 )
    {
      --v3;
      v2[4] = v4 % 12 + 12;
    }
    if ( v3 < 69 || v3 > 139 )
      return -1;
  }
  v5 = v2[4];
  v6 = dword_436E84[v5];
  if ( (v3 & 3) == 0 && v5 > 1 )
    ++v6;
  v7 = 365 * v3 + ((v3 - 1) >> 2) + v6 - 25567;
  v8 = v2[3];
  v9 = v7 + v8;
  if ( v7 < 0 )
  {
    if ( v8 < 0 && v9 >= 0 )
      return -1;
  }
  else if ( v8 >= 0 && v9 < 0 )
  {
    return -1;
  }
  v10 = 24 * v9;
  if ( v9 )
    v11 = v10 / v9 != 24;
  else
    v11 = 0;
  if ( v11 )
    return -1;
  v12 = v2[2];
  v13 = v12 + v10;
  if ( v10 < 0 )
  {
    if ( v12 < 0 && v13 >= 0 )
      return -1;
  }
  else if ( v12 >= 0 && v13 < 0 )
  {
    return -1;
  }
  v14 = 60 * v13;
  if ( v13 )
    v15 = v14 / v13 != 60;
  else
    v15 = 0;
  if ( v15 )
    return -1;
  v16 = v2[1];
  v17 = v16 + v14;
  if ( v14 < 0 )
  {
    if ( v16 < 0 && v17 >= 0 )
      return -1;
  }
  else if ( v16 >= 0 && v17 < 0 )
  {
    return -1;
  }
  v18 = 60 * v17;
  if ( v17 )
    v19 = v18 / v17 != 60;
  else
    v19 = 0;
  if ( v19 )
    return -1;
  v20 = *v2;
  v21 = *v2 + v18;
  Time = (int *)v21;
  if ( v18 < 0 )
  {
    if ( v20 < 0 && v21 >= 0 )
      return -1;
  }
  else if ( v20 >= 0 && v21 < 0 )
  {
    return -1;
  }
  if ( a2 )
  {
    __tzset();
    Time = (int *)((char *)Time + dword_436C88);
    v22 = localtime((const __time32_t *const)&Time);
    if ( v22 )
    {
      v23 = v2[8];
      if ( v23 > 0 || v23 < 0 && v22->tm_isdst > 0 )
      {
        Time = (int *)((char *)Time + dword_436C90);
        v22 = localtime((const __time32_t *const)&Time);
      }
      goto LABEL_54;
    }
  }
  else
  {
    v22 = gmtime((const __time32_t *const)&Time);
    if ( v22 )
    {
LABEL_54:
      v24 = v22;
      result = (int)Time;
      qmemcpy(v2, v24, 0x24u);
      return result;
    }
  }
  return -1;
}


// ========== Function: _gmtime @ 0x40FF6E ==========
struct tm *__cdecl gmtime(const __time32_t *const Time)
{
  __time32_t v1; // esi
  int v2; // ebx
  int v3; // eax
  int v4; // edi
  void *v6; // eax
  struct tm *v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // edx
  int *v11; // edi
  int v12; // esi
  int v13; // eax
  int *i; // ebx
  int tm_yday; // edx
  int v16; // eax
  int v17; // esi

  v1 = *Time;
  v2 = 0;
  v3 = _getptd();
  v4 = v3;
  if ( v1 < 0 )
    return 0;
  if ( *(_DWORD *)(v3 + 64) || (v6 = malloc(0x24u), *(_DWORD *)(v4 + 64) = v6, v7 = (struct tm *)&unk_439418, v6) )
    v7 = *(struct tm **)(v4 + 64);
  v8 = v1 / 126230400;
  v9 = v1 % 126230400;
  v10 = 4 * v8 + 70;
  if ( v9 >= 31536000 )
  {
    v9 -= 31536000;
    v10 = 4 * v8 + 71;
    if ( v9 >= 31536000 )
    {
      v9 -= 31536000;
      v10 = 4 * v8 + 72;
      if ( v9 < 31622400 )
      {
        v2 = 1;
      }
      else
      {
        v10 = 4 * v8 + 73;
        v9 -= 31622400;
      }
    }
  }
  v7->tm_year = v10;
  v11 = &dword_436E50;
  v7->tm_yday = v9 / 86400;
  v12 = v9 % 86400;
  if ( !v2 )
    v11 = dword_436E84;
  v13 = 1;
  for ( i = v11 + 1; *i < v7->tm_yday; ++i )
    ++v13;
  tm_yday = v7->tm_yday;
  v16 = v13 - 1;
  v7->tm_mon = v16;
  v7->tm_mday = tm_yday - v11[v16];
  v7->tm_wday = (*Time / 86400 + 4) % 7;
  v7->tm_hour = v12 / 3600;
  v17 = v12 % 3600;
  v7->tm_min = v17 / 60;
  v7->tm_isdst = 0;
  v7->tm_sec = v17 % 60;
  return v7;
}


// ========== Function: __except_handler3 @ 0x410080 ==========
int __cdecl _except_handler3(int a1, _DWORD *TargetFrame, int a3)
{
  int *v3; // ebp
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  _DWORD v11[2]; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = &savedregs;
  v4 = TargetFrame;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind2((int)TargetFrame, -1);
    return 1;
  }
  else
  {
    v11[0] = a1;
    v11[1] = a3;
    *(TargetFrame - 1) = v11;
    v5 = TargetFrame[3];
    v6 = TargetFrame[2];
    while ( v5 != -1 )
    {
      if ( *(_DWORD *)(v6 + 12 * v5 + 4) )
      {
        v7 = (*(int (**)(void))(v6 + 12 * v5 + 4))();
        v4 = (_DWORD *)v3[3];
        if ( v7 )
        {
          if ( v7 < 0 )
            return 0;
          v8 = v4[2];
          _global_unwind2((PVOID)v3[3]);
          v3 = v4 + 4;
          _local_unwind2((int)v4, v5);
          _NLG_Notify(*(_DWORD *)(v8 + 12 * v5 + 8), (int)(v4 + 4), 1);
          v4[3] = *(_DWORD *)(v8 + 4 * v9);
          (*(void (**)(void))(v8 + 4 * v9 + 8))();
        }
      }
      v6 = v4[2];
      v5 = *(_DWORD *)(v6 + 12 * v5);
    }
    return 1;
  }
}


// ========== Function: __seh_longjmp_unwind@4 @ 0x41013D ==========
int __stdcall _seh_longjmp_unwind(int a1)
{
  return _local_unwind2(*(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28));
}


// ========== Function: ?terminate@@YAXXZ @ 0x410158 ==========
void __cdecl __noreturn terminate()
{
  int v0; // eax

  if ( *(_DWORD *)(_getptd() + 96) )
  {
    v0 = _getptd();
    (*(void (**)(void))(v0 + 96))();
  }
  abort();
}


// ========== Function: sub_4101B9 @ 0x4101B9 ==========
void __thiscall __noreturn sub_4101B9(EXCEPTION_POINTERS *this)
{
  int v1; // [esp-Ch] [ebp-24h] BYREF
  CPPEH_RECORD ms_exc; // [esp+0h] [ebp-18h]

  ms_exc.registration.ScopeTable = stru_42BF40;
  ms_exc.registration.ExceptionHandler = _except_handler3;
  ms_exc.registration.Next = (struct _EH3_EXCEPTION_REGISTRATION *)NtCurrentTeb()->NtTib.ExceptionList;
  ms_exc.exc_ptr = this;
  ms_exc.old_esp = (DWORD)&v1;
  ms_exc.registration.TryLevel = 0;
  if ( off_434460 )
  {
    ms_exc.registration.TryLevel = 1;
    off_434460();
  }
  ms_exc.registration.TryLevel = -1;
  terminate();
}


// ========== Function: ___InternalCxxFrameHandler @ 0x41020F ==========
int __cdecl __InternalCxxFrameHandler(
        struct EHExceptionRecord *a1,
        struct EHRegistrationNode *a2,
        struct _CONTEXT *a3,
        void *a4,
        struct _s_FuncInfo *a5,
        int a6,
        struct EHRegistrationNode *a7,
        unsigned __int8 a8)
{
  EXCEPTION_POINTERS *v8; // ecx
  int (__cdecl *pForwardCompat)(); // ecx

  if ( *(_DWORD *)a5 != 429065504 )
    sub_4101B9(v8);
  if ( (a1->ExceptionFlags & 0x66) != 0 )
  {
    if ( a5->maxState )
    {
      if ( !a6 )
        __FrameUnwindToState(a2, a4, a5, -1);
    }
  }
  else if ( a5->nTryBlocks )
  {
    if ( a1->ExceptionCode == -529697949 && a1->params.magicNumber > 0x19930520 )
    {
      pForwardCompat = a1->params.pThrowInfo->pForwardCompat;
      if ( pForwardCompat )
        return ((int (__cdecl *)(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, struct _s_FuncInfo *, int, struct EHRegistrationNode *, _DWORD))pForwardCompat)(
                 a1,
                 a2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8);
    }
    FindHandler(a1, a2, a3, a4, a5, a8, a6, a7);
  }
  return 1;
}


// ========== Function: ?FindHandler@@YAXPAUEHExceptionRecord@@PAUEHRegistrationNode@@PAU_CONTEXT@@PAXPBU_s_FuncInfo@@EH1@Z @ 0x4102AA ==========
void __cdecl FindHandler(
        struct EHExceptionRecord *ExceptionRecord,
        struct EHRegistrationNode *a2,
        struct _CONTEXT *a3,
        void *a4,
        EXCEPTION_POINTERS *a5,
        char a6,
        int a7,
        struct EHRegistrationNode *TargetFrame)
{
  EXCEPTION_POINTERS *v8; // ecx
  struct EHExceptionRecord *v9; // esi
  int v10; // edi
  const struct _s_TryBlockMapEntry *v11; // ebx
  CatchableTypeArray *pCatchableTypeArray; // eax
  const struct _s_CatchableType **arrayOfCatchableTypes; // edi
  EXCEPTION_POINTERS *v14; // [esp-10h] [ebp-28h]
  unsigned int v15; // [esp+0h] [ebp-18h] BYREF
  unsigned __int8 v16[4]; // [esp+4h] [ebp-14h]
  int state; // [esp+8h] [ebp-10h]
  int nCatches; // [esp+Ch] [ebp-Ch]
  int nCatchableTypes; // [esp+10h] [ebp-8h]
  unsigned int v20; // [esp+14h] [ebp-4h] BYREF
  const struct _s_HandlerType *ExceptionRecorda; // [esp+20h] [ebp+8h]

  v16[0] = 0;
  state = a2->state;
  if ( state < -1 || (v8 = a5, state >= (int)a5->ContextRecord) )
    sub_4101B9(v8);
  v9 = ExceptionRecord;
  if ( ExceptionRecord->ExceptionCode != -529697949 )
    goto LABEL_35;
  if ( ExceptionRecord->NumberParameters == 3
    && ExceptionRecord->params.magicNumber == 429065504
    && !ExceptionRecord->params.pThrowInfo )
  {
    if ( !*(_DWORD *)(_getptd() + 108) )
      return;
    v9 = *(struct EHExceptionRecord **)(_getptd() + 108);
    a3 = *(struct _CONTEXT **)(_getptd() + 112);
    v16[0] = 1;
    if ( !_ValidateRead(v9, 1u) )
      sub_4101B9(v14);
    if ( v9->ExceptionCode != -529697949 )
      goto LABEL_35;
    if ( v9->NumberParameters == 3 && v9->params.magicNumber == 429065504 && !v9->params.pThrowInfo )
      sub_4101B9(v14);
  }
  if ( v9->ExceptionCode != -529697949 || v9->NumberParameters != 3 || v9->params.magicNumber != 429065504 )
  {
LABEL_35:
    if ( a6 )
      terminate();
    FindHandlerForForeignException(v9, a2, a3, a4, (const struct _s_FuncInfo *)a5, state, a7, TargetFrame);
    return;
  }
  v10 = state;
  v11 = (const struct _s_TryBlockMapEntry *)_GetRangeOfTrysToCheck(
                                              (const struct _s_FuncInfo *)a5,
                                              a7,
                                              state,
                                              &v20,
                                              &v15);
  while ( v20 < v15 )
  {
    if ( v11->tryLow <= v10 && v10 <= v11->tryHigh )
    {
      ExceptionRecorda = (const struct _s_HandlerType *)v11->pHandlerArray;
      nCatches = v11->nCatches;
      if ( nCatches > 0 )
      {
        while ( 1 )
        {
          pCatchableTypeArray = v9->params.pThrowInfo->pCatchableTypeArray;
          arrayOfCatchableTypes = (const struct _s_CatchableType **)pCatchableTypeArray->arrayOfCatchableTypes;
          nCatchableTypes = pCatchableTypeArray->nCatchableTypes;
          if ( nCatchableTypes > 0 )
            break;
LABEL_27:
          --nCatches;
          ++ExceptionRecorda;
          if ( nCatches <= 0 )
            goto LABEL_30;
        }
        while ( !TypeMatch(ExceptionRecorda, *arrayOfCatchableTypes, v9->params.pThrowInfo) )
        {
          --nCatchableTypes;
          ++arrayOfCatchableTypes;
          if ( nCatchableTypes <= 0 )
            goto LABEL_27;
        }
        CatchIt(
          (PEXCEPTION_RECORD)v9,
          a2,
          a3,
          a4,
          (const struct _s_FuncInfo *)a5,
          ExceptionRecorda,
          *arrayOfCatchableTypes,
          v11,
          a7,
          TargetFrame,
          v16[0]);
      }
LABEL_30:
      v10 = state;
    }
    ++v20;
    ++v11;
  }
  if ( a6 )
    unknown_libname_4(v9, 1);
}


// ========== Function: ?FindHandlerForForeignException@@YAXPAUEHExceptionRecord@@PAUEHRegistrationNode@@PAU_CONTEXT@@PAXPBU_s_FuncInfo@@HH1@Z @ 0x41045D ==========
void __cdecl FindHandlerForForeignException(
        EXCEPTION_RECORD *ExceptionRecord,
        struct EHRegistrationNode *a2,
        struct _CONTEXT *a3,
        void *a4,
        const struct _s_FuncInfo *a5,
        __ehstate_t a6,
        int a7,
        struct EHRegistrationNode *TargetFrame)
{
  const struct _s_TryBlockMapEntry *v8; // esi
  int v9; // eax
  int v10; // ecx
  unsigned int v11; // [esp+8h] [ebp-8h] BYREF
  unsigned int v12; // [esp+Ch] [ebp-4h] BYREF

  if ( !*(_DWORD *)(_getptd() + 104)
    || !_CallSETranslator((struct EHExceptionRecord *)ExceptionRecord, a2, a3, a4, a5, a7, TargetFrame) )
  {
    v8 = (const struct _s_TryBlockMapEntry *)_GetRangeOfTrysToCheck(a5, a7, a6, &v12, &v11);
    while ( v12 < v11 )
    {
      if ( a6 >= v8->tryLow && a6 <= v8->tryHigh )
      {
        v9 = (int)&v8->pHandlerArray[v8->nCatches];
        v10 = *(_DWORD *)(v9 - 12);
        if ( !v10 || !*(_BYTE *)(v10 + 8) )
          CatchIt(ExceptionRecord, a2, a3, a4, a5, (const struct _s_HandlerType *)(v9 - 16), 0, v8, a7, TargetFrame, 1u);
      }
      ++v12;
      ++v8;
    }
  }
}


// ========== Function: ?TypeMatch@@YAHPBU_s_HandlerType@@PBU_s_CatchableType@@PBU_s_ThrowInfo@@@Z @ 0x410507 ==========
BOOL __cdecl TypeMatch(
        const struct _s_HandlerType *a1,
        const struct _s_CatchableType *a2,
        const struct _s_ThrowInfo *a3)
{
  TypeDescriptor *pType; // eax
  TypeDescriptor *v4; // ecx
  BOOL result; // eax

  pType = a1->pType;
  result = 1;
  if ( pType && pType->name[0] )
  {
    v4 = a2->pType;
    if ( pType != v4 )
    {
      if ( strcmp(pType->name, v4->name) )
        return 0;
    }
    if ( (a2->properties & 2) != 0 && (a1->adjectives & 8) == 0
      || (a3->attributes & 1) != 0 && (a1->adjectives & 1) == 0
      || (a3->attributes & 2) != 0 && (a1->adjectives & 2) == 0 )
    {
      return 0;
    }
  }
  return result;
}


// ========== Function: ___FrameUnwindToState @ 0x410564 ==========
void __cdecl __FrameUnwindToState(int a1, int a2, int a3, int a4)
{
  EXCEPTION_POINTERS *v4; // ecx
  int i; // esi
  int v6; // eax

  for ( i = *(_DWORD *)(a1 + 8); i != a4; i = *(_DWORD *)(*(_DWORD *)(a3 + 8) + 8 * i) )
  {
    if ( i <= -1 || i >= *(_DWORD *)(a3 + 4) )
      sub_4101B9(v4);
    v6 = *(_DWORD *)(*(_DWORD *)(a3 + 8) + 8 * i + 4);
    if ( v6 )
      _CallSettingFrame(v6, a1, 259);
  }
  *(_DWORD *)(a1 + 8) = i;
}


// ========== Function: ?CatchIt@@YAXPAUEHExceptionRecord@@PAUEHRegistrationNode@@PAU_CONTEXT@@PAXPBU_s_FuncInfo@@PBU_s_HandlerType@@PBU_s_CatchableType@@PBU_s_TryBlockMapEntry@@H1E@Z @ 0x410602 ==========
void __cdecl CatchIt(
        struct EHExceptionRecord *ExceptionRecord,
        struct EHRegistrationNode *a2,
        struct _CONTEXT *a3,
        void *a4,
        const struct _s_FuncInfo *a5,
        struct _s_HandlerType *a6,
        const struct _s_CatchableType *a7,
        const struct _s_TryBlockMapEntry *a8,
        int a9,
        PVOID TargetFrame)
{
  void (__stdcall *v10)(void *, struct EHRegistrationNode *); // eax

  if ( a7 )
    BuildCatchObject(ExceptionRecord, a2, a6, a7);
  if ( TargetFrame )
    _UnwindNestedFrames((struct _EXCEPTION_REGISTRATION_RECORD **)a6, TargetFrame, (PEXCEPTION_RECORD)ExceptionRecord);
  else
    _UnwindNestedFrames((struct _EXCEPTION_REGISTRATION_RECORD **)a6, a2, (PEXCEPTION_RECORD)ExceptionRecord);
  __FrameUnwindToState((int)a2, (int)a4, (int)a5, a8->tryLow);
  a2->state = a8->tryHigh + 1;
  v10 = (void (__stdcall *)(void *, struct EHRegistrationNode *))CallCatchBlock(
                                                                   ExceptionRecord,
                                                                   a2,
                                                                   a3,
                                                                   a5,
                                                                   a6->addressOfHandler,
                                                                   a9,
                                                                   0x100u);
  if ( v10 )
    _JumpToContinuation(v10, a2);
}


// ========== Function: ?CallCatchBlock@@YAPAXPAUEHExceptionRecord@@PAUEHRegistrationNode@@PAU_CONTEXT@@PBU_s_FuncInfo@@PAXHK@Z @ 0x41067D ==========
void *__cdecl CallCatchBlock(
        struct EHExceptionRecord *a1,
        struct EHRegistrationNode *a2,
        struct _CONTEXT *a3,
        const struct _s_FuncInfo *a4,
        void *a5,
        int a6,
        unsigned int a7)
{
  char v8; // al
  void *v9; // [esp+Ch] [ebp-2Ch]
  __ehstate_t state; // [esp+10h] [ebp-28h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]

  state = a2[-1].state;
  v12 = *(_DWORD *)(_getptd() + 108);
  v11 = *(_DWORD *)(_getptd() + 112);
  *(_DWORD *)(_getptd() + 108) = a1;
  *(_DWORD *)(_getptd() + 112) = a3;
  v9 = _CallCatchBlock2(a2, a4, a5, a6, a7);
  a2[-1].state = state;
  *(_DWORD *)(_getptd() + 108) = v12;
  *(_DWORD *)(_getptd() + 112) = v11;
  if ( a1->ExceptionCode == -529697949 && a1->NumberParameters == 3 && a1->params.magicNumber == 429065504 && v9 )
  {
    v8 = _abnormal_termination();
    unknown_libname_4(a1, v8);
  }
  return v9;
}


// ========== Function: ?ExFilterRethrow@@YAHPAU_EXCEPTION_POINTERS@@@Z @ 0x410798 ==========
BOOL __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *a1)
{
  PEXCEPTION_RECORD ExceptionRecord; // eax

  ExceptionRecord = a1->ExceptionRecord;
  return a1->ExceptionRecord->ExceptionCode == -529697949
      && ExceptionRecord->NumberParameters == 3
      && ExceptionRecord->ExceptionInformation[0] == 429065504
      && !ExceptionRecord->ExceptionInformation[2];
}


// ========== Function: ?BuildCatchObject@@YAXPAUEHExceptionRecord@@PAUEHRegistrationNode@@PBU_s_HandlerType@@PBU_s_CatchableType@@@Z @ 0x4107C2 ==========
void __cdecl BuildCatchObject(
        struct EHExceptionRecord *a1,
        struct EHRegistrationNode *a2,
        const struct _s_HandlerType *a3,
        const struct _s_CatchableType *a4)
{
  TypeDescriptor *pType; // eax
  ptrdiff_t dispCatchObj; // eax
  void **v6; // edi
  int v7; // eax
  EXCEPTION_POINTERS *v8; // ecx
  int v9; // eax
  void *pExceptionObject; // eax
  void *v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  const void *v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  void *v20; // [esp-8h] [ebp-30h]
  EXCEPTION_POINTERS *v21; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v22; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v23; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v24; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v25; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v26; // [esp-4h] [ebp-2Ch]
  size_t sizeOrOffset; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v28; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v29; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v30; // [esp-4h] [ebp-2Ch]

  pType = a3->pType;
  if ( pType )
  {
    if ( pType->name[0] )
    {
      dispCatchObj = a3->dispCatchObj;
      if ( dispCatchObj )
      {
        v6 = (void **)((char *)&a2[1].pNext + dispCatchObj);
        if ( (a3->adjectives & 8) != 0 )
        {
          v7 = _ValidateRead(a1->params.pExceptionObject, 1u);
          v8 = v21;
          if ( v7 )
          {
            v9 = _ValidateWrite(v6, 1u);
            v8 = v22;
            if ( v9 )
            {
              pExceptionObject = a1->params.pExceptionObject;
              *v6 = pExceptionObject;
              v11 = AdjustPointer(pExceptionObject, &a4->thisDisplacement);
LABEL_8:
              *v6 = v11;
              return;
            }
          }
LABEL_25:
          sub_4101B9(v8);
        }
        if ( (a4->properties & 1) != 0 )
        {
          v12 = _ValidateRead(a1->params.pExceptionObject, 1u);
          v8 = v23;
          if ( !v12 )
            goto LABEL_25;
          v13 = _ValidateWrite(v6, 1u);
          v8 = v24;
          if ( !v13 )
            goto LABEL_25;
          memcpy_0(v6, a1->params.pExceptionObject, a4->sizeOrOffset);
          if ( a4->sizeOrOffset == 4 && *v6 )
          {
            v11 = AdjustPointer(*v6, &a4->thisDisplacement);
            goto LABEL_8;
          }
        }
        else
        {
          v20 = a1->params.pExceptionObject;
          if ( a4->copyFunction )
          {
            v17 = _ValidateRead(v20, 1u);
            v8 = v28;
            if ( !v17 )
              goto LABEL_25;
            v18 = _ValidateWrite(v6, 1u);
            v8 = v29;
            if ( !v18 )
              goto LABEL_25;
            v19 = _ValidateExecute((FARPROC)a4->copyFunction);
            v8 = v30;
            if ( !v19 )
              goto LABEL_25;
            if ( (a4->properties & 4) != 0 )
            {
              AdjustPointer(a1->params.pExceptionObject, &a4->thisDisplacement);
              sub_40CB22((int)v6, (int)a4->copyFunction);
            }
            else
            {
              AdjustPointer(a1->params.pExceptionObject, &a4->thisDisplacement);
              sub_40CB1B((int)v6, (int)a4->copyFunction);
            }
          }
          else
          {
            v14 = _ValidateRead(v20, 1u);
            v8 = v25;
            if ( !v14 )
              goto LABEL_25;
            v15 = _ValidateWrite(v6, 1u);
            v8 = v26;
            if ( !v15 )
              goto LABEL_25;
            sizeOrOffset = a4->sizeOrOffset;
            v16 = AdjustPointer(a1->params.pExceptionObject, &a4->thisDisplacement);
            memcpy_0(v6, v16, sizeOrOffset);
          }
        }
      }
    }
  }
}


// ========== Function: unknown_libname_4 @ 0x410986 ==========
// Microsoft VisualC 2-14/net runtime
int __cdecl unknown_libname_4(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4);
    if ( v2 )
      return sub_40CB1B(*(_DWORD *)(a1 + 24), v2);
  }
  return result;
}


// ========== Function: ?AdjustPointer@@YAPAXPAXABUPMD@@@Z @ 0x4109ED ==========
char *__cdecl AdjustPointer(char *a1, const struct PMD *a2)
{
  int pdisp; // edx
  char *result; // eax

  pdisp = a2->pdisp;
  result = &a1[a2->mdisp];
  if ( pdisp >= 0 )
    result += pdisp + *(_DWORD *)(*(_DWORD *)&a1[pdisp] + a2->vdisp);
  return result;
}


// ========== Function: __CallSettingFrame@12 @ 0x410A10 ==========
void __stdcall _CallSettingFrame(int a1, int a2, int a3)
{
  void (*v3)(void); // eax
  int v4; // ecx

  _NLG_Notify1(a3);
  v3();
  v4 = a3;
  if ( a3 == 256 )
    v4 = 2;
  _NLG_Notify1(v4);
}


// ========== Function: __mtinit @ 0x410A5C ==========
int _mtinit()
{
  DWORD *v0; // eax
  DWORD *v1; // esi
  DWORD CurrentThreadId; // eax

  _mtinitlocks();
  dwTlsIndex = TlsAlloc();
  if ( dwTlsIndex == -1 )
    return 0;
  v0 = (DWORD *)sub_412B34(1, 116);
  v1 = v0;
  if ( !v0 || !TlsSetValue(dwTlsIndex, v0) )
    return 0;
  _initptd(v1);
  CurrentThreadId = GetCurrentThreadId();
  v1[1] = -1;
  *v1 = CurrentThreadId;
  return 1;
}


// ========== Function: __initptd @ 0x410AB0 ==========
int __cdecl _initptd(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 80) = &unk_434750;
  *(_DWORD *)(a1 + 20) = 1;
  return result;
}


// ========== Function: __getptd @ 0x410AC3 ==========
_DWORD *__cdecl _getptd()
{
  DWORD LastError; // edi
  _DWORD *Value; // esi
  _DWORD *v2; // eax
  DWORD CurrentThreadId; // eax

  LastError = GetLastError();
  Value = TlsGetValue(dwTlsIndex);
  if ( !Value )
  {
    v2 = (_DWORD *)sub_412B34(1, 116);
    Value = v2;
    if ( !v2 || !TlsSetValue(dwTlsIndex, v2) )
      _amsg_exit(0x10u);
    _initptd((int)Value);
    CurrentThreadId = GetCurrentThreadId();
    Value[1] = -1;
    *Value = CurrentThreadId;
  }
  SetLastError(LastError);
  return Value;
}


// ========== Function: __isctype @ 0x410B2A ==========
int __cdecl _isctype(int C, int Type)
{
  int v2; // ecx
  int v3; // eax
  int result; // eax
  int SrcStr; // [esp+0h] [ebp-4h] BYREF

  SrcStr = v2;
  if ( (unsigned int)(C + 1) <= 0x100 )
  {
    v3 = *((unsigned __int16 *)off_434474 + C);
    return Type & v3;
  }
  if ( *((char *)off_434474 + 2 * BYTE1(C) + 1) >= 0 )
  {
    LOWORD(SrcStr) = (unsigned __int8)C;
    result = __crtGetStringTypeA(1u, (LPCSTR)&SrcStr, 1, (LPWORD)&C + 1, 0, 0, 1);
  }
  else
  {
    LOBYTE(SrcStr) = BYTE1(C);
    *(_WORD *)((char *)&SrcStr + 1) = (unsigned __int8)C;
    result = __crtGetStringTypeA(1u, (LPCSTR)&SrcStr, 2, (LPWORD)&C + 1, 0, 0, 1);
  }
  if ( result )
  {
    v3 = HIWORD(C);
    return Type & v3;
  }
  return result;
}


// ========== Function: hard @ 0x410BB9 ==========
int __fastcall hard(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return a1 * a3;
}


// ========== Function: __mtinitlocks @ 0x410BD4 ==========
void _mtinitlocks()
{
  InitializeCriticalSection(lpCriticalSection);
  InitializeCriticalSection(off_4346C4);
  InitializeCriticalSection(off_4346B4);
  InitializeCriticalSection(off_434694);
}


// ========== Function: __lock @ 0x410BFD ==========
void __cdecl _lock(int a1)
{
  struct _RTL_CRITICAL_SECTION *v1; // edi

  if ( !*(&dword_434690 + a1) )
  {
    v1 = (struct _RTL_CRITICAL_SECTION *)malloc(0x18u);
    if ( !v1 )
      _amsg_exit(0x11u);
    _lock(17);
    if ( *(&dword_434690 + a1) )
    {
      sub_40D386(v1);
    }
    else
    {
      InitializeCriticalSection(v1);
      *(&dword_434690 + a1) = v1;
    }
    _unlock(17);
  }
  EnterCriticalSection(*(&dword_434690 + a1));
}


// ========== Function: __unlock @ 0x410C5E ==========
void __cdecl _unlock(int a1)
{
  LeaveCriticalSection(*(&dword_434690 + a1));
}


// ========== Function: _strcmp @ 0x410C80 ==========
int __cdecl strcmp(const char *Str1, const char *Str2)
{
  const char *v2; // edx
  const char *v3; // ecx
  unsigned int v4; // eax
  bool v5; // cf
  unsigned int v6; // eax
  __int16 v8; // ax

  v2 = Str1;
  v3 = Str2;
  if ( ((unsigned __int8)Str1 & 3) == 0 )
  {
dodwords:
    while ( 1 )
    {
      v4 = *(_DWORD *)v2;
      v5 = (unsigned __int8)*(_DWORD *)v2 < (unsigned int)*v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *v3 )
        break;
      if ( !(_BYTE)v4 )
        return 0;
      v5 = BYTE1(v4) < (unsigned int)v3[1];
      if ( BYTE1(v4) != v3[1] )
        break;
      if ( !BYTE1(v4) )
        return 0;
      v6 = HIWORD(v4);
      v5 = (unsigned __int8)v6 < (unsigned int)v3[2];
      if ( (_BYTE)v6 != v3[2] )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v5 = BYTE1(v6) < (unsigned int)v3[3];
      if ( BYTE1(v6) != v3[3] )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -2 * v5 + 1;
  }
  if ( ((unsigned __int8)Str1 & 1) != 0 )
  {
    v2 = Str1 + 1;
    v5 = *Str1 < (unsigned int)*Str2;
    if ( *Str1 != *Str2 )
      return -2 * v5 + 1;
    v3 = Str2 + 1;
    if ( !*Str1 )
      return 0;
    if ( ((unsigned __int8)v2 & 2) == 0 )
      goto dodwords;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v5 = (unsigned __int8)v8 < (unsigned int)*v3;
  if ( (_BYTE)v8 != *v3 )
    return -2 * v5 + 1;
  if ( !(_BYTE)v8 )
    return 0;
  v5 = HIBYTE(v8) < (unsigned int)v3[1];
  if ( HIBYTE(v8) == v3[1] )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto dodwords;
    }
    return 0;
  }
  return -2 * v5 + 1;
}


// ========== Function: __XcptFilter @ 0x410D04 ==========
LONG __cdecl _XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  _DWORD *v2; // esi
  int *v3; // eax
  void (__cdecl *v4)(int); // ebx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // edi
  int v11; // [esp+8h] [ebp-4h]

  v2 = _getptd();
  v3 = (int *)xcptlookup(a1, v2[20]);
  if ( !v3 )
    return UnhandledExceptionFilter(ExceptionInfo);
  v4 = (void (__cdecl *)(int))v3[2];
  if ( !v4 )
    return UnhandledExceptionFilter(ExceptionInfo);
  if ( v4 == (void (__cdecl *)(int))5 )
  {
    v3[2] = 0;
    return 1;
  }
  else
  {
    if ( v4 != (void (__cdecl *)(int))1 )
    {
      v11 = v2[21];
      v2[21] = ExceptionInfo;
      v6 = v3[1];
      if ( v6 == 8 )
      {
        v7 = dword_4347C8;
        if ( dword_4347C8 < dword_4347C8 + dword_4347CC )
        {
          v8 = 12 * dword_4347C8;
          do
          {
            v8 += 12;
            *(_DWORD *)(v8 + v2[20] - 4) = 0;
            ++v7;
          }
          while ( v7 < dword_4347C8 + dword_4347CC );
        }
        v9 = *v3;
        v10 = v2[22];
        switch ( v9 )
        {
          case -1073741682:
            v2[22] = 131;
            break;
          case -1073741680:
            v2[22] = 129;
            break;
          case -1073741679:
            v2[22] = 132;
            break;
          case -1073741677:
            v2[22] = 133;
            break;
          case -1073741683:
            v2[22] = 130;
            break;
          case -1073741681:
            v2[22] = 134;
            break;
          case -1073741678:
            v2[22] = 138;
            break;
        }
        v4(8);
        v2[22] = v10;
      }
      else
      {
        v3[2] = 0;
        v4(v6);
      }
      v2[21] = v11;
    }
    return -1;
  }
}


// ========== Function: _xcptlookup @ 0x410E42 ==========
_DWORD *__cdecl xcptlookup(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != a1 )
  {
    do
      result += 3;
    while ( result < &a2[3 * dword_4347D4] && *result != a1 );
  }
  if ( result >= &a2[3 * dword_4347D4] || *result != a1 )
    return 0;
  return result;
}


// ========== Function: __wincmdln @ 0x410E7C ==========
_BYTE *_wincmdln()
{
  _BYTE *v0; // esi
  unsigned __int8 v1; // al

  if ( !dword_43AAEC )
    __initmbctable();
  v0 = (_BYTE *)dword_43AAF8;
  if ( *(_BYTE *)dword_43AAF8 != 34 )
  {
    if ( *(_BYTE *)dword_43AAF8 > 0x20u )
    {
      do
        ++v0;
      while ( *v0 > 0x20u );
    }
    goto LABEL_12;
  }
  while ( 1 )
  {
    v1 = *++v0;
    if ( v1 == 34 || !v1 )
      break;
    if ( _ismbblead(v1) )
      ++v0;
  }
  if ( *v0 != 34 )
    goto LABEL_12;
  do
  {
    ++v0;
LABEL_12:
    ;
  }
  while ( *v0 && *v0 <= 0x20u );
  return v0;
}


// ========== Function: __setenvp @ 0x410ED4 ==========
void _setenvp()
{
  char *v0; // esi
  int v1; // edi
  char **v2; // esi
  const char *i; // edi
  size_t v4; // eax
  size_t v5; // ebp
  char *v6; // eax

  if ( !dword_43AAEC )
    __initmbctable();
  v0 = Source;
  v1 = 0;
  while ( *v0 )
  {
    if ( *v0 != 61 )
      ++v1;
    v0 += strlen(v0) + 1;
  }
  v2 = (char **)malloc(4 * v1 + 4);
  dword_4393D0 = v2;
  if ( !v2 )
    _amsg_exit(9u);
  for ( i = Source; *i; i += v5 )
  {
    v4 = strlen(i);
    v5 = v4 + 1;
    if ( *i != 61 )
    {
      v6 = (char *)malloc(v4 + 1);
      *v2 = v6;
      if ( !v6 )
        _amsg_exit(9u);
      strcpy(*v2++, i);
    }
  }
  sub_40D386(Source);
  Source = 0;
  *v2 = 0;
  dword_43AAE8 = 1;
}


// ========== Function: __setargv @ 0x410F8D ==========
int _setargv()
{
  CHAR *v0; // edi
  char *v1; // esi
  int result; // eax
  int v3; // [esp+Ch] [ebp-8h] BYREF
  int v4; // [esp+10h] [ebp-4h] BYREF

  if ( !dword_43AAEC )
    __initmbctable();
  GetModuleFileNameA(0, Filename, 0x104u);
  dword_4393E0 = (int)Filename;
  v0 = Filename;
  if ( *(_BYTE *)dword_43AAF8 )
    v0 = (CHAR *)dword_43AAF8;
  parse_cmdline(v0, 0, 0, &v4, &v3);
  v1 = (char *)malloc(v3 + 4 * v4);
  if ( !v1 )
    _amsg_exit(8u);
  parse_cmdline(v0, v1, &v1[4 * v4], &v4, &v3);
  result = v4 - 1;
  dword_4393C8 = (int)v1;
  dword_4393C4 = v4 - 1;
  return result;
}


// ========== Function: _parse_cmdline @ 0x411026 ==========
_DWORD *__cdecl parse_cmdline(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // dl
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned __int8 v15; // dl
  _DWORD *result; // eax
  int v17; // [esp+14h] [ebp+8h]
  BOOL v18; // [esp+24h] [ebp+18h]

  *a5 = 0;
  v6 = a3;
  v7 = a2;
  *a4 = 1;
  v8 = a1;
  if ( a2 )
  {
    *a2 = a3;
    v7 = ++a2;
  }
  if ( *a1 == 34 )
  {
    while ( 1 )
    {
      v9 = *++v8;
      if ( v9 == 34 || !v9 )
        break;
      if ( (byte_43A9E1[v9] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8++;
      }
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
    }
    ++*a5;
    if ( v6 )
      *v6++ = 0;
    if ( *v8 == 34 )
      ++v8;
  }
  else
  {
    do
    {
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
      v10 = *v8++;
      if ( (byte_43A9E1[v10] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8;
        ++v8;
      }
      if ( v10 == 32 )
        break;
      if ( !v10 )
      {
        --v8;
        goto LABEL_28;
      }
    }
    while ( v10 != 9 );
    if ( v6 )
      *(v6 - 1) = 0;
  }
LABEL_28:
  v18 = 0;
  while ( *v8 )
  {
    while ( *v8 == 32 || *v8 == 9 )
      ++v8;
    if ( !*v8 )
      break;
    if ( v7 )
    {
      *v7++ = v6;
      a2 = v7;
    }
    ++*a4;
    while ( 1 )
    {
      v17 = 1;
      v11 = 0;
      while ( *v8 == 92 )
      {
        ++v8;
        ++v11;
      }
      if ( *v8 == 34 )
      {
        if ( (v11 & 1) == 0 )
        {
          if ( v18 && v8[1] == 34 )
            ++v8;
          else
            v17 = 0;
          v7 = a2;
          v18 = !v18;
        }
        v11 >>= 1;
      }
      v12 = v11;
      v13 = v11 - 1;
      if ( v12 )
      {
        v14 = v13 + 1;
        do
        {
          if ( v6 )
            *v6++ = 92;
          ++*a5;
          --v14;
        }
        while ( v14 );
      }
      v15 = *v8;
      if ( !*v8 || !v18 && (v15 == 32 || v15 == 9) )
        break;
      if ( v17 )
      {
        if ( v6 )
        {
          if ( (byte_43A9E1[v15] & 4) != 0 )
          {
            *v6++ = v15;
            ++v8;
            ++*a5;
          }
          *v6++ = *v8;
        }
        else if ( (byte_43A9E1[v15] & 4) != 0 )
        {
          ++v8;
          ++*a5;
        }
        ++*a5;
      }
      ++v8;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
  }
  if ( v7 )
    *v7 = 0;
  result = a4;
  ++*a4;
  return result;
}


// ========== Function: ___crtGetEnvironmentStringsA @ 0x4111DA ==========
CHAR *__crtGetEnvironmentStringsA()
{
  CHAR *v0; // ebx
  WCHAR *EnvironmentStringsW; // esi
  LPCH EnvironmentStrings; // edi
  WCHAR *i; // eax
  size_t v4; // eax
  int v5; // ebp
  CHAR *v6; // eax
  LPCH j; // eax
  size_t v9; // ebp
  void *v10; // eax
  void *v11; // esi
  CHAR *lpMem; // [esp+10h] [ebp-8h]
  int cchWideChar; // [esp+14h] [ebp-4h]

  v0 = 0;
  EnvironmentStringsW = 0;
  EnvironmentStrings = 0;
  if ( dword_4395A4 )
  {
    if ( dword_4395A4 == 1 )
      goto LABEL_7;
    if ( dword_4395A4 != 2 )
      return 0;
  }
  else
  {
    EnvironmentStringsW = GetEnvironmentStringsW();
    if ( EnvironmentStringsW )
    {
      dword_4395A4 = 1;
LABEL_7:
      if ( EnvironmentStringsW || (EnvironmentStringsW = GetEnvironmentStringsW()) != 0 )
      {
        for ( i = EnvironmentStringsW; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        cchWideChar = i - EnvironmentStringsW + 1;
        v4 = WideCharToMultiByte(0, 0, EnvironmentStringsW, cchWideChar, 0, 0, 0, 0);
        v5 = v4;
        if ( v4 )
        {
          v6 = (CHAR *)malloc(v4);
          lpMem = v6;
          if ( v6 )
          {
            if ( !WideCharToMultiByte(0, 0, EnvironmentStringsW, cchWideChar, v6, v5, 0, 0) )
            {
              sub_40D386(lpMem);
              lpMem = 0;
            }
            v0 = lpMem;
          }
        }
        FreeEnvironmentStringsW(EnvironmentStringsW);
        return v0;
      }
      return 0;
    }
    EnvironmentStrings = GetEnvironmentStrings();
    if ( !EnvironmentStrings )
      return 0;
    dword_4395A4 = 2;
  }
  if ( !EnvironmentStrings )
  {
    EnvironmentStrings = GetEnvironmentStrings();
    if ( !EnvironmentStrings )
      return 0;
  }
  for ( j = EnvironmentStrings; *j; ++j )
  {
    do
      ++j;
    while ( *j );
  }
  v9 = j - EnvironmentStrings + 1;
  v10 = malloc(v9);
  v11 = v10;
  if ( v10 )
    memcpy(v10, EnvironmentStrings, v9);
  else
    v11 = 0;
  FreeEnvironmentStringsA(EnvironmentStrings);
  return (CHAR *)v11;
}


// ========== Function: __ioinit @ 0x41130C ==========
UINT _ioinit()
{
  char *v0; // eax
  char *v1; // esi
  unsigned int i; // eax
  int v3; // edi
  LPBYTE v4; // ebx
  _DWORD *v5; // esi
  char *v6; // eax
  unsigned int j; // ecx
  int k; // esi
  int v9; // eax
  int m; // ebx
  int v11; // esi
  DWORD v12; // eax
  HANDLE StdHandle; // eax
  HANDLE v14; // edi
  DWORD FileType; // eax
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-48h] BYREF
  HANDLE *v18; // [esp+50h] [ebp-4h]

  v0 = (char *)malloc(0x480u);
  v1 = v0;
  if ( !v0 )
    _amsg_exit(0x1Bu);
  dword_43A7C0[0] = (int)v0;
  uNumber = 32;
  for ( i = (unsigned int)(v0 + 1152); (unsigned int)v1 < i; i = dword_43A7C0[0] + 1152 )
  {
    v1[4] = 0;
    *(_DWORD *)v1 = -1;
    *((_DWORD *)v1 + 2) = 0;
    v1[5] = 10;
    v1 += 36;
  }
  GetStartupInfoA(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v3 = *(_DWORD *)StartupInfo.lpReserved2;
    v4 = StartupInfo.lpReserved2 + 4;
    v18 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
    if ( v3 >= 2048 )
      v3 = 2048;
    if ( (int)uNumber < v3 )
    {
      v5 = &unk_43A7C4;
      while ( 1 )
      {
        v6 = (char *)malloc(0x480u);
        if ( !v6 )
          break;
        uNumber += 32;
        *v5 = v6;
        for ( j = (unsigned int)(v6 + 1152); (unsigned int)v6 < j; j = *v5 + 1152 )
        {
          v6[4] = 0;
          *(_DWORD *)v6 = -1;
          *((_DWORD *)v6 + 2) = 0;
          v6[5] = 10;
          v6 += 36;
        }
        ++v5;
        if ( (int)uNumber >= v3 )
          goto LABEL_19;
      }
      v3 = uNumber;
    }
LABEL_19:
    for ( k = 0; k < v3; ++v4 )
    {
      if ( *v18 != (HANDLE)-1 && (*v4 & 1) != 0 && ((*v4 & 8) != 0 || GetFileType(*v18)) )
      {
        v9 = dword_43A7C0[k >> 5] + 36 * (k & 0x1F);
        *(_DWORD *)v9 = *v18;
        *(_BYTE *)(v9 + 4) = *v4;
      }
      ++v18;
      ++k;
    }
  }
  for ( m = 0; m < 3; ++m )
  {
    v11 = dword_43A7C0[0] + 36 * m;
    if ( *(_DWORD *)v11 == -1 )
    {
      *(_BYTE *)(v11 + 4) = -127;
      if ( m )
        v12 = -(m != 1) - 11;
      else
        v12 = -10;
      StdHandle = GetStdHandle(v12);
      v14 = StdHandle;
      if ( StdHandle == (HANDLE)-1
        || (FileType = GetFileType(StdHandle)) == 0
        || (*(_DWORD *)v11 = v14, (unsigned __int8)FileType == 2) )
      {
        *(_BYTE *)(v11 + 4) |= 0x40u;
      }
      else if ( (unsigned __int8)FileType == 3 )
      {
        *(_BYTE *)(v11 + 4) |= 8u;
      }
    }
    else
    {
      *(_BYTE *)(v11 + 4) |= 0x80u;
    }
  }
  return SetHandleCount(uNumber);
}


// ========== Function: sub_4114C8 @ 0x4114C8 ==========
char __cdecl sub_4114C8(int a1)
{
  HMODULE ModuleHandleA; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  ModuleHandleA = GetModuleHandleA(0);
  if ( *(_WORD *)ModuleHandleA == 23117 )
  {
    v2 = *((_DWORD *)ModuleHandleA + 15);
    if ( v2 )
    {
      ModuleHandleA = (HMODULE)((char *)ModuleHandleA + v2);
      *(_BYTE *)a1 = *((_BYTE *)ModuleHandleA + 26);
      LOBYTE(ModuleHandleA) = *((_BYTE *)ModuleHandleA + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)ModuleHandleA;
    }
  }
  return (char)ModuleHandleA;
}


// ========== Function: sub_4114F5 @ 0x4114F5 ==========
int sub_4114F5()
{
  int result; // eax
  CHAR *i; // ecx
  char v2; // al
  CHAR *v3; // eax
  CHAR *j; // ecx
  char v5; // al
  char *v6; // eax
  const char *v7; // eax
  const char *v8; // ecx
  CHAR Buffer[4240]; // [esp+4h] [ebp-122Ch] BYREF
  CHAR Filename[260]; // [esp+1094h] [ebp-19Ch] BYREF
  _OSVERSIONINFOA VersionInformation; // [esp+1198h] [ebp-98h] BYREF
  _BYTE v12[4]; // [esp+122Ch] [ebp-4h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    return 1;
  }
  if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", Buffer, 0x1090u) )
    goto LABEL_29;
  for ( i = Buffer; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp("__GLOBAL_HEAP_SELECTED", Buffer, 0x16u) )
  {
    v3 = Buffer;
  }
  else
  {
    GetModuleFileNameA(0, Filename, 0x104u);
    for ( j = Filename; *j; ++j )
    {
      v5 = *j;
      if ( *j >= 97 && v5 <= 122 )
        *j = v5 - 32;
    }
    v3 = strstr(Buffer, Filename);
  }
  if ( !v3 )
    goto LABEL_29;
  v6 = strchr(v3, 44);
  if ( !v6 )
    goto LABEL_29;
  v7 = v6 + 1;
  v8 = v7;
  while ( *v8 )
  {
    if ( *v8 == 59 )
      *v8 = 0;
    else
      ++v8;
  }
  result = strtol(v7, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_4114C8((int)v12);
    return 3 - (v12[0] < 6u);
  }
  return result;
}


// ========== Function: sub_41163D @ 0x41163D ==========
int __cdecl sub_41163D(int a1)
{
  int v1; // eax
  int v2; // eax

  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  v1 = sub_4114F5();
  dword_43A7A4 = v1;
  if ( v1 == 3 )
  {
    v2 = __sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_412467();
  }
  if ( !v2 )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}


// ========== Function: __FF_MSGBANNER @ 0x41169A ==========
int _FF_MSGBANNER()
{
  int result; // eax

  result = dword_4393AC;
  if ( dword_4393AC == 1 || !dword_4393AC && dword_4340EC == 1 )
  {
    sub_4116D3(0xFCu);
    if ( dword_4395A8 )
      dword_4395A8();
    return sub_4116D3(0xFFu);
  }
  return result;
}


// ========== Function: sub_4116D3 @ 0x4116D3 ==========
int *__cdecl sub_4116D3(DWORD NumberOfBytesWritten)
{
  int v1; // ecx
  int *result; // eax
  int v3; // esi
  char *v4; // edi
  const char **v5; // esi
  HANDLE StdHandle; // eax
  const char *v7; // [esp-14h] [ebp-1B8h]
  DWORD v8; // [esp-10h] [ebp-1B4h]
  DWORD *p_NumberOfBytesWritten; // [esp-Ch] [ebp-1B0h]
  int v10; // [esp-8h] [ebp-1ACh]
  CHAR Filename[260]; // [esp+0h] [ebp-1A4h] BYREF
  char Destination[160]; // [esp+104h] [ebp-A0h] BYREF
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v1 = 0;
  result = dword_434800;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v1;
  }
  while ( result < (int *)&off_434890 );
  v3 = 2 * v1;
  if ( NumberOfBytesWritten == dword_434800[2 * v1] )
  {
    result = (int *)dword_4393AC;
    if ( dword_4393AC == 1 || !dword_4393AC && dword_4340EC == 1 )
    {
      v5 = (const char **)&(&off_434804)[v3];
      v10 = 0;
      p_NumberOfBytesWritten = &NumberOfBytesWritten;
      v8 = strlen(*v5);
      v7 = *v5;
      StdHandle = GetStdHandle(0xFFFFFFF4);
      return (int *)WriteFile(StdHandle, v7, v8, &NumberOfBytesWritten, 0);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !GetModuleFileNameA(0, Filename, 0x104u) )
        strcpy(Filename, "<program name unknown>");
      v4 = Filename;
      if ( strlen(Filename) + 1 > 0x3C )
      {
        v4 = (char *)&savedregs + strlen(Filename) - 479;
        strncpy(v4, "...", 3u);
      }
      strcpy(Destination, "Runtime Error!\n\nProgram: ");
      strcat(Destination, v4);
      strcat(Destination, "\n\n");
      strcat(Destination, (&off_434804)[v3]);
      return (int *)__crtMessageBoxA(Destination, "Microsoft Visual C++ Runtime Library", 73744);
    }
  }
  return result;
}


// ========== Function: _strcpy @ 0x411830 ==========
char *__cdecl strcpy(char *Destination, const char *Source)
{
  JUMPOUT(0x4118A1);
}


// ========== Function: _strcat @ 0x411840 ==========
char *__cdecl strcat(char *Destination, const char *Source)
{
  char *v2; // ecx
  int v4; // eax
  int v5; // eax
  char *v6; // edi
  const char *v7; // ecx
  int v8; // edx
  int v9; // eax
  char *result; // eax

  v2 = Destination;
  if ( ((unsigned __int8)Destination & 3) == 0 )
    goto find_end_of_dest_string_loop;
  do
  {
    if ( !*v2++ )
    {
start_byte_3:
      v6 = v2 - 1;
      goto copy_start;
    }
  }
  while ( ((unsigned __int8)v2 & 3) != 0 );
  while ( 1 )
  {
    do
    {
find_end_of_dest_string_loop:
      v4 = (*(_DWORD *)v2 + 2130640639) ^ ~*(_DWORD *)v2;
      v2 += 4;
    }
    while ( (v4 & 0x81010100) == 0 );
    v5 = *((_DWORD *)v2 - 1);
    if ( !(_BYTE)v5 )
      break;
    if ( !BYTE1(v5) )
    {
      v6 = v2 - 3;
      goto copy_start;
    }
    if ( (v5 & 0xFF0000) == 0 )
    {
      v6 = v2 - 2;
      goto copy_start;
    }
    if ( (v5 & 0xFF000000) == 0 )
      goto start_byte_3;
  }
  v6 = v2 - 4;
copy_start:
  v7 = Source;
  if ( ((unsigned __int8)Source & 3) == 0 )
    goto main_loop_entrance;
  while ( 1 )
  {
    LOBYTE(v8) = *v7++;
    if ( !(_BYTE)v8 )
      break;
    *v6++ = v8;
    if ( ((unsigned __int8)v7 & 3) == 0 )
    {
      while ( 1 )
      {
main_loop_entrance:
        v9 = (*(_DWORD *)v7 + 2130640639) ^ ~*(_DWORD *)v7;
        v8 = *(_DWORD *)v7;
        v7 += 4;
        if ( (v9 & 0x81010100) != 0 )
        {
          if ( !(_BYTE)v8 )
            goto LABEL_26;
          if ( !BYTE1(v8) )
          {
            *(_WORD *)v6 = (unsigned __int8)v8;
            return Destination;
          }
          if ( (v8 & 0xFF0000) == 0 )
          {
            *(_WORD *)v6 = v8;
            result = Destination;
            v6[2] = 0;
            return result;
          }
          if ( (v8 & 0xFF000000) == 0 )
          {
            *(_DWORD *)v6 = v8;
            return Destination;
          }
        }
        *(_DWORD *)v6 = v8;
        v6 += 4;
      }
    }
  }
LABEL_26:
  *v6 = v8;
  return Destination;
}


// ========== Function: ___sbh_heap_init @ 0x411920 ==========
int __cdecl __sbh_heap_init(int a1)
{
  int result; // eax

  result = (int)HeapAlloc(hHeap, 0, 0x140u);
  lpMem = (LPVOID)result;
  if ( result )
  {
    dword_43A790 = 0;
    dword_43A794 = 0;
    dword_43A78C = result;
    dword_43A79C = a1;
    dword_43A784 = 16;
    return 1;
  }
  return result;
}


// ========== Function: ___sbh_find_block @ 0x411968 ==========
char *__cdecl __sbh_find_block(int a1)
{
  char *result; // eax

  for ( result = (char *)lpMem; result < (char *)lpMem + 20 * dword_43A794; result += 20 )
  {
    if ( (unsigned int)(a1 - *((_DWORD *)result + 3)) < 0x100000 )
      return result;
  }
  return 0;
}


// ========== Function: sub_411993 @ 0x411993 ==========
_DWORD *__cdecl sub_411993(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  bool v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  LPVOID *v18; // eax
  _DWORD *v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  int v22; // [esp+18h] [ebp-4h]
  char *v23; // [esp+28h] [ebp+Ch]
  int *v24; // [esp+28h] [ebp+Ch]
  char v25; // [esp+2Bh] [ebp+Fh]

  result = (_DWORD *)a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - a1[3]) >> 15;
  v19 = &result[129 * v4 + 81];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v22 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v20 = *(int *)((char *)v3 + v5);
    v21 = *(_DWORD *)(a2 - 8);
    v23 = (char *)v3 + v5;
    if ( (v20 & 1) == 0 )
    {
      v7 = (v20 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (char *)result + v7 + 4;
          v12 = ~(0x80000000 >> (v7 - 32));
          result[v4 + 49] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            a1[1] &= v12;
        }
        else
        {
          v8 = (char *)result + v7 + 4;
          v9 = ~(0x80000000 >> v7);
          result[v4 + 17] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *a1 &= v9;
        }
        v5 = v22;
        v6 = v23;
      }
      v5 += v20;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v22 = v5;
      *(_DWORD *)(*((_DWORD *)v23 + 1) + 8) = *((_DWORD *)v23 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v21 & 1) != 0 )
    {
      v14 = (unsigned int)a1;
    }
    else
    {
      v24 = (int *)((char *)v3 - v21);
      v14 = (v21 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v22 = v21 + v5;
      v13 = ((v21 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v24[1] == v24[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            result[v4 + 49] &= v16;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              a1[1] &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            result[v4 + 17] &= v15;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              *a1 &= v15;
          }
        }
        *(_DWORD *)(v24[2] + 4) = v24[1];
        *(_DWORD *)(v24[1] + 8) = v24[2];
      }
      v3 = v24;
    }
    if ( (v21 & 1) != 0 || v14 != v13 )
    {
      v17 = &v19[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v25 = *((_BYTE *)result + v13 + 4);
        *((_BYTE *)result + v13 + 4) = v25 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v25 )
            a1[1] |= 0x80000000 >> (v13 - 32);
          result[v4 + 49] |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v25 )
            *a1 |= 0x80000000 >> v13;
          result[v4 + 17] |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v22;
    *(int *)((char *)v3 + v22 - 4) = v22;
    result += 129 * v4 + 81;
    v10 = (*v19)-- == 1;
    if ( v10 )
    {
      if ( dword_43A790 )
      {
        VirtualFree((LPVOID)(*((_DWORD *)dword_43A790 + 3) + (dword_43A788 << 15)), 0x8000u, 0x4000u);
        *((_DWORD *)dword_43A790 + 2) |= 0x80000000 >> dword_43A788;
        *(_DWORD *)(*((_DWORD *)dword_43A790 + 4) + 4 * dword_43A788 + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_43A790 + 4) + 67);
        v18 = (LPVOID *)dword_43A790;
        if ( !*(_BYTE *)(*((_DWORD *)dword_43A790 + 4) + 67) )
        {
          *((_DWORD *)dword_43A790 + 1) &= ~1u;
          v18 = (LPVOID *)dword_43A790;
        }
        if ( v18[2] == (LPVOID)-1 )
        {
          VirtualFree(v18[3], 0, 0x8000u);
          HeapFree(hHeap, 0, *((LPVOID *)dword_43A790 + 4));
          memcpy_0(
            dword_43A790,
            (char *)dword_43A790 + 20,
            (size_t)lpMem + 20 * dword_43A794 - (_DWORD)dword_43A790 - 20);
          --dword_43A794;
          if ( a1 > dword_43A790 )
            a1 -= 5;
          dword_43A78C = (int)lpMem;
        }
      }
      result = a1;
      dword_43A788 = v4;
      dword_43A790 = a1;
    }
  }
  return result;
}


// ========== Function: ___sbh_alloc_block @ 0x411CBC ==========
_DWORD *__cdecl __sbh_alloc_block(int a1)
{
  int v1; // ecx
  unsigned int v2; // esi
  char *i; // ebx
  bool v4; // zf
  bool v5; // zf
  bool v6; // zf
  _DWORD *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  int *v14; // edx
  int v15; // ecx
  int v16; // esi
  unsigned int v17; // ebx
  _BYTE *v18; // edi
  unsigned int v19; // ebx
  _BYTE *v20; // edi
  int v21; // ebx
  _DWORD *v22; // ecx
  char v23; // cl
  _DWORD *v24; // edx
  int v25; // [esp+Ch] [ebp-14h]
  int v26; // [esp+Ch] [ebp-14h]
  signed int v27; // [esp+10h] [ebp-10h]
  unsigned int v28; // [esp+14h] [ebp-Ch]
  _DWORD *v29; // [esp+14h] [ebp-Ch]
  unsigned int v30; // [esp+18h] [ebp-8h]
  int v31; // [esp+18h] [ebp-8h]
  char *v32; // [esp+1Ch] [ebp-4h]
  int v33; // [esp+1Ch] [ebp-4h]
  char *v34; // [esp+28h] [ebp+8h]

  v32 = (char *)lpMem + 20 * dword_43A794;
  v27 = (a1 + 23) & 0xFFFFFFF0;
  v1 = (v27 >> 4) - 1;
  if ( v1 >= 32 )
  {
    v2 = 0;
    v28 = 0;
    v30 = 0xFFFFFFFF >> ((v27 >> 4) - 33);
  }
  else
  {
    v2 = 0xFFFFFFFF >> v1;
    v30 = -1;
    v28 = 0xFFFFFFFF >> v1;
  }
  i = (char *)dword_43A78C;
  v34 = (char *)dword_43A78C;
  if ( dword_43A78C < (unsigned int)lpMem + 20 * dword_43A794 )
  {
    do
    {
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
        break;
      i += 20;
      v34 = i;
    }
    while ( i < v32 );
  }
  if ( i == v32 )
  {
    for ( i = (char *)lpMem; ; i += 20 )
    {
      v4 = i == (char *)dword_43A78C;
      v34 = i;
      if ( (unsigned int)i >= dword_43A78C )
        break;
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
      {
        v4 = i == (char *)dword_43A78C;
        break;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = i == v32;
        if ( i >= v32 )
          break;
        if ( *((_DWORD *)i + 2) )
        {
          v5 = i == v32;
          break;
        }
        i += 20;
        v34 = i;
      }
      if ( v5 )
      {
        for ( i = (char *)lpMem; ; i += 20 )
        {
          v6 = i == (char *)dword_43A78C;
          v34 = i;
          if ( (unsigned int)i >= dword_43A78C )
            break;
          if ( *((_DWORD *)i + 2) )
          {
            v6 = i == (char *)dword_43A78C;
            break;
          }
        }
        if ( v6 )
        {
          i = (char *)__sbh_alloc_new_region();
          v34 = i;
          if ( !i )
            return 0;
        }
      }
      **((_DWORD **)i + 4) = __sbh_alloc_new_group(i);
      if ( **((_DWORD **)i + 4) == -1 )
        return 0;
    }
  }
  dword_43A78C = (int)i;
  v8 = (_DWORD *)*((_DWORD *)i + 4);
  v9 = *v8;
  v33 = *v8;
  if ( *v8 == -1 || !(v2 & v8[v9 + 17] | v30 & v8[v9 + 49]) )
  {
    v33 = 0;
    v10 = v8 + 17;
    v2 = v28;
    if ( !(v28 & v8[17] | v30 & v8[49]) )
    {
      do
      {
        v11 = v10[33];
        ++v33;
        ++v10;
      }
      while ( !(*v10 & v28 | v30 & v11) );
    }
    v9 = v33;
  }
  v12 = 0;
  v29 = &v8[129 * v9 + 81];
  v13 = v2 & v8[v9 + 17];
  if ( !v13 )
  {
    v13 = v30 & v8[v9 + 49];
    v12 = 32;
  }
  while ( v13 >= 0 )
  {
    v13 *= 2;
    ++v12;
  }
  v14 = (int *)v29[2 * v12 + 1];
  v31 = *v14 - v27;
  v15 = v31;
  v16 = (v31 >> 4) - 1;
  if ( v16 > 63 )
    v16 = 63;
  if ( v16 == v12 )
    goto LABEL_57;
  if ( v14[1] != v14[2] )
    goto LABEL_47;
  if ( v12 >= 32 )
  {
    v19 = 0x80000000 >> (v12 - 32);
    v20 = (char *)v8 + v12 + 4;
    v21 = ~v19;
    v8[v33 + 49] &= v21;
    v4 = (*v20)-- == 1;
    v26 = v21;
    if ( v4 )
    {
      i = v34;
      *((_DWORD *)v34 + 1) &= v26;
      goto LABEL_47;
    }
  }
  else
  {
    v17 = 0x80000000 >> v12;
    v18 = (char *)v8 + v12 + 4;
    v25 = ~v17;
    v8[v33 + 17] &= ~v17;
    v4 = (*v18)-- == 1;
    if ( v4 )
    {
      i = v34;
      *(_DWORD *)v34 &= v25;
      goto LABEL_47;
    }
  }
  i = v34;
LABEL_47:
  *(_DWORD *)(v14[2] + 4) = v14[1];
  *(_DWORD *)(v14[1] + 8) = v14[2];
  if ( v31 )
  {
    v22 = &v29[2 * v16];
    v14[1] = v22[1];
    v14[2] = (int)v22;
    v22[1] = v14;
    *(_DWORD *)(v14[1] + 8) = v14;
    if ( v14[1] == v14[2] )
    {
      v23 = *((_BYTE *)v8 + v16 + 4);
      if ( v16 >= 32 )
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *((_DWORD *)i + 1) |= 0x80000000 >> (v16 - 32);
        v8[v33 + 49] |= 0x80000000 >> (v16 - 32);
      }
      else
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *(_DWORD *)i |= 0x80000000 >> v16;
        v8[v33 + 17] |= 0x80000000 >> v16;
      }
    }
    v15 = v31;
LABEL_57:
    if ( v15 )
    {
      *v14 = v15;
      *(int *)((char *)v14 + v15 - 4) = v15;
    }
    goto LABEL_60;
  }
  v15 = 0;
LABEL_60:
  v24 = (int *)((char *)v14 + v15);
  *v24 = v27 + 1;
  *(_DWORD *)((char *)v24 + v27 - 4) = v27 + 1;
  v4 = (*v29)++ == 0;
  if ( v4 && i == dword_43A790 && v33 == dword_43A788 )
    dword_43A790 = 0;
  *v8 = v33;
  return v24 + 1;
}


// ========== Function: ___sbh_alloc_new_region @ 0x411FC5 ==========
char *__sbh_alloc_new_region()
{
  int v0; // eax
  void *v1; // eax
  char *v2; // esi
  LPVOID v3; // eax
  LPVOID v4; // eax

  v0 = dword_43A794;
  if ( dword_43A794 == dword_43A784 )
  {
    v1 = HeapReAlloc(hHeap, 0, lpMem, 4 * (5 * dword_43A784 + 80));
    if ( !v1 )
      return 0;
    dword_43A784 += 16;
    lpMem = v1;
    v0 = dword_43A794;
  }
  v2 = (char *)lpMem + 20 * v0;
  v3 = HeapAlloc(hHeap, 8u, 0x41C4u);
  *((_DWORD *)v2 + 4) = v3;
  if ( !v3 )
    return 0;
  v4 = VirtualAlloc(0, 0x100000u, 0x2000u, 4u);
  *((_DWORD *)v2 + 3) = v4;
  if ( !v4 )
  {
    HeapFree(hHeap, 0, *((LPVOID *)v2 + 4));
    return 0;
  }
  *((_DWORD *)v2 + 2) = -1;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  ++dword_43A794;
  **((_DWORD **)v2 + 4) = -1;
  return v2;
}


// ========== Function: ___sbh_alloc_new_group @ 0x412076 ==========
int __cdecl __sbh_alloc_new_group(_DWORD *a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  _DWORD *v6; // edi
  _DWORD *v8; // eax

  v1 = a1[4];
  v2 = a1[2];
  v3 = 0;
  while ( v2 >= 0 )
  {
    v2 *= 2;
    ++v3;
  }
  v4 = 63;
  v5 = 516 * v3 + v1 + 324;
  do
  {
    *(_DWORD *)(v5 + 8) = v5;
    *(_DWORD *)(v5 + 4) = v5;
    v5 += 8;
    --v4;
  }
  while ( v4 );
  v6 = (_DWORD *)(a1[3] + (v3 << 15));
  if ( !VirtualAlloc(v6, 0x8000u, 0x1000u, 4u) )
    return -1;
  if ( v6 < v6 + 7168 )
  {
    v8 = v6 + 4;
    do
    {
      *(v8 - 2) = -1;
      v8[1019] = -1;
      *(v8 - 1) = 4080;
      *v8 = v8 + 1023;
      v8[1] = v8 - 1025;
      v8[1018] = 4080;
      v8 += 1024;
    }
    while ( v8 - 4 <= v6 + 7168 );
  }
  *(_DWORD *)(516 * v3 + v1 + 832) = v6 + 3;
  v6[5] = 516 * v3 + v1 + 828;
  *(_DWORD *)(516 * v3 + v1 + 836) = v6 + 7171;
  v6[7172] = 516 * v3 + v1 + 828;
  *(_DWORD *)(v1 + 4 * v3 + 68) = 0;
  *(_DWORD *)(v1 + 4 * v3 + 196) = 1;
  if ( (*(_BYTE *)(v1 + 67))++ == 0 )
    a1[1] |= 1u;
  a1[2] &= ~(0x80000000 >> v3);
  return v3;
}


// ========== Function: ___sbh_resize_block @ 0x412171 ==========
int __cdecl __sbh_resize_block(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // ebx
  int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  _BYTE *v11; // ecx
  int v12; // ebx
  bool v13; // zf
  unsigned int v14; // ebx
  _BYTE *v15; // ecx
  int v16; // ebx
  unsigned int v17; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  char v20; // cl
  int v21; // edx
  int *v22; // eax
  int v24; // ecx
  int *v25; // ebx
  unsigned int v26; // esi
  unsigned int v27; // esi
  unsigned int v28; // ebx
  _BYTE *v29; // esi
  int v30; // ebx
  _BYTE *v31; // ecx
  unsigned int v32; // ebx
  unsigned int v33; // ecx
  _DWORD *v34; // eax
  char v35; // cl
  int v36; // [esp+Ch] [ebp-Ch]
  int v37; // [esp+10h] [ebp-8h]
  int v38; // [esp+14h] [ebp-4h]
  int v39; // [esp+14h] [ebp-4h]
  int *v40; // [esp+24h] [ebp+Ch]
  char v41; // [esp+27h] [ebp+Fh]
  int v42; // [esp+28h] [ebp+10h]
  unsigned int v43; // [esp+28h] [ebp+10h]
  int v44; // [esp+28h] [ebp+10h]
  char v45; // [esp+2Bh] [ebp+13h]

  v3 = a1[4];
  v4 = (a3 + 23) & 0xFFFFFFF0;
  v5 = (unsigned int)(a2 - a1[3]) >> 15;
  v36 = 516 * v5 + v3 + 324;
  v6 = *(_DWORD *)(a2 - 4) - 1;
  v42 = v6;
  v7 = *(_DWORD *)(v6 + a2 - 4);
  v8 = v6 + a2 - 4;
  v38 = v7;
  if ( v4 <= v6 )
  {
    if ( v4 < v6 )
    {
      v44 = v6 - v4;
      v24 = v4 + 1;
      *(_DWORD *)(a2 - 4) = v4 + 1;
      v25 = (int *)(a2 + v4 - 4);
      v40 = v25;
      v26 = (v44 >> 4) - 1;
      *(v25 - 1) = v24;
      if ( v26 > 0x3F )
        v26 = 63;
      if ( (v38 & 1) == 0 )
      {
        v27 = (v38 >> 4) - 1;
        if ( v27 > 0x3F )
          v27 = 63;
        if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
        {
          if ( v27 >= 0x20 )
          {
            v31 = (_BYTE *)(v27 + v3 + 4);
            v32 = ~(0x80000000 >> (v27 - 32));
            *(_DWORD *)(v3 + 4 * v5 + 196) &= v32;
            v13 = (*v31)-- == 1;
            if ( v13 )
              a1[1] &= v32;
          }
          else
          {
            v28 = 0x80000000 >> v27;
            v29 = (_BYTE *)(v27 + v3 + 4);
            v30 = ~v28;
            *(_DWORD *)(v3 + 4 * v5 + 68) &= v30;
            v13 = (*v29)-- == 1;
            if ( v13 )
              *a1 &= v30;
          }
          v25 = v40;
        }
        *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
        *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
        v44 += v38;
        v26 = (v44 >> 4) - 1;
        if ( v26 > 0x3F )
          v26 = 63;
      }
      v33 = v36 + 8 * v26;
      v25[1] = *(_DWORD *)(v33 + 4);
      v25[2] = v33;
      *(_DWORD *)(v33 + 4) = v25;
      *(_DWORD *)(v25[1] + 8) = v25;
      if ( v25[1] == v25[2] )
      {
        v41 = *(_BYTE *)(v26 + v3 + 4);
        *(_BYTE *)(v26 + v3 + 4) = v41 + 1;
        if ( v26 >= 0x20 )
        {
          if ( !v41 )
            a1[1] |= 0x80000000 >> (v26 - 32);
          v34 = (_DWORD *)(v3 + 4 * v5 + 196);
          v35 = v26 - 32;
        }
        else
        {
          if ( !v41 )
            *a1 |= 0x80000000 >> v26;
          v34 = (_DWORD *)(v3 + 4 * v5 + 68);
          v35 = v26;
        }
        *v34 |= 0x80000000 >> v35;
      }
      *v25 = v44;
      *(int *)((char *)v25 + v44 - 4) = v44;
    }
  }
  else
  {
    if ( (v7 & 1) != 0 || v4 > v6 + v7 )
      return 0;
    v9 = (v7 >> 4) - 1;
    v37 = v9;
    if ( v9 > 0x3F )
    {
      v9 = 63;
      v37 = 63;
    }
    if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
    {
      if ( v9 >= 0x20 )
      {
        v14 = 0x80000000 >> (v9 - 32);
        v15 = (_BYTE *)(v37 + v3 + 4);
        v16 = ~v14;
        *(_DWORD *)(v3 + 4 * v5 + 196) &= v16;
        v13 = (*v15)-- == 1;
        if ( v13 )
          a1[1] &= v16;
      }
      else
      {
        v10 = 0x80000000 >> v9;
        v11 = (_BYTE *)(v37 + v3 + 4);
        v12 = ~v10;
        *(_DWORD *)(v3 + 4 * v5 + 68) &= v12;
        v13 = (*v11)-- == 1;
        if ( v13 )
          *a1 &= v12;
      }
    }
    *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
    v39 = v42 - v4 + v38;
    if ( v39 <= 0 )
    {
      v21 = a2;
    }
    else
    {
      v17 = (v39 >> 4) - 1;
      v18 = a2 + v4 - 4;
      if ( v17 > 0x3F )
        v17 = 63;
      v43 = v36 + 8 * v17;
      *(_DWORD *)(a2 + v4) = *(_DWORD *)(v43 + 4);
      *(_DWORD *)(v18 + 8) = v43;
      *(_DWORD *)(v43 + 4) = v18;
      *(_DWORD *)(*(_DWORD *)(a2 + v4) + 8) = a2 + v4 - 4;
      if ( *(_DWORD *)(a2 + v4) == *(_DWORD *)(a2 + v4 - 4 + 8) )
      {
        v45 = *(_BYTE *)(v17 + v3 + 4);
        *(_BYTE *)(v17 + v3 + 4) = v45 + 1;
        if ( v17 >= 0x20 )
        {
          if ( !v45 )
            a1[1] |= 0x80000000 >> (v17 - 32);
          v19 = (_DWORD *)(v3 + 4 * v5 + 196);
          v20 = v17 - 32;
        }
        else
        {
          if ( !v45 )
            *a1 |= 0x80000000 >> v17;
          v19 = (_DWORD *)(v3 + 4 * v5 + 68);
          v20 = v17;
        }
        *v19 |= 0x80000000 >> v20;
      }
      v21 = a2;
      v22 = (int *)(a2 + v4 - 4);
      *v22 = v39;
      *(int *)((char *)v22 + v39 - 4) = v39;
    }
    *(_DWORD *)(v21 - 4) = v4 + 1;
    *(_DWORD *)(v21 + v4 - 8) = v4 + 1;
  }
  return 1;
}


// ========== Function: sub_412467 @ 0x412467 ==========
int *sub_412467()
{
  int *v0; // esi
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  int *v3; // eax
  int v4; // ebp
  int v5; // edx

  if ( dword_4348A0 == -1 )
  {
    v0 = (int *)&off_434890;
  }
  else
  {
    v0 = (int *)HeapAlloc(hHeap, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
  v2 = v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != (int *)&off_434890 )
      HeapFree(hHeap, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree(v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == (int *)&off_434890 )
  {
    if ( !off_434890 )
      off_434890 = &off_434890;
    if ( !off_434894 )
      off_434894 = &off_434890;
  }
  else
  {
    *v0 = (int)&off_434890;
    v0[1] = (int)off_434894;
    off_434894 = v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = (int)(v2 + 0x100000);
  v3 = v0 + 6;
  v0[3] = (int)(v0 + 38);
  v0[4] = (int)v2;
  v0[2] = (int)(v0 + 6);
  v4 = 0;
  do
  {
    v5 = v4++ >= 16 ? -1 : 240;
    *v3 = v5;
    v3[1] = 241;
    v3 += 2;
  }
  while ( v4 < 1024 );
  memset(v2, 0, 0x10000u);
  while ( (unsigned int)v2 < v0[4] + 0x10000 )
  {
    *((_BYTE *)v2 + 248) = -1;
    *v2 = v2 + 2;
    v2[1] = 240;
    v2 += 1024;
  }
  return v0;
}


// ========== Function: sub_4125AB @ 0x4125AB ==========
_UNKNOWN **__cdecl sub_4125AB(LPVOID *lpMem)
{
  _UNKNOWN **result; // eax

  result = (_UNKNOWN **)VirtualFree(lpMem[4], 0, 0x8000u);
  if ( off_4368B0 == (_UNKNOWN **)lpMem )
  {
    result = (_UNKNOWN **)lpMem[1];
    off_4368B0 = result;
  }
  if ( lpMem == (LPVOID *)&off_434890 )
  {
    dword_4348A0 = -1;
  }
  else
  {
    *(_DWORD *)lpMem[1] = *lpMem;
    *((_DWORD *)*lpMem + 1) = lpMem[1];
    return (_UNKNOWN **)HeapFree(hHeap, 0, lpMem);
  }
  return result;
}


// ========== Function: sub_412601 @ 0x412601 ==========
void __cdecl sub_412601(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = off_434894;
  do
  {
    if ( v1[4] != -1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && VirtualFree((LPVOID)(v1[4] + i), 0x1000u, 0x4000u) )
        {
          *v2 = -1;
          --dword_4395AC;
          v4 = v1[3];
          if ( !v4 || v4 > (unsigned int)v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = v1;
      v1 = (_DWORD *)v1[1];
      if ( v8 && v5[6] == -1 )
      {
        v6 = v5 + 8;
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_4125AB((LPVOID *)v5);
      }
    }
  }
  while ( v1 != off_434894 && a1 > 0 );
}


// ========== Function: sub_4126C3 @ 0x4126C3 ==========
unsigned int __cdecl sub_4126C3(unsigned int a1, _DWORD *a2, unsigned int *a3)
{
  _UNKNOWN **v3; // ecx

  v3 = &off_434890;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (_UNKNOWN **)*v3;
    if ( v3 == &off_434890 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}


// ========== Function: sub_41271A @ 0x41271A ==========
void __cdecl sub_41271A(int a1, int a2, _BYTE *a3)
{
  _DWORD *v3; // eax
  bool v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += (unsigned __int8)*a3;
  *a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_4395AC == 32 )
    sub_412601(16);
}


// ========== Function: sub_41275F @ 0x41275F ==========
_DWORD *__cdecl sub_41275F(unsigned int a1)
{
  char *v1; // esi
  char *v2; // edx
  char *v3; // edi
  char *v4; // eax
  unsigned int v5; // ebx
  _DWORD *result; // eax
  char *v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *i; // esi
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  _UNKNOWN **v13; // eax
  bool v14; // cf
  int *v15; // eax
  int v16; // ecx
  unsigned int Val; // [esp+Ch] [ebp-8h]
  char *v18; // [esp+10h] [ebp-4h]
  char *v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]

  v1 = (char *)off_4368B0;
  do
  {
    v2 = (char *)*((_DWORD *)v1 + 4);
    if ( v2 == (char *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (char *)*((_DWORD *)v1 + 2);
      v4 = &v2[4096 * ((v3 - v1 - 24) >> 3)];
      v18 = v4;
      if ( v3 < v1 + 8216 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( *(_DWORD *)v3 >= (signed int)a1 && *((_DWORD *)v3 + 1) > a1 )
          {
            result = (_DWORD *)sub_412967(v4, *(_DWORD *)v3, a1);
            if ( result )
            {
LABEL_21:
              off_4368B0 = (_UNKNOWN **)v1;
              *(_DWORD *)v3 -= v5;
              *((_DWORD *)v1 + 2) = v3;
              return result;
            }
            v4 = v18;
            *((_DWORD *)v3 + 1) = a1;
          }
          v3 += 8;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= v1 + 8216 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = v1 + 24;
      Val = *((_DWORD *)v1 + 2);
      v19 = (char *)*((_DWORD *)v1 + 4);
      if ( (unsigned int)(v1 + 24) < Val )
      {
        do
        {
          if ( *(_DWORD *)v3 >= (signed int)v5 && *((_DWORD *)v3 + 1) > v5 )
          {
            result = (_DWORD *)sub_412967(v19, *(_DWORD *)v3, v5);
            if ( result )
              goto LABEL_21;
            *((_DWORD *)v3 + 1) = v5;
          }
          v19 += 4096;
          v3 += 8;
        }
        while ( (unsigned int)v3 < Val );
      }
    }
    v1 = *(char **)v1;
  }
  while ( v1 != (char *)off_4368B0 );
  v7 = (char *)&off_434890;
  while ( *((_DWORD *)v7 + 4) == -1 || !*((_DWORD *)v7 + 3) )
  {
    v7 = *(char **)v7;
    if ( v7 == (char *)&off_434890 )
    {
      v15 = sub_412467();
      if ( v15 )
      {
        v16 = v15[4];
        *(_BYTE *)(v16 + 8) = v5;
        off_4368B0 = (_UNKNOWN **)v15;
        *(_DWORD *)v16 = v16 + v5 + 8;
        *(_DWORD *)(v16 + 4) = 240 - v5;
        v15[6] -= (unsigned __int8)v5;
        return (_DWORD *)(v16 + 256);
      }
      return 0;
    }
  }
  v8 = (_DWORD *)*((_DWORD *)v7 + 3);
  v20 = 0;
  v9 = v8;
  for ( i = (_DWORD *)(*((_DWORD *)v7 + 4) + (((char *)v8 - v7 - 24) >> 3 << 12)); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( VirtualAlloc(i, v20 << 12, 0x1000u, 4u) != i )
    return 0;
  v11 = v8;
  if ( v20 > 0 )
  {
    v12 = i + 1;
    do
    {
      *((_BYTE *)v12 + 244) = -1;
      *(v12 - 1) = v12 + 1;
      *v12 = 240;
      *v11 = 240;
      v11[1] = 241;
      v12 += 1024;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  off_4368B0 = (_UNKNOWN **)v7;
  v13 = (_UNKNOWN **)(v7 + 8216);
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == -1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  *((_DWORD *)v7 + 3) = v14 ? v11 : 0;
  *((_BYTE *)i + 8) = a1;
  *((_DWORD *)v7 + 2) = v8;
  *v8 -= a1;
  i[1] -= a1;
  result = i + 64;
  *i = (char *)i + a1 + 8;
  return result;
}


// ========== Function: sub_412967 @ 0x412967 ==========
int __cdecl sub_412967(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}


// ========== Function: sub_412A8B @ 0x412A8B ==========
int __cdecl sub_412A8B(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  _BYTE *i; // eax
  bool v8; // zf
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v4 = (unsigned __int8)*a3;
  v11 = 0;
  v5 = (_DWORD *)(a1 + 8 * (((int)a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  if ( v4 > a4 )
  {
    *a3 = a4;
    *v5 += v4 - a4;
    v5[1] = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = &a3[a4];
    if ( &a3[a4] <= (_BYTE *)a2 + 248 )
    {
      for ( i = &a3[v4]; ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *a3 = a4;
        if ( (unsigned int)a3 <= *a2 && (unsigned int)v6 > *a2 )
        {
          if ( v6 >= (_BYTE *)a2 + 248 )
          {
            a2[1] = 0;
            *a2 = a2 + 2;
          }
          else
          {
            v9 = 0;
            *a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            a2[1] = v9;
          }
        }
        *v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}


// ========== Function: sub_412B34 @ 0x412B34 ==========
int __cdecl sub_412B34(int a1, int a2)
{
  SIZE_T v2; // esi
  int result; // eax
  void *v4; // [esp+14h] [ebp-20h]
  unsigned int v5; // [esp+18h] [ebp-1Ch]

  v2 = a2 * a1;
  v5 = a2 * a1;
  if ( (unsigned int)(a2 * a1) <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    v4 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_43A7A4 == 3 )
      {
        if ( v5 > dword_43A79C )
          goto LABEL_14;
        _lock(9);
        v4 = __sbh_alloc_block(v5);
        _unlock(9);
        if ( v4 )
        {
          memset(v4, 0, v5);
          goto LABEL_14;
        }
LABEL_15:
        v4 = HeapAlloc(hHeap, 8u, v2);
        goto LABEL_16;
      }
      if ( dword_43A7A4 == 2 && v2 <= dword_4368B4 )
      {
        _lock(9);
        v4 = sub_41275F(v2 >> 4);
        _unlock(9);
        if ( !v4 )
          goto LABEL_15;
        memset(v4, 0, v2);
      }
LABEL_14:
      if ( v4 )
        return (int)v4;
      goto LABEL_15;
    }
LABEL_16:
    if ( v4 || !dword_4395B0 )
      return (int)v4;
    result = _callnewh(v2);
    if ( !result )
      return result;
  }
}


// ========== Function: __callnewh @ 0x412C71 ==========
int __cdecl _callnewh(size_t Size)
{
  return dword_4395B4 && dword_4395B4(Size);
}


// ========== Function: ?__CxxUnhandledExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z @ 0x412C8C ==========
LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  PEXCEPTION_RECORD ExceptionRecord; // eax

  ExceptionRecord = ExceptionInfo->ExceptionRecord;
  if ( ExceptionInfo->ExceptionRecord->ExceptionCode == -529697949
    && ExceptionRecord->NumberParameters == 3
    && ExceptionRecord->ExceptionInformation[0] == 429065504 )
  {
    terminate();
  }
  if ( lpfn && _ValidateExecute((FARPROC)lpfn) )
    return lpfn(ExceptionInfo);
  else
    return 0;
}


// ========== Function: sub_412CD2 @ 0x412CD2 ==========
LONG (__stdcall *sub_412CD2())(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  LONG (__stdcall *result)(struct _EXCEPTION_POINTERS *); // eax

  result = SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  lpfn = result;
  return result;
}


// ========== Function: sub_412CE3 @ 0x412CE3 ==========
LPTOP_LEVEL_EXCEPTION_FILTER sub_412CE3()
{
  return SetUnhandledExceptionFilter(lpfn);
}


// ========== Function: _strchr @ 0x412D00 ==========
char *__cdecl strchr(const char *Str, int Val)
{
  const char *v2; // edx
  char v3; // cl
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  unsigned int v7; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax

  v2 = Str;
  if ( ((unsigned __int8)Str & 3) != 0 )
  {
    while ( 1 )
    {
      v3 = *v2++;
      if ( v3 == (_BYTE)Val )
        return (char *)(v2 - 1);
      if ( !v3 )
        return 0;
      if ( ((unsigned __int8)v2 & 3) == 0 )
        goto main_loop_2;
    }
  }
  else
  {
    while ( 1 )
    {
main_loop_2:
      while ( 1 )
      {
        v4 = (((unsigned __int8)Val << 8) | (unsigned __int8)Val | ((((unsigned __int8)Val << 8) | (unsigned __int8)Val) << 16)) ^ *(_DWORD *)v2;
        v5 = *(_DWORD *)v2 + 2130640639;
        v6 = v5 ^ ~*(_DWORD *)v2;
        v2 += 4;
        if ( (((v4 + 2130640639) ^ ~v4) & 0x81010100) != 0 )
          break;
        v7 = v6 & 0x81010100;
        if ( v7 && ((v7 & 0x1010100) != 0 || (v5 & 0x80000000) == 0) )
          return 0;
      }
      v9 = *((_DWORD *)v2 - 1);
      if ( (_BYTE)v9 == (_BYTE)Val )
        break;
      if ( !(_BYTE)v9 )
        return 0;
      if ( BYTE1(v9) == (_BYTE)Val )
        return (char *)(v2 - 3);
      if ( !BYTE1(v9) )
        return 0;
      v10 = HIWORD(v9);
      if ( (_BYTE)v10 == (_BYTE)Val )
        return (char *)(v2 - 2);
      if ( !(_BYTE)v10 )
        return 0;
      if ( BYTE1(v10) == (_BYTE)Val )
        return (char *)(v2 - 1);
      if ( !BYTE1(v10) )
        return 0;
    }
    return (char *)(v2 - 4);
  }
}


// ========== Function: _strpbrk @ 0x412DC0 ==========
char *__cdecl strpbrk(const char *Str, const char *Control)
{
  char *result; // eax
  signed __int32 v5[9]; // [esp+0h] [ebp-24h] BYREF

  result = 0;
  memset(v5, 0, 32);
  while ( 1 )
  {
    LOBYTE(result) = *Control;
    if ( !*Control )
      break;
    ++Control;
    _bittestandset(v5, (unsigned int)result);
  }
  while ( 1 )
  {
    LOBYTE(result) = *Str;
    if ( !*Str )
      break;
    ++Str;
    if ( _bittest(v5, (unsigned int)result) )
      return (char *)(Str - 1);
  }
  return result;
}


// ========== Function: ___crtLCMapStringA @ 0x412DFA ==========
int __cdecl __crtLCMapStringA(
        LCID Locale,
        DWORD dwMapFlags,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPSTR lpDestStr,
        int cchDest,
        UINT CodePage,
        int a8)
{
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  void *v12; // esp
  int v13; // eax
  int v14; // esi
  int v15; // eax
  void *v16; // esp
  int v17; // eax
  WCHAR v18[8]; // [esp+0h] [ebp-38h] BYREF
  int v19; // [esp+10h] [ebp-28h]
  LPWSTR lpWideCharStr; // [esp+14h] [ebp-24h]
  WCHAR *v21; // [esp+18h] [ebp-20h]
  int v22; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !dword_4395BC )
  {
    if ( LCMapStringW(0, 0x100u, &String1, 1, 0, 0) )
    {
      dword_4395BC = 1;
    }
    else
    {
      if ( !LCMapStringA(0, 0x100u, &byte_42C2D8, 1, 0, 0) )
        return 0;
      dword_4395BC = 2;
    }
  }
  if ( cchSrc > 0 )
    cchSrc = strncnt(lpSrcStr, cchSrc);
  if ( dword_4395BC == 2 )
    return LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
  if ( dword_4395BC != 1 )
    return 0;
  if ( !CodePage )
    CodePage = dword_4395EC;
  v9 = MultiByteToWideChar(CodePage, a8 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
  v10 = v9;
  v22 = v9;
  if ( !v9 )
    return 0;
  v11 = 2 * v9 + 3;
  LOBYTE(v11) = v11 & 0xFC;
  v12 = alloca(v11);
  ms_exc.old_esp = (DWORD)v18;
  lpWideCharStr = v18;
  ms_exc.registration.TryLevel = -1;
  if ( !v18 )
    return 0;
  if ( !MultiByteToWideChar(CodePage, 1u, lpSrcStr, cchSrc, lpWideCharStr, v10) )
    return 0;
  v13 = LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v10, 0, 0);
  v14 = v13;
  v19 = v13;
  if ( !v13 )
    return 0;
  if ( (dwMapFlags & 0x400) != 0 )
  {
    if ( cchDest && (v13 > cchDest || !LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v10, (LPWSTR)lpDestStr, cchDest)) )
      return 0;
  }
  else
  {
    v15 = 2 * v13 + 3;
    LOBYTE(v15) = v15 & 0xFC;
    v16 = alloca(v15);
    ms_exc.old_esp = (DWORD)v18;
    v21 = v18;
    ms_exc.registration.TryLevel = -1;
    if ( !v18 || !LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v22, v18, v14) )
      return 0;
    v17 = cchDest
        ? WideCharToMultiByte(CodePage, 0x220u, v18, v14, lpDestStr, cchDest, 0, 0)
        : WideCharToMultiByte(CodePage, 0x220u, v18, v14, 0, 0, 0, 0);
    v14 = v17;
    if ( !v17 )
      return 0;
  }
  return v14;
}


// ========== Function: __strrev @ 0x413020 ==========
char *__cdecl _strrev(char *Str)
{
  char *v1; // esi
  unsigned int v2; // kr04_4
  char *i; // edi
  char v4; // ah

  v1 = Str;
  v2 = strlen(Str) + 1;
  if ( ~v2 != -2 )
  {
    for ( i = &Str[v2 - 2]; v1 < i; --i )
    {
      v4 = *v1;
      *v1 = *i;
      *i = v4;
      ++v1;
    }
  }
  return Str;
}


// ========== Function: _strstr @ 0x413050 ==========
char *__cdecl strstr(const char *Str, const char *SubStr)
{
  char v2; // dl
  const char *v3; // edi
  char v4; // dh
  const char *v5; // ecx
  char *v6; // esi
  char v7; // al
  char v9; // ah
  char v10; // al
  char v11; // al

  v2 = *SubStr;
  v3 = Str;
  if ( !*SubStr )
    return (char *)Str;
  v4 = SubStr[1];
  if ( !v4 )
    JUMPOUT(0x412D06);
findnext:
  v5 = SubStr;
  v6 = (char *)(v3 + 1);
  if ( *v3 == v2 )
    goto first_char_found;
  if ( *v3 )
  {
    while ( 2 )
    {
      v7 = *v6++;
      while ( v7 == v2 )
      {
first_char_found:
        v7 = *v6++;
        if ( v7 == v4 )
        {
          v3 = v6 - 1;
          while ( 1 )
          {
            v9 = v5[2];
            if ( !v9 )
              break;
            v10 = *v6;
            v6 += 2;
            if ( v10 != v9 )
              goto findnext;
            v11 = v5[3];
            if ( !v11 )
              break;
            v5 += 2;
            if ( v11 != *(v6 - 1) )
              goto findnext;
          }
          return (char *)(v3 - 1);
        }
      }
      if ( v7 )
        continue;
      break;
    }
  }
  return 0;
}


// ========== Function: _strspn @ 0x4130D0 ==========
size_t __cdecl strspn(const char *Str, const char *Control)
{
  unsigned int v2; // eax
  size_t v5; // ecx
  signed __int32 v7[9]; // [esp+0h] [ebp-24h] BYREF

  v2 = 0;
  memset(v7, 0, 32);
  while ( 1 )
  {
    LOBYTE(v2) = *Control;
    if ( !*Control )
      break;
    ++Control;
    _bittestandset(v7, v2);
  }
  v5 = -1;
  do
  {
    ++v5;
    LOBYTE(v2) = *Str;
    if ( !*Str )
      break;
    ++Str;
  }
  while ( _bittest(v7, v2) );
  return v5;
}


// ========== Function: _strcspn @ 0x413110 ==========
size_t __cdecl strcspn(const char *Str, const char *Control)
{
  unsigned int v2; // eax
  size_t v5; // ecx
  signed __int32 v7[9]; // [esp+0h] [ebp-24h] BYREF

  v2 = 0;
  memset(v7, 0, 32);
  while ( 1 )
  {
    LOBYTE(v2) = *Control;
    if ( !*Control )
      break;
    ++Control;
    _bittestandset(v7, v2);
  }
  v5 = -1;
  do
  {
    ++v5;
    LOBYTE(v2) = *Str;
    if ( !*Str )
      break;
    ++Str;
  }
  while ( !_bittest(v7, v2) );
  return v5;
}


// ========== Function: _strrchr @ 0x413150 ==========
char *__cdecl strrchr(const char *Str, int Ch)
{
  unsigned int v2; // ecx
  const char *v3; // edi
  bool v4; // zf
  char *v5; // edi

  v2 = strlen(Str) + 1;
  v3 = &Str[v2 - 1];
  do
  {
    if ( !v2 )
      break;
    v4 = *v3-- == (unsigned __int8)Ch;
    --v2;
  }
  while ( !v4 );
  v5 = (char *)(v3 + 1);
  if ( *v5 == (_BYTE)Ch )
    return v5;
  else
    return 0;
}


// ========== Function: __flsbuf @ 0x413177 ==========
int __cdecl _flsbuf(int Ch, FILE *File)
{
  FILE *v2; // esi
  int flag; // eax
  int v4; // ebx
  int v5; // eax
  char *base; // eax
  signed int v7; // edi
  _BYTE *v8; // eax

  v2 = File;
  flag = File->_flag;
  v4 = File->_file;
  if ( (flag & 0x82) == 0 || (flag & 0x40) != 0 )
    goto LABEL_24;
  if ( (flag & 1) == 0 )
    goto LABEL_6;
  File->_cnt = 0;
  if ( (flag & 0x10) == 0 )
  {
LABEL_24:
    LOBYTE(flag) = flag | 0x20;
    v2->_flag = flag;
    return -1;
  }
  LOBYTE(flag) = flag & 0xFE;
  v2->_ptr = v2->_base;
  v2->_flag = flag;
LABEL_6:
  v5 = v2->_flag;
  v2->_cnt = 0;
  File = 0;
  LOBYTE(v5) = v5 & 0xED | 2;
  v2->_flag = v5;
  if ( (v5 & 0x10C) == 0 && (v2 != (FILE *)&unk_436910 && v2 != (FILE *)&unk_436930 || !_isatty(v4)) )
    _getbuf(v2);
  if ( (v2->_flag & 0x108) != 0 )
  {
    base = v2->_base;
    v7 = v2->_ptr - base;
    v2->_ptr = base + 1;
    v2->_cnt = v2->_bufsiz - 1;
    if ( v7 <= 0 )
    {
      if ( v4 == -1 )
        v8 = &unk_4347D8;
      else
        v8 = (_BYTE *)(dword_43A7C0[v4 >> 5] + 36 * (v4 & 0x1F));
      if ( (v8[4] & 0x20) != 0 )
        _lseek(v4, 0, 2);
    }
    else
    {
      File = (FILE *)_write(v4, base, v7);
    }
    *v2->_base = Ch;
  }
  else
  {
    v7 = 1;
    File = (FILE *)_write(v4, &Ch, 1u);
  }
  if ( File == (FILE *)v7 )
    return (unsigned __int8)Ch;
  v2->_flag |= 0x20u;
  return -1;
}


// ========== Function: sub_41328F @ 0x41328F ==========
int __cdecl sub_41328F(FILE *File, char *a2, int a3)
{
  int v3; // ecx
  char v4; // bl
  char *v5; // esi
  bool v6; // zf
  int v7; // eax
  int int_arg; // eax
  int v9; // eax
  int v10; // esi
  int v11; // eax
  char *v12; // ecx
  char *i; // eax
  int v14; // edx
  wchar_t short_arg; // ax
  __int16 *v16; // eax
  int v17; // ecx
  unsigned int v18; // eax
  int v19; // eax
  void *v20; // eax
  char *j; // eax
  int v22; // edx
  _WORD *v23; // eax
  __int64 v24; // rax
  int v25; // eax
  int v26; // ebx
  _BYTE *v27; // eax
  char *v28; // eax
  char v29; // bl
  int v30; // esi
  wchar_t *v31; // ebx
  int v32; // edi
  wchar_t v33; // ax
  int v34; // eax
  char MbCh[511]; // [esp+Ch] [ebp-24Ch] BYREF
  char v38; // [esp+20Bh] [ebp-4Dh] BYREF
  int v39; // [esp+20Ch] [ebp-4Ch]
  int v40; // [esp+210h] [ebp-48h]
  char v41[4]; // [esp+214h] [ebp-44h] BYREF
  int v42; // [esp+218h] [ebp-40h]
  int v43; // [esp+21Ch] [ebp-3Ch]
  int v44; // [esp+220h] [ebp-38h]
  int v45; // [esp+224h] [ebp-34h]
  LPVOID lpMem; // [esp+228h] [ebp-30h]
  int v47; // [esp+22Ch] [ebp-2Ch]
  int v48; // [esp+230h] [ebp-28h]
  int v49; // [esp+234h] [ebp-24h]
  unsigned __int64 v50; // [esp+238h] [ebp-20h]
  _WORD v51[3]; // [esp+242h] [ebp-16h] BYREF
  int v52; // [esp+248h] [ebp-10h]
  int v53; // [esp+24Ch] [ebp-Ch]
  int v54; // [esp+250h] [ebp-8h]
  int v55; // [esp+254h] [ebp-4h]
  char *v56; // [esp+264h] [ebp+Ch]

  v3 = 0;
  v52 = 0;
  v4 = *a2;
  v5 = a2 + 1;
  v6 = *a2 == 0;
  *(_DWORD *)&v51[1] = 0;
  lpMem = 0;
  v56 = a2 + 1;
  if ( !v6 )
  {
    while ( 1 )
    {
      if ( *(int *)&v51[1] < 0 )
        return *(_DWORD *)&v51[1];
      if ( v4 < 32 || v4 > 120 )
        v7 = 0;
      else
        v7 = *(&byte_42C2D8 + v4) & 0xF;
      v43 = byte_42C2F8[8 * v7 + v3] >> 4;
      switch ( v43 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v54 = -1;
          v42 = 0;
          v44 = 0;
          v48 = 0;
          v49 = 0;
          v55 = 0;
          v47 = 0;
          goto LABEL_179;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v55 |= 2u;
              break;
            case '#':
              LOBYTE(v55) = v55 | 0x80;
              break;
            case '+':
              v55 |= 1u;
              break;
            case '-':
              v55 |= 4u;
              break;
            case '0':
              v55 |= 8u;
              break;
          }
          goto LABEL_179;
        case 3:
          if ( v4 == 42 )
          {
            int_arg = get_int_arg(&a3);
            v48 = int_arg;
            if ( int_arg >= 0 )
              goto LABEL_179;
            v55 |= 4u;
            v9 = -int_arg;
          }
          else
          {
            v9 = v4 + 10 * v48 - 48;
          }
          v48 = v9;
          goto LABEL_179;
        case 4:
          v54 = 0;
          goto LABEL_179;
        case 5:
          if ( v4 == 42 )
          {
            v54 = get_int_arg(&a3);
            if ( v54 < 0 )
              v54 = -1;
          }
          else
          {
            v54 = v4 + 10 * v54 - 48;
          }
          goto LABEL_179;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v55) |= 0x80u;
                v56 = v5 + 2;
              }
              else
              {
                v43 = 0;
LABEL_42:
                v47 = 0;
                if ( *((char *)off_434474 + 2 * (unsigned __int8)v4 + 1) < 0 )
                {
                  write_char(v4, File, (int)&v51[1]);
                  v4 = *v5;
                  v56 = v5 + 1;
                }
                write_char(v4, File, (int)&v51[1]);
              }
              break;
            case 'h':
              v55 |= 0x20u;
              break;
            case 'l':
              v55 |= 0x10u;
              break;
            case 'w':
              v55 |= 0x800u;
              break;
          }
          goto LABEL_179;
        case 7:
          if ( v4 > 103 )
          {
            switch ( v4 )
            {
              case 'i':
                goto LABEL_119;
              case 'n':
                v23 = (_WORD *)get_int_arg(&a3);
                if ( (v55 & 0x20) != 0 )
                  *v23 = v51[1];
                else
                  *(_DWORD *)v23 = *(_DWORD *)&v51[1];
                v44 = 1;
                goto LABEL_177;
              case 'o':
                v52 = 8;
                if ( (v55 & 0x80u) != 0 )
                  v55 |= 0x200u;
                break;
              default:
                switch ( v4 )
                {
                  case 'p':
                    v54 = 8;
LABEL_110:
                    v45 = 7;
                    break;
                  case 's':
                    goto LABEL_55;
                  case 'u':
                    goto LABEL_120;
                  case 'x':
                    v45 = 39;
                    break;
                  default:
                    goto LABEL_154;
                }
                v52 = 16;
                if ( (v55 & 0x80u) != 0 )
                {
                  LOBYTE(v51[0]) = 48;
                  v49 = 2;
                  HIBYTE(v51[0]) = v45 + 81;
                }
                break;
            }
LABEL_121:
            if ( (v55 & 0x8000) == 0 )
            {
              if ( (v55 & 0x20) != 0 )
              {
                if ( (v55 & 0x40) != 0 )
                  LODWORD(v24) = (__int16)get_int_arg(&a3);
                else
                  LODWORD(v24) = (unsigned __int16)get_int_arg(&a3);
              }
              else
              {
                if ( (v55 & 0x40) == 0 )
                {
                  v24 = (unsigned int)get_int_arg(&a3);
                  goto LABEL_131;
                }
                LODWORD(v24) = get_int_arg(&a3);
              }
              v24 = (int)v24;
            }
            else
            {
              LODWORD(v24) = get_int64_arg(&a3);
            }
LABEL_131:
            if ( (v55 & 0x40) != 0 && v24 < 0 )
            {
              BYTE1(v55) |= 1u;
              v50 = -v24;
            }
            else
            {
              v50 = v24;
            }
            if ( (v55 & 0x8000) == 0 )
              HIDWORD(v50) = 0;
            if ( v54 >= 0 )
            {
              v55 &= ~8u;
              if ( v54 > 512 )
                v54 = 512;
            }
            else
            {
              v54 = 1;
            }
            if ( !v50 )
              v49 = 0;
            v53 = (int)&v38;
            while ( 1 )
            {
              v25 = v54--;
              if ( v25 <= 0 && !v50 )
                break;
              v26 = v50 % v52 + 48;
              v50 /= (unsigned __int64)v52;
              if ( v26 > 57 )
                LOBYTE(v26) = v45 + v26;
              v27 = (_BYTE *)v53--;
              *v27 = v26;
            }
            v28 = &v38 - v53++;
            v52 = (int)v28;
            if ( (v55 & 0x200) != 0 && (*(_BYTE *)v53 != 48 || !v28) )
            {
              --v53;
              v19 = (int)(v28 + 1);
              *(_BYTE *)v53 = 48;
              goto LABEL_153;
            }
            goto LABEL_154;
          }
          if ( v4 >= 101 )
            goto LABEL_65;
          if ( v4 > 88 )
          {
            if ( v4 == 90 )
            {
              v16 = (__int16 *)get_int_arg(&a3);
              if ( v16 && (v17 = *((_DWORD *)v16 + 1)) != 0 )
              {
                if ( (v55 & 0x800) != 0 )
                {
                  v18 = (unsigned int)*v16 >> 1;
                  v53 = v17;
                  v52 = v18;
                  v47 = 1;
                  goto LABEL_154;
                }
                v47 = 0;
                v53 = v17;
                v19 = *v16;
              }
              else
              {
                v53 = (int)off_4368C0;
                v19 = strlen(off_4368C0);
              }
              goto LABEL_153;
            }
            if ( v4 == 99 )
              goto LABEL_69;
            if ( v4 != 100 )
              goto LABEL_154;
LABEL_119:
            v55 |= 0x40u;
LABEL_120:
            v52 = 10;
            goto LABEL_121;
          }
          switch ( v4 )
          {
            case 'X':
              goto LABEL_110;
            case 'C':
              if ( (v55 & 0x830) == 0 )
                v55 |= 0x800u;
LABEL_69:
              if ( (v55 & 0x810) != 0 )
              {
                short_arg = get_short_arg(&a3);
                v52 = wctomb(MbCh, short_arg);
                if ( v52 < 0 )
                  v44 = 1;
              }
              else
              {
                MbCh[0] = get_int_arg(&a3);
                v52 = 1;
              }
              v53 = (int)MbCh;
              break;
            case 'E':
            case 'G':
              v42 = 1;
              v4 += 32;
LABEL_65:
              v55 |= 0x40u;
              v53 = (int)MbCh;
              if ( v54 >= 0 )
              {
                if ( v54 )
                {
                  if ( v54 > 512 )
                    v54 = 512;
                  if ( v54 > 163 )
                  {
                    v20 = malloc(v54 + 349);
                    lpMem = v20;
                    if ( v20 )
                      v53 = (int)v20;
                    else
                      v54 = 163;
                  }
                }
                else
                {
                  v54 = v4 == 103;
                }
              }
              else
              {
                v54 = 6;
              }
              a3 += 8;
              v39 = *(_DWORD *)(a3 - 8);
              v40 = *(_DWORD *)(a3 - 4);
              off_4368D0[0]();
            case 'S':
              if ( (v55 & 0x830) == 0 )
                v55 |= 0x800u;
LABEL_55:
              v10 = 0x7FFFFFFF;
              if ( v54 != -1 )
                v10 = v54;
              v11 = get_int_arg(&a3);
              v12 = (char *)v11;
              v53 = v11;
              if ( (v55 & 0x810) != 0 )
              {
                if ( !v11 )
                {
                  v12 = (char *)off_4368C4;
                  v53 = (int)off_4368C4;
                }
                v47 = 1;
                for ( i = v12; ; i += 2 )
                {
                  v14 = v10--;
                  if ( !v14 || !*(_WORD *)i )
                    break;
                }
                v19 = (i - v12) >> 1;
              }
              else
              {
                if ( !v11 )
                {
                  v12 = off_4368C0;
                  v53 = (int)off_4368C0;
                }
                for ( j = v12; ; ++j )
                {
                  v22 = v10--;
                  if ( !v22 || !*j )
                    break;
                }
                v19 = j - v12;
              }
LABEL_153:
              v52 = v19;
              break;
          }
LABEL_154:
          if ( v44 )
            goto LABEL_177;
          v29 = v55;
          if ( (v55 & 0x40) == 0 )
            goto LABEL_163;
          if ( (v55 & 0x100) != 0 )
          {
            LOBYTE(v51[0]) = 45;
LABEL_162:
            v49 = 1;
            goto LABEL_163;
          }
          if ( (v55 & 1) != 0 )
          {
            LOBYTE(v51[0]) = 43;
            goto LABEL_162;
          }
          if ( (v55 & 2) != 0 )
          {
            LOBYTE(v51[0]) = 32;
            goto LABEL_162;
          }
LABEL_163:
          v30 = v48 - v49 - v52;
          if ( (v55 & 0xC) == 0 )
            write_multi_char(32, v48 - v49 - v52, File, (int)&v51[1]);
          write_string((int)v51, v49, File, (int)&v51[1]);
          if ( (v29 & 8) != 0 && (v29 & 4) == 0 )
            write_multi_char(48, v30, File, (int)&v51[1]);
          if ( v47 && v52 > 0 )
          {
            v31 = (wchar_t *)v53;
            v32 = v52 - 1;
            do
            {
              v33 = *v31++;
              v34 = wctomb(v41, v33);
              if ( v34 <= 0 )
                break;
              write_string((int)v41, v34, File, (int)&v51[1]);
            }
            while ( v32-- );
          }
          else
          {
            write_string(v53, v52, File, (int)&v51[1]);
          }
          if ( (v55 & 4) != 0 )
            write_multi_char(32, v30, File, (int)&v51[1]);
LABEL_177:
          if ( lpMem )
          {
            sub_40D386(lpMem);
            lpMem = 0;
          }
LABEL_179:
          v4 = *v56;
          v5 = v56 + 1;
          v6 = *v56++ == 0;
          if ( v6 )
            return *(_DWORD *)&v51[1];
          v3 = v43;
          break;
        default:
          goto LABEL_179;
      }
    }
  }
  return *(_DWORD *)&v51[1];
}


// ========== Function: _write_char @ 0x413A2D ==========
_DWORD *__cdecl write_char(int a1, FILE *File, _DWORD *a3)
{
  int v4; // eax
  bool v5; // zf
  _DWORD *result; // eax

  if ( --File->_cnt < 0 )
  {
    v4 = _flsbuf(a1, File);
  }
  else
  {
    *File->_ptr++ = a1;
    v4 = (unsigned __int8)a1;
  }
  v5 = v4 == -1;
  result = a3;
  if ( v5 )
    *a3 = -1;
  else
    ++*a3;
  return result;
}


// ========== Function: _write_multi_char @ 0x413A62 ==========
_DWORD *__cdecl write_multi_char(int a1, _DWORD *a2, FILE *File, _DWORD *a4)
{
  _DWORD *result; // eax
  _DWORD *i; // edi

  result = a2;
  for ( i = (_DWORD *)((char *)a2 - 1); (int)result > 0; i = (_DWORD *)((char *)i - 1) )
  {
    result = write_char(a1, File, a4);
    if ( *a4 == -1 )
      break;
    result = i;
  }
  return result;
}


// ========== Function: _write_string @ 0x413A93 ==========
_DWORD *__cdecl write_string(char *a1, _DWORD *a2, FILE *File, _DWORD *a4)
{
  _DWORD *result; // eax
  _DWORD *i; // ebx
  int v7; // eax

  result = a2;
  for ( i = (_DWORD *)((char *)a2 - 1); (int)result > 0; i = (_DWORD *)((char *)i - 1) )
  {
    v7 = *a1++;
    result = write_char(v7, File, a4);
    if ( *a4 == -1 )
      break;
    result = i;
  }
  return result;
}


// ========== Function: _get_int_arg @ 0x413ACB ==========
int __cdecl get_int_arg(_DWORD *a1)
{
  *a1 += 4;
  return *(_DWORD *)(*a1 - 4);
}


// ========== Function: _get_int64_arg @ 0x413AD8 ==========
__int64 __cdecl get_int64_arg(_DWORD *a1)
{
  *a1 += 8;
  return *(_QWORD *)(*a1 - 8);
}


// ========== Function: _get_short_arg @ 0x413AE8 ==========
__int16 __cdecl get_short_arg(_DWORD *a1)
{
  *a1 += 4;
  return *(_WORD *)(*a1 - 4);
}


// ========== Function: _strncmp @ 0x413B00 ==========
int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount)
{
  size_t v3; // ecx
  const char *v4; // edi
  bool v5; // zf
  size_t v6; // ecx
  const char *v7; // edi
  unsigned __int8 v9; // al

  v3 = MaxCount;
  if ( MaxCount )
  {
    v4 = Str1;
    do
    {
      if ( !v3 )
        break;
      v5 = *v4++ == 0;
      --v3;
    }
    while ( !v5 );
    v6 = MaxCount - v3;
    v7 = Str1;
    do
    {
      if ( !v6 )
        break;
      v5 = *Str2++ == *v7++;
      --v6;
    }
    while ( v5 );
    v9 = *(Str2 - 1);
    v3 = 0;
    if ( v9 > (unsigned int)*(v7 - 1) )
      return ~v3;
    if ( v9 != *(v7 - 1) )
    {
      v3 = -2;
      return ~v3;
    }
  }
  return v3;
}


// ========== Function: ___crtGetStringTypeA @ 0x413B38 ==========
BOOL __cdecl __crtGetStringTypeA(
        DWORD dwInfoType,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPWORD lpCharType,
        UINT CodePage,
        LCID Locale,
        int a7)
{
  int v7; // eax
  LCID v8; // eax
  int v10; // eax
  size_t v11; // edi
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  WCHAR v15[8]; // [esp+0h] [ebp-34h] BYREF
  WCHAR *v16; // [esp+10h] [ebp-24h]
  int cchWideChar; // [esp+14h] [ebp-20h]
  WORD CharType; // [esp+18h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  v7 = dword_4395C0;
  if ( !dword_4395C0 )
  {
    if ( GetStringTypeW(1u, &String1, 1, &CharType) )
    {
      v7 = 1;
    }
    else
    {
      if ( !GetStringTypeA(0, 1u, &byte_42C2D8, 1, &CharType) )
        return 0;
      v7 = 2;
    }
    dword_4395C0 = v7;
  }
  if ( v7 != 2 )
  {
    if ( v7 == 1 )
    {
      if ( !CodePage )
        CodePage = dword_4395EC;
      v10 = MultiByteToWideChar(CodePage, a7 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
      cchWideChar = v10;
      if ( v10 )
      {
        v11 = 2 * v10;
        v12 = 2 * v10 + 3;
        LOBYTE(v12) = v12 & 0xFC;
        v13 = alloca(v12);
        ms_exc.old_esp = (DWORD)v15;
        v16 = v15;
        memset(v15, 0, v11);
        ms_exc.registration.TryLevel = -1;
        if ( v15 )
        {
          v14 = MultiByteToWideChar(CodePage, 1u, lpSrcStr, cchSrc, v15, cchWideChar);
          if ( v14 )
            return GetStringTypeW(dwInfoType, v15, v14, lpCharType);
        }
      }
    }
    return 0;
  }
  v8 = Locale;
  if ( !Locale )
    v8 = dword_4395DC;
  return GetStringTypeA(v8, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}


// ========== Function: __setdefaultprecision @ 0x413C81 ==========
unsigned int _setdefaultprecision()
{
  return _controlfp(0x10000u, 0x30000u);
}


// ========== Function: __ms_p5_test_fdiv @ 0x413C93 ==========
BOOL _ms_p5_test_fdiv()
{
  return 4195835.0 - 4195835.0 / 3145727.0 * 3145727.0 > 1.0;
}


// ========== Function: __ms_p5_mp_test_fdiv @ 0x413CD1 ==========
int _ms_p5_mp_test_fdiv()
{
  HMODULE ModuleHandleA; // eax
  BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD); // eax

  ModuleHandleA = GetModuleHandleA("KERNEL32");
  if ( ModuleHandleA
    && (IsProcessorFeaturePresent = (BOOL (__stdcall *)(DWORD))GetProcAddress(
                                                                 ModuleHandleA,
                                                                 "IsProcessorFeaturePresent")) != 0 )
  {
    return IsProcessorFeaturePresent(0);
  }
  else
  {
    return _ms_p5_test_fdiv();
  }
}


// ========== Function: __forcdecpt @ 0x413CFA ==========
char __cdecl _forcdecpt(char *a1)
{
  char *v1; // esi
  int v2; // eax
  char result; // al
  char *v4; // esi
  char v5; // cl

  v1 = a1;
  if ( tolower(*a1) != 101 )
  {
    do
    {
      ++v1;
      if ( cbMultiByte <= 1 )
        v2 = *((_BYTE *)off_434474 + 2 * *v1) & 4;
      else
        v2 = _isctype(*v1, 4);
    }
    while ( v2 );
  }
  result = *v1;
  *v1 = byte_434684;
  v4 = v1 + 1;
  do
  {
    v5 = *v4;
    *v4 = result;
    result = v5;
  }
  while ( *v4++ );
  return result;
}


// ========== Function: __cropzeros @ 0x413D54 ==========
char *__cdecl _cropzeros(char *a1)
{
  char *v1; // eax
  char i; // cl
  char v3; // cl
  char *result; // eax
  char v5; // cl
  char *v6; // ecx
  char v7; // dl

  v1 = a1;
  for ( i = *a1; i; i = *++v1 )
  {
    if ( i == byte_434684 )
      break;
  }
  v3 = *v1;
  result = v1 + 1;
  if ( v3 )
  {
    while ( 1 )
    {
      v5 = *result;
      if ( !*result || v5 == 101 || v5 == 69 )
        break;
      ++result;
    }
    v6 = result;
    do
      --result;
    while ( *result == 48 );
    if ( *result == byte_434684 )
      --result;
    do
    {
      v7 = *v6;
      ++result;
      ++v6;
      *result = v7;
    }
    while ( v7 );
  }
  return result;
}


// ========== Function: __positive @ 0x413DA2 ==========
BOOL __cdecl _positive(double *a1)
{
  return *a1 >= 0.0;
}


// ========== Function: __fassign @ 0x413DBA ==========
_DWORD *__cdecl _fassign(int a1, _DWORD *a2, int a3)
{
  _DWORD *result; // eax
  _DWORD v4[2]; // [esp+0h] [ebp-8h] BYREF

  if ( a1 )
  {
    sub_415DDF(v4, a3);
    result = a2;
    *a2 = v4[0];
    a2[1] = v4[1];
  }
  else
  {
    sub_415E0C(&a3, a3);
    result = a2;
    *a2 = a3;
  }
  return result;
}


// ========== Function: __cftoe @ 0x413DF8 ==========
int __cdecl _cftoe(double *a1, int a2, int a3, int a4)
{
  double v6; // [esp+0h] [ebp-3Ch]
  char Destination[24]; // [esp+14h] [ebp-28h] BYREF
  int v8[4]; // [esp+2Ch] [ebp-10h] BYREF

  v6 = *a1;
  _fltout2(SLOBYTE(v6), SHIDWORD(v6), (int)v8, Destination);
  _fptostr((void *)((v8[0] == 45) + a2 + (a3 > 0)), a3 + 1, (int)v8);
  _cftoe2(a2, a3, a4, v8, 0);
  return a2;
}


// ========== Function: __cftoe2 @ 0x413E59 ==========
_BYTE *__cdecl _cftoe2(_BYTE *a1, int a2, int a3, int a4, char a5)
{
  _BYTE *v5; // eax
  char *v6; // eax
  int v7; // ebx

  if ( a5 )
    _shift(&a1[*(_DWORD *)a4 == 45], a2 > 0);
  v5 = a1;
  if ( *(_DWORD *)a4 == 45 )
  {
    *a1 = 45;
    v5 = a1 + 1;
  }
  if ( a2 > 0 )
  {
    *v5 = v5[1];
    *++v5 = byte_434684;
  }
  v6 = strcpy(&v5[(a5 == 0) + a2], "e+000");
  if ( a3 )
    *v6 = 69;
  if ( **(_BYTE **)(a4 + 12) != 48 )
  {
    v7 = *(_DWORD *)(a4 + 4) - 1;
    if ( v7 < 0 )
    {
      v7 = 1 - *(_DWORD *)(a4 + 4);
      v6[1] = 45;
    }
    if ( v7 >= 100 )
    {
      v6[2] += v7 / 100;
      v7 %= 100;
    }
    if ( v7 >= 10 )
    {
      v6[3] += v7 / 10;
      v7 %= 10;
    }
    v6[4] += v7;
  }
  return a1;
}


// ========== Function: __cftof @ 0x413F1B ==========
char *__cdecl _cftof(double *a1, char *Src, size_t Size)
{
  double v5; // [esp+0h] [ebp-3Ch]
  char Destination[24]; // [esp+14h] [ebp-28h] BYREF
  int v7[4]; // [esp+2Ch] [ebp-10h] BYREF

  v5 = *a1;
  _fltout2(SLOBYTE(v5), SHIDWORD(v5), (int)v7, Destination);
  _fptostr(&Src[v7[0] == 45], Size + v7[1], (int)v7);
  _cftof2(Src, Size, (int)v7, 0);
  return Src;
}


// ========== Function: __cftof2 @ 0x413F70 ==========
char *__cdecl _cftof2(char *Src, int Size, _DWORD *a3, char a4)
{
  int v4; // eax
  char *v5; // eax
  _BYTE *v6; // edi
  int v7; // eax
  _BYTE *v8; // edi
  int v9; // esi
  void *v10; // edi
  int v11; // esi

  v4 = a3[1] - 1;
  if ( a4 && v4 == Size )
  {
    v5 = &Src[v4 + (*a3 == 45)];
    *v5 = 48;
    v5[1] = 0;
  }
  v6 = Src;
  if ( *a3 == 45 )
  {
    *Src = 45;
    v6 = Src + 1;
  }
  v7 = a3[1];
  if ( v7 > 0 )
  {
    v8 = &v6[v7];
  }
  else
  {
    _shift(v6, 1);
    *v6 = 48;
    v8 = v6 + 1;
  }
  if ( Size > 0 )
  {
    _shift(v8, 1);
    *v8 = byte_434684;
    v9 = a3[1];
    v10 = v8 + 1;
    if ( v9 < 0 )
    {
      if ( a4 )
      {
        v11 = -v9;
      }
      else
      {
        v11 = -v9;
        if ( Size < v11 )
        {
LABEL_15:
          _shift(v10, Size);
          memset(v10, 48, Size);
          return Src;
        }
      }
      Size = v11;
      goto LABEL_15;
    }
  }
  return Src;
}


// ========== Function: __cftog @ 0x414017 ==========
char *__cdecl _cftog(double *a1, char *Src, signed int Size, int a4)
{
  int v5; // esi
  char *v6; // edi
  double v8; // [esp+0h] [ebp-44h]
  char Destination[24]; // [esp+1Ch] [ebp-28h] BYREF
  int v10; // [esp+34h] [ebp-10h] BYREF
  int v11; // [esp+38h] [ebp-Ch]

  v8 = *a1;
  _fltout2(SLOBYTE(v8), SHIDWORD(v8), (int)&v10, Destination);
  v5 = v11 - 1;
  v6 = &Src[v10 == 45];
  _fptostr(v6, Size, (int)&v10);
  if ( v11 - 1 < -4 || v11 - 1 >= Size )
    return _cftoe2(Src, Size, a4, (int)&v10, 1);
  if ( v5 < v11 - 1 )
    v6[strlen(v6) - 1] = 0;
  return _cftof2(Src, Size, &v10, 1);
}


// ========== Function: __cfltcvt @ 0x4140AA ==========
char *__cdecl _cfltcvt(double *a1, char *Src, int a3, size_t Size, int a5)
{
  if ( a3 == 101 || a3 == 69 )
    return (char *)_cftoe(a1, (int)Src, Size, a5);
  if ( a3 == 102 )
    return _cftof(a1, Src, Size);
  return _cftog(a1, Src, Size, a5);
}


// ========== Function: __shift @ 0x4140FB ==========
void __cdecl _shift(const char *Src, int a2)
{
  size_t v2; // eax

  if ( a2 )
  {
    v2 = strlen(Src);
    memcpy_0((void *)&Src[a2], Src, v2 + 1);
  }
}


// ========== Function: _toupper @ 0x414120 ==========
int __cdecl toupper(int C)
{
  int v1; // ebx
  int result; // eax
  int Ca; // [esp+8h] [ebp+4h]

  v1 = 0;
  if ( dword_4395DC )
  {
    InterlockedIncrement(&Addend);
    if ( dword_439770 )
    {
      InterlockedDecrement(&Addend);
      _lock(19);
      v1 = 1;
    }
    Ca = toupper_0(C);
    if ( v1 )
      _unlock(19);
    else
      InterlockedDecrement(&Addend);
    return Ca;
  }
  else
  {
    result = C;
    if ( C >= 97 && C <= 122 )
      return C - 32;
  }
  return result;
}


// ========== Function: _toupper_0 @ 0x41418F ==========
int __cdecl toupper_0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  CHAR DestStr[4]; // [esp+4h] [ebp-4h] BYREF

  if ( dword_4395DC )
  {
    v2 = C;
    if ( (C >= 256 || (cbMultiByte <= 1 ? (v3 = *((_BYTE *)off_434474 + 2 * C) & 2) : (v3 = _isctype(C, 2)), v3))
      && (*((char *)off_434474 + 2 * BYTE1(v2) + 1) >= 0
        ? (LOWORD(C) = (unsigned __int8)v2, v4 = __crtLCMapStringA(
                                                   dword_4395DC,
                                                   0x200u,
                                                   (LPCSTR)&C,
                                                   1,
                                                   DestStr,
                                                   3,
                                                   0,
                                                   1))
        : (LOBYTE(C) = BYTE1(v2),
           *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2,
           v4 = __crtLCMapStringA(dword_4395DC, 0x200u, (LPCSTR)&C, 2, DestStr, 3, 0, 1)),
          v4) )
    {
      if ( v4 == 1 )
        return (unsigned __int8)DestStr[0];
      else
        return *(unsigned __int16 *)DestStr;
    }
    else
    {
      return v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 97 && C <= 122 )
      return C - 32;
  }
  return result;
}


// ========== Function: __aulldiv @ 0x414260 ==========
unsigned int __stdcall _aulldiv(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    return v8;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (unsigned int)a2;
    return v3 / (unsigned int)a2;
  }
}


// ========== Function: __aullrem @ 0x4142D0 ==========
unsigned __int64 __stdcall _aullrem(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  bool v7; // cf
  int v8; // ecx
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = HIDWORD(a2) * (v6 / v5);
    v9 = (unsigned int)a2 * (unsigned __int64)(unsigned int)(v6 / v5);
    v7 = __CFADD__(v8, HIDWORD(v9));
    HIDWORD(v9) += v8;
    if ( v7 || v9 > a1 )
      v9 -= a2;
    return a1 - v9;
  }
  else
  {
    LODWORD(v2) = a1;
    HIDWORD(v2) = HIDWORD(a1) % (unsigned int)a2;
    return v2 % (unsigned int)a2;
  }
}


// ========== Function: ___initstdio @ 0x414345 ==========
int __initstdio()
{
  int v0; // eax
  int v1; // ecx
  _UNKNOWN **v2; // eax
  int v3; // ecx
  _DWORD *v4; // edx
  int result; // eax

  v0 = dword_43A780;
  if ( !dword_43A780 )
  {
    v0 = 512;
LABEL_5:
    dword_43A780 = v0;
    goto LABEL_6;
  }
  if ( dword_43A780 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  dword_439778 = sub_412B34(v0, 4);
  if ( !dword_439778 )
  {
    dword_43A780 = 20;
    dword_439778 = sub_412B34(20, 4);
    if ( !dword_439778 )
      _amsg_exit(0x1Au);
  }
  v1 = 0;
  v2 = &off_4368F0;
  do
  {
    *(_DWORD *)(v1 + dword_439778) = v2;
    v2 += 8;
    v1 += 4;
  }
  while ( (int)v2 < (int)&unk_436B70 );
  v3 = 0;
  v4 = &unk_436900;
  do
  {
    result = *(_DWORD *)(dword_43A7C0[v3 >> 5] + 36 * (v3 & 0x1F));
    if ( result == -1 || !result )
      *v4 = -1;
    v4 += 8;
    ++v3;
  }
  while ( (int)v4 < (int)dword_436960 );
  return result;
}


// ========== Function: ___endstdio @ 0x4143ED ==========
int __endstdio()
{
  int result; // eax

  result = sub_40F0E8();
  if ( byte_4393E8 )
    return _fcloseall();
  return result;
}


// ========== Function: __lock_file @ 0x414401 ==========
void __cdecl _lock_file(FILE *Stream)
{
  if ( Stream < (FILE *)&off_4368F0 || Stream > &stru_436B50 )
    EnterCriticalSection((LPCRITICAL_SECTION)&Stream[1]);
  else
    _lock((((char *)Stream - (char *)&off_4368F0) >> 5) + 28);
}


// ========== Function: __lock_file2 @ 0x414430 ==========
void __cdecl _lock_file2(int a1, int a2)
{
  if ( a1 >= 20 )
    EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _lock(a1 + 28);
}


// ========== Function: __unlock_file @ 0x414453 ==========
void __cdecl _unlock_file(FILE *Stream)
{
  if ( Stream < (FILE *)&off_4368F0 || Stream > &stru_436B50 )
    LeaveCriticalSection((LPCRITICAL_SECTION)&Stream[1]);
  else
    _unlock((((char *)Stream - (char *)&off_4368F0) >> 5) + 28);
}


// ========== Function: __unlock_file2 @ 0x414482 ==========
void __cdecl _unlock_file2(int a1, int a2)
{
  if ( a1 >= 20 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _unlock(a1 + 28);
}


// ========== Function: __getstream @ 0x4144A5 ==========
_DWORD *_getstream()
{
  _DWORD *v0; // edi
  int v1; // esi
  int v2; // eax
  int v3; // esi
  int v4; // eax

  v0 = 0;
  _lock(2);
  v1 = 0;
  if ( dword_43A780 > 0 )
  {
    while ( 1 )
    {
      v2 = *(_DWORD *)(dword_439778 + 4 * v1);
      if ( !v2 )
        break;
      if ( (*(_BYTE *)(v2 + 12) & 0x83) == 0 )
      {
        _lock_file2(v1, *(_DWORD *)(dword_439778 + 4 * v1));
        if ( (*(_BYTE *)(*(_DWORD *)(dword_439778 + 4 * v1) + 12) & 0x83) == 0 )
        {
          v0 = *(_DWORD **)(dword_439778 + 4 * v1);
          goto LABEL_11;
        }
        _unlock_file2(v1, *(_DWORD *)(dword_439778 + 4 * v1));
      }
      if ( ++v1 >= dword_43A780 )
        goto LABEL_13;
    }
    v3 = 4 * v1;
    *(_DWORD *)(v3 + dword_439778) = malloc(0x38u);
    v4 = *(_DWORD *)(v3 + dword_439778);
    if ( !v4 )
      goto LABEL_13;
    InitializeCriticalSection((LPCRITICAL_SECTION)(v4 + 32));
    EnterCriticalSection((LPCRITICAL_SECTION)(*(_DWORD *)(v3 + dword_439778) + 32));
    v0 = *(_DWORD **)(v3 + dword_439778);
LABEL_11:
    if ( v0 )
    {
      v0[4] = -1;
      v0[1] = 0;
      v0[3] = 0;
      v0[2] = 0;
      *v0 = 0;
      v0[7] = 0;
    }
  }
LABEL_13:
  _unlock(2);
  return v0;
}


// ========== Function: __filbuf @ 0x41456D ==========
int __cdecl _filbuf(FILE *File)
{
  int flag; // eax
  int v2; // eax
  int v3; // edx
  _BYTE *v4; // edi
  int v5; // ecx
  char *ptr; // ecx
  int result; // eax

  flag = File->_flag;
  if ( (flag & 0x83) == 0 || (flag & 0x40) != 0 )
    return -1;
  if ( (flag & 2) != 0 )
  {
    LOBYTE(flag) = flag | 0x20;
    File->_flag = flag;
    return -1;
  }
  LOBYTE(flag) = flag | 1;
  File->_flag = flag;
  if ( (flag & 0x10C) != 0 )
    File->_ptr = File->_base;
  else
    _getbuf(File);
  v2 = _read(File->_file, File->_base, File->_bufsiz);
  File->_cnt = v2;
  if ( !v2 || v2 == -1 )
  {
    File->_flag |= v2 != 0 ? 32 : 16;
    File->_cnt = 0;
    return -1;
  }
  v3 = File->_flag;
  if ( (v3 & 0x82) == 0 )
  {
    v4 = File->_file == -1 ? &unk_4347D8 : (_BYTE *)(dword_43A7C0[File->_file >> 5] + 36 * (File->_file & 0x1F));
    if ( (v4[4] & 0x82) == 0x82 )
    {
      BYTE1(v3) |= 0x20u;
      File->_flag = v3;
    }
  }
  if ( File->_bufsiz == 512 )
  {
    v5 = File->_flag;
    if ( (v5 & 8) != 0 && (v5 & 0x400) == 0 )
      File->_bufsiz = 4096;
  }
  ptr = File->_ptr;
  File->_cnt = v2 - 1;
  result = (unsigned __int8)*ptr;
  File->_ptr = ptr + 1;
  return result;
}


// ========== Function: __read @ 0x414649 ==========
int __cdecl _read(int FileHandle, void *DstBuf, unsigned int MaxCharCount)
{
  int lk; // edi

  if ( FileHandle < uNumber && (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(FileHandle);
    lk = _read_lk(FileHandle, DstBuf, MaxCharCount);
    _unlock_fhandle(FileHandle);
    return lk;
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
}


// ========== Function: __read_lk @ 0x4146AE ==========
unsigned int __cdecl _read_lk(int FileHandle, char *lpBuffer, DWORD nNumberOfBytesToRead)
{
  char *v3; // ebx
  char *v4; // edx
  int v5; // esi
  int v6; // eax
  char v7; // cl
  char v8; // al
  int v9; // eax
  DWORD LastError; // eax
  int v12; // eax
  char *v13; // ecx
  char v14; // al
  char v15; // al
  char *v16; // ecx
  bool v17; // cf
  char v18; // al
  char v19; // al
  _BYTE *v20; // esi
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v22; // [esp+10h] [ebp-8h]
  char Buffer; // [esp+17h] [ebp-1h] BYREF
  char *nNumberOfBytesToReada; // [esp+28h] [ebp+10h]

  v22 = 0;
  v3 = lpBuffer;
  v4 = lpBuffer;
  if ( nNumberOfBytesToRead )
  {
    v5 = 36 * (FileHandle & 0x1F);
    v6 = v5 + dword_43A7C0[FileHandle >> 5];
    v7 = *(_BYTE *)(v6 + 4);
    if ( (v7 & 2) == 0 )
    {
      if ( (v7 & 0x48) != 0 )
      {
        v8 = *(_BYTE *)(v6 + 5);
        if ( v8 != 10 )
        {
          --nNumberOfBytesToRead;
          *lpBuffer = v8;
          v9 = dword_43A7C0[FileHandle >> 5];
          v4 = lpBuffer + 1;
          v22 = 1;
          *(_BYTE *)(v9 + v5 + 5) = 10;
        }
      }
      if ( !ReadFile(
              *(HANDLE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F)),
              v4,
              nNumberOfBytesToRead,
              &NumberOfBytesRead,
              0) )
      {
        LastError = GetLastError();
        if ( LastError == 5 )
        {
          *_errno() = 9;
          *__doserrno() = 5;
          return -1;
        }
        if ( LastError != 109 )
        {
          sub_40E93A(LastError);
          return -1;
        }
        return 0;
      }
      v12 = dword_43A7C0[FileHandle >> 5];
      v22 += NumberOfBytesRead;
      v13 = (char *)(v12 + v5 + 4);
      v14 = *v13;
      if ( *v13 < 0 )
      {
        if ( NumberOfBytesRead && *lpBuffer == 10 )
          v15 = v14 | 4;
        else
          v15 = v14 & 0xFB;
        *v13 = v15;
        nNumberOfBytesToReada = lpBuffer;
        v16 = &lpBuffer[v22];
        v17 = lpBuffer < &lpBuffer[v22];
        v22 += (unsigned int)lpBuffer;
        if ( v17 )
        {
          do
          {
            v18 = *nNumberOfBytesToReada;
            if ( *nNumberOfBytesToReada == 26 )
            {
              v20 = (_BYTE *)(dword_43A7C0[FileHandle >> 5] + v5 + 4);
              if ( (*v20 & 0x40) == 0 )
                *v20 |= 2u;
              return v3 - lpBuffer;
            }
            if ( v18 == 13 )
            {
              if ( nNumberOfBytesToReada >= v16 - 1 )
              {
                ++nNumberOfBytesToReada;
                if ( !ReadFile(
                        *(HANDLE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F)),
                        &Buffer,
                        1u,
                        &NumberOfBytesRead,
                        0)
                  && GetLastError()
                  || !NumberOfBytesRead )
                {
LABEL_35:
                  *v3 = 13;
                  goto LABEL_36;
                }
                if ( (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + v5 + 4) & 0x48) != 0 )
                {
                  v19 = Buffer;
                  if ( Buffer == 10 )
                    goto LABEL_33;
                  *v3++ = 13;
                  *(_BYTE *)(dword_43A7C0[FileHandle >> 5] + v5 + 5) = v19;
                }
                else
                {
                  if ( v3 == lpBuffer && Buffer == 10 )
                    goto LABEL_33;
                  _lseek_lk(FileHandle, -1, 1u);
                  if ( Buffer != 10 )
                    goto LABEL_35;
                }
              }
              else
              {
                if ( nNumberOfBytesToReada[1] == 10 )
                {
                  nNumberOfBytesToReada += 2;
LABEL_33:
                  *v3 = 10;
LABEL_36:
                  ++v3;
                  goto LABEL_37;
                }
                *v3++ = 13;
                ++nNumberOfBytesToReada;
              }
            }
            else
            {
              *v3++ = v18;
              ++nNumberOfBytesToReada;
            }
LABEL_37:
            v16 = (char *)v22;
          }
          while ( (unsigned int)nNumberOfBytesToReada < v22 );
        }
        return v3 - lpBuffer;
      }
      return v22;
    }
  }
  return 0;
}


// ========== Function: __write @ 0x414887 ==========
int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount)
{
  int v3; // edi

  if ( FileHandle < uNumber && (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(FileHandle);
    v3 = _write_lk(FileHandle, Buf, MaxCharCount);
    _unlock_fhandle(FileHandle);
    return v3;
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
}


// ========== Function: __write_lk @ 0x4148EC ==========
int __cdecl _write_lk(int FileHandle, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite)
{
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax
  _BYTE *v7; // eax
  char *v8; // ecx
  char v9; // cl
  signed int v10; // edi
  _BYTE Buffer[1028]; // [esp+Ch] [ebp-414h] BYREF
  int v12; // [esp+410h] [ebp-10h]
  DWORD NumberOfBytesWritten; // [esp+414h] [ebp-Ch] BYREF
  DWORD v14; // [esp+418h] [ebp-8h]
  char *v15; // [esp+41Ch] [ebp-4h]
  DWORD FileHandlea; // [esp+428h] [ebp+8h]

  v14 = 0;
  v12 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  v4 = (_DWORD *)(4 * (FileHandle >> 5) + 4433856);
  v5 = 36 * (FileHandle & 0x1F);
  if ( (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + v5 + 4) & 0x20) != 0 )
    _lseek_lk(FileHandle, 0, 2u);
  v6 = v5 + dword_43A7C0[FileHandle >> 5];
  if ( *(char *)(v6 + 4) >= 0 )
  {
    if ( WriteFile(*(HANDLE *)v6, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
    {
      FileHandlea = 0;
      v14 = NumberOfBytesWritten;
    }
    else
    {
      FileHandlea = GetLastError();
    }
  }
  else
  {
    v15 = lpBuffer;
    FileHandlea = 0;
    while ( 1 )
    {
      v7 = Buffer;
      do
      {
        if ( v15 - lpBuffer >= nNumberOfBytesToWrite )
          break;
        v8 = v15++;
        v9 = *v8;
        if ( v9 == 10 )
        {
          ++v12;
          *v7++ = 13;
        }
        *v7++ = v9;
      }
      while ( v7 - Buffer < 1024 );
      v10 = v7 - Buffer;
      if ( !WriteFile(*(HANDLE *)(*v4 + v5), Buffer, v7 - Buffer, &NumberOfBytesWritten, 0) )
        break;
      v14 += NumberOfBytesWritten;
      if ( (int)NumberOfBytesWritten < v10 || v15 - lpBuffer >= nNumberOfBytesToWrite )
        goto LABEL_15;
    }
    FileHandlea = GetLastError();
  }
LABEL_15:
  if ( v14 )
    return v14 - v12;
  if ( FileHandlea )
  {
    if ( FileHandlea == 5 )
    {
      *_errno() = 9;
      *__doserrno() = 5;
    }
    else
    {
      sub_40E93A(FileHandlea);
    }
  }
  else
  {
    if ( (*(_BYTE *)(*v4 + v5 + 4) & 0x40) != 0 && *lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
  }
  return -1;
}


// ========== Function: __stbuf @ 0x414A77 ==========
int __cdecl _stbuf(int a1)
{
  int v1; // eax
  int *v2; // edi
  void *v3; // eax
  int v4; // edi

  if ( !_isatty(*(_DWORD *)(a1 + 16)) )
    return 0;
  if ( (_UNKNOWN *)a1 == &unk_436910 )
  {
    v1 = 0;
  }
  else
  {
    if ( (_UNKNOWN *)a1 != &unk_436930 )
      return 0;
    v1 = 1;
  }
  ++dword_4395C4;
  if ( (*(_WORD *)(a1 + 12) & 0x10C) != 0 )
    return 0;
  v2 = (int *)(4 * v1 + 4429260);
  if ( dword_4395CC[v1] || (v3 = malloc(0x1000u), (*v2 = (int)v3) != 0) )
  {
    v4 = *v2;
    *(_DWORD *)(a1 + 24) = 4096;
    *(_DWORD *)(a1 + 8) = v4;
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)a1 = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
    *(_DWORD *)(a1 + 4) = 2;
  }
  *(_WORD *)(a1 + 12) |= 0x1102u;
  return 1;
}


// ========== Function: __ftbuf @ 0x414B04 ==========
int __cdecl _ftbuf(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    if ( (*(_BYTE *)(a2 + 13) & 0x10) != 0 )
    {
      result = _flush((_DWORD *)a2);
      *(_BYTE *)(a2 + 13) &= 0xEEu;
      *(_DWORD *)(a2 + 24) = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  return result;
}


// ========== Function: __lseek @ 0x414B2E ==========
int __cdecl _lseek(int FileHandle, int Offset, int Origin)
{
  int v3; // edi

  if ( FileHandle < uNumber && (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(FileHandle);
    v3 = _lseek_lk(FileHandle, Offset, Origin);
    _unlock_fhandle(FileHandle);
    return v3;
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
}


// ========== Function: __lseek_lk @ 0x414B93 ==========
DWORD __cdecl _lseek_lk(int FileHandle, LONG lDistanceToMove, DWORD dwMoveMethod)
{
  void *osfhandle; // eax
  DWORD v4; // edi
  DWORD LastError; // eax

  osfhandle = (void *)_get_osfhandle(FileHandle);
  if ( osfhandle == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  v4 = SetFilePointer(osfhandle, lDistanceToMove, 0, dwMoveMethod);
  if ( v4 == -1 )
    LastError = GetLastError();
  else
    LastError = 0;
  if ( LastError )
  {
    sub_40E93A(LastError);
    return -1;
  }
  *(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) &= ~2u;
  return v4;
}


// ========== Function: __commit @ 0x414C06 ==========
int __cdecl _commit(int FileHandle)
{
  int v1; // esi
  void *osfhandle; // eax
  DWORD LastError; // esi

  if ( FileHandle < uNumber )
  {
    v1 = 36 * (FileHandle & 0x1F);
    if ( (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + v1 + 4) & 1) != 0 )
    {
      _lock_fhandle(FileHandle);
      if ( (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + v1 + 4) & 1) != 0 )
      {
        osfhandle = (void *)_get_osfhandle(FileHandle);
        if ( FlushFileBuffers(osfhandle) )
          LastError = 0;
        else
          LastError = GetLastError();
        if ( !LastError )
          goto LABEL_10;
        *__doserrno() = LastError;
      }
      *_errno() = 9;
      LastError = -1;
LABEL_10:
      _unlock_fhandle(FileHandle);
      return LastError;
    }
  }
  *_errno() = 9;
  return -1;
}


// ========== Function: __close @ 0x414C99 ==========
int __cdecl _close(int FileHandle)
{
  int v1; // edi

  if ( FileHandle < uNumber && (*(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(FileHandle);
    v1 = _close_lk(FileHandle);
    _unlock_fhandle(FileHandle);
    return v1;
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
}


// ========== Function: __close_lk @ 0x414CF6 ==========
int __cdecl _close_lk(int FileHandle)
{
  intptr_t osfhandle; // edi
  void *v2; // eax
  DWORD LastError; // edi

  if ( _get_osfhandle(FileHandle) == -1
    || (FileHandle == 1 || FileHandle == 2) && (osfhandle = _get_osfhandle(2), _get_osfhandle(1) == osfhandle)
    || (v2 = (void *)_get_osfhandle(FileHandle), CloseHandle(v2)) )
  {
    LastError = 0;
  }
  else
  {
    LastError = GetLastError();
  }
  _free_osfhnd(FileHandle);
  *(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) = 0;
  if ( !LastError )
    return 0;
  sub_40E93A(LastError);
  return -1;
}


// ========== Function: __freebuf @ 0x414D79 ==========
int __cdecl _freebuf(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12);
  if ( (result & 0x83) != 0 && (result & 8) != 0 )
  {
    sub_40D386(*(LPVOID *)(a1 + 8));
    *(_WORD *)(a1 + 12) &= 0xFBF7u;
    result = 0;
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}


// ========== Function: ___tzset @ 0x414DA4 ==========
void __tzset()
{
  if ( !dword_4396B0 )
  {
    _lock(11);
    if ( !dword_4396B0 )
    {
      _tzset_lk();
      ++dword_4396B0;
    }
    _unlock(11);
  }
}


// ========== Function: __tzset_lk @ 0x414DD2 ==========
void _tzset_lk()
{
  char *v0; // eax
  const char *v1; // esi
  size_t v2; // eax
  char *v3; // eax
  const char *v4; // esi
  int v5; // ecx
  char v6; // al
  int v7; // eax
  int v8; // [esp+10h] [ebp-8h]
  BOOL UsedDefaultChar; // [esp+14h] [ebp-4h] BYREF

  v8 = 0;
  _lock(12);
  dword_436D30 = -1;
  dword_436D20 = -1;
  dword_4395F8 = 0;
  v0 = getenv("TZ");
  v1 = v0;
  if ( !v0 )
  {
    _unlock(12);
    if ( GetTimeZoneInformation(&TimeZoneInformation) == -1 )
      return;
    dword_436C88 = 60 * TimeZoneInformation.Bias;
    dword_4395F8 = 1;
    if ( TimeZoneInformation.StandardDate.wMonth )
      dword_436C88 = 60 * TimeZoneInformation.StandardBias + 60 * TimeZoneInformation.Bias;
    if ( TimeZoneInformation.DaylightDate.wMonth && TimeZoneInformation.DaylightBias )
    {
      dword_436C8C = 1;
      dword_436C90 = 60 * (TimeZoneInformation.DaylightBias - TimeZoneInformation.StandardBias);
    }
    else
    {
      dword_436C8C = 0;
      dword_436C90 = 0;
    }
    if ( !WideCharToMultiByte(
            dword_4395EC,
            0x220u,
            TimeZoneInformation.StandardName,
            -1,
            Destination,
            63,
            0,
            &UsedDefaultChar)
      || UsedDefaultChar )
    {
      *Destination = 0;
    }
    else
    {
      Destination[63] = 0;
    }
    if ( WideCharToMultiByte(
           dword_4395EC,
           0x220u,
           TimeZoneInformation.DaylightName,
           -1,
           off_436D18,
           63,
           0,
           &UsedDefaultChar)
      && !UsedDefaultChar )
    {
      off_436D18[63] = 0;
      return;
    }
LABEL_41:
    *off_436D18 = 0;
    return;
  }
  if ( *v0 && (!Str2 || strcmp(v0, Str2)) )
  {
    sub_40D386(Str2);
    v2 = strlen(v1);
    v3 = (char *)malloc(v2 + 1);
    Str2 = v3;
    if ( v3 )
    {
      strcpy(v3, v1);
      _unlock(12);
      strncpy(Destination, v1, 3u);
      v4 = v1 + 3;
      Destination[3] = 0;
      if ( *v4 == 45 )
      {
        v8 = 1;
        ++v4;
      }
      v5 = 3600 * atol(v4);
      dword_436C88 = v5;
      while ( 1 )
      {
        v6 = *v4;
        if ( *v4 != 43 && (v6 < 48 || v6 > 57) )
          break;
        ++v4;
      }
      if ( *v4 == 58 )
      {
        v5 = 60 * atol(++v4) + dword_436C88;
        dword_436C88 = v5;
        while ( *v4 >= 48 && *v4 <= 57 )
          ++v4;
        if ( *v4 == 58 )
        {
          v5 = atol(++v4) + dword_436C88;
          dword_436C88 = v5;
          while ( *v4 >= 48 && *v4 <= 57 )
            ++v4;
        }
      }
      if ( v8 )
        dword_436C88 = -v5;
      v7 = *v4;
      dword_436C8C = v7;
      if ( v7 )
      {
        strncpy(off_436D18, v4, 3u);
        off_436D18[3] = 0;
        return;
      }
      goto LABEL_41;
    }
  }
  _unlock(12);
}


// ========== Function: __isindst @ 0x415059 ==========
int __cdecl _isindst(int a1)
{
  int v1; // esi

  _lock(11);
  v1 = _isindst_0(a1);
  _unlock(11);
  return v1;
}


// ========== Function: __isindst_0 @ 0x41507A ==========
BOOL __cdecl _isindst_0(_DWORD *a1)
{
  int v2; // eax
  int v3; // ecx
  int v4; // eax

  if ( !dword_436C8C )
    return 0;
  v2 = a1[5];
  if ( v2 != dword_436D20 || v2 != dword_436D30 )
  {
    if ( dword_4395F8 )
    {
      if ( TimeZoneInformation.DaylightDate.wYear )
        cvtdate(
          1,
          0,
          v2,
          TimeZoneInformation.DaylightDate.wMonth,
          0,
          0,
          TimeZoneInformation.DaylightDate.wDay,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
      else
        cvtdate(
          1,
          1,
          v2,
          TimeZoneInformation.DaylightDate.wMonth,
          TimeZoneInformation.DaylightDate.wDay,
          TimeZoneInformation.DaylightDate.wDayOfWeek,
          0,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
      if ( TimeZoneInformation.StandardDate.wYear )
        cvtdate(
          0,
          0,
          a1[5],
          TimeZoneInformation.StandardDate.wMonth,
          0,
          0,
          TimeZoneInformation.StandardDate.wDay,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
      else
        cvtdate(
          0,
          1,
          a1[5],
          TimeZoneInformation.StandardDate.wMonth,
          TimeZoneInformation.StandardDate.wDay,
          TimeZoneInformation.StandardDate.wDayOfWeek,
          0,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
    }
    else
    {
      cvtdate(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      cvtdate(0, 1, a1[5], 10, 5, 0, 0, 2, 0, 0, 0);
    }
  }
  v3 = a1[7];
  if ( dword_436D24 < dword_436D34 )
  {
    if ( v3 >= dword_436D24 && v3 <= dword_436D34 )
    {
      if ( v3 > dword_436D24 && v3 < dword_436D34 )
        return 1;
      goto LABEL_24;
    }
    return 0;
  }
  if ( v3 < dword_436D34 || v3 > dword_436D24 )
    return 1;
  if ( v3 > dword_436D34 && v3 < dword_436D24 )
    return 0;
LABEL_24:
  v4 = 1000 * (*a1 + 60 * (a1[1] + 60 * a1[2]));
  if ( v3 == dword_436D24 )
    return v4 >= dword_436D28;
  else
    return v4 < dword_436D38;
}


// ========== Function: _cvtdate @ 0x415226 ==========
int __cdecl cvtdate(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int result; // eax
  int v19; // eax
  bool v20; // sf
  int v21; // ecx
  int v22; // [esp+18h] [ebp+10h]

  if ( a2 == 1 )
  {
    v22 = a3 & 3;
    if ( (a3 & 3) != 0 )
      v12 = dword_436E80[a4];
    else
      v12 = dword_436E4C[a4];
    v13 = v12 + 1;
    v14 = (365 * a3 + ((a3 - 1) >> 2) + v12 + 1 - 25563) % 7;
    if ( v14 > a6 )
      v15 = a6 + 7 * a5 - v14 + v13;
    else
      v15 = v13 + a6 + 7 * a5 - v14 - 7;
    if ( a5 == 5 )
    {
      if ( v22 )
        v16 = dword_436E84[a4];
      else
        v16 = dword_436E50[a4];
      if ( v15 > v16 )
        v15 -= 7;
    }
  }
  else
  {
    if ( (a3 & 3) != 0 )
      v17 = dword_436E80[a4];
    else
      v17 = dword_436E4C[a4];
    v15 = a7 + v17;
  }
  if ( a1 == 1 )
  {
    dword_436D24 = v15;
    dword_436D20 = a3;
    result = a11 + 1000 * (a10 + 60 * (a9 + 60 * a8));
    dword_436D28 = result;
    return result;
  }
  dword_436D34 = v15;
  v19 = 1000 * (a10 + dword_436C90 + 60 * (a9 + 60 * a8));
  v20 = a11 + v19 < 0;
  result = a11 + v19;
  dword_436D38 = result;
  if ( v20 )
  {
    result += 86400000;
    v21 = v15 - 1;
    dword_436D38 = result;
LABEL_24:
    dword_436D34 = v21;
    goto LABEL_25;
  }
  if ( result >= 86400000 )
  {
    result -= 86400000;
    v21 = v15 + 1;
    dword_436D38 = result;
    goto LABEL_24;
  }
LABEL_25:
  dword_436D30 = a3;
  return result;
}


// ========== Function: __strcmpi @ 0x415370 ==========
int __cdecl _strcmpi(const char *String1, const char *String2)
{
  int result; // eax
  char v5; // t0
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  int v9; // [esp-4h] [ebp-14h]
  int v10; // [esp+0h] [ebp-10h]

  if ( *((_DWORD *)&unk_4395D4 + 2) )
  {
    _InterlockedIncrement(&Addend);
    if ( dword_439770 > 0 )
    {
      _InterlockedDecrement(&Addend);
      _lock(19);
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    v6 = 255;
    v7 = 0;
    while ( (_BYTE)v6 )
    {
      LOBYTE(v6) = *String2++;
      LOBYTE(v7) = *String1++;
      if ( (_BYTE)v6 != (_BYTE)v7 )
      {
        v9 = v6;
        v7 = tolower_0(v7);
        v6 = tolower_0(v9);
        if ( (_BYTE)v7 != (_BYTE)v6 )
        {
          v6 = -((unsigned __int8)v7 < (unsigned __int8)v6) - (((unsigned __int8)v7 < (unsigned __int8)v6) - 1);
          break;
        }
      }
    }
    v8 = v6;
    if ( v10 )
      _unlock(19);
    else
      _InterlockedDecrement(&Addend);
    return v8;
  }
  else
  {
    LOBYTE(result) = -1;
    while ( (_BYTE)result )
    {
      LOBYTE(result) = *String2++;
      BYTE1(result) = *String1++;
      if ( BYTE1(result) != (_BYTE)result )
      {
        v5 = BYTE1(result);
        BYTE1(result) = ((unsigned __int8)(result - 65) < 0x1Au ? 0x20 : 0) + result;
        LOBYTE(result) = ((unsigned __int8)(v5 - 65) < 0x1Au ? 0x20 : 0) + v5;
        if ( (_BYTE)result != BYTE1(result) )
        {
          LOBYTE(result) = -((unsigned __int8)result < BYTE1(result)) - (((unsigned __int8)result < BYTE1(result)) - 1);
          return (char)result;
        }
      }
    }
    return (char)result;
  }
}


// ========== Function: _abort @ 0x415440 ==========
void __cdecl __noreturn abort()
{
  sub_4116D3(0xAu);
  raise(22);
  _exit(3);
}


// ========== Function: ?_ValidateRead@@YAHPBXI@Z @ 0x415457 ==========
BOOL __cdecl _ValidateRead(void *lp, UINT_PTR ucb)
{
  return !IsBadReadPtr(lp, ucb);
}


// ========== Function: ?_ValidateWrite@@YAHPAXI@Z @ 0x415473 ==========
BOOL __cdecl _ValidateWrite(void *lp, UINT_PTR ucb)
{
  return !IsBadWritePtr(lp, ucb);
}


// ========== Function: ?_ValidateExecute@@YAHP6GHXZ@Z @ 0x41548F ==========
BOOL __cdecl _ValidateExecute(FARPROC lpfn)
{
  return !IsBadCodePtr(lpfn);
}


// ========== Function: __ismbblead @ 0x4154A7 ==========
int __cdecl _ismbblead(unsigned int Ch)
{
  return x_ismbbtype(Ch, 0, 4);
}


// ========== Function: _x_ismbbtype @ 0x4154B8 ==========
int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  if ( (a3 & (unsigned __int8)byte_43A9E1[a1]) != 0 )
    return 1;
  result = a2 ? (unsigned __int16)(a2 & _ctype[a1 + 1]) : 0;
  if ( result )
    return 1;
  return result;
}


// ========== Function: ___crtMessageBoxA @ 0x4154E9 ==========
int __cdecl __crtMessageBoxA(const CHAR *a1, const CHAR *a2, UINT a3)
{
  HWND ActiveWindow_0; // ebx
  HMODULE LibraryA; // eax
  HMODULE v5; // edi

  ActiveWindow_0 = 0;
  if ( !MessageBoxA_0 )
  {
    LibraryA = LoadLibraryA("user32.dll");
    v5 = LibraryA;
    if ( !LibraryA )
      return 0;
    MessageBoxA_0 = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
    if ( !MessageBoxA_0 )
      return 0;
    GetActiveWindow_0 = (HWND (__stdcall *)())GetProcAddress(v5, "GetActiveWindow");
    GetLastActivePopup_0 = (HWND (__stdcall *)(HWND))GetProcAddress(v5, "GetLastActivePopup");
  }
  if ( GetActiveWindow_0 )
  {
    ActiveWindow_0 = GetActiveWindow_0();
    if ( ActiveWindow_0 )
    {
      if ( GetLastActivePopup_0 )
        ActiveWindow_0 = GetLastActivePopup_0(ActiveWindow_0);
    }
  }
  return MessageBoxA_0(ActiveWindow_0, a1, a2, a3);
}


// ========== Function: _strncpy @ 0x415580 ==========
char *__cdecl strncpy(char *Destination, const char *Source, size_t Count)
{
  size_t v3; // ecx
  size_t v4; // ebx
  const char *v5; // esi
  char *v6; // edi
  size_t v7; // ecx
  char v8; // al
  size_t v10; // ecx
  int v11; // eax
  int v12; // edx

  v3 = Count;
  if ( !Count )
    return Destination;
  v4 = Count;
  v5 = Source;
  v6 = Destination;
  if ( ((unsigned __int8)Source & 3) == 0 )
  {
    v7 = Count >> 2;
    if ( Count >> 2 )
      goto main_loop_entrance_0;
copy_tail_loop:
    while ( 1 )
    {
      v8 = *v5++;
      *v6++ = v8;
      if ( !v8 )
        break;
      if ( !--v4 )
        return Destination;
    }
    while ( --v4 )
finish_loop:
      *v6++ = v8;
    return Destination;
  }
  do
  {
    v8 = *v5++;
    *v6++ = v8;
    if ( !--v3 )
      return Destination;
    if ( !v8 )
    {
      while ( ((unsigned __int8)v6 & 3) != 0 )
      {
        *v6++ = 0;
        if ( !--v3 )
          return Destination;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto finish_loop;
      goto fill_dwords_with_EOS;
    }
  }
  while ( ((unsigned __int8)v5 & 3) != 0 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
tail_loop_start_0:
    v4 &= 3u;
    if ( v4 )
      goto copy_tail_loop;
    return Destination;
  }
  while ( 1 )
  {
main_loop_entrance_0:
    v11 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
    v12 = *(_DWORD *)v5;
    v5 += 4;
    if ( (v11 & 0x81010100) == 0 )
      goto main_loop_3;
    if ( !(_BYTE)v12 )
      break;
    if ( !BYTE1(v12) )
    {
      *(_DWORD *)v6 = (unsigned __int8)v12;
      goto fill_with_EOS_dwords;
    }
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_DWORD *)v6 = (unsigned __int16)v12;
      goto fill_with_EOS_dwords;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v6 = v12;
      goto fill_with_EOS_dwords;
    }
main_loop_3:
    *(_DWORD *)v6 = v12;
    v6 += 4;
    if ( !--v7 )
      goto tail_loop_start_0;
  }
  *(_DWORD *)v6 = 0;
fill_with_EOS_dwords:
  v6 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
fill_dwords_with_EOS:
    v8 = 0;
    do
    {
      *(_DWORD *)v6 = 0;
      v6 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto finish_loop;
  return Destination;
}


// ========== Function: __getbuf @ 0x41567E ==========
int __cdecl _getbuf(_DWORD *a1)
{
  void *v1; // eax
  int result; // eax

  ++dword_4395C4;
  v1 = malloc(0x1000u);
  a1[2] = v1;
  if ( v1 )
  {
    a1[3] |= 8u;
    a1[6] = 4096;
  }
  else
  {
    a1[3] |= 4u;
    a1[2] = a1 + 5;
    a1[6] = 2;
  }
  result = a1[2];
  a1[1] = 0;
  *a1 = result;
  return result;
}


// ========== Function: __isatty @ 0x4156C2 ==========
int __cdecl _isatty(int FileHandle)
{
  if ( FileHandle < uNumber )
    return *(_BYTE *)(dword_43A7C0[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 0x40;
  else
    return 0;
}


// ========== Function: _wctomb @ 0x4156EB ==========
int __cdecl wctomb(char *MbCh, wchar_t WCh)
{
  int v2; // ebx
  int WCha; // [esp+18h] [ebp+Ch]

  InterlockedIncrement(&Addend);
  v2 = 0;
  if ( dword_439770 )
  {
    InterlockedDecrement(&Addend);
    _lock(19);
    v2 = 1;
  }
  WCha = _wctomb_lk(MbCh, WCh);
  if ( v2 )
    _unlock(19);
  else
    InterlockedDecrement(&Addend);
  return WCha;
}


// ========== Function: __wctomb_lk @ 0x415744 ==========
int __cdecl _wctomb_lk(LPSTR lpMultiByteStr, WCHAR WideCharStr)
{
  int result; // eax

  result = (int)lpMultiByteStr;
  if ( lpMultiByteStr )
  {
    if ( !dword_4395DC )
    {
      if ( WideCharStr <= 0xFFu )
      {
        *lpMultiByteStr = WideCharStr;
        return 1;
      }
      goto LABEL_7;
    }
    lpMultiByteStr = 0;
    result = WideCharToMultiByte(
               dword_4395EC,
               0x220u,
               &WideCharStr,
               1,
               (LPSTR)result,
               cbMultiByte,
               0,
               (LPBOOL)&lpMultiByteStr);
    if ( !result || lpMultiByteStr )
    {
LABEL_7:
      *_errno() = 42;
      return -1;
    }
  }
  return result;
}


// ========== Function: __control87 @ 0x4157AD ==========
unsigned int __cdecl _control87(unsigned int NewValue, unsigned int Mask)
{
  unsigned int v2; // esi

  v2 = Mask & NewValue | ~Mask & _abstract_cw();
  _hw_cw(v2);
  return v2;
}


// ========== Function: __controlfp @ 0x4157E2 ==========
unsigned int __cdecl _controlfp(unsigned int NewValue, unsigned int Mask)
{
  return _control87(NewValue, Mask & 0xFFF7FFFF);
}


// ========== Function: __abstract_cw @ 0x4157F8 ==========
char __cdecl _abstract_cw(char a1)
{
  char result; // al

  result = 0;
  if ( (a1 & 1) != 0 )
    result = 16;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 0x10) != 0 )
    result |= 2u;
  if ( (a1 & 0x20) != 0 )
    return result | 1;
  return result;
}


// ========== Function: __hw_cw @ 0x41588A ==========
char __cdecl _hw_cw(int a1)
{
  char result; // al

  result = (a1 & 0x10) != 0;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 2) != 0 )
    result |= 0x10u;
  if ( (a1 & 1) != 0 )
    result |= 0x20u;
  if ( (a1 & 0x80000) != 0 )
    return result | 2;
  return result;
}


// ========== Function: _tolower @ 0x415913 ==========
int __cdecl tolower(int C)
{
  int v1; // ebx
  int result; // eax
  int Ca; // [esp+8h] [ebp+4h]

  v1 = 0;
  if ( dword_4395DC )
  {
    InterlockedIncrement(&Addend);
    if ( dword_439770 )
    {
      InterlockedDecrement(&Addend);
      _lock(19);
      v1 = 1;
    }
    Ca = tolower_0(C);
    if ( v1 )
      _unlock(19);
    else
      InterlockedDecrement(&Addend);
    return Ca;
  }
  else
  {
    result = C;
    if ( C >= 65 && C <= 90 )
      return C + 32;
  }
  return result;
}


// ========== Function: _tolower_0 @ 0x415982 ==========
int __cdecl tolower_0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  CHAR DestStr[4]; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_4395DC )
  {
    v2 = C;
    if ( (C >= 256 || (cbMultiByte <= 1 ? (v3 = *((_BYTE *)off_434474 + 2 * C) & 1) : (v3 = _isctype(C, 1)), v3))
      && (*((char *)off_434474 + 2 * BYTE1(v2) + 1) >= 0
        ? (LOWORD(C) = (unsigned __int8)v2, v4 = 1)
        : (LOBYTE(C) = BYTE1(v2), *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2, v4 = 2),
          (v5 = __crtLCMapStringA(dword_4395DC, 0x100u, (LPCSTR)&C, v4, DestStr, 3, 0, 1)) != 0) )
    {
      if ( v5 == 1 )
        return (unsigned __int8)DestStr[0];
      else
        return *(unsigned __int16 *)DestStr;
    }
    else
    {
      return v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 65 && C <= 90 )
      return C + 32;
  }
  return result;
}


// ========== Function: __ZeroTail @ 0x415A4D ==========
int __cdecl _ZeroTail(int a1, int a2)
{
  int v2; // esi
  _DWORD *i; // eax

  if ( (~(-1 << (31 - a2 % 32)) & *(_DWORD *)(a1 + 4 * (a2 / 32))) == 0 )
  {
    v2 = a2 / 32 + 1;
    if ( v2 >= 3 )
      return 1;
    for ( i = (_DWORD *)(a1 + 4 * v2); !*i; ++i )
    {
      if ( ++v2 >= 3 )
        return 1;
    }
  }
  return 0;
}


// ========== Function: __IncMan @ 0x415A96 ==========
int __cdecl _IncMan(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // edi

  result = __addl(*(_DWORD *)(a1 + 4 * (a2 / 32)), 1 << (31 - a2 % 32), a1 + 4 * (a2 / 32));
  v3 = a2 / 32 - 1;
  if ( v3 >= 0 )
  {
    v4 = (_DWORD *)(a1 + 4 * v3);
    do
    {
      if ( !result )
        break;
      result = __addl(*v4, 1, v4);
      --v3;
      --v4;
    }
    while ( v3 >= 0 );
  }
  return result;
}


// ========== Function: __RoundMan @ 0x415AEC ==========
int __cdecl _RoundMan(int a1, int a2)
{
  int v2; // edi
  int v4; // edx
  _DWORD *v5; // eax
  char v6; // si
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]
  _DWORD *v10; // [esp+20h] [ebp+Ch]

  v2 = a2 - 1;
  v9 = 0;
  v4 = a2 % 32;
  v8 = a2 / 32;
  v5 = (_DWORD *)(a1 + 4 * (a2 / 32));
  v10 = v5;
  v6 = 31 - v4;
  if ( ((1 << (31 - v4)) & *v5) != 0 )
  {
    if ( !_ZeroTail(a1, a2 + 1) )
      v9 = _IncMan(a1, v2);
    v5 = v10;
  }
  *v5 &= -1 << v6;
  if ( v8 + 1 < 3 )
    memset((void *)(a1 + 4 * (v8 + 1)), 0, 4 * (3 - (v8 + 1)));
  return v9;
}


// ========== Function: __CopyMan @ 0x415B78 ==========
_DWORD *__cdecl _CopyMan(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = a2;
  v3 = 3;
  do
  {
    *(_DWORD *)((char *)result + a1 - (_DWORD)a2) = *result;
    ++result;
    --v3;
  }
  while ( v3 );
  return result;
}


// ========== Function: __FillZeroMan @ 0x415B93 ==========
int __cdecl _FillZeroMan(_DWORD *a1)
{
  int result; // eax

  result = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return result;
}


// ========== Function: __IsZeroMan @ 0x415B9F ==========
int __cdecl _IsZeroMan(_DWORD *a1)
{
  int v2; // ecx

  v2 = 0;
  while ( !*a1 )
  {
    ++v2;
    ++a1;
    if ( v2 >= 3 )
      return 1;
  }
  return 0;
}


// ========== Function: __ShrMan @ 0x415BBA ==========
int *__cdecl _ShrMan(int *a1, int a2)
{
  int *v2; // edi
  int v3; // edx
  bool v4; // zf
  int v5; // ebx
  int i; // ecx
  int *result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+24h] [ebp+Ch]

  v2 = a1;
  v10 = 3;
  v8 = a2 / 32;
  v3 = a2 % 32;
  v11 = 0;
  do
  {
    v9 = ~(-1 << v3) & *v2;
    *v2 = v11 | ((unsigned int)*v2 >> v3);
    ++v2;
    v4 = v10-- == 1;
    v11 = v9 << (32 - v3);
  }
  while ( !v4 );
  v5 = 2;
  for ( i = 2; i >= 0; --i )
  {
    if ( v5 < v8 )
    {
      result = a1;
      a1[i] = 0;
    }
    else
    {
      result = *(int **)((char *)a1 + i * 4 - 4 * v8);
      a1[i] = (int)result;
    }
    --v5;
  }
  return result;
}


// ========== Function: __ld12cvt @ 0x415C47 ==========
int __cdecl _ld12cvt(unsigned __int16 *a1, unsigned int *a2, int *a3)
{
  unsigned __int16 v4; // bx
  unsigned int v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  int result; // eax
  int v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // edi
  unsigned int v14; // esi
  unsigned int v15; // edx
  int v16; // [esp-8h] [ebp-2Ch]
  int v17; // [esp-4h] [ebp-28h]
  int v18; // [esp-4h] [ebp-28h]
  _DWORD v19[3]; // [esp+Ch] [ebp-18h] BYREF
  int v20; // [esp+18h] [ebp-Ch] BYREF
  unsigned int v21; // [esp+1Ch] [ebp-8h]
  int v22; // [esp+20h] [ebp-4h]
  int v23; // [esp+2Ch] [ebp+8h]

  v4 = a1[5];
  v23 = v4 & 0x8000;
  v20 = *(_DWORD *)(a1 + 3);
  v5 = *(_DWORD *)(a1 + 1);
  v6 = *a1;
  v7 = (v4 & 0x7FFF) - 0x3FFF;
  v21 = v5;
  v22 = v6 << 16;
  if ( v7 != -16383 )
  {
    _CopyMan((int)v19, &v20);
    if ( _RoundMan((int)&v20, a3[2]) )
      ++v7;
    v10 = a3[1];
    if ( v7 >= v10 - a3[2] )
    {
      if ( v7 > v10 )
      {
        if ( v7 >= *a3 )
        {
          _FillZeroMan(&v20);
          v16 = a3[3];
          HIBYTE(v20) |= 0x80u;
          _ShrMan(&v20, v16);
          v8 = *a3 + a3[5];
          v17 = 1;
          goto LABEL_5;
        }
        v18 = a3[3];
        v12 = a3[5];
        HIBYTE(v20) &= ~0x80u;
        v8 = v7 + v12;
        _ShrMan(&v20, v18);
        goto LABEL_16;
      }
      v11 = v10 - v7;
      _CopyMan((int)&v20, v19);
      _ShrMan(&v20, v11);
      _RoundMan((int)&v20, a3[2]);
      _ShrMan(&v20, a3[3] + 1);
    }
    else
    {
      _FillZeroMan(&v20);
    }
    v8 = 0;
    goto LABEL_4;
  }
  v8 = 0;
  if ( !_IsZeroMan(&v20) )
  {
    _FillZeroMan(&v20);
LABEL_4:
    v17 = 2;
LABEL_5:
    result = v17;
    goto LABEL_17;
  }
LABEL_16:
  result = 0;
LABEL_17:
  v13 = a3[4];
  v14 = v20 | (v23 != 0 ? 0x80000000 : 0) | (v8 << (31 - *((_BYTE *)a3 + 12)));
  if ( v13 == 64 )
  {
    v15 = v21;
    a2[1] = v14;
    *a2 = v15;
  }
  else if ( v13 == 32 )
  {
    *a2 = v14;
  }
  return result;
}


// ========== Function: sub_415DB3 @ 0x415DB3 ==========
int __cdecl sub_415DB3(unsigned __int16 *a1, unsigned int *a2)
{
  return _ld12cvt(a1, a2, dword_436EC0);
}


// ========== Function: sub_415DC9 @ 0x415DC9 ==========
int __cdecl sub_415DC9(unsigned __int16 *a1, unsigned int *a2)
{
  return _ld12cvt(a1, a2, dword_436ED8);
}


// ========== Function: sub_415DDF @ 0x415DDF ==========
int __cdecl sub_415DDF(unsigned int *a1, int a2)
{
  unsigned __int16 v3[6]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_415DB3(v3, a1);
}


// ========== Function: sub_415E0C @ 0x415E0C ==========
int __cdecl sub_415E0C(unsigned int *a1, int a2)
{
  unsigned __int16 v3[6]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_415DC9(v3, a1);
}


// ========== Function: __fptostr @ 0x415E39 ==========
char *__cdecl _fptostr(char *a1, char *a2, int a3)
{
  int v3; // edx
  int v4; // ebx
  char *v6; // ecx
  const char *v7; // edi
  char *result; // eax
  char v9; // dl
  size_t v10; // eax
  char *v11; // [esp+14h] [ebp+8h]

  v3 = a3;
  v4 = (int)a2;
  v6 = *(char **)(a3 + 12);
  v7 = a1 + 1;
  *a1 = 48;
  result = a1 + 1;
  if ( (int)a2 > 0 )
  {
    v11 = a2;
    v4 = 0;
    do
    {
      v9 = *v6;
      if ( *v6 )
        ++v6;
      else
        v9 = 48;
      *result++ = v9;
      --v11;
    }
    while ( v11 );
    v3 = a3;
  }
  *result = 0;
  if ( v4 >= 0 && *v6 >= 53 )
  {
    while ( *--result == 57 )
      *result = 48;
    ++*result;
  }
  if ( *a1 == 49 )
  {
    ++*(_DWORD *)(v3 + 4);
  }
  else
  {
    v10 = strlen(v7);
    return (char *)memcpy_0(a1, v7, v10 + 1);
  }
  return result;
}


// ========== Function: __fltout2 @ 0x415EB0 ==========
_DWORD *__cdecl _fltout2(char a1, int a2, _DWORD *a3, char *Destination)
{
  int v4; // eax
  _DWORD *v5; // esi
  char *v6; // edi
  __int16 v8; // [esp-10h] [ebp-40h]
  __int16 v9; // [esp+8h] [ebp-28h] BYREF
  char v10; // [esp+Ah] [ebp-26h]
  char Source[24]; // [esp+Ch] [ebp-24h] BYREF
  _DWORD v12[2]; // [esp+24h] [ebp-Ch] BYREF
  __int16 v13; // [esp+2Ch] [ebp-4h]

  __dtold(v12, &a1);
  v8 = v13;
  v4 = _I10_OUTPUT(v12[0], v12[1], v8, 17, 0, &v9);
  v5 = a3;
  v6 = Destination;
  a3[2] = v4;
  *v5 = v10;
  v5[1] = v9;
  strcpy(v6, Source);
  v5[3] = v6;
  return v5;
}


// ========== Function: ___dtold @ 0x415F0C ==========
int __usercall __dtold@<eax>(unsigned int a1@<eax>, int a2, int *a3)
{
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  __int16 v8; // di
  int result; // eax
  int v10; // ecx
  int v11; // ecx
  unsigned __int64 v12; // rcx
  unsigned int v13; // [esp+Ch] [ebp-4h]
  __int16 v14; // [esp+1Ch] [ebp+Ch]

  LOWORD(a1) = *((_WORD *)a3 + 3);
  v4 = (a1 >> 4) & 0x7FF;
  v14 = a1 & 0x8000;
  v5 = a3[1];
  v6 = *a3;
  v7 = v5 & 0xFFFFF;
  v13 = 0x80000000;
  if ( (_WORD)v4 )
  {
    if ( (unsigned __int16)v4 == 2047 )
      v8 = 0x7FFF;
    else
      v8 = v4 + 15360;
  }
  else
  {
    if ( !v7 && !v6 )
    {
      result = a2;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)a2 = 0;
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    v8 = v4 + 15361;
    v13 = 0;
  }
  v10 = (v7 << 11) | (v6 >> 21);
  result = a2;
  v11 = v13 | v10;
  *(_DWORD *)(a2 + 4) = v11;
  *(_DWORD *)a2 = v6 << 11;
  while ( (v11 & 0x80000000) == 0 )
  {
    v12 = 2 * __PAIR64__(v11, *(_DWORD *)a2);
    *(_QWORD *)a2 = v12;
    --v8;
    v11 = HIDWORD(v12);
  }
  *(_WORD *)(a2 + 8) = v8 | v14;
  return result;
}


// ========== Function: __fptrap @ 0x415FC2 ==========
void __noreturn _fptrap()
{
  _amsg_exit(2u);
}


// ========== Function: __fcloseall @ 0x415FCB ==========
int __cdecl _fcloseall()
{
  int v0; // ebx
  int i; // edi
  int v2; // esi
  int v3; // eax

  v0 = 0;
  _lock(2);
  for ( i = 3; i < dword_43A780; ++i )
  {
    v2 = 4 * i;
    v3 = *(_DWORD *)(4 * i + dword_439778);
    if ( v3 )
    {
      if ( (*(_BYTE *)(v3 + 12) & 0x83) != 0 && fclose(*(FILE **)(4 * i + dword_439778)) != -1 )
        ++v0;
      if ( i >= 20 )
      {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*(_DWORD *)(v2 + dword_439778) + 32));
        sub_40D386(*(LPVOID *)(v2 + dword_439778));
        *(_DWORD *)(v2 + dword_439778) = 0;
      }
    }
  }
  _unlock(2);
  return v0;
}


// ========== Function: _getenv @ 0x41604C ==========
char *__cdecl getenv(const char *VarName)
{
  const char **v1; // esi
  size_t v2; // edi

  v1 = (const char **)dword_4393D0;
  if ( dword_43AAE8 )
  {
    if ( dword_4393D0 || dword_4393D8 && !__wtomb_environ() && (v1 = (const char **)dword_4393D0) != 0 )
    {
      if ( VarName )
      {
        v2 = strlen(VarName);
        while ( *v1 )
        {
          if ( strlen(*v1) > v2
            && (*v1)[v2] == 61
            && !_mbsnbicoll((const unsigned __int8 *)*v1, (const unsigned __int8 *)VarName, v2) )
          {
            return (char *)&(*v1)[v2 + 1];
          }
          ++v1;
        }
      }
    }
  }
  return 0;
}


// ========== Function: _raise @ 0x4160C9 ==========
int __cdecl raise(int Signal)
{
  void (__cdecl *v2)(_DWORD); // ebx
  int *v3; // edi
  _DWORD *v4; // esi
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  v10 = 0;
  switch ( Signal )
  {
    case 2:
      v2 = (void (__cdecl *)(_DWORD))dword_439730;
      v3 = &dword_439730;
      break;
    case 4:
    case 8:
    case 11:
      v4 = _getptd();
      v3 = (int *)(siglookup(Signal, v4[20]) + 8);
      v2 = (void (__cdecl *)(_DWORD))*v3;
      goto LABEL_15;
    case 15:
      v2 = (void (__cdecl *)(_DWORD))dword_43973C;
      v3 = &dword_43973C;
      break;
    case 21:
      v2 = (void (__cdecl *)(_DWORD))dword_439734;
      v3 = &dword_439734;
      break;
    case 22:
      v2 = (void (__cdecl *)(_DWORD))dword_439738;
      v3 = &dword_439738;
      break;
    default:
      return -1;
  }
  v10 = 1;
  _lock(1);
  v4 = (_DWORD *)Signal;
LABEL_15:
  if ( v2 != (void (__cdecl *)(_DWORD))1 )
  {
    if ( !v2 )
    {
      if ( v10 )
        _unlock(1);
      _exit(3);
    }
    if ( Signal == 8 || Signal == 11 || Signal == 4 )
    {
      v9 = v4[21];
      v4[21] = 0;
      if ( Signal != 8 )
        goto LABEL_32;
      v5 = v4[22];
      v4[22] = 140;
      v8 = v5;
    }
    if ( Signal == 8 )
    {
      v6 = dword_4347C8;
      if ( dword_4347C8 < dword_4347C8 + dword_4347CC )
      {
        v7 = 12 * dword_4347C8;
        do
        {
          v7 += 12;
          *(_DWORD *)(v4[20] + v7 - 4) = 0;
          ++v6;
        }
        while ( v6 < dword_4347C8 + dword_4347CC );
      }
LABEL_33:
      if ( v10 )
        _unlock(1);
      if ( Signal == 8 )
      {
        ((void (__cdecl *)(int, _DWORD))v2)(8, v4[22]);
      }
      else
      {
        v2(Signal);
        if ( Signal != 11 && Signal != 4 )
          return 0;
      }
      v4[21] = v9;
      if ( Signal == 8 )
        v4[22] = v8;
      return 0;
    }
LABEL_32:
    *v3 = 0;
    goto LABEL_33;
  }
  if ( v10 )
    _unlock(1);
  return 0;
}


// ========== Function: _siglookup @ 0x41624B ==========
unsigned int __cdecl siglookup(int a1, unsigned int a2)
{
  unsigned int result; // eax

  result = a2;
  if ( *(_DWORD *)(a2 + 4) != a1 )
  {
    do
      result += 12;
    while ( result < a2 + 12 * dword_4347D4 && *(_DWORD *)(result + 4) != a1 );
  }
  if ( result >= a2 + 12 * dword_4347D4 || *(_DWORD *)(result + 4) != a1 )
    return 0;
  return result;
}


// ========== Function: ___addl @ 0x416288 ==========
int __cdecl __addl(unsigned int a1, unsigned int a2, unsigned int *a3)
{
  int result; // eax
  unsigned int v4; // ecx

  result = 0;
  v4 = a1 + a2;
  if ( a1 + a2 < a1 || v4 < a2 )
    result = 1;
  *a3 = v4;
  return result;
}


// ========== Function: ___add_12 @ 0x4162A9 ==========
int __cdecl __add_12(unsigned int *a1, unsigned int *a2)
{
  if ( __addl(*a1, *a2, a1) && __addl(a1[1], 1u, a1 + 1) )
    ++a1[2];
  if ( __addl(a1[1], a2[1], a1 + 1) )
    ++a1[2];
  return __addl(a1[2], a2[2], a1 + 2);
}


// ========== Function: ___shl_12 @ 0x416307 ==========
_DWORD *__cdecl __shl_12(_DWORD *a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edi
  unsigned int v3; // ecx
  int v4; // esi
  int v5; // ecx

  result = a1;
  v2 = a1[1];
  v3 = *a1;
  *a1 *= 2;
  v4 = (v3 >> 31) | (2 * v2);
  v5 = a1[2];
  a1[1] = v4;
  a1[2] = (v2 >> 31) | (2 * v5);
  return result;
}


// ========== Function: ___shr_12 @ 0x416335 ==========
int *__cdecl __shr_12(int *a1)
{
  int *result; // eax
  unsigned int v2; // edx
  int v3; // edi
  int v4; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[1];
  a1[1] = *(__int64 *)(a1 + 1) >> 1;
  v4 = (v3 << 31) | ((unsigned int)*a1 >> 1);
  a1[2] = v2 >> 1;
  *a1 = v4;
  return result;
}


// ========== Function: ___mtold12 @ 0x416362 ==========
__int16 __cdecl __mtold12(char *a1, int a2, int a3)
{
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // eax
  __int16 result; // ax
  unsigned int v8; // [esp+8h] [ebp-10h] BYREF
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]
  int v12; // [esp+28h] [ebp+10h]

  v11 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v12 = a2;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      v10 = *(_DWORD *)(a3 + 8);
      __shl_12((_DWORD *)a3);
      __shl_12((_DWORD *)a3);
      __add_12((unsigned int *)a3, &v8);
      __shl_12((_DWORD *)a3);
      v9 = 0;
      v10 = 0;
      v8 = *a1;
      __add_12((unsigned int *)a3, &v8);
      ++a1;
      --v12;
    }
    while ( v12 );
  }
  while ( !*(_DWORD *)(a3 + 8) )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 8) = HIWORD(v4);
    v5 = (v4 << 16) | HIWORD(*(_DWORD *)a3);
    v6 = *(_DWORD *)a3 << 16;
    v11 += 65520;
    *(_DWORD *)(a3 + 4) = v5;
    *(_DWORD *)a3 = v6;
  }
  while ( (*(_DWORD *)(a3 + 8) & 0x8000) == 0 )
  {
    __shl_12((_DWORD *)a3);
    v11 += 0xFFFF;
  }
  result = v11;
  *(_WORD *)(a3 + 10) = v11;
  return result;
}


// ========== Function: ___strgtold12 @ 0x416429 ==========
int __cdecl __strgtold12(int a1, char **a2, char *a3, int a4, int a5, int a6, int a7)
{
  char *v7; // edi
  int v8; // eax
  char v9; // cl
  char v10; // bl
  char *v12; // eax
  char *v14; // eax
  int v15; // eax
  char *v16; // ecx
  int v17; // esi
  int v18; // eax
  bool v20; // zf
  char *v21; // eax
  int v22; // eax
  int v23; // eax
  char *v24; // ebx
  unsigned int v25; // esi
  __int16 v26; // ax
  __int16 v27; // dx
  __int16 v28; // ax
  int result; // eax
  int v30; // [esp-4h] [ebp-6Ch]
  int v31; // [esp-4h] [ebp-6Ch]
  char v32[23]; // [esp+Ch] [ebp-5Ch] BYREF
  char v33; // [esp+23h] [ebp-45h]
  _WORD v34[3]; // [esp+28h] [ebp-40h] BYREF
  unsigned int v35; // [esp+2Eh] [ebp-3Ah]
  int v36; // [esp+32h] [ebp-36h]
  int v37; // [esp+38h] [ebp-30h]
  int v38; // [esp+3Ch] [ebp-2Ch]
  int v39; // [esp+40h] [ebp-28h]
  int v40; // [esp+44h] [ebp-24h]
  int v41; // [esp+48h] [ebp-20h]
  int v42; // [esp+4Ch] [ebp-1Ch]
  int v43; // [esp+50h] [ebp-18h]
  int v44; // [esp+54h] [ebp-14h]
  int v45; // [esp+58h] [ebp-10h]
  char *v46; // [esp+5Ch] [ebp-Ch]
  int v47; // [esp+60h] [ebp-8h]
  unsigned int v48; // [esp+64h] [ebp-4h]

  v7 = a3;
  v46 = v32;
  v8 = 0;
  v39 = 0;
  v43 = 1;
  v48 = 0;
  v45 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v37 = 0;
  v42 = 0;
  v47 = 0;
  v44 = 0;
  while ( 1 )
  {
    v9 = *v7;
    if ( *v7 != 32 && v9 != 9 && v9 != 10 && v9 != 13 )
      break;
    ++v7;
  }
  while ( 2 )
  {
    v10 = *v7++;
    switch ( v8 )
    {
      case 0:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == byte_434684 )
          goto LABEL_12;
        if ( v10 == 43 )
        {
          v39 = 0;
          v8 = 2;
          continue;
        }
        if ( v10 == 45 )
        {
          v39 = 0x8000;
          v8 = 2;
          continue;
        }
        if ( v10 != 48 )
          goto LABEL_108;
        goto LABEL_35;
      case 1:
        v45 = 1;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == byte_434684 )
          goto LABEL_46;
        if ( v10 == 43 || v10 == 45 )
          goto LABEL_30;
        if ( v10 != 48 )
          goto LABEL_25;
        goto LABEL_35;
      case 2:
        if ( v10 >= 49 && v10 <= 57 )
        {
LABEL_10:
          v30 = 3;
LABEL_80:
          v8 = v30;
LABEL_81:
          --v7;
        }
        else
        {
          if ( v10 == byte_434684 )
          {
LABEL_12:
            v31 = 5;
            goto LABEL_89;
          }
          if ( v10 != 48 )
          {
LABEL_93:
            v7 = a3;
            goto LABEL_110;
          }
LABEL_35:
          v8 = 1;
        }
        continue;
      case 3:
        v45 = 1;
        while ( cbMultiByte <= 1
              ? *((_BYTE *)off_434474 + 2 * (unsigned __int8)v10) & 4
              : _isctype((unsigned __int8)v10, 4) )
        {
          if ( v48 >= 0x19 )
          {
            ++v47;
          }
          else
          {
            v12 = v46;
            ++v48;
            ++v46;
            *v12 = v10 - 48;
          }
          v10 = *v7++;
        }
        if ( v10 != byte_434684 )
          goto LABEL_57;
LABEL_46:
        v8 = 4;
        continue;
      case 4:
        v45 = 1;
        v40 = 1;
        if ( !v48 )
        {
          while ( v10 == 48 )
          {
            --v47;
            v10 = *v7++;
          }
        }
        while ( cbMultiByte <= 1
              ? *((_BYTE *)off_434474 + 2 * (unsigned __int8)v10) & 4
              : _isctype((unsigned __int8)v10, 4) )
        {
          if ( v48 < 0x19 )
          {
            v14 = v46;
            ++v48;
            ++v46;
            --v47;
            *v14 = v10 - 48;
          }
          v10 = *v7++;
        }
LABEL_57:
        if ( v10 == 43 || v10 == 45 )
        {
LABEL_30:
          --v7;
          v31 = 11;
        }
        else
        {
LABEL_25:
          if ( v10 <= 67 || v10 > 69 && (v10 <= 99 || v10 > 101) )
          {
LABEL_108:
            --v7;
            goto LABEL_110;
          }
          v31 = 6;
        }
        goto LABEL_89;
      case 5:
        v40 = 1;
        if ( cbMultiByte <= 1 )
          v15 = *((_BYTE *)off_434474 + 2 * (unsigned __int8)v10) & 4;
        else
          v15 = _isctype((unsigned __int8)v10, 4);
        if ( !v15 )
          goto LABEL_93;
        v8 = 4;
        goto LABEL_81;
      case 6:
        v16 = v7 - 2;
        a3 = v7 - 2;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 43 )
          goto LABEL_88;
        if ( v10 == 45 )
          goto LABEL_87;
        if ( v10 != 48 )
          goto LABEL_109;
LABEL_70:
        v31 = 8;
        goto LABEL_89;
      case 7:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 48 )
          goto LABEL_70;
        goto LABEL_93;
      case 8:
        v41 = 1;
        while ( v10 == 48 )
          v10 = *v7++;
        if ( v10 < 49 || v10 > 57 )
          goto LABEL_108;
LABEL_79:
        v30 = 9;
        goto LABEL_80;
      case 9:
        v41 = 1;
        v17 = 0;
        while ( 2 )
        {
          if ( cbMultiByte <= 1 )
            v18 = *((_BYTE *)off_434474 + 2 * (unsigned __int8)v10) & 4;
          else
            v18 = _isctype((unsigned __int8)v10, 4);
          if ( v18 )
          {
            v17 = v10 + 10 * v17 - 48;
            if ( v17 <= 5200 )
            {
              v10 = *v7++;
              continue;
            }
            v17 = 5201;
          }
          break;
        }
        v42 = v17;
        while ( cbMultiByte <= 1
              ? *((_BYTE *)off_434474 + 2 * (unsigned __int8)v10) & 4
              : _isctype((unsigned __int8)v10, 4) )
          v10 = *v7++;
        goto LABEL_108;
      case 11:
        if ( !a7 )
        {
          --v7;
          v8 = 10;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_110;
          continue;
        }
        v16 = v7 - 1;
        a3 = v7 - 1;
        if ( v10 == 43 )
        {
LABEL_88:
          v31 = 7;
LABEL_89:
          v8 = v31;
          continue;
        }
        if ( v10 == 45 )
        {
LABEL_87:
          v43 = -1;
          v8 = 7;
          continue;
        }
LABEL_109:
        v7 = v16;
LABEL_110:
        v20 = v45 == 0;
        *a2 = v7;
        if ( v20 )
        {
          v27 = 0;
          v26 = 0;
          v25 = 0;
          v24 = 0;
          v44 = 4;
        }
        else
        {
          if ( v48 <= 0x18 )
          {
            v21 = v46;
          }
          else
          {
            if ( v33 >= 5 )
              ++v33;
            v48 = 24;
            v21 = v46 - 1;
            ++v47;
          }
          if ( v48 )
          {
            while ( !*--v21 )
            {
              --v48;
              ++v47;
            }
            __mtold12(v32, v48, (int)v34);
            v22 = v42;
            if ( v43 < 0 )
              v22 = -v42;
            v23 = v47 + v22;
            if ( !v41 )
              v23 += a5;
            if ( !v40 )
              v23 -= a6;
            if ( v23 > 5200 )
            {
              v38 = 1;
              goto LABEL_127;
            }
            if ( v23 >= -5200 )
            {
              __multtenpow12(v34, v23, a4);
              v27 = v34[0];
              v24 = *(char **)&v34[1];
              v25 = v35;
              v26 = v36;
            }
            else
            {
              v37 = 1;
LABEL_127:
              v24 = a3;
              v25 = (unsigned int)a3;
              v26 = (__int16)a3;
              v27 = (__int16)a3;
            }
          }
          else
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
          }
          if ( v38 )
          {
            v24 = 0;
            v26 = 0x7FFF;
            v25 = 0x80000000;
            v27 = 0;
            v44 = 2;
          }
          else if ( v37 )
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
            v44 = 1;
          }
        }
        v28 = v39 | v26;
        *(_DWORD *)(a1 + 6) = v25;
        *(_DWORD *)(a1 + 2) = v24;
        *(_WORD *)(a1 + 10) = v28;
        result = v44;
        *(_WORD *)a1 = v27;
        return result;
      default:
        goto LABEL_91;
    }
  }
}


// ========== Function: _$I10_OUTPUT @ 0x4168FA ==========
int __cdecl _I10_OUTPUT(__int64 a1, int a2, int a3, char a4, int a5)
{
  int v5; // ebx
  __int16 v6; // cx
  unsigned __int16 v7; // dx
  int v8; // edi
  int v9; // esi
  bool v10; // zf
  int v11; // edi
  int v12; // esi
  int i; // esi
  int v14; // eax
  char v15; // al
  _BYTE *v16; // ecx
  char v17; // cl
  _BYTE *v18; // eax
  bool v19; // cc
  _BYTE *v20; // ecx
  char v21; // al
  _BYTE v23[12]; // [esp+Ch] [ebp-1Ch] BYREF
  _BYTE v24[12]; // [esp+18h] [ebp-10h] BYREF
  int v25; // [esp+24h] [ebp-4h]

  v5 = a5;
  v6 = a2 & 0x8000;
  memset(v23, 204, 10);
  v23[10] = -5;
  v23[11] = 63;
  v25 = 1;
  v7 = a2 & 0x7FFF;
  if ( (a2 & 0x8000u) == 0 )
    *(_BYTE *)(a5 + 2) = 32;
  else
    *(_BYTE *)(a5 + 2) = 45;
  v8 = HIDWORD(a1);
  if ( !v7 && !a1 )
    goto LABEL_6;
  if ( v7 == 0x7FFF )
  {
    *(_WORD *)v5 = 1;
    if ( (v8 != 0x80000000 || (_DWORD)a1) && (v8 & 0x40000000) == 0 )
    {
      strcpy((char *)(v5 + 4), "1#SNAN");
LABEL_22:
      *(_BYTE *)(v5 + 3) = 6;
      return 0;
    }
    if ( v6 && v8 == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        strcpy((char *)(v5 + 4), "1#IND");
LABEL_19:
        *(_BYTE *)(v5 + 3) = 5;
        return 0;
      }
    }
    else if ( v8 == 0x80000000 && !(_DWORD)a1 )
    {
      strcpy((char *)(v5 + 4), "1#INF");
      goto LABEL_19;
    }
    strcpy((char *)(v5 + 4), "1#QNAN");
    goto LABEL_22;
  }
  *(_WORD *)v24 = 0;
  *(_WORD *)&v24[10] = v7;
  v9 = (77 * (HIBYTE(v7) + 2 * HIBYTE(HIDWORD(a1))) + 19728 * v7 - 323162868) >> 16;
  *(_QWORD *)&v24[2] = a1;
  __multtenpow12(v24, -(__int16)v9, 1);
  if ( *(_WORD *)&v24[10] >= 0x3FFFu )
  {
    LOWORD(v9) = v9 + 1;
    __ld12mul(v24, v23);
  }
  v10 = (a4 & 1) == 0;
  *(_WORD *)v5 = v9;
  if ( v10 )
  {
    v11 = a3;
    goto LABEL_29;
  }
  v11 = (__int16)v9 + a3;
  if ( v11 > 0 )
  {
LABEL_29:
    if ( v11 > 21 )
      v11 = 21;
    v12 = *(unsigned __int16 *)&v24[10] - 16382;
    *(_WORD *)&v24[10] = 0;
    a5 = 8;
    do
    {
      __shl_12(v24);
      --a5;
    }
    while ( a5 );
    if ( v12 < 0 )
    {
      for ( i = (unsigned __int8)-(char)v12; i; --i )
        __shr_12((int *)v24);
    }
    v14 = v5 + 4;
    a5 = v5 + 4;
    if ( v11 + 1 > 0 )
    {
      a3 = v11 + 1;
      do
      {
        a1 = *(_QWORD *)v24;
        a2 = *(_DWORD *)&v24[8];
        __shl_12(v24);
        __shl_12(v24);
        __add_12((unsigned int *)v24, (unsigned int *)&a1);
        __shl_12(v24);
        v15 = v24[11];
        v16 = (_BYTE *)a5;
        v24[11] = 0;
        ++a5;
        v10 = a3-- == 1;
        *v16 = v15 + 48;
      }
      while ( !v10 );
      v14 = a5;
    }
    v17 = *(_BYTE *)(v14 - 1);
    v18 = (_BYTE *)(v14 - 2);
    v19 = v17 < 53;
    v20 = (_BYTE *)(v5 + 4);
    if ( v19 )
    {
      while ( v18 >= v20 )
      {
        if ( *v18 != 48 )
        {
          if ( v18 >= v20 )
            goto LABEL_47;
          break;
        }
        --v18;
      }
      *(_WORD *)v5 = 0;
      *(_BYTE *)(v5 + 2) = 32;
      *(_BYTE *)(v5 + 3) = 1;
      *v20 = 48;
      goto LABEL_54;
    }
    while ( v18 >= v20 )
    {
      if ( *v18 != 57 )
      {
        if ( v18 >= v20 )
          goto LABEL_46;
        break;
      }
      *v18-- = 48;
    }
    ++v18;
    ++*(_WORD *)v5;
LABEL_46:
    ++*v18;
LABEL_47:
    v21 = (_BYTE)v18 - v5 - 3;
    *(_BYTE *)(v5 + 3) = v21;
    *(_BYTE *)(v21 + v5 + 4) = 0;
    return v25;
  }
LABEL_6:
  *(_WORD *)v5 = 0;
  *(_BYTE *)(v5 + 2) = 32;
  *(_BYTE *)(v5 + 3) = 1;
  *(_BYTE *)(v5 + 4) = 48;
LABEL_54:
  *(_BYTE *)(v5 + 5) = 0;
  return 1;
}


// ========== Function: __mbsnbicoll @ 0x416B8D ==========
int __cdecl _mbsnbicoll(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount)
{
  int v4; // eax

  if ( !MaxCount )
    return 0;
  v4 = __crtCompareStringA(Locale, 1u, (PCNZCH)Str1, MaxCount, (PCNZCH)Str2, MaxCount, CodePage);
  if ( v4 )
    return v4 - 2;
  else
    return 0x7FFFFFFF;
}


// ========== Function: ___wtomb_environ @ 0x416BCC ==========
int __wtomb_environ()
{
  int v0; // esi
  const WCHAR *v1; // eax
  size_t v2; // eax
  int v3; // ebp
  CHAR *v4; // eax
  unsigned __int8 *Str; // [esp+10h] [ebp-4h]

  v0 = dword_4393D8;
  v1 = *(const WCHAR **)dword_4393D8;
  if ( !*(_DWORD *)dword_4393D8 )
    return 0;
  while ( 1 )
  {
    v2 = WideCharToMultiByte(1u, 0, v1, -1, 0, 0, 0, 0);
    v3 = v2;
    if ( !v2 )
      break;
    v4 = (CHAR *)malloc(v2);
    Str = (unsigned __int8 *)v4;
    if ( !v4 || !WideCharToMultiByte(1u, 0, *(LPCWCH *)v0, -1, v4, v3, 0, 0) )
      break;
    __crtsetenv(Str, 0);
    v1 = *(const WCHAR **)(v0 + 4);
    v0 += 4;
    if ( !v1 )
      return 0;
  }
  return -1;
}


// ========== Function: __strnicmp @ 0x416C40 ==========
int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount)
{
  size_t v3; // ecx
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // al
  bool v8; // cf
  unsigned int v9; // eax
  unsigned int v10; // ebx
  bool v11; // cf
  int v12; // ebx
  int v14; // [esp-8h] [ebp-18h]
  size_t v15; // [esp-4h] [ebp-14h]
  int v16; // [esp+0h] [ebp-10h]

  v3 = MaxCount;
  if ( MaxCount )
  {
    if ( *((_DWORD *)&unk_4395D4 + 2) )
    {
      _InterlockedIncrement(&Addend);
      if ( dword_439770 > 0 )
      {
        _InterlockedDecrement(&Addend);
        _lock(19);
        v16 = 1;
        v3 = MaxCount;
      }
      else
      {
        v16 = 0;
      }
      v9 = 0;
      v10 = 0;
      do
      {
        LOBYTE(v9) = *String1;
        LOBYTE(v10) = *String2;
        if ( !v9 || !v10 )
          break;
        ++String1;
        ++String2;
        v15 = v3;
        v14 = v9;
        v10 = tolower_0(v10);
        v9 = tolower_0(v14);
        v11 = v9 < v10;
        if ( v9 != v10 )
          goto differ2;
        v3 = v15 - 1;
      }
      while ( v15 != 1 );
      v3 = 0;
      v11 = v9 < v10;
      if ( v9 == v10 )
        goto toend2;
differ2:
      v3 = -1;
      if ( !v11 )
        v3 = 1;
toend2:
      if ( v16 )
      {
        v12 = v3;
        _unlock(19);
        return v12;
      }
      else
      {
        _InterlockedDecrement(&Addend);
      }
    }
    else
    {
      do
      {
        v6 = *String1;
        v7 = *String2;
        if ( !*String1 || !v7 )
          break;
        ++String1;
        ++String2;
        if ( v6 >= 0x41u && v6 <= 0x5Au )
          v6 += 32;
        if ( v7 >= 0x41u && v7 <= 0x5Au )
          v7 += 32;
        v8 = v6 < v7;
        if ( v6 != v7 )
          goto differ;
        --v3;
      }
      while ( v3 );
      v3 = 0;
      v8 = v6 < v7;
      if ( v6 == v7 )
        return v3;
differ:
      v3 = -1;
      if ( !v8 )
        return 1;
    }
  }
  return v3;
}


// ========== Function: ___ld12mul @ 0x416D41 ==========
int __cdecl __ld12mul(int a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // ax
  __int16 v6; // di
  int result; // eax
  int v8; // ecx
  int v9; // edi
  unsigned __int16 v10; // dx
  int v11; // eax
  int v12; // ebx
  int v13[3]; // [esp+Ch] [ebp-24h] BYREF
  int v14; // [esp+18h] [ebp-18h]
  int v15; // [esp+1Ch] [ebp-14h]
  int v16; // [esp+20h] [ebp-10h]
  unsigned __int16 *v17; // [esp+24h] [ebp-Ch]
  unsigned __int16 *v18; // [esp+28h] [ebp-8h]
  int *v19; // [esp+2Ch] [ebp-4h]
  int v20; // [esp+38h] [ebp+8h]
  int v21; // [esp+38h] [ebp+8h]
  int i; // [esp+3Ch] [ebp+Ch]

  v4 = *(_WORD *)(a2 + 10);
  v15 = 0;
  memset(v13, 0, sizeof(v13));
  v5 = *(_WORD *)(a1 + 10);
  v6 = v5 ^ v4;
  result = v5 & 0x7FFF;
  v8 = v4 & 0x7FFF;
  v9 = v6 & 0x8000;
  v10 = v8 + result;
  v20 = v8 + result;
  if ( (unsigned __int16)result < 0x7FFFu && (unsigned __int16)v8 < 0x7FFFu && v10 <= 0xBFFDu )
  {
    if ( v10 <= 0x3FBFu )
    {
      result = 0;
LABEL_16:
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
      return result;
    }
    if ( (_WORD)result || (++v20, (*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0) )
    {
      result = 0;
    }
    else
    {
      result = 0;
      if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
        goto LABEL_45;
    }
    if ( !(_WORD)v8 )
    {
      ++v20;
      if ( (*(_DWORD *)(a2 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD *)(a2 + 4) && !*(_DWORD *)a2 )
        goto LABEL_16;
    }
    v16 = 0;
    v19 = &v13[1];
    for ( i = 5; i > 0; --i )
    {
      v18 = (unsigned __int16 *)(a1 + 2 * v16);
      v17 = (unsigned __int16 *)(a2 + 8);
      v14 = i;
      do
      {
        if ( __addl(*(v19 - 1), *v17 * *v18, (unsigned int *)v19 - 1) )
          ++*(_WORD *)v19;
        ++v18;
        --v17;
        --v14;
      }
      while ( v14 );
      v19 = (int *)((char *)v19 + 2);
      ++v16;
    }
    v21 = v20 + 49154;
    if ( (__int16)v21 <= 0 )
      goto LABEL_49;
    do
    {
      if ( v13[2] < 0 )
        break;
      __shl_12(v13);
      v21 += 0xFFFF;
    }
    while ( (__int16)v21 > 0 );
    if ( (__int16)v21 <= 0 )
    {
LABEL_49:
      v21 += 0xFFFF;
      if ( (v21 & 0x8000u) != 0 )
      {
        v11 = -(__int16)v21;
        v21 -= (__int16)v21;
        v12 = v11;
        do
        {
          if ( (v13[0] & 1) != 0 )
            ++v15;
          __shr_12(v13);
          --v12;
        }
        while ( v12 );
        if ( v15 )
          LOBYTE(v13[0]) |= 1u;
      }
    }
    if ( LOWORD(v13[0]) > 0x8000u || (v13[0] & 0x1FFFF) == 0x18000 )
    {
      if ( *(int *)((char *)v13 + 2) == -1 )
      {
        *(int *)((char *)v13 + 2) = 0;
        if ( *(int *)((char *)&v13[1] + 2) == -1 )
        {
          *(int *)((char *)&v13[1] + 2) = 0;
          if ( HIWORD(v13[2]) == 0xFFFF )
          {
            ++v21;
            HIWORD(v13[2]) = 0x8000;
          }
          else
          {
            ++HIWORD(v13[2]);
          }
        }
        else
        {
          ++*(int *)((char *)&v13[1] + 2);
        }
      }
      else
      {
        ++*(int *)((char *)v13 + 2);
      }
    }
    result = v21;
    if ( (unsigned __int16)v21 < 0x7FFFu )
    {
      result = v9 | v21;
      *(_WORD *)a1 = HIWORD(v13[0]);
      *(_DWORD *)(a1 + 2) = v13[1];
      *(_DWORD *)(a1 + 6) = v13[2];
LABEL_45:
      *(_WORD *)(a1 + 10) = result;
      return result;
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = (_WORD)v9 != 0 ? -32768 : 2147450880;
  return result;
}


// ========== Function: ___multtenpow12 @ 0x416F61 ==========
void __cdecl __multtenpow12(_WORD *a1, int a2, int a3)
{
  char *v3; // ebx
  char v4; // al
  int v5; // eax
  char *v6; // esi
  _DWORD *v7; // esi
  __int64 v8; // [esp+4h] [ebp-Ch] BYREF
  int v9; // [esp+Ch] [ebp-4h]

  v3 = (char *)&unk_436F40 - 96;
  if ( a2 )
  {
    if ( a2 < 0 )
    {
      a2 = -a2;
      v3 = (char *)&unk_4370A0 - 96;
    }
    if ( !a3 )
      *a1 = 0;
    while ( a2 )
    {
      v4 = a2;
      v3 += 84;
      a2 >>= 3;
      v5 = v4 & 7;
      if ( v5 )
      {
        v6 = &v3[12 * v5];
        if ( *(_WORD *)v6 >= 0x8000u )
        {
          LODWORD(v8) = *(_DWORD *)v6;
          v7 = v6 + 4;
          HIDWORD(v8) = *v7;
          v9 = v7[1];
          --*(_DWORD *)((char *)&v8 + 2);
          v6 = (char *)&v8;
        }
        __ld12mul((int)a1, (int)v6);
      }
    }
  }
}


// ========== Function: ___crtCompareStringA @ 0x416FDD ==========
int __cdecl __crtCompareStringA(
        LCID Locale,
        DWORD dwCmpFlags,
        PCNZCH lpString1,
        int cchCount1,
        PCNZCH lpString2,
        int cchCount2,
        UINT CodePage)
{
  int v7; // esi
  BYTE *LeadByte; // eax
  unsigned __int8 v10; // dl
  BYTE *i; // eax
  unsigned __int8 v12; // dl
  int v13; // eax
  int v14; // eax
  void *v15; // esp
  int v16; // eax
  int v17; // esi
  int v18; // eax
  void *v19; // esp
  WCHAR v21[8]; // [esp+0h] [ebp-4Ch] BYREF
  struct _cpinfo CPInfo; // [esp+10h] [ebp-3Ch] BYREF
  WCHAR *v23; // [esp+24h] [ebp-28h]
  LPWSTR lpWideCharStr; // [esp+28h] [ebp-24h]
  int v25; // [esp+2Ch] [ebp-20h]
  int cchWideChar; // [esp+30h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  if ( !dword_439754 )
  {
    if ( CompareStringW(0, 0, &String1, 1, &String1, 1) )
    {
      dword_439754 = 1;
    }
    else
    {
      if ( !CompareStringA(0, 0, &byte_42C2D8, 1, &byte_42C2D8, 1) )
        return 0;
      dword_439754 = 2;
    }
  }
  v7 = cchCount1;
  if ( cchCount1 > 0 )
    v7 = strncnt(lpString1, cchCount1);
  if ( cchCount2 > 0 )
    cchCount2 = strncnt(lpString2, cchCount2);
  if ( dword_439754 == 2 )
    return CompareStringA(Locale, dwCmpFlags, lpString1, v7, lpString2, cchCount2);
  if ( dword_439754 == 1 )
  {
    if ( !CodePage )
      CodePage = dword_4395EC;
    if ( !v7 || !cchCount2 )
    {
      if ( v7 == cchCount2 )
        return 2;
      if ( cchCount2 > 1 )
        return 1;
      if ( v7 > 1 )
        return 3;
      if ( !GetCPInfo(CodePage, &CPInfo) )
        return 0;
      if ( v7 > 0 )
      {
        if ( CPInfo.MaxCharSize >= 2 )
        {
          LeadByte = CPInfo.LeadByte;
          if ( CPInfo.LeadByte[0] )
          {
            while ( 1 )
            {
              v10 = LeadByte[1];
              if ( !v10 )
                break;
              if ( (unsigned int)*lpString1 >= *LeadByte && (unsigned int)*lpString1 <= v10 )
                return 2;
              LeadByte += 2;
              if ( !*LeadByte )
                return 3;
            }
          }
        }
        return 3;
      }
      if ( cchCount2 > 0 )
      {
        if ( CPInfo.MaxCharSize >= 2 )
        {
          for ( i = CPInfo.LeadByte; *i; i += 2 )
          {
            v12 = i[1];
            if ( !v12 )
              break;
            if ( (unsigned int)*lpString2 >= *i && (unsigned int)*lpString2 <= v12 )
              return 2;
          }
        }
        return 1;
      }
    }
    v13 = MultiByteToWideChar(CodePage, 9u, lpString1, v7, 0, 0);
    cchWideChar = v13;
    if ( v13 )
    {
      v14 = 2 * v13 + 3;
      LOBYTE(v14) = v14 & 0xFC;
      v15 = alloca(v14);
      ms_exc.old_esp = (DWORD)v21;
      lpWideCharStr = v21;
      ms_exc.registration.TryLevel = -1;
      if ( v21 )
      {
        if ( MultiByteToWideChar(CodePage, 1u, lpString1, v7, lpWideCharStr, cchWideChar) )
        {
          v16 = MultiByteToWideChar(CodePage, 9u, lpString2, cchCount2, 0, 0);
          v17 = v16;
          v25 = v16;
          if ( v16 )
          {
            v18 = 2 * v16 + 3;
            LOBYTE(v18) = v18 & 0xFC;
            v19 = alloca(v18);
            ms_exc.old_esp = (DWORD)v21;
            v23 = v21;
            ms_exc.registration.TryLevel = -1;
            if ( v21 )
            {
              if ( MultiByteToWideChar(CodePage, 1u, lpString2, cchCount2, v21, v17) )
                return CompareStringW(Locale, dwCmpFlags, lpWideCharStr, cchWideChar, v21, v17);
            }
          }
        }
      }
    }
  }
  return 0;
}


// ========== Function: _strncnt @ 0x41725A ==========
_BYTE *__cdecl strncnt(_BYTE *a1, int a2)
{
  _BYTE *v2; // eax
  int v3; // ecx

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    return (_BYTE *)a2;
  else
    return (_BYTE *)(v2 - a1);
}


// ========== Function: ___crtsetenv @ 0x417285 ==========
int __cdecl __crtsetenv(unsigned __int8 *Str, int a2)
{
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // esi
  void *v4; // eax
  BOOL v5; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  _DWORD *v12; // edi
  void *v13; // eax
  size_t v14; // eax
  char *v15; // eax
  CHAR *v16; // esi
  unsigned __int8 *v17; // eax
  void *v18; // [esp-4h] [ebp-18h]
  unsigned __int8 *v19; // [esp+Ch] [ebp-8h]
  void *lpMem; // [esp+10h] [ebp-4h]

  if ( !Str )
    return -1;
  v2 = _mbschr(Str, 0x3Du);
  v3 = v2;
  v19 = v2;
  if ( !v2 || Str == v2 )
    return -1;
  v4 = dword_4393D0;
  v5 = v3[1] == 0;
  if ( dword_4393D0 == (LPVOID)dword_4393D4 )
  {
    v4 = (void *)copy_environ(dword_4393D0);
    dword_4393D0 = v4;
  }
  if ( !v4 )
  {
    if ( a2 && dword_4393D8 )
    {
      if ( __wtomb_environ() )
        return -1;
    }
    else
    {
      if ( v5 )
        return 0;
      v7 = malloc(4u);
      dword_4393D0 = v7;
      if ( !v7 )
        return -1;
      *v7 = 0;
      if ( !dword_4393D8 )
      {
        v8 = malloc(4u);
        dword_4393D8 = (int)v8;
        if ( !v8 )
          return -1;
        *v8 = 0;
      }
    }
  }
  v9 = dword_4393D0;
  lpMem = dword_4393D0;
  v10 = findenv(Str, v3 - Str);
  v11 = v10;
  if ( v10 >= 0 && *v9 )
  {
    if ( !v5 )
    {
      v9[v10] = Str;
      goto LABEL_31;
    }
    v18 = (void *)v9[v10];
    v12 = &v9[v10];
    sub_40D386(v18);
    while ( *v12 )
    {
      ++v11;
      *v12 = v12[1];
      ++v12;
    }
    v13 = sub_40F8ED(lpMem, 4 * v11);
    if ( !v13 )
    {
LABEL_31:
      if ( a2 )
      {
        v14 = strlen((const char *)Str);
        v15 = (char *)malloc(v14 + 2);
        v16 = v15;
        if ( v15 )
        {
          strcpy(v15, (const char *)Str);
          v17 = &v19[v16 - (CHAR *)Str];
          *v17 = 0;
          SetEnvironmentVariableA(v16, !v5 ? (LPCSTR)v17 + 1 : 0);
          sub_40D386(v16);
        }
      }
      return 0;
    }
LABEL_30:
    dword_4393D0 = v13;
    goto LABEL_31;
  }
  if ( !v5 )
  {
    if ( v10 < 0 )
      v11 = -v10;
    v13 = sub_40F8ED(v9, 4 * v11 + 8);
    if ( !v13 )
      return -1;
    *((_DWORD *)v13 + v11) = Str;
    *((_DWORD *)v13 + v11 + 1) = 0;
    goto LABEL_30;
  }
  return 0;
}


// ========== Function: _findenv @ 0x41740C ==========
int __cdecl findenv(unsigned __int8 *Str1, size_t MaxCount)
{
  char *v2; // esi
  const unsigned __int8 *v3; // eax
  char v4; // al

  v2 = (char *)dword_4393D0;
  v3 = *(const unsigned __int8 **)dword_4393D0;
  if ( !*(_DWORD *)dword_4393D0 )
    return -((v2 - (_BYTE *)dword_4393D0) >> 2);
  while ( 1 )
  {
    if ( !_mbsnbicoll(Str1, v3, MaxCount) )
    {
      v4 = *(_BYTE *)(*(_DWORD *)v2 + MaxCount);
      if ( v4 == 61 || !v4 )
        break;
    }
    v3 = (const unsigned __int8 *)*((_DWORD *)v2 + 1);
    v2 += 4;
    if ( !v3 )
      return -((v2 - (_BYTE *)dword_4393D0) >> 2);
  }
  return (v2 - (_BYTE *)dword_4393D0) >> 2;
}


// ========== Function: _copy_environ @ 0x417464 ==========
_DWORD *__cdecl copy_environ(_DWORD *a1)
{
  int v1; // ecx
  int *v3; // eax
  int v4; // edx
  _DWORD *v5; // esi
  _DWORD *v6; // ebp
  const char *v7; // eax
  const char **v8; // ebx

  v1 = 0;
  if ( !a1 )
    return 0;
  v3 = a1 + 1;
  if ( *a1 )
  {
    do
    {
      v4 = *v3;
      ++v1;
      ++v3;
    }
    while ( v4 );
  }
  v5 = malloc(4 * v1 + 4);
  v6 = v5;
  if ( !v5 )
    _amsg_exit(9u);
  v7 = (const char *)*a1;
  v8 = (const char **)a1;
  while ( v7 )
  {
    ++v8;
    *v5 = _strdup(v7);
    v7 = *v8;
    ++v5;
  }
  *v5 = 0;
  return v6;
}


// ========== Function: RtlUnwind @ 0x4174CC ==========
// attributes: thunk
void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)
{
  __imp_RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}


// ========== Function: GetSaveFileNameA @ 0x4174D2 ==========
// attributes: thunk
BOOL __stdcall GetSaveFileNameA(LPOPENFILENAMEA a1)
{
  return __imp_GetSaveFileNameA(a1);
}


// ========== Function: GetOpenFileNameA @ 0x4174D8 ==========
// attributes: thunk
BOOL __stdcall GetOpenFileNameA(LPOPENFILENAMEA a1)
{
  return __imp_GetOpenFileNameA(a1);
}


// ========== Function: GetFileTitleA @ 0x4174DE ==========
// attributes: thunk
__int16 __stdcall GetFileTitleA(LPCSTR a1, LPSTR Buf, WORD cchSize)
{
  return __imp_GetFileTitleA(a1, Buf, cchSize);
}


// ========== Function: ClosePrinter @ 0x4174E4 ==========
// attributes: thunk
BOOL __stdcall ClosePrinter(HANDLE hPrinter)
{
  return __imp_ClosePrinter(hPrinter);
}


// ========== Function: DocumentPropertiesA @ 0x4174EA ==========
// attributes: thunk
LONG __stdcall DocumentPropertiesA(
        HWND hWnd,
        HANDLE hPrinter,
        LPSTR pDeviceName,
        PDEVMODEA pDevModeOutput,
        PDEVMODEA pDevModeInput,
        DWORD fMode)
{
  return __imp_DocumentPropertiesA(hWnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode);
}


// ========== Function: OpenPrinterA @ 0x4174F0 ==========
// attributes: thunk
BOOL __stdcall OpenPrinterA(LPSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSA pDefault)
{
  return __imp_OpenPrinterA(pPrinterName, phPrinter, pDefault);
}


// ========== Function: OleUIBusyA @ 0x4174F6 ==========
// attributes: thunk
UINT __stdcall OleUIBusyA(LPOLEUIBUSYA a1)
{
  return __imp_OleUIBusyA(a1);
}


// ========== Function: _LpfnGetDefWndProcNull @ 0x417500 ==========
HANDLE __cdecl LpfnGetDefWndProcNull(HWND hWnd)
{
  if ( hWnd )
    return GetPropA(hWnd, (LPCSTR)(unsigned __int16)lpString);
  else
    return 0;
}


// ========== Function: _LpfnGetDefWndProc @ 0x417520 ==========
HANDLE __cdecl LpfnGetDefWndProc(HWND hWnd, int a2)
{
  HANDLE DefWndProcNull; // edi

  DefWndProcNull = LpfnGetDefWndProcNull(hWnd);
  if ( !DefWndProcNull )
  {
    if ( a2 == 6 )
      DefWndProcNull = hData;
    else
      DefWndProcNull = (HANDLE)dword_43B584[6 * a2];
    SetPropA(hWnd, (LPCSTR)(unsigned __int16)lpString, DefWndProcNull);
  }
  return DefWndProcNull;
}


// ========== Function: _SubclassWindow @ 0x417570 ==========
HANDLE __cdecl SubclassWindow(HWND hWnd, LONG dwNewLong)
{
  HANDLE result; // eax
  void *v3; // eax
  CHAR ClassName[16]; // [esp+8h] [ebp-10h] BYREF

  result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)nAtom);
  if ( !result )
  {
    result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)lpString);
    if ( !result )
    {
      result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB32);
      if ( !result )
      {
        result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB2C);
        if ( !result )
        {
          result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB30);
          if ( !result )
          {
            result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB2A);
            if ( !result )
            {
              result = LpfnGetDefWndProcNull(hWnd);
              if ( !result )
              {
                if ( byte_43B625 )
                {
                  if ( !IsWindowUnicode(hWnd) )
                  {
                    GetClassNameA(hWnd, ClassName, 16);
                    lstrcmpiA(ClassName, aEdit);
                  }
                }
                v3 = (void *)SetWindowLongA(hWnd, -4, dwNewLong);
                return (HANDLE)SetPropA(hWnd, (LPCSTR)(unsigned __int16)lpString, v3);
              }
            }
          }
        }
      }
    }
  }
  return result;
}


// ========== Function: _CallWndProcFilterProc@12 @ 0x417660 ==========
LRESULT __stdcall CallWndProcFilterProc(int code, WPARAM wParam, LPARAM lParam)
{
  LRESULT v3; // edi
  char WindowLongA; // al
  LPARAM v6; // [esp+8h] [ebp-4h] BYREF

  v3 = CallNextHookEx(hhk, code, wParam, lParam);
  if ( *(_DWORD *)(lParam + 12) == dword_439760 )
  {
    UnhookWindowsHookEx(hhk);
    if ( (unsigned __int16)word_43AB40 < 0x35Fu
      || (WindowLongA = GetWindowLongA(*(HWND *)(lParam + 12), -16), v6 = 0, (WindowLongA & 4) == 0) )
    {
      v6 = 1;
    }
    SendMessageA(*(HWND *)(lParam + 12), 0x11F0u, 0, (LPARAM)&v6);
    if ( v6 )
      SubclassWindow(*(HWND *)(lParam + 12), dwNewLong);
    hhk = 0;
    dwNewLong = 0;
    dword_439760 = 0;
  }
  return v3;
}


// ========== Function: _HookSubclassWindow @ 0x417710 ==========
HHOOK __cdecl HookSubclassWindow(int a1, LONG a2)
{
  DWORD CurrentThreadId; // eax
  HHOOK result; // eax

  dwNewLong = a2;
  dword_439760 = a1;
  CurrentThreadId = GetCurrentThreadId();
  result = SetWindowsHookExA(4, CallWndProcFilterProc, hmod, CurrentThreadId);
  hhk = result;
  return result;
}


// ========== Function: _CleanupSubclass @ 0x417750 ==========
LRESULT __cdecl CleanupSubclass(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, int a5)
{
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT v6; // edi

  DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, a5);
  v6 = CallWindowProcA(DefWndProc, hWnd, Msg, wParam, lParam);
  RemovePropA(hWnd, (LPCSTR)(unsigned __int16)lpString);
  RemovePropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34);
  return v6;
}


// ========== Function: _DeleteObjectNull @ 0x4177B0 ==========
HGDIOBJ __cdecl DeleteObjectNull(HGDIOBJ *a1)
{
  HGDIOBJ result; // eax

  result = *a1;
  if ( *a1 )
  {
    result = (HGDIOBJ)DeleteObject(*a1);
    *a1 = 0;
  }
  return result;
}


// ========== Function: _DeleteObjects @ 0x4177D0 ==========
HGDIOBJ DeleteObjects()
{
  HGDIOBJ *v0; // esi

  v0 = (HGDIOBJ *)&dword_43AB64;
  do
    DeleteObjectNull(v0++);
  while ( v0 < &dword_43AB70 );
  return DeleteObjectNull(&dword_43AB70);
}


// ========== Function: _PatFill @ 0x417800 ==========
BOOL __cdecl PatFill(HDC hdc, int *a2)
{
  return PatBlt(hdc, *a2, a2[1], a2[2] - *a2, a2[3] - a2[1], 0xF00021u);
}


// ========== Function: _DrawRec3d @ 0x417830 ==========
COLORREF __cdecl DrawRec3d(HDC hdc, LONG *a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5)
{
  COLORREF v5; // esi
  LONG v6; // edx
  LONG v7; // ebp
  RECT rect; // [esp+10h] [ebp-10h] BYREF

  v5 = SetBkColor(hdc, *(&color + a3));
  v6 = a2[1];
  v7 = a2[2];
  rect.left = *a2;
  rect.top = v6;
  rect.right = v7;
  rect.bottom = v6 + 1;
  if ( (a5 & 2) != 0 )
    ExtTextOutA(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  rect.bottom = a2[3];
  rect.right = rect.left + 1;
  if ( (a5 & 1) != 0 )
    ExtTextOutA(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  if ( a3 != a4 )
    SetBkColor(hdc, *(&color + a4));
  rect.right = a2[2];
  rect.left = rect.right - 1;
  if ( (a5 & 4) != 0 )
    ExtTextOutA(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  if ( (a5 & 8) != 0 )
  {
    rect.left = *a2;
    rect.top = rect.bottom - 1;
    if ( (a5 & 0x1000) != 0 )
      rect.right -= 2;
    ExtTextOutA(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  }
  return SetBkColor(hdc, v5);
}


// ========== Function: _DrawInsetRect3d @ 0x417970 ==========
COLORREF __cdecl DrawInsetRect3d(HDC hdc, int *a2, __int16 a3)
{
  int v3; // esi
  int v4; // edi
  int v5; // eax
  int v7; // [esp+8h] [ebp-10h] BYREF
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  v3 = a2[1];
  v4 = a2[2];
  v7 = *a2;
  v5 = a2[3];
  v8 = v3;
  v9 = v4;
  v10 = v5;
  DrawRec3d(hdc, &v7, 7u, 1u, a3 & 0xF);
  --v7;
  --v8;
  ++v9;
  ++v10;
  return DrawRec3d(hdc, &v7, 2u, 0, a3);
}


// ========== Function: _ClipCtlDc @ 0x4179E0 ==========
int __cdecl ClipCtlDc(HWND hWnd, HDC hdc)
{
  struct tagRECT Rect; // [esp+0h] [ebp-10h] BYREF

  GetClientRect(hWnd, &Rect);
  return IntersectClipRect(hdc, Rect.left, Rect.top, Rect.right, Rect.bottom);
}


// ========== Function: _MyGetTextExtent @ 0x417A20 ==========
LONG *__cdecl MyGetTextExtent(HDC hdc, CHAR *a2, LONG *a3, LONG *a4)
{
  LPSTR v4; // eax
  CHAR *v5; // esi
  CHAR v6; // cl
  const CHAR *v7; // eax
  CHAR v8; // cl
  int v9; // eax
  LONG *result; // eax
  LONG cy; // edx
  struct tagSIZE sz; // [esp+Ch] [ebp-108h] BYREF
  CHAR String[256]; // [esp+14h] [ebp-100h] BYREF

  v4 = a2;
  v5 = String;
  while ( *v4 )
  {
    v6 = *v4;
    if ( *v4 == 38 )
    {
      if ( !*++v4 )
        break;
    }
    else if ( byte_43B625 )
    {
      if ( v6 == byte_43B624 )
      {
        if ( !*++v4 )
          break;
      }
      else if ( v6 == 30 || v6 == 31 )
      {
        v7 = v4 + 1;
        if ( !*v7 )
          break;
        v4 = CharNextA(v7);
        continue;
      }
    }
    v8 = *v4++;
    *v5++ = v8;
  }
  *v5 = 0;
  v9 = lstrlenA(String);
  GetTextExtentPointA(hdc, String, v9, &sz);
  result = a3;
  cy = sz.cy;
  *a3 = sz.cx;
  *a4 = cy;
  return result;
}


// ========== Function: _Ctl3dRegister@4 @ 0x417AD0 ==========
BOOL __stdcall Ctl3dRegister(HINSTANCE a1)
{
  InitializeCriticalSection(&stru_43AB00);
  EnterCriticalSection(&stru_43AB00);
  ++dword_43AB24;
  LeaveCriticalSection(&stru_43AB00);
  if ( dword_43AB24 == 1 )
  {
    LibMain(a1, 1);
    FInit3dDialogs();
  }
  if ( Ctl3dIsAutoSubclass() )
    Ctl3dAutoSubclass(a1);
  return dword_43AB20;
}


// ========== Function: _Ctl3dUnregister@4 @ 0x417B40 ==========
BOOL __stdcall Ctl3dUnregister(HINSTANCE a1)
{
  int v1; // ebp
  DWORD CurrentThreadId; // ebx
  int v3; // eax
  int *v4; // edi

  v1 = 0;
  CurrentThreadId = GetCurrentThreadId();
  EnterCriticalSection(&stru_43AB00);
  if ( dword_43AB7C > 0 )
  {
    do
    {
      if ( dword_43AB84[5 * v1] == CurrentThreadId )
      {
        v3 = dword_43AB8C[5 * v1] - 1;
        dword_43AB8C[5 * v1] = v3;
        if ( !v3 || (HINSTANCE)dword_43AB80[5 * v1] == a1 )
        {
          UnhookWindowsHookEx((HHOOK)dword_43AB88[5 * v1]);
          if ( v1 < --dword_43AB7C )
          {
            v4 = &dword_43AB80[5 * v1];
            do
            {
              ++v1;
              qmemcpy(v4, v4 + 5, 0x14u);
              v4 += 5;
            }
            while ( v1 < dword_43AB7C );
          }
        }
      }
      ++v1;
    }
    while ( v1 < dword_43AB7C );
  }
  --dword_43AB24;
  LeaveCriticalSection(&stru_43AB00);
  if ( !dword_43AB24 )
    End3dDialogs();
  return 1;
}


// ========== Function: _Ctl3dAutoSubclass@4 @ 0x417C00 ==========
BOOL __stdcall Ctl3dAutoSubclass(HINSTANCE a1)
{
  return Ctl3dAutoSubclassEx(a1, 0);
}


// ========== Function: _Ctl3dAutoSubclassEx@8 @ 0x417C10 ==========
BOOL __stdcall Ctl3dAutoSubclassEx(HINSTANCE a1, DWORD a2)
{
  DWORD v3; // esi
  int CurrentThreadId; // edi
  int v5; // eax
  int *v6; // ecx
  HHOOK v7; // eax

  if ( (unsigned __int16)word_43AB40 < 0x30Au )
    return 0;
  if ( !dword_43AB20 )
    return 0;
  v3 = a2 | 1;
  if ( (a2 & 2) != 0 )
    v3 = a2 & 0xFFFFFFFC;
  EnterCriticalSection(&stru_43AB00);
  if ( dword_43AB7C != 128 )
  {
    CurrentThreadId = GetCurrentThreadId();
    v5 = 0;
    if ( dword_43AB7C > 0 )
    {
      v6 = dword_43AB84;
      while ( *v6 != CurrentThreadId )
      {
        v6 += 5;
        if ( ++v5 >= dword_43AB7C )
          goto LABEL_12;
      }
      ++dword_43AB8C[5 * v5];
      goto LABEL_14;
    }
LABEL_12:
    v7 = SetWindowsHookExA(5, Ctl3dHook, hmod, CurrentThreadId);
    if ( v7 )
    {
      dword_43AB80[5 * dword_43AB7C] = (int)a1;
      dword_43AB84[5 * dword_43AB7C] = CurrentThreadId;
      dword_43AB88[5 * dword_43AB7C] = (int)v7;
      dword_43AB8C[5 * dword_43AB7C] = 1;
      dword_43AB90[5 * dword_43AB7C] = v3;
      dword_43AB74 = CurrentThreadId;
      dword_43AB78 = dword_43AB7C++;
LABEL_14:
      LeaveCriticalSection(&stru_43AB00);
      return 1;
    }
  }
  LeaveCriticalSection(&stru_43AB00);
  return 0;
}


// ========== Function: _Ctl3dIsAutoSubclass@0 @ 0x417D50 ==========
BOOL __stdcall Ctl3dIsAutoSubclass()
{
  DWORD CurrentThreadId; // eax
  int v1; // edx
  int *i; // ecx

  CurrentThreadId = GetCurrentThreadId();
  v1 = 0;
  if ( dword_43AB7C <= 0 )
    return 0;
  for ( i = dword_43AB84; *i != CurrentThreadId; i += 5 )
  {
    if ( ++v1 >= dword_43AB7C )
      return 0;
  }
  return 1;
}


// ========== Function: _Ctl3dUnAutoSubclass@0 @ 0x417D80 ==========
BOOL __stdcall Ctl3dUnAutoSubclass()
{
  int v0; // ebp
  DWORD CurrentThreadId; // ebx
  int v2; // eax
  int *v3; // edi

  v0 = 0;
  CurrentThreadId = GetCurrentThreadId();
  EnterCriticalSection(&stru_43AB00);
  if ( dword_43AB7C > 0 )
  {
    do
    {
      if ( dword_43AB84[5 * v0] == CurrentThreadId )
      {
        v2 = dword_43AB8C[5 * v0] - 1;
        dword_43AB8C[5 * v0] = v2;
        if ( !v2 )
        {
          UnhookWindowsHookEx((HHOOK)dword_43AB88[5 * v0]);
          if ( v0 < --dword_43AB7C )
          {
            v3 = &dword_43AB80[5 * v0];
            do
            {
              ++v0;
              qmemcpy(v3, v3 + 5, 0x14u);
              v3 += 5;
            }
            while ( v0 < dword_43AB7C );
          }
        }
      }
      ++v0;
    }
    while ( v0 < dword_43AB7C );
  }
  LeaveCriticalSection(&stru_43AB00);
  return 1;
}


// ========== Function: _Ctl3dSubclassCtl@4 @ 0x417E20 ==========
BOOL __stdcall Ctl3dSubclassCtl(HWND hWnd)
{
  if ( dword_43AB20 )
    return DoSubclassCtl(hWnd, 0xFFFF, 0, 0);
  else
    return 0;
}


// ========== Function: _Ctl3dUnsubclassCtl@4 @ 0x417E50 ==========
BOOL __stdcall Ctl3dUnsubclassCtl(HWND hWnd)
{
  int (__stdcall *WindowLongA)(HWND, UINT, WPARAM, LPARAM); // eax
  int i; // ecx
  HANDLE DefWndProc; // ebp
  HANDLE v5; // ebp
  HWND j; // edi

  if ( !dword_43AB20 )
    return 0;
  WindowLongA = (int (__stdcall *)(HWND, UINT, WPARAM, LPARAM))GetWindowLongA(hWnd, -4);
  for ( i = 0; i < 6; ++i )
  {
    if ( (int (__stdcall *)(HWND, UINT, WPARAM, LPARAM))*(&dword_43B580 + 6 * i) == WindowLongA )
    {
      DefWndProc = LpfnGetDefWndProc(hWnd, i);
      RemovePropA(hWnd, (LPCSTR)(unsigned __int16)lpString);
      SetWindowLongA(hWnd, -4, (LONG)DefWndProc);
      WindowLongA = 0;
      i = 16;
    }
  }
  if ( i == 6 )
  {
    if ( WindowLongA == Ctl3dDlgProc )
    {
      v5 = LpfnGetDefWndProc(hWnd, 6);
      RemovePropA(hWnd, (LPCSTR)(unsigned __int16)lpString);
      SetWindowLongA(hWnd, -4, (LONG)v5);
    }
    else if ( GetPropA(hWnd, (LPCSTR)(unsigned __int16)lpString)
           || GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB32)
           || GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB30) )
    {
      SetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34, HANDLE_FLAG_INHERIT);
    }
  }
  for ( j = GetWindow(hWnd, 5u); j; j = GetWindow(j, 2u) )
    Ctl3dUnsubclassCtl(j);
  return 1;
}


// ========== Function: _Ctl3dSubclassCtlEx@8 @ 0x417F60 ==========
BOOL __stdcall Ctl3dSubclassCtlEx(HWND hWnd, int a2)
{
  LONG WindowLongA; // ebx

  if ( !dword_43AB20 )
    return 0;
  if ( (unsigned int)a2 > 6 )
    return 0;
  if ( LpfnGetDefWndProcNull(hWnd) )
    return 0;
  WindowLongA = GetWindowLongA(hWnd, -16);
  GetParent(hWnd);
  if ( (*(&off_42CBE0 + 8 * a2))((int)hWnd, WindowLongA) == 1 )
    SubclassWindow(hWnd, *(&dword_43B580 + 6 * a2));
  return 1;
}


// ========== Function: _CheckChildSubclass @ 0x417FF0 ==========
HANDLE __cdecl CheckChildSubclass(HWND hWnd, __int16 a2, int a3)
{
  HANDLE result; // eax
  LPARAM lParam; // [esp+Ch] [ebp-4h] BYREF

  if ( !LpfnGetDefWndProcNull(hWnd) )
    return (HANDLE)DoSubclassCtl(hWnd, a2, 0, a3);
  result = GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34);
  if ( !result )
  {
    lParam = 666;
    result = (HANDLE)SendMessageA(hWnd, 0x1944u, 0, (LPARAM)&lParam);
    if ( lParam == 666 )
    {
      result = (HANDLE)SendMessageA(hWnd, 0x1943u, 0, (LPARAM)&lParam);
      if ( lParam == 666 )
      {
        RemovePropA(hWnd, (LPCSTR)(unsigned __int16)lpString);
        return (HANDLE)DoSubclassCtl(hWnd, a2, 0, a3);
      }
    }
  }
  return result;
}


// ========== Function: _Ctl3dCheckSubclassDlg@8 @ 0x4180A0 ==========
int __stdcall Ctl3dCheckSubclassDlg(HWND hWnd, __int16 a2)
{
  HWND i; // edi
  HWND j; // ebx

  if ( !dword_43AB20 )
    return 0;
  for ( i = GetWindow(hWnd, 5u); i; i = GetWindow(i, 2u) )
  {
    CheckChildSubclass(i, a2, 0);
    for ( j = GetWindow(i, 5u); j; j = GetWindow(j, 2u) )
      CheckChildSubclass(j, a2, (int)i);
  }
  return 1;
}


// ========== Function: _Ctl3dSubclassDlgEx@8 @ 0x418120 ==========
BOOL __stdcall Ctl3dSubclassDlgEx(HWND hWnd, DWORD a2)
{
  HWND i; // ebx

  if ( !dword_43AB20 )
    return 0;
  for ( i = GetWindow(hWnd, 5u); i; i = GetWindow(i, 2u) )
    DoSubclassCtl(i, a2, 0, 0);
  SubclassWindow(hWnd, (LONG)Ctl3dDlgProc);
  return 1;
}


// ========== Function: _Ctl3dCtlColorEx@12 @ 0x418190 ==========
HBRUSH __stdcall Ctl3dCtlColorEx(UINT wm, WPARAM wParam, LPARAM lParam)
{
  if ( !dword_43AB20 || wm < 0x134 || wm == 311 )
    return 0;
  if ( wm == 308
    && ((unsigned __int16)word_43AB40 >= 0x35Fu
     || !GetWindow((HWND)lParam, 5u)
     || (GetWindowLongA((HWND)lParam, -16) & 3) == 3) )
  {
    return 0;
  }
  SetTextColor((HDC)wParam, dword_43AB50);
  SetBkColor((HDC)wParam, dword_43AB48);
  return (HBRUSH)h;
}


// ========== Function: _Ctl3dColorChange@0 @ 0x418220 ==========
BOOL __stdcall Ctl3dColorChange()
{
  int v0; // esi

  EnterCriticalSection(&stru_43AB00);
  v0 = InternalCtl3dColorChange(0);
  LeaveCriticalSection(&stru_43AB00);
  return v0;
}


// ========== Function: _Ctl3dDlgFramePaintI@20 @ 0x418250 ==========
LRESULT __stdcall Ctl3dDlgFramePaintI(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, int a5)
{
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  HWND v6; // esi
  LRESULT result; // eax
  LONG WindowLongA; // eax
  BOOL v9; // ebp
  int v10; // ebx
  HDC WindowDC; // edi
  LRESULT v12; // [esp+10h] [ebp-3Ch]
  LPARAM v13; // [esp+14h] [ebp-38h] BYREF
  HGDIOBJ h; // [esp+18h] [ebp-34h]
  struct tagRECT Rect; // [esp+1Ch] [ebp-30h] BYREF
  struct tagRECT rc; // [esp+2Ch] [ebp-20h] BYREF
  int v17[4]; // [esp+3Ch] [ebp-10h] BYREF

  if ( a5 )
  {
    DefWndProc = 0;
    v6 = hWnd;
  }
  else
  {
    v6 = hWnd;
    DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 6);
  }
  if ( DefWndProc )
    result = CallWindowProcA(DefWndProc, v6, Msg, wParam, lParam);
  else
    result = DefWindowProcA(v6, Msg, wParam, lParam);
  v12 = result;
  if ( dword_43AB20 )
  {
    if ( IsIconic(v6) )
    {
      return v12;
    }
    else
    {
      v13 = 1;
      SendMessageA(v6, 0x11EFu, 0, (LPARAM)&v13);
      WindowLongA = GetWindowLongA(v6, -16);
      if ( v13 && (WindowLongA & 0x10400080) == 0x10400080 )
      {
        v9 = (WindowLongA & 0xC00000) == 12582912;
        v10 = dword_43B618 - v9;
        WindowDC = GetWindowDC(v6);
        GetWindowRect(v6, &Rect);
        Rect.right -= Rect.left;
        Rect.bottom -= Rect.top;
        Rect.top = 0;
        Rect.left = 0;
        DrawRec3d(WindowDC, &Rect.left, 2u, 7u, 15);
        InflateRect(&Rect, -1, -1);
        DrawRec3d(WindowDC, &Rect.left, 0, 2u, 15);
        InflateRect(&Rect, -1, -1);
        h = SelectObject(WindowDC, ::h);
        rc.left = Rect.left;
        rc.top = Rect.top;
        rc.bottom = Rect.bottom;
        rc.right = dword_43B614 + Rect.left;
        PatFill(WindowDC, &rc.left);
        OffsetRect(&rc, Rect.right - Rect.left - dword_43B614, 0);
        PatFill(WindowDC, &rc.left);
        rc.left = dword_43B614 + Rect.left;
        rc.right = Rect.right - dword_43B614;
        rc.bottom = v10 + rc.top;
        PatFill(WindowDC, &rc.left);
        if ( v9 )
        {
          v17[0] = rc.left;
          v17[2] = rc.right;
          v17[1] = rc.top + v10;
          v17[3] = rc.top + v10 + dword_43B61C;
          DrawRec3d(WindowDC, v17, 2u, 0, 15);
        }
        rc.top += Rect.bottom - Rect.top - dword_43B614;
        rc.bottom = dword_43B618 + rc.top;
        PatFill(WindowDC, &rc.left);
        SelectObject(WindowDC, h);
        ReleaseDC(v6, WindowDC);
      }
      return v12;
    }
  }
  return result;
}


// ========== Function: _Ctl3dWinIniChange@0 @ 0x418500 ==========
void __stdcall Ctl3dWinIniChange()
{
  CHAR ReturnedString[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( byte_43B625 )
  {
    EnterCriticalSection(&stru_43AB00);
    byte_43B624 = 30;
    GetProfileStringA(AppName, KeyName, Default, ReturnedString, 9u);
    if ( !lstrcmpiA(ReturnedString, aKanji) )
      byte_43B624 = 31;
    GetProfileStringA(AppName, aHangeulmenu, aEnglish, ReturnedString, 9u);
    if ( !lstrcmpiA(ReturnedString, aHangeul) )
      byte_43B624 = 31;
    LeaveCriticalSection(&stru_43AB00);
  }
}


// ========== Function: _FInit3dDialogs @ 0x4185A0 ==========
int FInit3dDialogs()
{
  HDC DC; // ebx
  int DeviceCaps; // edi
  int result; // eax
  ATOM v3; // ax
  ATOM v4; // ax
  LONG *v5; // ebx
  int (__stdcall **v6)(HWND, UINT, WPARAM, LPARAM); // esi
  const CHAR *v7; // [esp-8h] [ebp-3Ch]
  struct tagWNDCLASSA WndClass; // [esp+Ch] [ebp-28h] BYREF

  EnterCriticalSection(&stru_43AB00);
  DC = GetDC(0);
  DeviceCaps = GetDeviceCaps(DC, 12);
  dword_43AB20 = GetDeviceCaps(DC, 14) * DeviceCaps >= 4;
  if ( GetSystemMetrics(1) == 350 && GetSystemMetrics(0) == 640 )
    dword_43AB20 = 0;
  ReleaseDC(0, DC);
  if ( !dword_43AB20 )
    goto LABEL_7;
  LOWORD(nAtom) = GlobalAddAtomA(aC3d);
  if ( !(_WORD)nAtom )
    goto LABEL_6;
  LOWORD(lpString) = GlobalAddAtomA(aC3dnew);
  if ( !(_WORD)lpString )
    goto LABEL_6;
  LOWORD(word_43AB2C) = GlobalAddAtomA(aC3dl);
  v3 = GlobalAddAtomA(aC3dh);
  LOWORD(word_43AB2A) = v3;
  if ( (_WORD)word_43AB2C && v3 )
  {
    LOWORD(word_43AB32) = GlobalAddAtomA(aC3dlnew);
    v4 = GlobalAddAtomA(aC3dhnew);
    LOWORD(word_43AB30) = v4;
    if ( (_WORD)word_43AB32 && v4 )
    {
      LOWORD(word_43AB34) = GlobalAddAtomA(aC3dd);
      if ( (_WORD)word_43AB34 )
      {
        byte_43B625 = GetSystemMetrics(42);
        Ctl3dWinIniChange();
        if ( InternalCtl3dColorChange(1) )
        {
          v5 = &dword_43B580;
          v6 = &off_42CBDC;
          do
          {
            *v5 = (LONG)*v6;
            v5 += 6;
            v7 = (const CHAR *)(v6 - 5);
            v6 += 8;
            GetClassInfoA(0, v7, &WndClass);
            *(v5 - 5) = (LONG)WndClass.lpfnWndProc;
          }
          while ( v6 < (int (__stdcall **)(HWND, UINT, WPARAM, LPARAM))&dword_42CC9C );
          if ( GetClassInfoA(0, (LPCSTR)0x8002, &WndClass) )
            hData = WndClass.lpfnWndProc;
          else
            hData = DefDlgProcA;
          goto LABEL_7;
        }
      }
LABEL_6:
      dword_43AB20 = 0;
LABEL_7:
      LeaveCriticalSection(&stru_43AB00);
      return dword_43AB20;
    }
    result = 0;
    dword_43AB20 = 0;
  }
  else
  {
    result = 0;
    dword_43AB20 = 0;
  }
  return result;
}


// ========== Function: _End3dDialogs @ 0x418790 ==========
void End3dDialogs()
{
  LONG *v0; // eax

  EnterCriticalSection(&stru_43AB00);
  v0 = &dword_43B580;
  do
  {
    if ( *v0 )
      *v0 = 0;
    v0 += 6;
  }
  while ( v0 < (LONG *)&hData );
  DeleteObjects();
  if ( (_WORD)nAtom )
    GlobalDeleteAtom((ATOM)nAtom);
  if ( (_WORD)lpString )
    GlobalDeleteAtom((ATOM)lpString);
  if ( (_WORD)word_43AB2C )
    GlobalDeleteAtom((ATOM)word_43AB2C);
  if ( (_WORD)word_43AB2A )
    GlobalDeleteAtom((ATOM)word_43AB2A);
  if ( (_WORD)word_43AB32 )
    GlobalDeleteAtom((ATOM)word_43AB32);
  if ( (_WORD)word_43AB30 )
    GlobalDeleteAtom((ATOM)word_43AB30);
  if ( (_WORD)word_43AB34 )
    GlobalDeleteAtom((ATOM)word_43AB34);
  dword_43AB20 = 0;
  LeaveCriticalSection(&stru_43AB00);
}


// ========== Function: _InternalCtl3dColorChange @ 0x418870 ==========
int __cdecl InternalCtl3dColorChange(int a1)
{
  unsigned __int16 i; // si
  int v3; // edi
  unsigned __int16 v4; // si
  int v5; // eax
  unsigned __int16 v6; // ax
  int v7; // ecx
  unsigned __int16 j; // si
  int v9; // eax
  HGDIOBJ UIBitmap; // [esp+Ch] [ebp-30h] BYREF
  _DWORD v11[3]; // [esp+10h] [ebp-2Ch] BYREF
  COLORREF color[8]; // [esp+1Ch] [ebp-20h] BYREF

  if ( !dword_43AB20 )
    return 0;
  for ( i = 0; i < 8u; ++i )
  {
    v3 = i;
    color[v3] = GetSysColor(*((unsigned __int16 *)&nIndex + v3));
  }
  if ( word_43AB40 == 768 )
    color[0] = 0xFFFFFF;
  if ( !color[6] || color[1] == color[6] )
  {
    color[6] = 12632256;
    if ( color[1] != 8421504 )
      color[6] = 8421504;
  }
  if ( !a1 && !memcmp(&::color, color, 0x20u) )
    return 1;
  v4 = 0;
  UIBitmap = (HGDIOBJ)LoadUIBitmap(hModule, (LPCSTR)0x67C7, color[5], color[1], color[2], color[0], color[4], color[7]);
  do
  {
    v5 = v4++;
    v11[v5] = CreateSolidBrush(color[v5]);
  }
  while ( v4 < 3u );
  v6 = 0;
  while ( v11[v6] )
  {
    if ( ++v6 >= 3u )
    {
      if ( UIBitmap )
      {
        DeleteObjects();
        v7 = v11[2];
        dword_43AB64 = v11[0];
        *(&dword_43AB64 + 1) = v11[1];
        *(&dword_43AB64 + 2) = v7;
        qmemcpy(&::color, color, 0x20u);
        dword_43AB70 = UIBitmap;
        return 1;
      }
      break;
    }
  }
  for ( j = 0; j < 3u; ++j )
  {
    v9 = j;
    DeleteObjectNull((HGDIOBJ *)&v11[v9]);
  }
  DeleteObjectNull(&UIBitmap);
  return 0;
}


// ========== Function: _Ctl3dDlgProc@16 @ 0x418A00 ==========
unsigned int __stdcall Ctl3dDlgProc(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lParam)
{
  unsigned int result; // eax
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  WPARAM v6; // ebx
  LPARAM v7; // ebp
  LRESULT (__stdcall *v8)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT v9; // edi
  LRESULT (__stdcall *v10)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT (__stdcall *WindowLongA)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT (__stdcall *v12)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT (__stdcall *v13)(HWND, UINT, WPARAM, LPARAM); // eax
  LPARAM v14; // [esp+10h] [ebp-18h] BYREF
  WNDPROC lpPrevWndFunc; // [esp+14h] [ebp-14h]
  CHAR ClassName[16]; // [esp+18h] [ebp-10h] BYREF

  if ( Msg == 130 )
    return CleanupSubclass(hWnd, 0x82u, wParam, (LPARAM)lParam, 6);
  if ( GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34) )
    goto LABEL_4;
  if ( Msg <= 0x86 )
  {
    if ( Msg < 0x85 && Msg != 12 )
      goto LABEL_8;
    if ( (unsigned __int16)word_43AB40 >= 0x35Fu || IsIconic(hWnd) )
    {
LABEL_4:
      DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 6);
      return CallWindowProcA(DefWndProc, hWnd, Msg, wParam, (LPARAM)lParam);
    }
    return Ctl3dDlgFramePaintI(hWnd, Msg, wParam, (LPARAM)lParam, 0);
  }
  if ( Msg > 0x138 )
  {
    if ( Msg < 0x1943 || Msg > 0x1944 )
      goto LABEL_8;
    result = 1006;
    *lParam = 1;
    return result;
  }
  if ( Msg >= 0x132 )
  {
    GetClassNameA(hWnd, ClassName, 16);
    if ( lstrcmpA(a32770, ClassName) )
    {
      v7 = (LPARAM)lParam;
      v6 = wParam;
      v10 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 6);
      result = CallWindowProcA(v10, hWnd, Msg + 3263, wParam, (LPARAM)lParam);
      if ( result > 1 )
        goto LABEL_42;
    }
    else
    {
      WindowLongA = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))GetWindowLongA(hWnd, 4);
      if ( !WindowLongA )
      {
        v7 = (LPARAM)lParam;
        v6 = wParam;
        result = (unsigned int)Ctl3dCtlColorEx(Msg, wParam, (LPARAM)lParam);
        goto LABEL_42;
      }
      if ( (unsigned int)WindowLongA <= 0xFFFF0000 || (unsigned __int16)word_43AB40 > 0x30Au )
      {
        v7 = (LPARAM)lParam;
        v6 = wParam;
        result = CallWindowProcA(WindowLongA, hWnd, Msg, wParam, (LPARAM)lParam);
        if ( result > 1
          || (v13 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 6),
              result = CallWindowProcA(v13, hWnd, Msg + 3263, wParam, (LPARAM)lParam),
              result > 1) )
        {
LABEL_42:
          if ( !result )
            goto LABEL_9;
          return result;
        }
      }
      else
      {
        v7 = (LPARAM)lParam;
        v6 = wParam;
        v12 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 6);
        result = CallWindowProcA(v12, hWnd, Msg + 3263, wParam, (LPARAM)lParam);
        if ( result > 1 )
          goto LABEL_42;
      }
    }
    result = (unsigned int)Ctl3dCtlColorEx(Msg, v6, v7);
    goto LABEL_42;
  }
  if ( Msg != 272 )
  {
LABEL_8:
    v6 = wParam;
    v7 = (LPARAM)lParam;
LABEL_9:
    v8 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 6);
    return CallWindowProcA(v8, hWnd, Msg, v6, v7);
  }
  lpPrevWndFunc = (WNDPROC)LpfnGetDefWndProc(hWnd, 6);
  if ( (unsigned __int16)word_43AB40 < 0x35Fu || (v14 = 0, (GetWindowLongA(hWnd, -16) & 4) == 0) )
    v14 = 1;
  SendMessageA(hWnd, 0x11F0u, 0, (LPARAM)&v14);
  if ( v14 )
  {
    v9 = CallWindowProcA(lpPrevWndFunc, hWnd, 0x110u, wParam, (LPARAM)lParam);
    if ( (unsigned __int16)word_43AB40 < 0x35Fu || (GetWindowLongA(hWnd, -16) & 4) == 0 )
      Ctl3dCheckSubclassDlg(hWnd, 0xFFFF);
    return v9;
  }
  else
  {
    Ctl3dUnsubclassCtl(hWnd);
    return CallWindowProcA(lpPrevWndFunc, hWnd, 0x110u, wParam, (LPARAM)lParam);
  }
}


// ========== Function: _DoesChildNeedSubclass @ 0x418D30 ==========
BOOL __cdecl DoesChildNeedSubclass(HWND hWnd)
{
  if ( !LpfnGetDefWndProcNull(hWnd) )
    return 0;
  return (unsigned __int16)word_43AB40 < 0x35Fu || (GetWindowLongA(hWnd, -16) & 4) == 0;
}


// ========== Function: _Ctl3dHook@12 @ 0x418D70 ==========
LRESULT __stdcall Ctl3dHook(int code, HWND wParam, int *lParam)
{
  DWORD CurrentThreadId; // esi
  int v4; // ecx
  bool v5; // zf
  int *v6; // eax
  int v8; // edi
  int v9; // ebp
  HWND Parent; // eax
  LPARAM v11; // [esp+10h] [ebp-4h] BYREF

  CurrentThreadId = GetCurrentThreadId();
  EnterCriticalSection(&stru_43AB00);
  if ( dword_43AB74 == CurrentThreadId )
    goto LABEL_11;
  v4 = 0;
  v5 = dword_43AB7C == 0;
  if ( dword_43AB7C > 0 )
  {
    v6 = dword_43AB84;
    while ( *v6 != CurrentThreadId )
    {
      v6 += 5;
      if ( ++v4 >= dword_43AB7C )
        goto LABEL_8;
    }
    dword_43AB78 = v4;
    dword_43AB74 = CurrentThreadId;
LABEL_8:
    v5 = v4 == dword_43AB7C;
  }
  if ( !v5 )
  {
LABEL_11:
    v8 = dword_43AB78;
    LeaveCriticalSection(&stru_43AB00);
    if ( code == 3 )
    {
      v9 = *lParam;
      if ( *(_DWORD *)(*lParam + 40) == 32770 )
      {
        if ( word_43AB42 == 32 )
        {
          if ( (unsigned __int16)word_43AB40 < 0x35Fu || (v11 = 0, (GetWindowLongA(wParam, -16) & 4) == 0) )
            v11 = 1;
          SendMessageA(wParam, 0x11F0u, 0, (LPARAM)&v11);
          if ( v11 )
            SubclassWindow(wParam, (LONG)Ctl3dDlgProc);
        }
        else
        {
          HookSubclassWindow((int)wParam, (LONG)Ctl3dDlgProc);
        }
      }
      else if ( (dword_43AB90[5 * v8] & 1) != 0 )
      {
        if ( DoesChildNeedSubclass(*(HWND *)(v9 + 12))
          || *(_DWORD *)(v9 + 12)
          && word_43AB42 != 24
          && (Parent = GetParent(*(HWND *)(v9 + 12)), DoesChildNeedSubclass(Parent)) )
        {
          DoSubclassCtl(wParam, 0xFFFF, 1, *(_DWORD *)(v9 + 12));
        }
      }
    }
    return CallNextHookEx((HHOOK)dword_43AB88[5 * v8], code, (WPARAM)wParam, (LPARAM)lParam);
  }
  else
  {
    LeaveCriticalSection(&stru_43AB00);
    return CallNextHookEx(0, code, (WPARAM)wParam, (LPARAM)lParam);
  }
}


// ========== Function: _FBtn @ 0x418F20 ==========
BOOL __cdecl FBtn(int a1, __int16 a2)
{
  return (unsigned __int16)word_43AB40 < 0x35Fu && (a2 & 0xFFDFu) <= 9;
}


// ========== Function: sub_418F50 @ 0x418F50 ==========
// _FList
// doubtful name
BOOL __cdecl sub_418F50(int a1, int a2, int a3, int a4, HWND hWnd)
{
  CHAR ClassName[16]; // [esp+0h] [ebp-10h] BYREF

  if ( (unsigned __int16)word_43AB40 < 0x35Fu || !hWnd )
    return 1;
  GetClassNameA(hWnd, ClassName, 16);
  return lstrcmpA(ClassName, "ComboBox") != 0;
}


// ========== Function: _FComboList @ 0x418FA0 ==========
BOOL __cdecl FComboList(int a1, int a2, int a3, __int16 a4, HWND hWnd)
{
  int v6; // eax

  if ( (unsigned __int16)word_43AB40 >= 0x35Fu )
    return 0;
  if ( a4 != 1 )
    return 1;
  v6 = GetWindowLongA(hWnd, -16) & 3;
  return v6 != 2 && v6 != 3;
}


// ========== Function: _FCombo @ 0x418FE0 ==========
int __cdecl FCombo(HWND hWnd, char a2, int a3, __int16 a4)
{
  int v5; // eax
  HWND Window; // eax
  HWND v7; // eax
  HWND v8; // ebp
  HWND v9; // eax

  if ( (unsigned __int16)word_43AB40 >= 0x35Fu )
    return 0;
  v5 = a2 & 3;
  if ( v5 == 2 )
  {
    if ( a4 == 1 )
    {
      return 0;
    }
    else
    {
      Window = GetWindow(hWnd, 5u);
      if ( Window )
        DoSubclassCtl(Window, 4, a4, (int)hWnd);
      return 1;
    }
  }
  else if ( v5 == 3 )
  {
    return 1;
  }
  else if ( a4 == 1 )
  {
    return 1;
  }
  else
  {
    v7 = GetWindow(hWnd, 5u);
    v8 = v7;
    if ( v7 )
    {
      DoSubclassCtl(v7, 2, a4, (int)hWnd);
      v9 = GetWindow(v8, 2u);
      if ( v9 )
        DoSubclassCtl(v9, 4, a4, (int)hWnd);
      return 1;
    }
    else
    {
      return 0;
    }
  }
}


// ========== Function: _FStatic @ 0x4190B0 ==========
BOOL __cdecl FStatic(int a1, char a2, __int16 a3)
{
  int v3; // ecx

  v3 = a2 & 0x1F;
  return v3 != 3
      && ((a3 & 0x10) != 0 && ((a2 & 0x1Fu) <= 2 || v3 == 12)
       || (a3 & 0x20) != 0
       && ((a2 & 0x1Fu) >= 4 && (a2 & 0x1Fu) <= 9
        || (unsigned __int16)word_43AB40 < 0x35Fu && (a2 & 0x1Fu) >= 0x10 && (a2 & 0x1Fu) <= 0x12));
}


// ========== Function: _DoSubclassCtl @ 0x419100 ==========
int __cdecl DoSubclassCtl(HWND hWnd, unsigned __int16 a2, __int16 a3)
{
  int v4; // ebp
  const CHAR *v5; // ebx
  __int16 WindowLongA; // ax
  int v7; // edi
  bool v8; // cf
  CHAR ClassName[16]; // [esp+10h] [ebp-10h] BYREF

  if ( LpfnGetDefWndProcNull(hWnd) )
    return 0;
  v4 = 0;
  v5 = (const CHAR *)&unk_42CBE4;
  GetClassNameA(hWnd, ClassName, 16);
  while ( (a2 & *(_WORD *)v5) == 0 || lstrcmpA(v5 - 28, ClassName) )
  {
    v5 += 32;
    ++v4;
    if ( v5 >= (const CHAR *)&dword_42CCA4 )
      return 0;
  }
  WindowLongA = GetWindowLongA(hWnd, -16);
  v7 = (*(&off_42CBE0 + 8 * v4))((int)hWnd, WindowLongA);
  v8 = v7 == 0;
  if ( v7 == 1 )
  {
    if ( a3 == 1 && word_43AB42 == 16 )
    {
      HookSubclassWindow((int)hWnd, *(&dword_43B580 + 6 * v4));
      return 1;
    }
    SubclassWindow(hWnd, *(&dword_43B580 + 6 * v4));
    v8 = 0;
  }
  return 1 - v8;
}


// ========== Function: _Inval3dCtl @ 0x4191F0 ==========
LONG __cdecl Inval3dCtl(HWND hWnd, _DWORD *a2)
{
  LONG result; // eax
  LONG v3; // esi
  int v4; // ecx
  int v5; // eax
  HWND Parent; // edi
  struct tagRECT Rect; // [esp+Ch] [ebp-10h] BYREF

  GetWindowRect(hWnd, &Rect);
  result = GetWindowLongA(hWnd, -16);
  v3 = result;
  if ( (result & 0x10000000) != 0 )
  {
    result = (LONG)a2;
    if ( a2 )
    {
      v4 = a2[6];
      if ( (v4 & 0xC0) == 0 && (v4 & 2) != 0 && (v4 & 1) != 0 )
        return result;
      if ( (v4 & 3) == 2 && Rect.right - a2[4] == Rect.left )
      {
        v5 = a2[5];
        if ( Rect.bottom - Rect.top >= v5 )
          Rect.top += v5 + 1;
      }
    }
    InflateRect(&Rect, 1, 1);
    Parent = GetParent(hWnd);
    ScreenToClient(Parent, (LPPOINT)&Rect);
    ScreenToClient(Parent, (LPPOINT)&Rect.right);
    if ( (v3 & 0x200000) != 0 )
      ++Rect.right;
    return InvalidateRect(Parent, &Rect, 0);
  }
  return result;
}


// ========== Function: _Val3dCtl @ 0x4192B0 ==========
BOOL __cdecl Val3dCtl(HWND hWnd)
{
  LONG WindowLongA; // esi
  HWND Parent; // edi
  struct tagRECT Rect; // [esp+Ch] [ebp-10h] BYREF

  WindowLongA = GetWindowLongA(hWnd, -16);
  GetWindowRect(hWnd, &Rect);
  InflateRect(&Rect, 1, 1);
  Parent = GetParent(hWnd);
  ScreenToClient(Parent, (LPPOINT)&Rect);
  ScreenToClient(Parent, (LPPOINT)&Rect.right);
  if ( (WindowLongA & 0x200000) != 0 )
    ++Rect.right;
  return ValidateRect(Parent, &Rect);
}


// ========== Function: _DrawPushButton @ 0x419320 ==========
HWND __cdecl DrawPushButton(HWND hWnd, HDC hdc, RECT *lprcSrc2, CHAR *lpchText, int cchText, __int16 a6, int a7)
{
  LONG top; // edx
  LONG right; // ebx
  LONG bottom; // eax
  int v10; // ebx
  HGDIOBJ v11; // eax
  int v12; // ebp
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  HWND result; // eax
  HGDIOBJ h; // [esp+10h] [ebp-1Ch]
  int v19; // [esp+14h] [ebp-18h] BYREF
  int v20; // [esp+18h] [ebp-14h] BYREF
  struct tagRECT rc; // [esp+1Ch] [ebp-10h] BYREF

  top = lprcSrc2->top;
  right = lprcSrc2->right;
  rc.left = lprcSrc2->left;
  bottom = lprcSrc2->bottom;
  rc.top = top;
  rc.right = right;
  rc.bottom = bottom;
  DrawRec3d(hdc, &lprcSrc2->left, 7u, 7u, 15);
  InflateRect(&rc, -1, -1);
  if ( a6 == 1 && IsWindowEnabled(hWnd) )
  {
    DrawRec3d(hdc, &rc.left, 7u, 7u, 15);
    InflateRect(&rc, -1, -1);
  }
  PatBlt(hdc, lprcSrc2->left, lprcSrc2->top, 1, 1, 0xF00021u);
  PatBlt(hdc, lprcSrc2->right - 1, lprcSrc2->top, 1, 1, 0xF00021u);
  PatBlt(hdc, lprcSrc2->left, lprcSrc2->bottom - 1, 1, 1, 0xF00021u);
  PatBlt(hdc, lprcSrc2->right - 1, lprcSrc2->bottom - 1, 1, 1, 0xF00021u);
  v10 = (a7 == 0) + 1;
  if ( a7 )
    v11 = dword_43AB6C;
  else
    v11 = (HGDIOBJ)dword_43AB64;
  h = SelectObject(hdc, v11);
  PatBlt(hdc, rc.left, rc.top, v10, rc.bottom - rc.top, 0xF00021u);
  PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, v10, 0xF00021u);
  if ( !a7 )
  {
    v12 = 0;
    SelectObject(hdc, dword_43AB6C);
    --rc.bottom;
    --rc.right;
    if ( v10 > 0 )
    {
      do
      {
        PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left + 1, 1, 0xF00021u);
        PatBlt(hdc, rc.right, rc.top, 1, rc.bottom - rc.top, 0xF00021u);
        if ( (a7 == 0) > v12 )
          InflateRect(&rc, -1, -1);
        ++v12;
      }
      while ( v10 > v12 );
    }
  }
  ++rc.left;
  ++rc.top;
  SelectObject(hdc, ::h);
  PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, 0xF00021u);
  if ( !IsWindowEnabled(hWnd) )
    SetTextColor(hdc, dword_43AB5C);
  MyGetTextExtent(hdc, lpchText, &v19, &v20);
  rc.top += (rc.bottom - rc.top - v20) / 2;
  rc.left += (rc.right - rc.left - v19) / 2;
  v13 = v20 + rc.top;
  if ( v20 + rc.top >= rc.bottom )
    v13 = rc.bottom;
  rc.bottom = v13;
  v14 = v19 + rc.left;
  if ( v19 + rc.left >= rc.right )
    v14 = rc.right;
  rc.right = v14;
  if ( a7 )
  {
    OffsetRect(&rc, 1, 1);
    v15 = lprcSrc2->right - 3;
    if ( v15 >= rc.right )
      v15 = rc.right;
    rc.right = v15;
    v16 = lprcSrc2->bottom - 3;
    if ( v16 >= rc.bottom )
      v16 = rc.bottom;
    rc.bottom = v16;
  }
  DrawTextA(hdc, lpchText, cchText, &rc, 0x20u);
  result = GetFocus();
  if ( result == hWnd )
  {
    InflateRect(&rc, 1, 1);
    IntersectRect(&rc, &rc, lprcSrc2);
    result = (HWND)DrawFocusRect(hdc, &rc);
  }
  if ( h )
    return (HWND)SelectObject(hdc, h);
  return result;
}


// ========== Function: _BtnPaint @ 0x419660 ==========
HGDIOBJ __cdecl BtnPaint(HWND hWnd, HDC hdc, char a3)
{
  char WindowLongA; // al
  unsigned int v4; // ebx
  void *v5; // eax
  COLORREF SysColor; // eax
  COLORREF v7; // eax
  void *v8; // eax
  char v9; // al
  BOOL v10; // ecx
  HDC CompatibleDC; // edi
  HGDIOBJ v12; // ebx
  HGDIOBJ result; // eax
  int v14; // eax
  HGDIOBJ v15; // [esp+10h] [ebp-154h]
  int x1; // [esp+14h] [ebp-150h]
  int y1; // [esp+18h] [ebp-14Ch]
  HWND Parent; // [esp+1Ch] [ebp-148h]
  int v19; // [esp+20h] [ebp-144h] BYREF
  int cchText; // [esp+24h] [ebp-140h]
  BOOL v21; // [esp+28h] [ebp-13Ch]
  HGDIOBJ h; // [esp+2Ch] [ebp-138h]
  int v23; // [esp+30h] [ebp-134h] BYREF
  struct tagRECT left; // [esp+34h] [ebp-130h] BYREF
  struct tagRECT Rect; // [esp+44h] [ebp-120h] BYREF
  RECT Point; // [esp+54h] [ebp-110h] BYREF
  CHAR String[256]; // [esp+64h] [ebp-100h] BYREF

  WindowLongA = GetWindowLongA(hWnd, -16);
  v4 = WindowLongA & 0x1F;
  v19 = WindowLongA & 0x20;
  Parent = GetParent(hWnd);
  SetBkMode(hdc, 2);
  GetClientRect(hWnd, &Rect);
  left = Rect;
  v5 = (void *)SendMessageA(hWnd, 0x31u, 0, 0);
  v15 = v5;
  if ( v5 )
    v15 = SelectObject(hdc, v5);
  SysColor = GetSysColor(15);
  SetBkColor(hdc, SysColor);
  v7 = GetSysColor(18);
  SetTextColor(hdc, v7);
  v8 = (void *)SendMessageA(Parent, 0x135u, (WPARAM)hdc, (LPARAM)hWnd);
  h = SelectObject(hdc, v8);
  IntersectClipRect(hdc, left.left, left.top, left.right, left.bottom);
  if ( (a3 & 0x10) != 0 && v4 != 7 )
    PatBlt(hdc, left.left, left.top, left.right - left.left, left.bottom - left.top, 0xF00021u);
  v21 = IsWindowEnabled(hWnd);
  v9 = SendMessageA(hWnd, 0xF2u, 0, 0);
  y1 = 0;
  v23 = v9 & 3;
  v10 = v23 != 0;
  Point.left = v9 & 4;
  x1 = 14 * (v10 | (Point.left >> 1));
  if ( !v21 )
    x1 += 14 * (v10 + 2);
  if ( (a3 & 0xA) != 0 || v4 <= 1 )
    cchText = GetWindowTextA(hWnd, String, 256);
  switch ( v4 )
  {
    case 0u:
    case 1u:
      DrawPushButton(hWnd, hdc, &Rect, String, cchText, v4, Point.left);
      goto LABEL_44;
    case 2u:
    case 3u:
      goto $DrawBtn$19917;
    case 4u:
    case 9u:
      y1 = 13;
      goto $DrawBtn$19917;
    case 5u:
    case 6u:
      if ( v23 == 2 )
        y1 = 26;
$DrawBtn$19917:
      if ( (a3 & 4) != 0 )
      {
        CompatibleDC = CreateCompatibleDC(hdc);
        if ( CompatibleDC )
        {
          v12 = SelectObject(CompatibleDC, dword_43AB70);
          if ( v12 )
          {
            if ( v19 )
              BitBlt(
                hdc,
                left.right - 14,
                (left.bottom - left.top - 13) / 2 + left.top,
                14,
                13,
                CompatibleDC,
                x1,
                y1,
                0xCC0020u);
            else
              BitBlt(
                hdc,
                left.left,
                (left.bottom - left.top - 13) / 2 + left.top,
                14,
                13,
                CompatibleDC,
                x1,
                y1,
                0xCC0020u);
            SelectObject(CompatibleDC, v12);
          }
          DeleteDC(CompatibleDC);
        }
      }
      if ( (a3 & 2) != 0 )
      {
        if ( v19 )
          left.right = Rect.right - 18;
        else
          left.left = Rect.left + 18;
        if ( !v21 )
          SetTextColor(hdc, dword_43AB5C);
        DrawTextA(hdc, String, cchText, &left, 0x24u);
      }
      if ( (a3 & 8) != 0 )
      {
        MyGetTextExtent(hdc, String, &Point.left, &v23);
        left.top = (left.bottom - left.top - v23) / 2;
        left.bottom = left.top + v23;
        v14 = Rect.left;
        if ( v19 )
          Rect.right -= 18;
        else
          v14 = Rect.left + 18;
        left.left = v14;
        left.right = v14 + Point.left;
        InflateRect(&left, 1, 1);
        IntersectRect(&left, &left, &Rect);
        DrawFocusRect(hdc, &left);
      }
      goto LABEL_44;
    case 7u:
      if ( (a3 & 6) == 0 )
        goto LABEL_44;
      MyGetTextExtent(hdc, String, &v23, &v19);
      if ( !v19 )
        MyGetTextExtent(hdc, asc_437280, &Point.left, &v19);
      left.left += 4;
      left.right = left.left + v23 + 4;
      left.bottom = left.top + v19;
      if ( (a3 & 0x20) != 0 )
      {
        Point.left = left.left;
        Point.top = left.top;
        Point.bottom = left.bottom;
        Point.right = Rect.right;
        ClientToScreen(hWnd, (LPPOINT)&Point);
        ClientToScreen(hWnd, (LPPOINT)&Point.right);
        ScreenToClient(Parent, (LPPOINT)&Point);
        ScreenToClient(Parent, (LPPOINT)&Point.right);
        return (HGDIOBJ)InvalidateRect(Parent, &Point, 1);
      }
      else
      {
        --Rect.right;
        --Rect.bottom;
        Rect.top += v19 / 2;
        DrawRec3d(hdc, &Rect.left, 2u, 2u, 15);
        OffsetRect(&Rect, 1, 1);
        DrawRec3d(hdc, &Rect.left, 0, 0, 15);
        if ( !v21 )
          SetTextColor(hdc, dword_43AB5C);
        DrawTextA(hdc, String, cchText, &left, 0x20u);
LABEL_44:
        result = SelectObject(hdc, h);
        if ( v15 )
          return SelectObject(hdc, v15);
      }
      return result;
    default:
      goto LABEL_44;
  }
}


// ========== Function: _BtnWndProc3d@16 @ 0x419BB0 ==========
int __stdcall BtnWndProc3d(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lParam)
{
  int result; // eax
  LRESULT (__stdcall *v5)(HWND, UINT, WPARAM, LPARAM); // eax
  char v6; // bp
  LONG v7; // eax
  char v8; // di
  HDC v9; // ebp
  LONG WindowLongA; // eax
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  LONG v12; // eax
  LRESULT v13; // eax
  char v14; // bl
  HDC DC; // eax
  HDC v16; // edi
  char v17; // bl
  LRESULT v18; // [esp+10h] [ebp-48h]
  LRESULT v19; // [esp+14h] [ebp-44h]
  tagPAINTSTRUCT Paint; // [esp+18h] [ebp-40h] BYREF

  if ( Msg == 130 )
    return CleanupSubclass(hWnd, 0x82u, wParam, (LPARAM)lParam, 0);
  if ( GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34) )
    goto LABEL_4;
  if ( Msg > 0xF1 )
  {
    if ( Msg != 243 )
    {
      if ( Msg >= 0x1943 && Msg <= 0x1944 )
      {
        *lParam = 1;
        return 1000;
      }
      goto LABEL_4;
    }
LABEL_28:
    v6 = 4;
LABEL_29:
    v18 = SendMessageA(hWnd, 0xF2u, 0, 0);
    WindowLongA = GetWindowLongA(hWnd, -16);
    if ( (WindowLongA & 0x10000000) != 0 )
    {
      if ( Msg != 7 )
        SetWindowLongA(hWnd, -16, WindowLongA & 0xEFFFFFFF);
      DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 0);
      v19 = CallWindowProcA(DefWndProc, hWnd, Msg, wParam, (LPARAM)lParam);
      if ( Msg != 7 )
      {
        v12 = GetWindowLongA(hWnd, -16);
        SetWindowLongA(hWnd, -16, v12 | 0x10000000);
      }
      v13 = SendMessageA(hWnd, 0xF2u, 0, 0);
      v14 = v13;
      if ( Msg != 243 && Msg != 241 || v13 != v18 )
      {
        DC = GetDC(hWnd);
        v16 = DC;
        if ( DC )
        {
          v17 = v18 ^ v14;
          if ( (v17 & 3) != 0 )
            v6 |= 4u;
          ExcludeUpdateRgn(DC, hWnd);
          BtnPaint(hWnd, v16, v6 | v17 & 8);
          ReleaseDC(hWnd, v16);
        }
      }
      return v19;
    }
LABEL_4:
    v5 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 0);
    return CallWindowProcA(v5, hWnd, Msg, wParam, (LPARAM)lParam);
  }
  if ( Msg == 241 )
    goto LABEL_28;
  switch ( Msg )
  {
    case 7u:
      v6 = 22;
      goto LABEL_29;
    case 8u:
      if ( (GetWindowLongA(hWnd, -16) & 0x1F) == 9 )
        SendMessageA(hWnd, 0xF3u, 0, 0);
      v6 = 0;
      goto LABEL_29;
    case 0xAu:
      v6 = 6;
      goto LABEL_29;
    case 0xCu:
      v7 = GetWindowLongA(hWnd, -16);
      if ( (v7 & 0x10000000) != 0 && (v7 & 0x1F) == 7 )
        v6 = 34;
      else
        v6 = 22;
      goto LABEL_29;
    case 0xFu:
      v8 = SendMessageA(hWnd, 0xF2u, 0, 0);
      v9 = (HDC)wParam;
      if ( !wParam )
        v9 = BeginPaint(hWnd, &Paint);
      if ( (GetWindowLongA(hWnd, -16) & 0x10000000) != 0 )
        BtnPaint(hWnd, v9, v8 & 8 | 6);
      if ( !wParam )
        EndPaint(hWnd, &Paint);
      result = 0;
      break;
    default:
      goto LABEL_4;
  }
  return result;
}


// ========== Function: _ListEditPaint3d @ 0x419E90 ==========
LONG __cdecl ListEditPaint3d(HWND hWnd, int a2, int a3)
{
  LONG result; // eax
  HWND Parent; // edi
  __int16 v5; // bp
  HDC DC; // ebx
  int v7; // eax
  HWND Window; // eax
  LONG right; // ebp
  LONG v10; // ebp
  LONG v11; // ebp
  LONG v12; // [esp+10h] [ebp-44h]
  HWND hWndTo; // [esp+14h] [ebp-40h]
  LPARAM lParam; // [esp+18h] [ebp-3Ch] BYREF
  int v15; // [esp+1Ch] [ebp-38h]
  int v16; // [esp+20h] [ebp-34h]
  struct tagRECT Rect; // [esp+24h] [ebp-30h] BYREF
  struct tagRECT v18; // [esp+34h] [ebp-20h] BYREF
  CHAR ClassName[16]; // [esp+44h] [ebp-10h] BYREF

  result = GetWindowLongA(hWnd, -16);
  v12 = result;
  if ( (result & 0x10000000) != 0 && (a3 != 3 || (result & 3) != 3 || (result = SendMessageA(hWnd, 0x157u, 0, 0)) == 0) )
  {
    if ( a2 )
      HideCaret(hWnd);
    GetWindowRect(hWnd, &Rect);
    Parent = GetParent(hWnd);
    ScreenToClient(Parent, (LPPOINT)&Rect);
    v5 = 15;
    ScreenToClient(Parent, (LPPOINT)&Rect.right);
    DC = GetDC(Parent);
    v15 = v12 & 0x100000;
    if ( (v12 & 0x100000) != 0 )
      v5 = 7;
    v16 = v12 & 0x200000;
    if ( (v12 & 0x200000) != 0 )
      v5 &= ~4u;
    if ( a2 - GetWindowLongA(hWnd, -12) == -1000 )
    {
      lParam = 666;
      v18.left = SendMessageA(Parent, 0x1944u, 0, (LPARAM)&lParam);
      if ( lParam == 666 )
        v18.left = SendMessageA(Parent, 0x1943u, 0, (LPARAM)&lParam);
      GetClassNameA(Parent, ClassName, 16);
      if ( !lstrcmpA(ClassName, "ComboBox") || lParam == 1 && v18.left == 1003 )
      {
        hWndTo = GetParent(Parent);
        MapWindowPoints(Parent, hWndTo, (LPPOINT)&Rect, 2u);
        ReleaseDC(Parent, DC);
        DC = GetDC(hWndTo);
        if ( a2 )
        {
          v7 = GetWindowLongA(Parent, -16) & 3;
          if ( v7 == 2 || v7 == 3 )
          {
            if ( SendMessageA(Parent, 0x157u, 0, 0) )
            {
              ReleaseDC(hWndTo, DC);
              return ShowCaret(hWnd);
            }
          }
          else
          {
            v5 &= ~8u;
            Window = GetWindow(Parent, 5u);
            GetWindowRect(Window, &v18);
            Rect.right += v18.left - v18.right;
            DrawInsetRect3d(DC, &Rect.left, 4104);
            Rect.right += v18.right - v18.left;
          }
        }
        else
        {
          v5 &= ~2u;
          ++Rect.top;
        }
        Parent = hWndTo;
      }
    }
    DrawInsetRect3d(DC, &Rect.left, v5);
    if ( a3 == 3 && (v12 & 3) == 3 )
    {
      right = Rect.right;
      Rect.left = right - GetSystemMetrics(2);
      DrawRec3d(DC, &Rect.left, 7u, 7u, 12);
      Val3dCtl(hWnd);
    }
    else
    {
      if ( v16 )
      {
        ++Rect.right;
        DrawRec3d(DC, &Rect.left, 0, 0, 4);
        v10 = --Rect.right;
        *(_DWORD *)ClassName = Rect.left;
        Rect.left = v10 - GetSystemMetrics(2);
        DrawRec3d(DC, &Rect.left, 7u, 7u, 8);
        Rect.left = *(_DWORD *)ClassName;
      }
      if ( v15 )
      {
        ++Rect.bottom;
        DrawRec3d(DC, &Rect.left, 0, 0, 8);
        v11 = --Rect.bottom;
        Rect.top = v11 - GetSystemMetrics(21);
        DrawRec3d(DC, &Rect.left, 7u, 7u, 4);
      }
    }
    result = ReleaseDC(Parent, DC);
    if ( a2 )
      return ShowCaret(hWnd);
  }
  return result;
}


// ========== Function: _ShareEditComboWndProc3d @ 0x41A1D0 ==========
int __cdecl ShareEditComboWndProc3d(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lParam, int a5)
{
  int result; // eax
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // eax
  char WindowLongA; // al
  int v9; // eax
  LRESULT v10; // [esp+10h] [ebp-4h]

  if ( Msg == 130 )
    return CleanupSubclass(hWnd, 0x82u, wParam, (LPARAM)lParam, a5);
  if ( GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34) )
  {
    DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, a5);
    return CallWindowProcA(DefWndProc, hWnd, Msg, wParam, (LPARAM)lParam);
  }
  v7 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, a5);
  v10 = CallWindowProcA(v7, hWnd, Msg, wParam, (LPARAM)lParam);
  if ( a5 == 3 )
  {
    WindowLongA = GetWindowLongA(hWnd, -16);
    if ( (WindowLongA & 3) == 2 )
      return v10;
  }
  else
  {
    WindowLongA = v10;
  }
  if ( Msg <= 0x18 )
  {
    if ( Msg == 24 )
    {
      if ( (unsigned __int16)word_43AB40 < 0x30Au && !wParam )
        Inval3dCtl(hWnd, 0);
    }
    else if ( Msg == 15 )
    {
      if ( a5 != 3 || (v9 = WindowLongA & 3, v9 == 2) || v9 == 3 )
        ListEditPaint3d(hWnd, 1, a5);
    }
    return v10;
  }
  if ( Msg == 70 )
  {
    if ( (unsigned __int16)word_43AB40 >= 0x30Au )
      Inval3dCtl(hWnd, lParam);
    return v10;
  }
  if ( Msg < 0x1943 || Msg > 0x1944 )
    return v10;
  result = 1002;
  *lParam = 1;
  return result;
}


// ========== Function: _EditWndProc3d@16 @ 0x41A320 ==========
int __stdcall EditWndProc3d(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lParam)
{
  return ShareEditComboWndProc3d(hWnd, Msg, wParam, lParam, 2);
}


// ========== Function: _SharedListWndProc @ 0x41A350 ==========
LRESULT __cdecl SharedListWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LONG *lParam, int a5)
{
  LRESULT (__stdcall *v6)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT v8; // esi
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  LRESULT v10; // esi
  LONG v11; // ebx
  LONG v12; // eax
  LONG v13; // edx
  HWND Parent; // edi
  struct tagRECT rc; // [esp+Ch] [ebp-20h] BYREF
  struct tagRECT Rect; // [esp+1Ch] [ebp-10h] BYREF

  if ( Msg == 130 )
    return CleanupSubclass(hWnd, 0x82u, wParam, (LPARAM)lParam, a5);
  if ( GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34) )
    goto LABEL_4;
  if ( Msg > 0x18 )
  {
    if ( Msg > 0x83 )
    {
      if ( Msg < 0x1943 || Msg > 0x1944 )
        goto LABEL_4;
      *lParam = 1;
      return 1001;
    }
    else
    {
      if ( Msg != 131 )
      {
        if ( Msg == 70 && (unsigned __int16)word_43AB40 >= 0x30Au )
          Inval3dCtl(hWnd, lParam);
        goto LABEL_4;
      }
      if ( (unsigned __int16)word_43AB40 >= 0x30Au )
        goto LABEL_4;
      GetWindowRect(hWnd, &Rect);
      DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, a5);
      v10 = CallWindowProcA(DefWndProc, hWnd, 0x83u, wParam, (LPARAM)lParam);
      v11 = lParam[1];
      rc.left = *lParam;
      v12 = lParam[2];
      rc.top = v11;
      v13 = lParam[3];
      rc.right = v12;
      rc.bottom = v13;
      InflateRect(&rc, 2, 1);
      if ( rc.bottom < Rect.bottom )
      {
        rc.top = rc.bottom + 1;
        rc.bottom = Rect.bottom + 1;
        Parent = GetParent(hWnd);
        ScreenToClient(Parent, (LPPOINT)&rc);
        ScreenToClient(Parent, (LPPOINT)&rc.right);
        InvalidateRect(Parent, &rc, 1);
      }
      return v10;
    }
  }
  else
  {
    if ( Msg == 24 )
    {
      if ( (unsigned __int16)word_43AB40 < 0x30Au && !wParam )
        Inval3dCtl(hWnd, 0);
      goto LABEL_4;
    }
    if ( Msg != 15 )
    {
LABEL_4:
      v6 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, a5);
      return CallWindowProcA(v6, hWnd, Msg, wParam, (LPARAM)lParam);
    }
    v7 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, a5);
    v8 = CallWindowProcA(v7, hWnd, 0xFu, wParam, (LPARAM)lParam);
    ListEditPaint3d(hWnd, 0, a5);
    return v8;
  }
}


// ========== Function: _ListWndProc3d@16 @ 0x41A580 ==========
LRESULT __stdcall ListWndProc3d(HWND hWnd, UINT Msg, WPARAM wParam, LONG *lParam)
{
  return SharedListWndProc(hWnd, Msg, wParam, lParam, 1);
}


// ========== Function: _ComboWndProc3d@16 @ 0x41A5B0 ==========
int __stdcall ComboWndProc3d(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lParam)
{
  if ( Msg < 0x1943 || Msg > 0x1944 )
    return ShareEditComboWndProc3d(hWnd, Msg, wParam, lParam, 3);
  *lParam = 1;
  return 1003;
}


// ========== Function: _StaticPrint @ 0x41A600 ==========
COLORREF __cdecl StaticPrint(HWND hWnd, HDC hdc, LPRECT lprc, int a4)
{
  int WindowTextLengthA; // ebx
  COLORREF result; // eax
  void *v6; // esp
  unsigned __int16 v7; // bx
  _BYTE v8[12]; // [esp+0h] [ebp-14h] BYREF
  COLORREF color; // [esp+Ch] [ebp-8h]
  LPSTR lpString; // [esp+10h] [ebp-4h]

  PatBlt(hdc, lprc->left, lprc->top, lprc->right - lprc->left, lprc->bottom - lprc->top, 0xF00021u);
  WindowTextLengthA = GetWindowTextLengthA(hWnd);
  result = (WindowTextLengthA + 8) & 0xFFFFFFFC;
  v6 = alloca(WindowTextLengthA + 5);
  lpString = v8;
  if ( v8 )
  {
    result = GetWindowTextA(hWnd, lpString, WindowTextLengthA + 2);
    if ( result )
    {
      v7 = 320;
      if ( (a4 & 0xF) != 0xC )
        v7 = a4 & 0xF | 0x150;
      if ( (a4 & 0x80) != 0 )
        HIBYTE(v7) |= 8u;
      if ( (a4 & 0x8000000) != 0 )
        color = SetTextColor(hdc, dword_43AB5C);
      result = DrawTextA(hdc, lpString, -1, lprc, v7);
      if ( (a4 & 0x8000000) != 0 )
        return SetTextColor(hdc, color);
    }
  }
  return result;
}


// ========== Function: _StaticPaint @ 0x41A6E0 ==========
int __cdecl StaticPaint(HWND hWnd, HDC hdc)
{
  int result; // eax
  void *v3; // eax
  HGDIOBJ v4; // ebx
  HWND Parent; // eax
  void *v6; // eax
  HGDIOBJ v7; // ebp
  int v8; // [esp+10h] [ebp-14h]
  struct tagRECT Rect; // [esp+14h] [ebp-10h] BYREF

  result = GetWindowLongA(hWnd, -16);
  v8 = result;
  if ( (result & 0x10000000) != 0 )
  {
    GetClientRect(hWnd, &Rect);
    result = v8 & 0x1F;
    switch ( v8 & 0x1F )
    {
      case 0:
      case 1:
      case 2:
      case 0xC:
        v3 = (void *)SendMessageA(hWnd, 0x31u, 0, 0);
        v4 = v3;
        if ( v3 )
          v4 = SelectObject(hdc, v3);
        SetBkMode(hdc, 2);
        Parent = GetParent(hWnd);
        v6 = (void *)SendMessageA(Parent, 0x138u, (WPARAM)hdc, (LPARAM)hWnd);
        v7 = v6;
        if ( v6 )
          v7 = SelectObject(hdc, v6);
        result = StaticPrint(hWnd, hdc, &Rect, v8);
        if ( v4 )
          result = (int)SelectObject(hdc, v4);
        if ( v7 )
          result = (int)SelectObject(hdc, v7);
        break;
      case 4:
      case 7:
        result = DrawRec3d(hdc, &Rect.left, 2u, 0, 15);
        break;
      case 5:
      case 8:
      case 0x10:
      case 0x11:
      case 0x12:
        ++Rect.left;
        ++Rect.top;
        DrawRec3d(hdc, &Rect.left, 0, 0, 15);
        OffsetRect(&Rect, -1, -1);
        result = DrawRec3d(hdc, &Rect.left, 2u, 2u, 15);
        break;
      case 6:
      case 9:
        result = DrawRec3d(hdc, &Rect.left, 0, 2u, 15);
        break;
      default:
        return result;
    }
  }
  return result;
}


// ========== Function: _StaticWndProc3d@16 @ 0x41A880 ==========
LRESULT __stdcall StaticWndProc3d(HWND hWnd, UINT Msg, WPARAM wParam, _DWORD *lParam)
{
  LRESULT (__stdcall *DefWndProc)(HWND, UINT, WPARAM, LPARAM); // eax
  HDC DC; // edi
  HDC v7; // edi
  struct tagPAINTSTRUCT Paint; // [esp+Ch] [ebp-40h] BYREF

  if ( Msg == 130 )
    return CleanupSubclass(hWnd, 0x82u, wParam, (LPARAM)lParam, 4);
  if ( GetPropA(hWnd, (LPCSTR)(unsigned __int16)word_43AB34) )
    goto LABEL_4;
  if ( Msg > 0xF )
  {
    if ( Msg < 0x1943 || Msg > 0x1944 )
      goto LABEL_4;
    *lParam = 1;
    return 1004;
  }
  else if ( Msg == 15 )
  {
    v7 = (HDC)wParam;
    if ( !wParam )
    {
      v7 = BeginPaint(hWnd, &Paint);
      ClipCtlDc(hWnd, v7);
    }
    StaticPaint(hWnd, v7);
    if ( !wParam )
      EndPaint(hWnd, &Paint);
    return 0;
  }
  else
  {
    if ( Msg != 10 )
    {
LABEL_4:
      DefWndProc = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))LpfnGetDefWndProc(hWnd, 4);
      return CallWindowProcA(DefWndProc, hWnd, Msg, wParam, (LPARAM)lParam);
    }
    DC = GetDC(hWnd);
    ClipCtlDc(hWnd, DC);
    StaticPaint(hWnd, DC);
    ReleaseDC(hWnd, DC);
    return 0;
  }
}


// ========== Function: _LibMain @ 0x41A9D0 ==========
int __cdecl LibMain(HMODULE a1, int a2)
{
  HMODULE ModuleHandleA; // eax
  signed int Version; // eax
  unsigned __int16 v4; // cx
  BOOL (__stdcall *DisableThreadLibraryCalls)(HMODULE); // [esp+4h] [ebp-4h]

  if ( a2 == 1 )
  {
    ModuleHandleA = GetModuleHandleA(aKernel32Dll_0);
    DisableThreadLibraryCalls = (BOOL (__stdcall *)(HMODULE))GetProcAddress(ModuleHandleA, aDisablethreadl);
    if ( DisableThreadLibraryCalls )
      DisableThreadLibraryCalls(a1);
    EnterCriticalSection(&stru_43AB00);
    hmod = a1;
    hModule = a1;
    Version = GetVersion();
    v4 = _byteswap_ushort(Version);
    word_43AB40 = v4;
    if ( Version >= 0 || (word_43AB42 = 16, v4 >= 0x35Fu) )
      word_43AB42 = 32;
    dword_43B614 = GetSystemMetrics(7) - 1;
    dword_43B618 = GetSystemMetrics(8) - 1;
    dword_43B61C = GetSystemMetrics(4);
    dword_43B620 = GetSystemMetrics(30);
    LeaveCriticalSection(&stru_43AB00);
  }
  return 1;
}


// ========== Function: _LoadUIBitmap@32 @ 0x41AAA0 ==========
HBITMAP __stdcall LoadUIBitmap(HMODULE hModule, LPCSTR lpName, int a3, int a4, int a5, int a6, int a7, int a8)
{
  HRSRC ResourceA; // eax
  HRSRC v9; // edi
  SIZE_T v11; // ebx
  HGLOBAL Resource; // esi
  BITMAPINFO *v13; // ebp
  HDC DC; // edi
  HBITMAP DIBitmap; // esi

  ResourceA = FindResourceA(hModule, lpName, (LPCSTR)2);
  v9 = ResourceA;
  if ( !ResourceA )
    return 0;
  v11 = SizeofResource(hModule, ResourceA);
  Resource = LoadResource(hModule, v9);
  if ( !Resource )
    return 0;
  v13 = (BITMAPINFO *)GlobalAlloc(0x40u, v11);
  if ( !v13 )
    return 0;
  qmemcpy(v13, Resource, v11);
  v13->bmiColors[0] = (RGBQUAD)(((unsigned __int8)a3 << 16) | BYTE2(a3) | (BYTE1(a3) << 8));
  v13[1].bmiHeader.biXPelsPerMeter = ((unsigned __int8)a5 << 16) | BYTE2(a5) | (BYTE1(a5) << 8);
  v13[1].bmiHeader.biYPelsPerMeter = ((unsigned __int8)a4 << 16) | BYTE2(a4) | (BYTE1(a4) << 8);
  *(_DWORD *)&v13[2].bmiHeader.biPlanes = BYTE2(a6) | ((unsigned __int8)a6 << 16) | (BYTE1(a6) << 8);
  v13[1].bmiColors[0] = (RGBQUAD)(BYTE2(a7) | ((unsigned __int8)a7 << 16) | (BYTE1(a7) << 8));
  v13[1].bmiHeader.biClrImportant = BYTE2(a8) | ((unsigned __int8)a8 << 16) | (BYTE1(a8) << 8);
  DC = GetDC(0);
  DIBitmap = CreateDIBitmap(DC, &v13->bmiHeader, 4u, &v13[2].bmiHeader.biCompression, v13, 0);
  ReleaseDC(0, DC);
  GlobalFree(v13);
  return DIBitmap;
}


// ========== Function: _WinMain@16 @ 0x41AC37 ==========
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  return sub_4220D1(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
}


// ========== Function: ?AfxInitialize@@YGHHK@Z @ 0x41AC4F ==========
int __stdcall AfxInitialize(int a1, unsigned int a2)
{
  *((_BYTE *)AfxGetModuleState() + 20) = a1;
  if ( !a1 )
    _setmbcp(-3);
  return 1;
}


// ========== Function: sub_41AC6D @ 0x41AC6D ==========
void __cdecl sub_41AC6D()
{
  AfxTermLocalData(0, 1);
  sub_425096();
  AfxTlsRelease();
}


// ========== Function: sub_41AC80 @ 0x41AC80 ==========
// attributes: thunk
int sub_41AC80()
{
  return sub_41AC85();
}


// ========== Function: sub_41AC85 @ 0x41AC85 ==========
int sub_41AC85()
{
  int result; // eax

  AfxInitialize(0, 0x600u);
  result = atexit(sub_41AC6D);
  byte_43976C = result;
  return result;
}


// ========== Function: sub_41ACA2 @ 0x41ACA2 ==========
int __stdcall sub_41ACA2(unsigned __int8 *Substr)
{
  return sub_41ACB0(Substr, 0);
}


// ========== Function: sub_41ACB0 @ 0x41ACB0 ==========
unsigned __int8 *__thiscall sub_41ACB0(_DWORD *this, unsigned __int8 *Substr, int a3)
{
  unsigned __int8 *v4; // eax

  if ( a3 <= *(_DWORD *)(*this - 8) && (v4 = _mbsstr((const unsigned __int8 *)(a3 + *this), Substr)) != 0 )
    return &v4[-*this];
  else
    return (unsigned __int8 *)-1;
}


// ========== Function: sub_41ACDB @ 0x41ACDB ==========
void __thiscall sub_41ACDB(CString *this, unsigned __int8 *Ptr, va_list a3)
{
  unsigned __int8 *v3; // edi
  unsigned __int8 v4; // al
  int v5; // esi
  int v6; // ebx
  unsigned __int8 *v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  void *v27; // esp
  size_t v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  size_t v33; // eax
  CString *v34; // esi
  char v35[12]; // [esp+8h] [ebp-20h] BYREF
  va_list ArgList; // [esp+14h] [ebp-14h]
  CString *v37; // [esp+18h] [ebp-10h]
  int v38; // [esp+1Ch] [ebp-Ch]
  int v39; // [esp+20h] [ebp-8h]
  int v40; // [esp+24h] [ebp-4h]

  v39 = 0;
  v3 = Ptr;
  v37 = this;
  ArgList = a3;
  while ( *v3 )
  {
    if ( *v3 != 37 || (v3 = _mbsinc(v3), v4 = *v3, *v3 == 37) )
    {
      v33 = _mbclen(v3);
      v39 += v33;
      goto LABEL_92;
    }
    v5 = 0;
    v40 = 0;
    if ( !v4 )
    {
LABEL_16:
      v40 = atoi((const char *)v3);
      while ( *v3 && _ismbcdigit((char)*v3) )
        v3 = _mbsinc(v3);
      goto LABEL_20;
    }
    while ( v4 == 35 )
    {
      v39 += 2;
LABEL_14:
      v3 = _mbsinc(v3);
      v4 = *v3;
      if ( !*v3 )
        goto LABEL_15;
    }
    if ( v4 == 42 )
    {
      a3 += 4;
      v40 = *((_DWORD *)a3 - 1);
      goto LABEL_14;
    }
    if ( v4 == 45 || v4 == 43 || v4 == 48 || v4 == 32 )
      goto LABEL_14;
LABEL_15:
    if ( !v40 )
      goto LABEL_16;
LABEL_20:
    v6 = 0;
    if ( *v3 == 46 )
    {
      v7 = _mbsinc(v3);
      v3 = v7;
      if ( *v7 == 42 )
      {
        a3 += 4;
        v6 = *((_DWORD *)a3 - 1);
        v3 = _mbsinc(v7);
      }
      else
      {
        v6 = atoi((const char *)v7);
        while ( *v3 && _ismbcdigit((char)*v3) )
          v3 = _mbsinc(v3);
      }
    }
    v38 = 0;
    if ( !_mbsnbcmp(v3, "I64", 3u) )
    {
      v3 += 3;
      v38 = 0x40000;
      goto LABEL_37;
    }
    switch ( *v3 )
    {
      case 'F':
      case 'L':
      case 'N':
        goto LABEL_36;
      case 'h':
        v38 = 0x10000;
LABEL_36:
        v3 = _mbsinc(v3);
        break;
      case 'l':
        v38 = 0x20000;
        goto LABEL_36;
    }
LABEL_37:
    v8 = v38 | (char)*v3;
    if ( v8 > 65635 )
    {
      v20 = v8 - 65651;
      if ( !v20 )
        goto LABEL_62;
      v21 = v20 - 65488;
      if ( !v21 )
        goto LABEL_61;
      v22 = v21 - 16;
      if ( !v22 )
      {
LABEL_59:
        a3 += 4;
        if ( !*((_DWORD *)a3 - 1) )
          goto LABEL_63;
        v24 = wcslen(*((const wchar_t **)a3 - 1));
        goto LABEL_65;
      }
      v23 = v22 - 16;
      if ( !v23 )
      {
LABEL_61:
        a3 += 4;
        v5 = 2;
        goto LABEL_68;
      }
      if ( v23 == 16 )
        goto LABEL_59;
LABEL_45:
      v14 = (char)*v3;
      if ( v14 > 105 )
      {
        v29 = v14 - 110;
        if ( !v29 )
        {
          a3 += 4;
          goto LABEL_90;
        }
        v30 = v29 - 1;
        if ( !v30 )
          goto LABEL_87;
        v31 = v30 - 1;
        if ( v31 )
        {
          v32 = v31 - 5;
          if ( v32 && v32 != 3 )
            goto LABEL_90;
          goto LABEL_87;
        }
      }
      else
      {
        if ( v14 != 105 )
        {
          v15 = v14 - 71;
          if ( !v15 )
            goto LABEL_76;
          v16 = v15 - 17;
          if ( v16 )
          {
            v17 = v16 - 12;
            if ( v17 )
            {
              v18 = v17 - 1;
              if ( !v18 )
                goto LABEL_76;
              v19 = v18 - 1;
              if ( v19 )
              {
                if ( v19 != 1 )
                  goto LABEL_90;
LABEL_76:
                a3 += 8;
                v5 = 128;
LABEL_85:
                v28 = v6 + v40;
                if ( v6 + v40 < v5 )
                  goto LABEL_90;
              }
              else
              {
                v25 = v6 + 318;
                if ( v40 > v6 + 318 )
                  v25 = v40;
                v26 = v25 + 3;
                LOBYTE(v26) = v26 & 0xFC;
                v27 = alloca(v26);
                a3 += 8;
                sprintf(v35, "%*.*f", v40, v6 + 6, *((double *)a3 - 1));
                v28 = strlen(v35);
              }
              v5 = v28;
              goto LABEL_90;
            }
          }
        }
LABEL_87:
        if ( (v38 & 0x40000) != 0 )
        {
          a3 += 8;
          goto LABEL_84;
        }
      }
      a3 += 4;
LABEL_84:
      v5 = 32;
      goto LABEL_85;
    }
    if ( v8 == 65635 )
      goto LABEL_61;
    v9 = v8 - 67;
    if ( !v9 )
      goto LABEL_61;
    v10 = v9 - 16;
    if ( !v10 )
      goto LABEL_59;
    v11 = v10 - 16;
    if ( !v11 )
      goto LABEL_61;
    v12 = v11 - 16;
    if ( !v12 )
      goto LABEL_62;
    v13 = v12 - 65488;
    if ( !v13 )
      goto LABEL_61;
    if ( v13 != 16 )
      goto LABEL_45;
LABEL_62:
    a3 += 4;
    if ( !*((_DWORD *)a3 - 1) )
    {
LABEL_63:
      v5 = 6;
      goto LABEL_68;
    }
    v24 = lstrlenA(*((LPCSTR *)a3 - 1));
LABEL_65:
    v5 = v24;
    if ( v24 < 1 )
      v5 = 1;
    if ( !v5 )
      goto LABEL_45;
LABEL_68:
    if ( v6 && v5 >= v6 )
      v5 = v6;
    if ( v5 <= v40 )
      v5 = v40;
LABEL_90:
    v39 += v5;
LABEL_92:
    v3 = _mbsinc(v3);
  }
  v34 = v37;
  sub_42034E(v39);
  vsprintf(*(char *const *)v34, (const char *const)Ptr, ArgList);
  CString::ReleaseBuffer(v34, -1);
}


// ========== Function: sub_41B028 @ 0x41B028 ==========
void __cdecl sub_41B028(CString *a1, unsigned __int8 *Ptr, int a3)
{
  sub_41ACDB(a1, Ptr, (va_list)&a3);
}


// ========== Function: sub_41B03B @ 0x41B03B ==========
int __thiscall sub_41B03B(int this, int a2, int a3, LPCSTR lpString2, int a5, const CHAR *lpString, struct CWnd *a7)
{
  const unsigned __int8 *v8; // eax
  unsigned __int8 *i; // eax

  CDialog::CDialog((CDialog *)this, 0, a7);
  *(_DWORD *)(this + 172) = off_433548;
  *(_DWORD *)this = &CFileDialog::`vftable';
  memset((void *)(this + 92), 0, 0x4Cu);
  *(_DWORD *)(this + 168) = a2;
  *(_BYTE *)(this + 240) = 0;
  *(_DWORD *)(this + 60) = 28677 - (a2 != 0);
  *(_DWORD *)(this + 152) = a3;
  *(_BYTE *)(this + 176) = 0;
  *(_DWORD *)(this + 144) |= a5 | 0x800020;
  *(_DWORD *)(this + 500) = 0;
  *(_DWORD *)(this + 92) = 76;
  *(_DWORD *)(this + 120) = this + 240;
  *(_DWORD *)(this + 124) = 260;
  *(_DWORD *)(this + 128) = this + 176;
  *(_DWORD *)(this + 132) = 64;
  if ( dword_4392D4 )
    goto LABEL_5;
  if ( sub_41D170() )
    *(_DWORD *)(this + 144) |= 0x10u;
  if ( dword_4392D4 )
  {
LABEL_5:
    *(_BYTE *)(this + 146) |= 8u;
    *(_DWORD *)(this + 100) = *((_DWORD *)AfxGetModuleState() + 3);
  }
  *(_DWORD *)(this + 160) = sub_41B52F;
  if ( lpString2 )
    lstrcpynA((LPSTR)(this + 240), lpString2, 260);
  if ( lpString )
  {
    CString::operator=((CString *)(this + 172), lpString);
    v8 = (const unsigned __int8 *)sub_42034E(0);
    for ( i = _mbschr(v8, 0x7Cu); i; i = _mbschr(i + 1, 0x7Cu) )
      *i = 0;
    *(_DWORD *)(this + 104) = *(_DWORD *)(this + 172);
  }
  return this;
}


// ========== Function: sub_41B181 @ 0x41B181 ==========
LPVOID __thiscall sub_41B181(LPVOID lpMem, char a2)
{
  sub_4027B0((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_41B19D @ 0x41B19D ==========
int __thiscall sub_41B19D(struct CWnd *this)
{
  int v2; // eax
  int v3; // edi
  struct _AFX_THREAD_STATE *ThreadState; // eax
  struct _AFX_THREAD_STATE *v5; // ebx
  BOOL OpenFileNameA; // eax
  int result; // eax
  struct tagOFNA *v8; // [esp-8h] [ebp-1Ch]
  HWND hWnd; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  v2 = lstrlenA(*((LPCSTR *)this + 30));
  memset((void *)(*((_DWORD *)this + 30) + v2 + 1), 0, *((_DWORD *)this + 31) - (v2 + 1));
  hWnd = GetFocus();
  v3 = 0;
  *((_DWORD *)this + 24) = sub_41CEC4(this);
  AfxUnhookWindowCreate();
  if ( *((_DWORD *)this + 24) && IsWindowEnabled(*((HWND *)this + 24)) )
  {
    v3 = 1;
    EnableWindow(*((HWND *)this + 24), 0);
  }
  ThreadState = AfxGetThreadState();
  v5 = ThreadState;
  if ( (*((_BYTE *)this + 146) & 8) != 0 )
    *((_DWORD *)ThreadState + 6) = this;
  else
    AfxHookWindowCreate(this);
  v8 = (struct tagOFNA *)((char *)this + 92);
  if ( *((_DWORD *)this + 42) )
    OpenFileNameA = GetOpenFileNameA(v8);
  else
    OpenFileNameA = GetSaveFileNameA(v8);
  *((_DWORD *)v5 + 6) = 0;
  v10 = OpenFileNameA;
  if ( v3 )
    EnableWindow(*((HWND *)this + 24), 1);
  if ( IsWindow(hWnd) )
    SetFocus(hWnd);
  CDialog::PostModal(this);
  result = v10;
  if ( !v10 )
    return 2;
  return result;
}


// ========== Function: sub_41B278 @ 0x41B278 ==========
CString *__thiscall sub_41B278(int this, CString *a2)
{
  HWND v2; // eax
  HWND Parent; // eax
  int v4; // ebx
  LPARAM v5; // eax
  HWND v6; // eax
  int v7; // edi
  LPARAM v8; // eax
  int v10; // [esp+Ch] [ebp-14h]
  _DWORD *v11; // [esp+10h] [ebp-10h] BYREF
  int v12; // [esp+1Ch] [ebp-4h]

  v11 = 0;
  v10 = this;
  if ( (*(_BYTE *)(this + 146) & 8) != 0 )
  {
    v2 = *(HWND *)(this + 28);
    if ( v2 )
    {
      v11 = off_433548;
      v12 = 0;
      Parent = GetParent(v2);
      v4 = sub_41D866(Parent);
      v5 = sub_42034E(260);
      if ( SendMessageA(*(HWND *)(v4 + 28), 0x464u, 0x104u, v5) >= 0 )
        CString::ReleaseBuffer((CString *)&v11, -1);
      else
        CString::Empty((CString *)&v11);
      if ( *(v11 - 2) )
      {
        v6 = GetParent(*(HWND *)(v10 + 28));
        v7 = sub_41D866(v6);
        v8 = sub_42034E(260);
        if ( SendMessageA(*(HWND *)(v7 + 28), 0x465u, 0x104u, v8) >= 0 )
        {
          CString::ReleaseBuffer((CString *)&v11, -1);
          sub_41FE52(a2, &v11);
          v12 = -1;
          sub_4200DD(&v11);
          return a2;
        }
        CString::Empty((CString *)&v11);
      }
      v12 = -1;
      sub_4200DD(&v11);
      this = v10;
    }
  }
  sub_420107(*(LPCSTR *)(this + 120));
  return a2;
}


// ========== Function: sub_41B388 @ 0x41B388 ==========
int __stdcall sub_41B388(int a1)
{
  return 0;
}


// ========== Function: sub_41B38D @ 0x41B38D ==========
int sub_41B38D()
{
  return 0;
}


// ========== Function: nullsub_9 @ 0x41B390 ==========
void __stdcall nullsub_9(int a1, int a2, int a3)
{
  ;
}


// ========== Function: ?OnInitDone@CFileDialog@@MAEXXZ @ 0x41B393 ==========
void __thiscall CFileDialog::OnInitDone(HWND *this)
{
  HWND Parent; // eax
  CWnd *v2; // eax

  Parent = GetParent(this[7]);
  v2 = (CWnd *)sub_41D866(Parent);
  CWnd::CenterWindow(v2, 0);
}


// ========== Function: nullsub_10 @ 0x41B3AC ==========
void nullsub_10()
{
  ;
}


// ========== Function: sub_41B3AD @ 0x41B3AD ==========
int __thiscall sub_41B3AD(HWND *this, unsigned int a2, int a3, int *a4)
{
  int v5; // eax
  int v7; // eax

  if ( CWnd::OnNotify((CWnd *)this, a2, a3, a4) )
    return 1;
  v5 = *(_DWORD *)(a3 + 8);
  switch ( v5 )
  {
    case -607:
      (*((void (__thiscall **)(HWND *))*this + 58))(this);
      return 1;
    case -606:
      v7 = (*((int (__thiscall **)(HWND *))*this + 53))(this);
      goto LABEL_14;
    case -605:
      if ( !SendMessageA(this[7], 0x111u, 0xE146u, 0) )
        SendMessageA(this[7], 0x365u, 0, 0);
      return 1;
    case -604:
      v7 = (*((int (__thiscall **)(HWND *, _DWORD))*this + 52))(this, *(_DWORD *)(a3 + 16));
LABEL_14:
      *a4 = v7;
      return 1;
    case -603:
      (*((void (__thiscall **)(HWND *))*this + 57))(this);
      break;
    case -602:
      (*((void (__thiscall **)(HWND *))*this + 56))(this);
      break;
    case -601:
      (*((void (__thiscall **)(HWND *))*this + 55))(this);
      break;
    default:
      return 0;
  }
  return 1;
}


// ========== Function: ?InitString@CSimpleException@@QAEXXZ @ 0x41B48B ==========
void __thiscall CSimpleException::InitString(CSimpleException *this)
{
  *((_DWORD *)this + 3) = 1;
  *((_DWORD *)this + 4) = AfxLoadString(*((_DWORD *)this + 37), (LPSTR)this + 20, 0x80u) != 0;
}


// ========== Function: ?GetErrorMessage@CSimpleException@@UAEHPADIPAI@Z @ 0x41B4B4 ==========
int __thiscall CSimpleException::GetErrorMessage(
        CHAR *this,
        LPSTR lpString1,
        unsigned int iMaxLength,
        unsigned int *a4)
{
  if ( a4 )
    *a4 = 0;
  if ( !*((_DWORD *)this + 3) )
    CSimpleException::InitString((CSimpleException *)this);
  if ( *((_DWORD *)this + 4) )
    lstrcpynA(lpString1, this + 20, iMaxLength);
  else
    *lpString1 = 0;
  return *((_DWORD *)this + 4);
}


// ========== Function: sub_41B4F7 @ 0x41B4F7 ==========
void __noreturn sub_41B4F7()
{
  void *pExceptionObject; // [esp+0h] [ebp-4h] BYREF

  pExceptionObject = &dword_438FE0;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI5PAVCMemoryException__);
}


// ========== Function: sub_41B510 @ 0x41B510 ==========
void __noreturn sub_41B510()
{
  void *pExceptionObject; // [esp+0h] [ebp-4h] BYREF

  pExceptionObject = &dword_438F48;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI5PAVCNotSupportedException__);
}


// ========== Function: sub_41B529 @ 0x41B529 ==========
_UNKNOWN ****sub_41B529()
{
  return &off_42B558;
}


// ========== Function: sub_41B52F @ 0x41B52F ==========
int __stdcall sub_41B52F(HWND hWnd, unsigned int a2, WPARAM a3, unsigned int a4)
{
  struct CNoTrackObject *Data; // esi
  int result; // eax
  int v6; // esi

  if ( !hWnd )
    return 0;
  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  if ( *((_DWORD *)Data + 6) && !sub_41D88D(hWnd) )
  {
    sub_41FDD8(hWnd);
    *((_DWORD *)Data + 6) = 0;
  }
  if ( a2 == 272 )
  {
    dword_439344 = RegisterWindowMessageA("commdlg_LBSelChangedNotify");
    dword_439340 = RegisterWindowMessageA("commdlg_ShareViolation");
    dword_43933C = RegisterWindowMessageA("commdlg_FileNameOK");
    dword_439338 = RegisterWindowMessageA("commdlg_ColorOK");
    dword_439334 = RegisterWindowMessageA("commdlg_help");
    dword_439330 = RegisterWindowMessageA("commdlg_SetRGBColor");
    return DialogFunc(hWnd, 0x110u, a3, a4);
  }
  if ( a2 == dword_439334 || a2 == 273 && (_WORD)a3 == 1038 )
  {
    SendMessageA(hWnd, 0x111u, 0xE146u, 0);
    return 1;
  }
  if ( a2 < 0xC000 )
    return 0;
  v6 = sub_41D88D(hWnd);
  if ( CObject::IsKindOf((CObject *)v6, (const struct CRuntimeClass *)&off_42ACB8) )
  {
    if ( (*(_BYTE *)(v6 + 146) & 8) != 0 )
      return 0;
  }
  if ( a2 == dword_439340 )
    return (*(int (__thiscall **)(int, unsigned int))(*(_DWORD *)v6 + 208))(v6, a4);
  if ( a2 != dword_43933C )
  {
    if ( a2 == dword_439344 )
    {
      (*(void (__thiscall **)(int, WPARAM, _DWORD, unsigned int))(*(_DWORD *)v6 + 216))(
        v6,
        a3,
        (unsigned __int16)a4,
        HIWORD(a4));
    }
    else if ( a2 == dword_439338 )
    {
      return (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 208))(v6);
    }
    return 0;
  }
  if ( dword_4392D4 )
    *(_DWORD *)(v6 + 500) = a4;
  result = (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 212))(v6);
  *(_DWORD *)(v6 + 500) = 0;
  return result;
}


// ========== Function: ?OnOK@CCommonDialog@@MAEXXZ @ 0x41B6C6 ==========
void __thiscall CCommonDialog::OnOK(CCommonDialog *this)
{
  if ( sub_41F4FD(1) )
    sub_41D7CD(this);
}


// ========== Function: sub_41B6DD @ 0x41B6DD ==========
// attributes: thunk
int __thiscall sub_41B6DD(void *this)
{
  return sub_41D7CD(this);
}


// ========== Function: ??0CTime@@QAE@HHHHHHH@Z @ 0x41B6EA ==========
CTime *__thiscall CTime::CTime(CTime *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  tm Tm; // [esp+4h] [ebp-24h] BYREF

  Tm.tm_sec = a7;
  Tm.tm_min = a6;
  Tm.tm_hour = a5;
  Tm.tm_mday = a4;
  Tm.tm_mon = a3 - 1;
  Tm.tm_year = a2 - 1900;
  Tm.tm_isdst = a8;
  *(_DWORD *)this = mktime(&Tm);
  return this;
}


// ========== Function: ??0CTime@@QAE@ABU_SYSTEMTIME@@H@Z @ 0x41B736 ==========
CTime *__thiscall CTime::CTime(CTime *this, const struct _SYSTEMTIME *a2, int a3)
{
  if ( a2->wYear >= 0x76Cu )
  {
    CTime::CTime((CTime *)&a2, a2->wYear, a2->wMonth, a2->wDay, a2->wHour, a2->wMinute, a2->wSecond, a3);
    *(_DWORD *)this = a2;
  }
  else
  {
    *(_DWORD *)this = 0;
  }
  return this;
}


// ========== Function: ??0CTime@@QAE@ABU_FILETIME@@H@Z @ 0x41B782 ==========
CTime *__thiscall CTime::CTime(CTime *this, FILETIME *lpFileTime, int a3)
{
  struct _SYSTEMTIME SystemTime; // [esp+4h] [ebp-18h] BYREF
  _FILETIME LocalFileTime; // [esp+14h] [ebp-8h] BYREF

  if ( FileTimeToLocalFileTime(lpFileTime, &LocalFileTime) && FileTimeToSystemTime(&LocalFileTime, &SystemTime) )
  {
    CTime::CTime((CTime *)&lpFileTime, &SystemTime, a3);
    *(_DWORD *)this = lpFileTime;
  }
  else
  {
    *(_DWORD *)this = 0;
  }
  return this;
}


// ========== Function: ??0facet@locale@std@@IAE@I@Z @ 0x41B7CE ==========
std::locale::facet *__thiscall std::locale::facet::facet(std::locale::facet *this, unsigned int a2)
{
  std::locale::facet *result; // eax

  result = this;
  *(_DWORD *)this = &CArchiveStream::`vftable';
  *((_DWORD *)this + 1) = a2;
  return result;
}


// ========== Function: sub_41B7E0 @ 0x41B7E0 ==========
int __stdcall sub_41B7E0(int a1)
{
  return 1;
}


// ========== Function: sub_41B7E6 @ 0x41B7E6 ==========
int __stdcall sub_41B7E6(int a1)
{
  return 0;
}


// ========== Function: ?QueryInterface@CArchiveStream@@UAGJABU_GUID@@PAPAX@Z @ 0x41B7EB ==========
int __stdcall CArchiveStream::QueryInterface(CArchiveStream *this, const struct _GUID *Buf1, void **a3)
{
  if ( memcmp(Buf1, &dword_42C760, 0x10u) && memcmp(Buf1, &unk_42CB68, 0x10u) )
    return -2147467262;
  *a3 = this;
  return 0;
}


// ========== Function: ?Read@CArchiveStream@@UAGJPAXKPAK@Z @ 0x41B82F ==========
int __stdcall CArchiveStream::Read(CArchiveStream *this, void *a2, unsigned int a3, unsigned int *a4)
{
  unsigned int v4; // eax
  int v6; // [esp+0h] [ebp-20h] BYREF
  int *v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-4h]

  v8 = 0;
  v7 = &v6;
  v4 = sub_422DA5(a2, a3);
  if ( a4 )
    *a4 = v4;
  return 0;
}


// ========== Function: ?Write@CArchiveStream@@UAGJPBXKPAK@Z @ 0x41B887 ==========
int __stdcall CArchiveStream::Write(CArchiveStream *this, void *Src, unsigned int a3, unsigned int *a4)
{
  CArchive *v4; // ecx
  int v6; // [esp+0h] [ebp-20h] BYREF
  int *v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-4h]

  v4 = (CArchive *)*((_DWORD *)this + 1);
  v8 = 0;
  v7 = &v6;
  CArchive::Write(v4, Src, a3);
  if ( a4 )
    *a4 = a3;
  return 0;
}


// ========== Function: sub_41B8E0 @ 0x41B8E0 ==========
int __stdcall sub_41B8E0(CException *a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // esi
  int v7; // eax
  int v8; // eax
  _DWORD v9[7]; // [esp+0h] [ebp-1Ch] BYREF

  v9[3] = v9;
  if ( a3 && (a3 != -1 || a2 >= 0) )
    return -2147467263;
  v5 = *(int **)(*((_DWORD *)a1 + 1) + 32);
  if ( !v5 )
    return -2147467263;
  sub_422F44();
  v7 = *v5;
  v9[6] = 0;
  v8 = (*(int (__thiscall **)(int *, int, int))(v7 + 40))(v5, a2, a4);
  if ( a5 )
  {
    a5[1] = 0;
    *a5 = v8;
  }
  return 0;
}


// ========== Function: sub_41B960 @ 0x41B960 ==========
int __stdcall sub_41B960(int a1, int a2, int a3)
{
  return -2147467263;
}


// ========== Function: sub_41B968 @ 0x41B968 ==========
int __stdcall sub_41B968(int a1)
{
  return -2147467263;
}


// ========== Function: sub_41B970 @ 0x41B970 ==========
int __stdcall sub_41B970(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return -2147467263;
}


// ========== Function: sub_41B978 @ 0x41B978 ==========
int __stdcall sub_41B978(int a1, int a2)
{
  return -2147467263;
}


// ========== Function: sub_41B980 @ 0x41B980 ==========
_DWORD *__thiscall sub_41B980(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[3] = 0;
  this[4] = 0;
  this[2] = 0;
  this[1] = 0;
  this[5] = 0;
  *this = &CPtrList::`vftable';
  this[6] = a2;
  return result;
}


// ========== Function: sub_41B9A3 @ 0x41B9A3 ==========
LPVOID __thiscall sub_41B9A3(LPVOID lpMem, char a2)
{
  sub_41B9DF(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_41B9BF @ 0x41B9BF ==========
void __thiscall sub_41B9BF(_DWORD *this)
{
  CPlex *v2; // ecx

  v2 = (CPlex *)this[5];
  this[3] = 0;
  this[4] = 0;
  this[2] = 0;
  this[1] = 0;
  CPlex::FreeDataChain(v2);
  this[5] = 0;
}


// ========== Function: sub_41B9DF @ 0x41B9DF ==========
void __thiscall sub_41B9DF(_DWORD *this)
{
  *this = &CPtrList::`vftable';
  sub_41B9BF(this);
}


// ========== Function: sub_41BA08 @ 0x41BA08 ==========
_DWORD *__thiscall sub_41BA08(int this, int a2, int a3)
{
  struct CPlex *v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  _DWORD *result; // eax

  if ( !*(_DWORD *)(this + 16) )
  {
    v4 = CPlex::Create((struct CPlex **)(this + 20), *(_DWORD *)(this + 24), 0xCu);
    v5 = *(_DWORD *)(this + 24);
    v6 = 3 * v5;
    v7 = v5 - 1;
    v8 = (_DWORD *)((char *)v4 + 4 * v6 - 8);
    if ( v7 >= 0 )
    {
      v9 = v7 + 1;
      do
      {
        *v8 = *(_DWORD *)(this + 16);
        *(_DWORD *)(this + 16) = v8;
        v8 -= 3;
        --v9;
      }
      while ( v9 );
    }
  }
  result = *(_DWORD **)(this + 16);
  *(_DWORD *)(this + 16) = *result;
  result[1] = a2;
  *result = a3;
  ++*(_DWORD *)(this + 12);
  result[2] = 0;
  return result;
}


// ========== Function: sub_41BA60 @ 0x41BA60 ==========
void __thiscall sub_41BA60(_DWORD *this, _DWORD *a2)
{
  bool v2; // zf

  *a2 = this[4];
  v2 = this[3]-- == 1;
  this[4] = a2;
  if ( v2 )
    sub_41B9BF(this);
}


// ========== Function: sub_41BA79 @ 0x41BA79 ==========
_DWORD *__thiscall sub_41BA79(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  _DWORD *v4; // ecx

  result = sub_41BA08((int)this, this[2], 0);
  result[2] = a2;
  v4 = (_DWORD *)this[2];
  if ( v4 )
    *v4 = result;
  else
    this[1] = result;
  this[2] = result;
  return result;
}


// ========== Function: sub_41BAA2 @ 0x41BAA2 ==========
int __thiscall sub_41BAA2(_DWORD *this)
{
  int *v1; // eax
  int v2; // edx
  int v3; // esi
  bool v4; // zf

  v1 = (int *)this[1];
  v2 = *v1;
  v3 = v1[2];
  v4 = *v1 == 0;
  this[1] = *v1;
  if ( v4 )
    this[2] = 0;
  else
    *(_DWORD *)(v2 + 4) = 0;
  sub_41BA60(this, v1);
  return v3;
}


// ========== Function: sub_41BAC6 @ 0x41BAC6 ==========
void __thiscall sub_41BAC6(_DWORD *this, _DWORD *a2)
{
  if ( a2 == (_DWORD *)this[1] )
    this[1] = *a2;
  else
    *(_DWORD *)a2[1] = *a2;
  if ( a2 == (_DWORD *)this[2] )
    this[2] = a2[1];
  else
    *(_DWORD *)(*a2 + 4) = a2[1];
  sub_41BA60(this, a2);
}


// ========== Function: sub_41BAFD @ 0x41BAFD ==========
// ?Find@CObList@@QBEPAU__POSITION@@PAVCObject@@PAU2@@Z
// doubtful name
_DWORD *__thiscall sub_41BAFD(_DWORD *this, int a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = a3;
  if ( a3 )
    goto LABEL_3;
  for ( result = (_DWORD *)this[1]; result; result = (_DWORD *)*result )
  {
    if ( result[2] == a2 )
      return result;
LABEL_3:
    ;
  }
  return 0;
}


// ========== Function: ?Create@CPlex@@SGPAU1@AAPAU1@II@Z @ 0x41BB20 ==========
struct CPlex *__stdcall CPlex::Create(struct CPlex **a1, unsigned int a2, unsigned int a3)
{
  struct CPlex *result; // eax

  result = (struct CPlex *)sub_41CA70(a3 * a2 + 4);
  *(_DWORD *)result = *a1;
  *a1 = result;
  return result;
}


// ========== Function: ?FreeDataChain@CPlex@@QAEXXZ @ 0x41BB40 ==========
void __thiscall CPlex::FreeDataChain(CPlex **this)
{
  CPlex *v1; // esi

  if ( this )
  {
    do
    {
      v1 = *this;
      sub_41CA99(this);
      this = (CPlex **)v1;
    }
    while ( v1 );
  }
}


// ========== Function: sub_41BB56 @ 0x41BB56 ==========
_DWORD *__thiscall sub_41BB56(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  *this = &CMapPtrToPtr::`vftable';
  this[2] = 17;
  this[6] = a2;
  return result;
}


// ========== Function: sub_41BB7D @ 0x41BB7D ==========
LPVOID __thiscall sub_41BB7D(LPVOID lpMem, char a2)
{
  sub_41BC09(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_41BB99 @ 0x41BB99 ==========
void *__thiscall sub_41BB99(int this, int a2, int a3)
{
  void *result; // eax
  void *v5; // eax

  result = *(void **)(this + 4);
  if ( result )
  {
    result = (void *)sub_41CA99(*(LPVOID *)(this + 4));
    *(_DWORD *)(this + 4) = 0;
  }
  if ( a3 )
  {
    v5 = (void *)sub_41CA70(4 * a2);
    *(_DWORD *)(this + 4) = v5;
    result = memset(v5, 0, 4 * a2);
  }
  *(_DWORD *)(this + 8) = a2;
  return result;
}


// ========== Function: sub_41BBDE @ 0x41BBDE ==========
// ?RemoveAll@CMapPtrToPtr@@QAEXXZ
// doubtful name
void __thiscall sub_41BBDE(int this)
{
  CPlex **v2; // ecx

  if ( *(_DWORD *)(this + 4) )
  {
    sub_41CA99(*(LPVOID *)(this + 4));
    *(_DWORD *)(this + 4) = 0;
  }
  v2 = *(CPlex ***)(this + 20);
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  CPlex::FreeDataChain(v2);
  *(_DWORD *)(this + 20) = 0;
}


// ========== Function: sub_41BC09 @ 0x41BC09 ==========
void __thiscall sub_41BC09(_DWORD *this)
{
  *this = &CMapPtrToPtr::`vftable';
  sub_41BBDE((int)this);
}


// ========== Function: sub_41BC32 @ 0x41BC32 ==========
int *__thiscall sub_41BC32(int this)
{
  struct CPlex *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // ecx
  int *result; // eax
  int v9; // ecx

  if ( !*(_DWORD *)(this + 16) )
  {
    v2 = CPlex::Create((struct CPlex **)(this + 20), *(_DWORD *)(this + 24), 0xCu);
    v3 = *(_DWORD *)(this + 24);
    v4 = 3 * v3;
    v5 = v3 - 1;
    v6 = (_DWORD *)((char *)v2 + 4 * v4 - 8);
    if ( v5 >= 0 )
    {
      v7 = v5 + 1;
      do
      {
        *v6 = *(_DWORD *)(this + 16);
        *(_DWORD *)(this + 16) = v6;
        v6 -= 3;
        --v7;
      }
      while ( v7 );
    }
  }
  result = *(int **)(this + 16);
  v9 = *result;
  ++*(_DWORD *)(this + 12);
  *(_DWORD *)(this + 16) = v9;
  result[1] = 0;
  result[2] = 0;
  return result;
}


// ========== Function: sub_41BC7F @ 0x41BC7F ==========
void __thiscall sub_41BC7F(_DWORD *this, _DWORD *a2)
{
  bool v2; // zf

  *a2 = this[4];
  v2 = this[3]-- == 1;
  this[4] = a2;
  if ( v2 )
    sub_41BBDE((int)this);
}


// ========== Function: sub_41BC98 @ 0x41BC98 ==========
// ?GetAssocAt@CMapPtrToPtr@@IBEPAUCAssoc@1@PAXAAI@Z
// doubtful name
_DWORD *__thiscall sub_41BC98(_DWORD *this, unsigned int a2, int *a3)
{
  int v3; // edx
  int v4; // ecx
  _DWORD *result; // eax

  v3 = (a2 >> 4) % this[2];
  *a3 = v3;
  v4 = this[1];
  if ( v4 )
  {
    for ( result = *(_DWORD **)(v4 + 4 * v3); result; result = (_DWORD *)*result )
    {
      if ( result[1] == a2 )
        return result;
    }
  }
  return 0;
}


// ========== Function: ?GetValueAt@CMapPtrToPtr@@QBEPAXPAX@Z @ 0x41BCCA ==========
void *__thiscall CMapPtrToPtr::GetValueAt(CMapPtrToPtr *this, unsigned int a2)
{
  int v2; // esi
  _DWORD *i; // edx

  v2 = *((_DWORD *)this + 1);
  if ( v2 )
  {
    for ( i = *(_DWORD **)(v2 + 4 * ((a2 >> 4) % *((_DWORD *)this + 2))); i; i = (_DWORD *)*i )
    {
      if ( i[1] == a2 )
        return (void *)i[2];
    }
  }
  return 0;
}


// ========== Function: sub_41BCFD @ 0x41BCFD ==========
_DWORD *__thiscall sub_41BCFD(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edi
  _DWORD *v4; // eax

  v2 = a2;
  v4 = sub_41BC98(this, a2, (int *)&a2);
  if ( !v4 )
  {
    if ( !this[1] )
      sub_41BB99((int)this, this[2], 1);
    v4 = sub_41BC32((int)this);
    v4[1] = v2;
    *v4 = *(_DWORD *)(this[1] + 4 * a2);
    *(_DWORD *)(this[1] + 4 * a2) = v4;
  }
  return v4 + 2;
}


// ========== Function: sub_41BD4D @ 0x41BD4D ==========
int __thiscall sub_41BD4D(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // edx

  v2 = this[1];
  if ( v2 )
  {
    v3 = (a2 >> 4) % this[2];
    v4 = *(_DWORD **)(v2 + 4 * v3);
    v5 = (_DWORD *)(v2 + 4 * v3);
    while ( v4 )
    {
      if ( v4[1] == a2 )
      {
        *v5 = *v4;
        sub_41BC7F(this, v4);
        return 1;
      }
      v5 = v4;
      v4 = (_DWORD *)*v4;
    }
  }
  return 0;
}


// ========== Function: sub_41BD8F @ 0x41BD8F ==========
int __thiscall sub_41BD8F(_DWORD *this, _DWORD **a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // edi
  _DWORD **v7; // eax
  _DWORD *v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // edx
  _DWORD *v11; // eax
  int result; // eax

  v4 = *a2;
  if ( *a2 == (_DWORD *)-1 )
  {
    v5 = this[2];
    v6 = 0;
    if ( v5 )
    {
      v7 = (_DWORD **)this[1];
      do
      {
        v4 = *v7;
        if ( *v7 )
          break;
        ++v6;
        ++v7;
      }
      while ( v6 < v5 );
    }
  }
  v8 = (_DWORD *)*v4;
  if ( !*v4 )
  {
    v9 = this[2];
    v10 = (v4[1] >> 4) % v9 + 1;
    if ( v10 < v9 )
    {
      v11 = (_DWORD *)(this[1] + 4 * v10);
      do
      {
        v8 = (_DWORD *)*v11;
        if ( *v11 )
          break;
        ++v10;
        ++v11;
      }
      while ( v10 < v9 );
    }
  }
  *a2 = v8;
  *a3 = v4[1];
  result = v4[2];
  *a4 = result;
  return result;
}


// ========== Function: sub_41BE01 @ 0x41BE01 ==========
_UNKNOWN **sub_41BE01()
{
  return &off_429A10;
}


// ========== Function: ?Run@CWinApp@@UAEHXZ @ 0x41BE07 ==========
int __thiscall CWinApp::Run(CWinApp *this)
{
  if ( !*((_DWORD *)this + 7) && AfxOleGetUserCtrl() )
    AfxPostQuitMessage(0);
  return sub_41C077(this);
}


// ========== Function: sub_41BE29 @ 0x41BE29 ==========
int __thiscall sub_41BE29(_DWORD *this, int a2, int a3)
{
  HWND *v4; // esi

  v4 = (HWND *)sub_404EA0();
  this[33] = 0;
  PostMessageA(v4[7], 0x36Au, 0, 0);
  return (*((int (__thiscall **)(HWND *, int, int))*v4 + 27))(v4, a2, a3);
}


// ========== Function: sub_41BE60 @ 0x41BE60 ==========
int __stdcall sub_41BE60(CObject *a1, int a2)
{
  int v2; // ebx
  int v3; // edi

  if ( *(_DWORD *)(a2 + 4) == 1 || *(_DWORD *)(a2 + 4) == 15 )
    return unknown_libname_11(a1, a2);
  v2 = 0;
  v3 = 61704;
  if ( *(_DWORD *)(a2 + 4) == 273 )
  {
    if ( !*(_DWORD *)(a2 + 12) )
      v3 = 61705;
    v2 = 1;
  }
  if ( CObject::IsKindOf(a1, (const struct CRuntimeClass *)&off_42AE40) )
  {
    (*(void (__thiscall **)(CObject *, int, int))(*(_DWORD *)a1 + 16))(a1, 4144, v3);
  }
  else if ( !CObject::IsKindOf(a1, (const struct CRuntimeClass *)&off_42A9C8) )
  {
    (*(void (__thiscall **)(CObject *, int, int))(*(_DWORD *)a1 + 16))(a1, 16, v3);
  }
  return v2;
}


// ========== Function: sub_41BED7 @ 0x41BED7 ==========
BOOL __thiscall sub_41BED7(CWinThread *this, int a2)
{
  int v2; // edi
  int v4; // ecx
  int v5; // eax

  v2 = a2;
  if ( a2 > 0 )
  {
    if ( a2 == 1 )
      CWinThread::OnIdle(this, 1);
  }
  else
  {
    CWinThread::OnIdle(this, a2);
    v4 = *((_DWORD *)this + 32);
    a2 = 0;
    if ( v4 )
    {
      a2 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 16))(v4);
      while ( a2 )
      {
        v5 = (*(int (__thiscall **)(_DWORD, int *))(**((_DWORD **)this + 32) + 20))(*((_DWORD *)this + 32), &a2);
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 136))(v5);
      }
    }
  }
  return v2 < 1;
}


// ========== Function: ?DevModeChange@CWinApp@@QAEXPAD@Z @ 0x41BF41 ==========
void __thiscall CWinApp::DevModeChange(HGLOBAL *this, char *lpString2)
{
  const CHAR *v3; // eax
  SIZE_T v4; // eax
  HGLOBAL v5; // eax
  struct _devicemodeA *v6; // eax
  HANDLE phPrinter; // [esp+Ch] [ebp-4h] BYREF

  if ( this[38] )
  {
    v3 = (const CHAR *)GlobalLock(this[38]);
    if ( !lstrcmpA(&v3[*((unsigned __int16 *)v3 + 1)], lpString2) )
    {
      if ( OpenPrinterA(lpString2, &phPrinter, 0) )
      {
        if ( this[37] )
          AfxGlobalFree(this[37]);
        v4 = DocumentPropertiesA(0, phPrinter, lpString2, 0, 0, 0);
        v5 = GlobalAlloc(0x42u, v4);
        this[37] = v5;
        v6 = (struct _devicemodeA *)GlobalLock(v5);
        if ( DocumentPropertiesA(0, phPrinter, lpString2, v6, 0, 2u) != 1 )
        {
          AfxGlobalFree(this[37]);
          this[37] = 0;
        }
        ClosePrinter(phPrinter);
      }
    }
  }
}


// ========== Function: ?AfxGetThread@@YGPAVCWinThread@@XZ @ 0x41BFEE ==========
struct CWinThread *__stdcall AfxGetThread()
{
  struct CWinThread *result; // eax

  result = (struct CWinThread *)*((_DWORD *)AfxGetModuleThreadState() + 1);
  if ( !result )
    return (struct CWinThread *)*((_DWORD *)AfxGetModuleState() + 1);
  return result;
}


// ========== Function: ?AfxInitThread@@YGXXZ @ 0x41C003 ==========
void __stdcall AfxInitThread()
{
  struct _AFX_THREAD_STATE *ThreadState; // esi
  DWORD CurrentThreadId; // eax
  int v2; // esi
  struct AFX_MODULE_STATE *ModuleState; // eax

  if ( !*((_BYTE *)AfxGetModuleState() + 20) )
  {
    ThreadState = AfxGetThreadState();
    CurrentThreadId = GetCurrentThreadId();
    *((_DWORD *)ThreadState + 12) = SetWindowsHookExA(-1, _AfxMsgFilterHook, 0, CurrentThreadId);
    v2 = sub_424E45(CProcessLocal<_AFX_CTL3D_STATE>::CreateObject);
    if ( *(_DWORD *)(v2 + 20) )
    {
      ModuleState = AfxGetModuleState();
      (*(void (__stdcall **)(_DWORD))(v2 + 20))(*((_DWORD *)ModuleState + 2));
    }
    CThreadLocalObject::GetData((CThreadLocalObject *)&unk_4392E4, sub_42407E);
  }
}


// ========== Function: ?Delete@CWinThread@@UAEXXZ @ 0x41C062 ==========
void __thiscall CWinThread::Delete(CWinThread *this)
{
  if ( *((_DWORD *)this + 9) )
  {
    if ( this )
      (*(void (__thiscall **)(CWinThread *, int))(*(_DWORD *)this + 4))(this, 1);
  }
}


// ========== Function: sub_41C074 @ 0x41C074 ==========
int sub_41C074()
{
  return 0;
}


// ========== Function: sub_41C077 @ 0x41C077 ==========
int __thiscall sub_41C077(char *this)
{
  int v2; // edi
  int v3; // eax
  int v5; // [esp+10h] [ebp-4h]

  v2 = 1;
  v5 = 0;
LABEL_2:
  while ( v2 )
  {
    if ( PeekMessageA((LPMSG)(this + 48), 0, 0, 0, 0) )
      break;
    v3 = v5++;
    if ( !(*(int (__thiscall **)(char *, int))(*(_DWORD *)this + 96))(this, v3) )
      v2 = 0;
  }
  while ( (*(int (__thiscall **)(char *))(*(_DWORD *)this + 92))(this) )
  {
    if ( (*(int (__thiscall **)(char *, char *))(*(_DWORD *)this + 100))(this, this + 48) )
    {
      v5 = 0;
      v2 = 1;
    }
    if ( !PeekMessageA((LPMSG)(this + 48), 0, 0, 0, 0) )
      goto LABEL_2;
  }
  return (*(int (__thiscall **)(char *))(*(_DWORD *)this + 104))(this);
}


// ========== Function: sub_41C0F6 @ 0x41C0F6 ==========
int __thiscall sub_41C0F6(_DWORD *this, _DWORD *a2)
{
  int v2; // esi
  int v4; // esi

  v2 = a2[1];
  if ( v2 == 512 || v2 == 160 )
  {
    if ( this[23] == a2[5] && this[24] == a2[6] && v2 == this[25] )
      return 0;
    v4 = a2[6];
    this[23] = a2[5];
    this[24] = v4;
    this[25] = a2[1];
  }
  else if ( v2 == 15 || v2 == 280 )
  {
    return 0;
  }
  return 1;
}


// ========== Function: sub_41C14F @ 0x41C14F ==========
int __thiscall sub_41C14F(_DWORD *this)
{
  return this[14];
}


// ========== Function: ?OnIdle@CWinThread@@UAEHJ@Z @ 0x41C153 ==========
BOOL __thiscall CWinThread::OnIdle(CWinThread *this, int a2)
{
  HWND *v2; // edi
  struct AFX_MODULE_STATE *v3; // eax
  int i; // esi
  struct AFX_MODULE_STATE *ModuleState; // eax

  if ( a2 > 0 )
  {
    ModuleState = AfxGetModuleState();
    if ( !*((_DWORD *)CThreadLocalObject::GetData((struct AFX_MODULE_STATE *)((char *)ModuleState + 4208), sub_423F73)
          + 4) )
    {
      AfxLockTempMaps();
      sub_420DBD(1u);
    }
  }
  else
  {
    v2 = (HWND *)*((_DWORD *)this + 7);
    if ( v2 && v2[7] && IsWindowVisible(v2[7]) )
    {
      sub_41D69B((struct CWnd *)v2, (__int16)v2[7], (CException *)0x363, 1, 0);
      CWnd::SendMessageToDescendants(v2[7], 0x363u, 1u, 0, 1, 1);
    }
    v3 = AfxGetModuleState();
    for ( i = *((_DWORD *)CThreadLocalObject::GetData((struct AFX_MODULE_STATE *)((char *)v3 + 4208), sub_423F73) + 2);
          i;
          i = *(_DWORD *)(i + 84) )
    {
      if ( *(_DWORD *)(i + 28) && (HWND *)i != v2 )
      {
        if ( !*(_DWORD *)(i + 136) )
          sub_4205F2(0);
        if ( IsWindowVisible(*(HWND *)(i + 28)) || *(int *)(i + 136) >= 0 )
        {
          sub_41D69B((struct CWnd *)i, *(_DWORD *)(i + 28), (CException *)0x363, 1, 0);
          CWnd::SendMessageToDescendants(*(HWND *)(i + 28), 0x363u, 1u, 0, 1, 1);
        }
        if ( *(int *)(i + 136) > 0 )
          sub_4205F2(*(_DWORD *)(i + 136));
        *(_DWORD *)(i + 136) = -1;
      }
    }
  }
  return a2 < 0;
}


// ========== Function: sub_41C25E @ 0x41C25E ==========
int __thiscall sub_41C25E(void *this, _DWORD *a2)
{
  _DWORD *i; // esi
  unsigned int v3; // eax
  int j; // eax

  for ( i = (_DWORD *)(*(int (__fastcall **)(void *))(*(_DWORD *)this + 40))(this); i; i = (_DWORD *)*i )
  {
    v3 = a2[1];
    if ( v3 >= 0xC000 )
    {
      for ( j = unknown_libname_16(i[1], 49152, 0, 0); j; j = unknown_libname_16(j + 24, 49152, 0, 0) )
      {
        if ( **(_DWORD **)(j + 16) == a2[1] )
          goto LABEL_10;
      }
    }
    else
    {
      j = unknown_libname_16(i[1], v3, 0, 0);
      if ( j )
      {
LABEL_10:
        (*(void (__thiscall **)(void *, _DWORD, _DWORD))(j + 20))(this, a2[2], a2[3]);
        return 1;
      }
    }
  }
  return 0;
}


// ========== Function: sub_41C2D9 @ 0x41C2D9 ==========
int __thiscall sub_41C2D9(void *this, void **a2)
{
  int v2; // eax
  int v3; // esi
  int v5; // eax

  if ( !*a2 && sub_41C25E(this, a2) )
    return 1;
  v2 = sub_404EA0();
  v3 = v2;
  if ( v2 )
    v2 = *(_DWORD *)(v2 + 28);
  if ( sub_41EEF4(v2, a2) )
    return 1;
  if ( !v3 )
    return 0;
  v5 = sub_41D866(*a2);
  if ( sub_41ED38(v5) == v3 )
    return 0;
  return (*(int (__thiscall **)(int, void **))(*(_DWORD *)v3 + 144))(v3, a2);
}


// ========== Function: unknown_libname_11 @ 0x41C336 ==========
// MFC 3.1-14.0 32bit
int __stdcall unknown_libname_11(int a1, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 == 1 )
    return -1;
  if ( v2 == 15 )
    ValidateRect(*(HWND *)a2, 0);
  return 0;
}


// ========== Function: ?_AfxMsgFilterHook@@YGJHIJ@Z @ 0x41C35B ==========
LRESULT __stdcall _AfxMsgFilterHook(int code, WPARAM wParam, LPARAM lParam)
{
  struct CWinThread *Thread; // eax
  struct CNoTrackObject *Data; // eax

  if ( !*((_BYTE *)AfxGetModuleState() + 20) && code >= 0 )
  {
    Thread = AfxGetThread();
    if ( Thread )
      return (*(int (__thiscall **)(struct CWinThread *, int, LPARAM))(*(_DWORD *)Thread + 112))(Thread, code, lParam);
  }
  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return CallNextHookEx(*((HHOOK *)Data + 12), code, wParam, lParam);
}


// ========== Function: ?IsHelpKey@@YGHPAUtagMSG@@@Z @ 0x41C3B3 ==========
BOOL __stdcall IsHelpKey(struct tagMSG *a1)
{
  return a1->message == 256
      && a1->wParam == 112
      && (a1->lParam & 0x40000000) == 0
      && GetKeyState(16) >= 0
      && GetKeyState(17) >= 0
      && GetKeyState(18) >= 0;
}


// ========== Function: sub_41C3FE @ 0x41C3FE ==========
int __thiscall sub_41C3FE(_DWORD *this, int a2, struct tagMSG *a3)
{
  int v3; // eax
  CFrameWnd *v4; // eax
  CFrameWnd *v5; // edi
  int v6; // eax
  UINT message; // ecx
  int v8; // eax
  int v9; // edi
  UINT v10; // eax
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v12; // ebx
  _DWORD *v13; // esi
  _BYTE v15[28]; // [esp+Ch] [ebp-20h] BYREF
  _DWORD *v16; // [esp+28h] [ebp-4h]

  v16 = this;
  if ( !a3 )
    return 0;
  if ( a2 )
  {
    if ( a2 != 2 )
      return 0;
    v3 = sub_41D866(a3->hwnd);
    if ( v3 )
    {
      v4 = (CFrameWnd *)sub_41ED60(v3);
      v5 = v4;
      if ( v4 )
      {
        if ( CFrameWnd::IsTracking(v4) )
        {
          if ( *((_DWORD *)v5 + 20) )
          {
            v6 = sub_404EA0();
            if ( v16[7] )
            {
              if ( (message = a3->message, message == 256) && a3->wParam == 13 || message == 514 )
              {
                SendMessageA(*(HWND *)(v6 + 28), 0x111u, 0xE146u, 0);
                return 1;
              }
            }
          }
        }
      }
    }
  }
  v8 = sub_404EA0();
  v9 = v8;
  if ( (unsigned int)dword_4392CC < 0x333 && v8 && IsHelpKey(a3) )
  {
    SendMessageA(*(HWND *)(v9 + 28), 0x111u, 0xE146u, 0);
    return 1;
  }
  if ( !a2 )
  {
    if ( v16[8] )
    {
      v10 = a3->message;
      if ( v10 >= 0x100 && v10 <= 0x108 )
      {
        Data = CThreadLocalObject::GetData(
                 (CThreadLocalObject *)&unk_438D7C,
                 CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
        v12 = Data;
        if ( !*((_DWORD *)Data + 47) )
        {
          *((_DWORD *)Data + 47) = 1;
          qmemcpy(v15, a3, sizeof(v15));
          v13 = v16;
          if ( sub_420619(v16[8]) && (*(int (__thiscall **)(_DWORD *, _BYTE *))(*v13 + 88))(v13, v15) )
          {
            *((_DWORD *)v12 + 47) = 0;
            return 1;
          }
          *((_DWORD *)v12 + 47) = 0;
        }
      }
    }
  }
  return 0;
}


// ========== Function: ?GetMainWnd@CWinThread@@UAEPAVCWnd@@XZ @ 0x41C548 ==========
struct CWnd *__thiscall CWinThread::GetMainWnd(CWinThread *this)
{
  struct CWnd *result; // eax
  HWND ActiveWindow; // eax

  result = (struct CWnd *)*((_DWORD *)this + 8);
  if ( !result )
  {
    result = (struct CWnd *)*((_DWORD *)this + 7);
    if ( !result )
    {
      ActiveWindow = GetActiveWindow();
      return (struct CWnd *)sub_41D866(ActiveWindow);
    }
  }
  return result;
}


// ========== Function: sub_41C563 @ 0x41C563 ==========
BOOL __thiscall sub_41C563(char *this)
{
  const MSG *v2; // edi
  BOOL result; // eax

  v2 = (const MSG *)(this + 48);
  result = GetMessageA((LPMSG)(this + 48), 0, 0, 0);
  if ( result )
  {
    if ( *((_DWORD *)this + 13) != 874 && !(*(int (__thiscall **)(char *, const MSG *))(*(_DWORD *)this + 88))(this, v2) )
    {
      TranslateMessage(v2);
      DispatchMessageA(v2);
    }
    return 1;
  }
  return result;
}


// ========== Function: sub_41C5A3 @ 0x41C5A3 ==========
_DWORD *__thiscall sub_41C5A3(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 1;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 1;
  this[6] = 0;
  return result;
}


// ========== Function: sub_41C5BD @ 0x41C5BD ==========
int __thiscall sub_41C5BD(_DWORD *this)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = this[4];
  v2 = this + 4;
  if ( result )
    return (*(int (__thiscall **)(_DWORD *, _DWORD *))(result + 28))(v2, this);
  return result;
}


// ========== Function: sub_41C5E8 @ 0x41C5E8 ==========
int __stdcall sub_41C5E8(
        int a1,
        int a2,
        int a3,
        int (__thiscall *a4)(_DWORD, _DWORD),
        _DWORD *a5,
        unsigned int a6,
        _DWORD *a7)
{
  BOOL v7; // ebx
  _DWORD *v10; // esi

  v7 = 1;
  if ( !a7 )
  {
    if ( a6 <= 0x28 )
    {
      switch ( a6 )
      {
        case 0x28u:
          ((void (__thiscall *)(int, int, _DWORD, _DWORD))a4)(a1, a2, a5[1], *a5);
          return v7;
        case 2u:
          return a4(a1, a2);
        case 0xCu:
          ((void (__thiscall *)(int))a4)(a1);
          return v7;
        case 0xDu:
          a4(a1, a2);
          return v7;
        case 0x23u:
          return ((int (__thiscall *)(int))a4)(a1);
        case 0x26u:
          ((void (__thiscall *)(int, _DWORD, _DWORD))a4)(a1, a5[1], *a5);
          return v7;
        case 0x27u:
          return ((int (__thiscall *)(int, _DWORD, _DWORD))a4)(a1, a5[1], *a5);
      }
      return 0;
    }
    switch ( a6 )
    {
      case ')':
        return ((int (__thiscall *)(int, int, _DWORD, _DWORD))a4)(a1, a2, a5[1], *a5);
      case ',':
        v10 = a5;
        a4(a1, a5);
        break;
      case '-':
        v10 = a5;
        ((void (__thiscall *)(int, _DWORD *, int))a4)(a1, a5, a2);
        break;
      case '.':
        a4(a1, a5);
        return v7;
      case '/':
        return a4(a1, a5);
      default:
        return 0;
    }
    v7 = v10[7] == 0;
    v10[7] = 0;
    return v7;
  }
  *a7 = a1;
  a7[1] = a4;
  return v7;
}


// ========== Function: sub_41C6EF @ 0x41C6EF ==========
int __thiscall sub_41C6EF(void *this, int a2, unsigned int a3, _DWORD *Buf1, _DWORD *a5)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  _DWORD *v9; // edi
  int i; // esi
  int v11; // eax
  unsigned int v12; // ebx
  _DWORD *j; // esi
  int v14; // eax
  int v15; // [esp+18h] [ebp+Ch]
  void *Buf1a; // [esp+1Ch] [ebp+10h]

  if ( a3 == -2 )
  {
    ModuleState = AfxGetModuleState();
    return (*(int (__thiscall **)(_DWORD, void *, int, _DWORD *, _DWORD *))(**((_DWORD **)ModuleState + 1038) + 4))(
             *((_DWORD *)ModuleState + 1038),
             this,
             a2,
             Buf1,
             a5);
  }
  if ( a3 == -3 )
  {
    v15 = 0;
    Buf1a = (void *)Buf1[12];
    v9 = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 44))(this);
LABEL_5:
    if ( v9 && !v15 )
    {
      for ( i = v9[1]; ; i += 12 )
      {
        v11 = *(_DWORD *)(i + 4);
        if ( !v11 || !*(_DWORD *)(i + 8) || v15 )
        {
          v9 = (_DWORD *)*v9;
          goto LABEL_5;
        }
        if ( a2 == v11 )
        {
          if ( Buf1a )
          {
            if ( *(_DWORD *)i && !memcmp(Buf1a, *(const void **)i, 0x10u) )
            {
LABEL_17:
              v15 = 1;
              Buf1[1] = *(_DWORD *)(i + 8);
              continue;
            }
          }
          else if ( !*(_DWORD *)i )
          {
            goto LABEL_17;
          }
        }
      }
    }
    return v15;
  }
  else
  {
    if ( a3 == -1 || (v12 = HIWORD(a3), a3 = (unsigned __int16)a3, !v12) )
      v12 = 273;
    for ( j = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 40))(this); j; j = (_DWORD *)*j )
    {
      v14 = unknown_libname_16(j[1], v12, a3, a2);
      if ( v14 )
        return sub_41C5E8(
                 (int)this,
                 a2,
                 a3,
                 *(int (__thiscall **)(_DWORD, _DWORD))(v14 + 20),
                 Buf1,
                 *(_DWORD *)(v14 + 16),
                 a5);
    }
    return 0;
  }
}


// ========== Function: sub_41C7FE @ 0x41C7FE ==========
int __stdcall sub_41C7FE(int a1)
{
  return 1;
}


// ========== Function: ?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z @ 0x41C804 ==========
int __thiscall CCmdTarget::GetTypeLib(CCmdTarget *this, unsigned int a2, struct ITypeLib **a3)
{
  return -2147312566;
}


// ========== Function: sub_41C80C @ 0x41C80C ==========
int sub_41C80C()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)ModuleState + 1) + 144))(*((_DWORD *)ModuleState + 1), 1);
}


// ========== Function: sub_41C821 @ 0x41C821 ==========
int sub_41C821()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)ModuleState + 1) + 144))(*((_DWORD *)ModuleState + 1), -1);
}


// ========== Function: sub_41C836 @ 0x41C836 ==========
void *sub_41C836()
{
  return &unk_429C28;
}


// ========== Function: sub_41C83C @ 0x41C83C ==========
void *sub_41C83C()
{
  return &unk_429C48;
}


// ========== Function: sub_41C842 @ 0x41C842 ==========
void *sub_41C842()
{
  return &unk_429C78;
}


// ========== Function: sub_41C848 @ 0x41C848 ==========
void *sub_41C848()
{
  return &unk_429CB0;
}


// ========== Function: sub_41C84E @ 0x41C84E ==========
void __thiscall sub_41C84E(void *this)
{
  CTypeLibCache *v2; // eax

  sub_4250E4(13);
  v2 = (CTypeLibCache *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
  if ( v2 )
    CTypeLibCache::Unlock(v2);
  AfxUnlockGlobals(13);
  if ( this )
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 4))(this, 1);
}


// ========== Function: sub_41C880 @ 0x41C880 ==========
int __stdcall sub_41C880(int a1)
{
  return 0;
}


// ========== Function: sub_41C885 @ 0x41C885 ==========
void *sub_41C885()
{
  return &unk_429CC8;
}


// ========== Function: sub_41C88B @ 0x41C88B ==========
void *sub_41C88B()
{
  return &unk_429CD8;
}


// ========== Function: ??0CCmdUI@@QAE@XZ @ 0x41C891 ==========
CCmdUI *__thiscall CCmdUI::CCmdUI(CCmdUI *this)
{
  CCmdUI *result; // eax

  result = this;
  *(_DWORD *)this = &off_429CF0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 6) = 0;
  return result;
}


// ========== Function: sub_41C8B7 @ 0x41C8B7 ==========
int __thiscall sub_41C8B7(int this, int a2)
{
  int result; // eax
  UINT v4; // ecx
  int v5; // edi
  HWND Parent; // eax
  int v7; // eax
  HWND v8; // ecx
  HWND NextDlgTabItem; // eax
  int v10; // eax

  result = *(_DWORD *)(this + 12);
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
      return result;
    v4 = a2 != 0 ? 0 : 3;
    BYTE1(v4) |= 4u;
    result = EnableMenuItem(*(HMENU *)(result + 4), *(_DWORD *)(this + 8), v4);
  }
  else
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 20);
      if ( GetFocus() == *(HWND *)(v5 + 28) )
      {
        Parent = GetParent(*(HWND *)(v5 + 28));
        v7 = sub_41D866(Parent);
        v8 = *(HWND *)(this + 20);
        if ( v8 )
          v8 = (HWND)*((_DWORD *)v8 + 7);
        NextDlgTabItem = GetNextDlgTabItem(*(HWND *)(v7 + 28), v8, 0);
        v10 = sub_41D866(NextDlgTabItem);
        sub_42065B(v10);
      }
    }
    result = CWnd::ShowWindow(*(CWnd **)(this + 20), a2);
  }
  *(_DWORD *)(this + 24) = 1;
  return result;
}


// ========== Function: ?SetCheck@CCmdUI@@UAEXH@Z @ 0x41C947 ==========
void __thiscall CCmdUI::SetCheck(CCmdUI *this, WPARAM wParam)
{
  int v3; // eax
  UINT v4; // ecx

  v3 = *((_DWORD *)this + 3);
  if ( v3 )
  {
    if ( !*((_DWORD *)this + 4) )
    {
      v4 = wParam != 0 ? 8 : 0;
      BYTE1(v4) |= 4u;
      CheckMenuItem(*(HMENU *)(v3 + 4), *((_DWORD *)this + 2), v4);
    }
  }
  else if ( (SendMessageA(*(HWND *)(*((_DWORD *)this + 5) + 28), 0x87u, 0, 0) & 0x2000) != 0 )
  {
    SendMessageA(*(HWND *)(*((_DWORD *)this + 5) + 28), 0xF1u, wParam, 0);
  }
}


// ========== Function: sub_41C9A9 @ 0x41C9A9 ==========
void __thiscall sub_41C9A9(UINT *this, int a2)
{
  (*(void (__thiscall **)(UINT *, bool))(*this + 4))(this, a2 != 0);
  if ( this[3] )
  {
    if ( !this[4] )
    {
      if ( hBitmapChecked || (_AfxLoadDotBitmap(), hBitmapChecked) )
        SetMenuItemBitmaps(*(HMENU *)(this[3] + 4), this[2], 0x400u, 0, hBitmapChecked);
    }
  }
}


// ========== Function: sub_41C9FF @ 0x41C9FF ==========
void __thiscall sub_41C9FF(UINT_PTR *this, LPCSTR lpNewItem)
{
  UINT_PTR v3; // eax
  UINT MenuState; // eax

  v3 = this[3];
  if ( v3 )
  {
    if ( !this[4] )
    {
      MenuState = GetMenuState(*(HMENU *)(v3 + 4), this[2], 0x400u);
      LOWORD(MenuState) = MenuState & 0xF6FB;
      ModifyMenuA(*(HMENU *)(this[3] + 4), this[2], MenuState | 0x400, this[1], lpNewItem);
    }
  }
  else
  {
    AfxSetWindowText(*(HWND *)(this[5] + 28), lpNewItem);
  }
}


// ========== Function: sub_41CA56 @ 0x41CA56 ==========
// attributes: thunk
void __noreturn sub_41CA56()
{
  sub_41B4F7();
}


// ========== Function: ?AfxSetNewHandler@@YGP6AHI@ZP6AHI@Z@Z @ 0x41CA5E ==========
void (__noreturn *__stdcall AfxSetNewHandler(void (__noreturn *a1)()))()
{
  void (__noreturn *result)(); // eax

  result = off_4334A0;
  off_4334A0 = a1;
  return result;
}


// ========== Function: sub_41CA70 @ 0x41CA70 ==========
void *__cdecl sub_41CA70(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 && off_4334A0 )
    off_4334A0();
  return v1;
}


// ========== Function: sub_41CA99 @ 0x41CA99 ==========
void __cdecl sub_41CA99(LPVOID lpMem)
{
  sub_40D386(lpMem);
}


// ========== Function: DialogFunc @ 0x41CAA4 ==========
INT_PTR __stdcall DialogFunc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
  struct CObject *v4; // eax
  struct CObject *v5; // eax

  if ( a2 != 272 )
    return 0;
  v4 = (struct CObject *)sub_41D88D(a1);
  v5 = AfxDynamicDownCast((struct CRuntimeClass *)&off_429D00, v4);
  if ( v5 )
    return (*(int (__thiscall **)(struct CObject *))(*(_DWORD *)v5 + 188))(v5);
  else
    return 1;
}


// ========== Function: sub_41CADE @ 0x41CADE ==========
_UNKNOWN ***sub_41CADE()
{
  return &off_429D20;
}


// ========== Function: ?PreTranslateMessage@CDialog@@UAEHPAUtagMSG@@@Z @ 0x41CAE4 ==========
int __thiscall CDialog::PreTranslateMessage(HWND *this, struct tagMSG *a2)
{
  int v3; // eax
  WPARAM wParam; // eax
  HWND DlgItem; // eax

  if ( CWnd::PreTranslateMessage((CWnd *)this, a2) )
    return 1;
  v3 = sub_41ED60(this);
  if ( v3 && *(_DWORD *)(v3 + 80) )
    return 0;
  if ( a2->message == 256 )
  {
    wParam = a2->wParam;
    if ( (wParam == 27 || wParam == 3) && (GetWindowLongA(a2->hwnd, -16) & 4) != 0 )
    {
      if ( _AfxCompareClassName(a2->hwnd, "Edit") )
      {
        DlgItem = GetDlgItem(this[7], 2);
        if ( !DlgItem || IsWindowEnabled(DlgItem) )
        {
          SendMessageA(this[7], 0x111u, 2u, 0);
          return 1;
        }
      }
    }
  }
  return CWnd::PreTranslateInput((CWnd *)this, a2);
}


// ========== Function: sub_41CB7D @ 0x41CB7D ==========
// ?OnCmdMsg@CPropertySheet@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
// doubtful name
BOOL __thiscall sub_41CB7D(HWND *this, unsigned int a2, unsigned int a3, _DWORD *Buf1, _DWORD *a5)
{
  HWND Parent; // eax
  int v7; // eax
  struct CWinThread *Thread; // eax
  BOOL result; // eax

  result = 1;
  if ( !sub_41C6EF(this, a2, a3, Buf1, a5) )
  {
    if ( a3 && a3 != -1 )
      return 0;
    if ( (a2 & 0x8000) == 0 || a2 >= 0xF000 )
      return 0;
    Parent = GetParent(this[7]);
    v7 = sub_41D866(Parent);
    if ( !v7
      || !(*(int (__thiscall **)(int, unsigned int, unsigned int, _DWORD *, _DWORD *))(*(_DWORD *)v7 + 12))(
            v7,
            a2,
            a3,
            Buf1,
            a5) )
    {
      Thread = AfxGetThread();
      if ( !Thread
        || !(*(int (__thiscall **)(struct CWinThread *, unsigned int, unsigned int, _DWORD *, _DWORD *))(*(_DWORD *)Thread + 12))(
              Thread,
              a2,
              a3,
              Buf1,
              a5) )
      {
        return 0;
      }
    }
  }
  return result;
}


// ========== Function: sub_41CC02 @ 0x41CC02 ==========
LPVOID __thiscall sub_41CC02(LPVOID lpMem, char a2)
{
  sub_41CC1E(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_41CC1E @ 0x41CC1E ==========
void __thiscall sub_41CC1E(CWnd *this)
{
  *(_DWORD *)this = &CDialog::`vftable';
  if ( *((_DWORD *)this + 7) )
    sub_41E0B1();
  CWnd::~CWnd(this);
}


// ========== Function: sub_41CC5C @ 0x41CC5C ==========
BOOL __thiscall sub_41CC5C(struct CWnd *this, LPCDLGTEMPLATEA lpTemplate, int a3, HINSTANCE hInstance)
{
  int v5; // edi
  HWND v7; // eax
  int v8; // [esp+0h] [ebp-4Ch] BYREF
  _BYTE v9[12]; // [esp+Ch] [ebp-40h] BYREF
  _BYTE v10[8]; // [esp+18h] [ebp-34h] BYREF
  int v11; // [esp+24h] [ebp-28h]
  struct CWnd *v12; // [esp+28h] [ebp-24h]
  unsigned __int16 v13[2]; // [esp+2Ch] [ebp-20h] BYREF
  unsigned __int8 *Str1; // [esp+30h] [ebp-1Ch] BYREF
  HWND hWnd; // [esp+34h] [ebp-18h]
  HGLOBAL hMem; // [esp+38h] [ebp-14h]
  int *v17; // [esp+3Ch] [ebp-10h]
  int v18; // [esp+48h] [ebp-4h]

  v17 = &v8;
  v12 = this;
  if ( !hInstance )
    hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  v5 = *((_DWORD *)AfxGetModuleState() + 1038);
  v11 = v5;
  hMem = 0;
  hWnd = 0;
  v18 = 0;
  sub_41FB02(16);
  sub_41FB02(245760);
  if ( v5 )
  {
    if ( !(*(int (__thiscall **)(struct CWnd *, _BYTE *))(*(_DWORD *)this + 180))(this, v10) )
      return 0;
    lpTemplate = (LPCDLGTEMPLATEA)(*(int (__thiscall **)(int, _BYTE *, LPCDLGTEMPLATEA))(*(_DWORD *)v5 + 16))(
                                    v5,
                                    v10,
                                    lpTemplate);
  }
  if ( !lpTemplate )
    return 0;
  Str1 = (unsigned __int8 *)off_433548;
  LOBYTE(v18) = 1;
  *(_DWORD *)v13 = 0;
  if ( !CDialogTemplate::GetFont(lpTemplate, (struct CString *)&Str1, v13) )
    goto LABEL_15;
  if ( GetSystemMetrics(42)
    && (!_mbscmp(Str1, "MS Shell Dlg") || !_mbscmp(Str1, "MS Sans Serif") || !_mbscmp(Str1, "Helv")) )
  {
    if ( v13[0] == 8 )
      *(_DWORD *)v13 = 0;
LABEL_15:
    CDialogTemplate::CDialogTemplate((CDialogTemplate *)v9, lpTemplate);
    LOBYTE(v18) = 2;
    CDialogTemplate::SetSystemFont((CDialogTemplate *)v9, v13[0]);
    hMem = (HGLOBAL)ATL::CComPtrBase<ICustomDestinationList>::Detach(v9);
    LOBYTE(v18) = 1;
    Concurrency::details::UMSFreeVirtualProcessorRoot::InitialThreadParam::~InitialThreadParam((Concurrency::details::UMSFreeVirtualProcessorRoot::InitialThreadParam *)v9);
    if ( hMem )
      lpTemplate = (LPCDLGTEMPLATEA)GlobalLock(hMem);
  }
  *((_DWORD *)this + 11) = -1;
  *((_DWORD *)this + 9) |= 0x10u;
  AfxHookWindowCreate(this);
  if ( a3 )
    v7 = *(HWND *)(a3 + 28);
  else
    v7 = 0;
  hWnd = CreateDialogIndirectParamA(hInstance, lpTemplate, v7, DialogFunc, 0);
  LOBYTE(v18) = 0;
  sub_4200DD(&Str1);
  v18 = -1;
  if ( v5 )
  {
    (*(void (__thiscall **)(int, _BYTE *))(*(_DWORD *)v5 + 20))(v5, v10);
    if ( hWnd )
      (*(void (__thiscall **)(struct CWnd *, _DWORD))(*(_DWORD *)this + 180))(this, 0);
  }
  if ( !AfxUnhookWindowCreate() )
    (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
  if ( hWnd && (*((_BYTE *)this + 36) & 0x10) == 0 )
  {
    DestroyWindow(hWnd);
    hWnd = 0;
  }
  if ( hMem )
  {
    GlobalUnlock(hMem);
    GlobalFree(hMem);
  }
  return hWnd != 0;
}


// ========== Function: ?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z @ 0x41CE7E ==========
int __thiscall CDialog::SetOccDialogInfo(CDialog *this, struct _AFX_OCC_DIALOG_INFO *a2)
{
  *((_DWORD *)this + 22) = a2;
  return 1;
}


// ========== Function: ??0CDialog@@QAE@IPAVCWnd@@@Z @ 0x41CE8B ==========
CDialog *__thiscall CDialog::CDialog(CDialog *this, unsigned int a2, struct CWnd *a3)
{
  sub_41D43B(this);
  *(_DWORD *)this = &CDialog::`vftable';
  memset((char *)this + 60, 0, 0x20u);
  *((_DWORD *)this + 20) = a3;
  *((_DWORD *)this + 15) = a2;
  *((_DWORD *)this + 16) = (unsigned __int16)a2;
  return this;
}


// ========== Function: sub_41CEC4 @ 0x41CEC4 ==========
int __thiscall sub_41CEC4(struct CWnd *this)
{
  HWND v2; // eax
  int v3; // edi

  if ( *((_DWORD *)AfxGetModuleState() + 1) )
    sub_42310D(0);
  v2 = (HWND)*((_DWORD *)this + 20);
  if ( v2 )
    v2 = (HWND)*((_DWORD *)v2 + 7);
  v3 = sub_4232B3(v2, (int)this + 84);
  AfxHookWindowCreate(this);
  return v3;
}


// ========== Function: ?PostModal@CDialog@@IAEXXZ @ 0x41CEFE ==========
void __thiscall CDialog::PostModal(HWND *this)
{
  AfxUnhookWindowCreate();
  sub_41D8E4(this);
  if ( IsWindow(this[21]) )
    EnableWindow(this[21], 1);
  this[21] = 0;
  if ( *((_DWORD *)AfxGetModuleState() + 1) )
    sub_42310D(1);
}


// ========== Function: sub_41CF40 @ 0x41CF40 ==========
int __thiscall sub_41CF40(int this)
{
  HGLOBAL Resource; // edi
  HINSTANCE v3; // ebx
  HRSRC ResourceA; // eax
  int v6; // eax
  unsigned int v7; // ebx
  int v8; // [esp+0h] [ebp-30h] BYREF
  int v9; // [esp+10h] [ebp-20h]
  int v10; // [esp+14h] [ebp-1Ch]
  LPCDLGTEMPLATEA lpTemplate; // [esp+18h] [ebp-18h]
  HWND hWnd; // [esp+1Ch] [ebp-14h]
  int *v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v13 = &v8;
  v10 = this;
  Resource = *(HGLOBAL *)(this + 68);
  lpTemplate = *(LPCDLGTEMPLATEA *)(this + 72);
  v3 = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 3);
  if ( *(_DWORD *)(this + 64) )
  {
    v3 = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 3);
    ResourceA = FindResourceA(v3, *(LPCSTR *)(this + 64), (LPCSTR)5);
    Resource = LoadResource(v3, ResourceA);
  }
  if ( Resource )
    lpTemplate = (LPCDLGTEMPLATEA)LockResource(Resource);
  if ( !lpTemplate )
    return -1;
  hWnd = (HWND)sub_41CEC4((struct CWnd *)this);
  AfxUnhookWindowCreate();
  v9 = 0;
  if ( hWnd && IsWindowEnabled(hWnd) )
  {
    EnableWindow(hWnd, 0);
    v9 = 1;
  }
  v14 = 0;
  AfxHookWindowCreate((struct CWnd *)this);
  v6 = sub_41D866(hWnd);
  if ( sub_41CC5C((struct CWnd *)this, lpTemplate, v6, v3) )
  {
    if ( (*(_BYTE *)(this + 36) & 0x10) != 0 )
    {
      v7 = 4;
      if ( (sub_4204BD(this) & 0x100) != 0 )
        v7 = 5;
      CWnd::RunModalLoop((CWnd *)this, v7);
    }
    if ( *(_DWORD *)(this + 28) )
      CWnd::SetWindowPos((CWnd *)this, 0, 0, 0, 0, 0, 0x97u);
  }
  v14 = -1;
  if ( v9 )
    EnableWindow(hWnd, 1);
  if ( hWnd )
  {
    if ( GetActiveWindow() == *(HWND *)(this + 28) )
      SetActiveWindow(hWnd);
  }
  (*(void (__thiscall **)(int))(*(_DWORD *)this + 88))(this);
  CDialog::PostModal((HWND *)this);
  return *(_DWORD *)(this + 44);
}


// ========== Function: sub_41D0A0 @ 0x41D0A0 ==========
BOOL __thiscall sub_41D0A0(void *this, INT_PTR nResult)
{
  if ( (*((_BYTE *)this + 36) & 0x18) != 0 )
    (*(void (__thiscall **)(void *, INT_PTR))(*(_DWORD *)this + 116))(this, nResult);
  return EndDialog(*((HWND *)this + 7), nResult);
}


// ========== Function: nullsub_11 @ 0x41D0E7 ==========
void nullsub_11()
{
  ;
}


// ========== Function: sub_41D170 @ 0x41D170 ==========
int sub_41D170()
{
  int v1; // eax
  struct AFX_MODULE_STATE *ModuleState; // eax
  _BYTE v3[8]; // [esp+8h] [ebp-8h] BYREF

  if ( !*((_DWORD *)AfxGetModuleState() + 1) )
    return 0;
  v1 = sub_404EA0();
  if ( v1 && (*(int (__thiscall **)(int, int, _DWORD, _DWORD, _BYTE *))(*(_DWORD *)v1 + 12))(v1, 57670, 0, 0, v3) )
    return 1;
  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int, _DWORD, _DWORD, _BYTE *))(**((_DWORD **)ModuleState + 1) + 12))(
           *((_DWORD *)ModuleState + 1),
           57670,
           0,
           0,
           v3);
}


// ========== Function: ?OnInitDialog@CDialog@@UAEHXZ @ 0x41D1C6 ==========
int __thiscall CDialog::OnInitDialog(CDialog *this)
{
  int v2; // eax
  int v4; // eax

  if ( *((_DWORD *)this + 19) )
    v2 = sub_41F7BE(*((_DWORD *)this + 19));
  else
    v2 = CWnd::ExecuteDlgInit(this, *((const char **)this + 16));
  if ( v2 && sub_41F4FD(0) )
  {
    if ( sub_420432(57670) )
    {
      v4 = sub_41D170();
      sub_4205F2(v4 != 0 ? 5 : 0);
    }
    return 1;
  }
  else
  {
    sub_41D0A0(this, -1);
    return 0;
  }
}


// ========== Function: ?OnOK@CDialog@@MAEXXZ @ 0x41D22B ==========
void __thiscall CDialog::OnOK(CDialog *this)
{
  if ( sub_41F4FD(1) )
    sub_41D0A0(this, 1);
}


// ========== Function: sub_41D244 @ 0x41D244 ==========
BOOL __thiscall sub_41D244(void *this)
{
  return sub_41D0A0(this, 2);
}


// ========== Function: sub_41D24C @ 0x41D24C ==========
BOOL __thiscall sub_41D24C(int this)
{
  _DWORD *v2; // esi
  HGLOBAL Resource; // eax
  HMODULE v4; // ebx
  HRSRC ResourceA; // eax
  BOOL result; // eax
  int v7; // ecx
  __int16 v8; // ax
  __int16 v9; // si

  v2 = *(_DWORD **)(this + 72);
  Resource = *(HGLOBAL *)(this + 68);
  if ( *(_DWORD *)(this + 64) )
  {
    v4 = (HMODULE)*((_DWORD *)AfxGetModuleState() + 3);
    ResourceA = FindResourceA(v4, *(LPCSTR *)(this + 64), (LPCSTR)5);
    Resource = LoadResource(v4, ResourceA);
  }
  if ( Resource )
    v2 = LockResource(Resource);
  result = 1;
  if ( v2 )
  {
    v7 = *v2;
    if ( HIWORD(*v2) == 0xFFFF )
    {
      v7 = v2[3];
      v8 = *((_WORD *)v2 + 9);
      v9 = *((_WORD *)v2 + 10);
    }
    else
    {
      v8 = *((_WORD *)v2 + 5);
      v9 = *((_WORD *)v2 + 6);
    }
    return (v7 & 0x1801) == 0 && !v8 && !v9;
  }
  return result;
}


// ========== Function: ?OnHelpHitTest@CDialog@@IAEJIJ@Z @ 0x41D31A ==========
int __thiscall CDialog::OnHelpHitTest(CDialog *this, unsigned int a2, int a3)
{
  int v3; // eax

  v3 = *((_DWORD *)this + 15);
  if ( v3 )
    return v3 + 0x20000;
  else
    return 0;
}


// ========== Function: sub_41D32D @ 0x41D32D ==========
// attributes: thunk
int sub_41D32D()
{
  return sub_41D332();
}


// ========== Function: sub_41D332 @ 0x41D332 ==========
UINT sub_41D332()
{
  UINT result; // eax

  result = RegisterWindowMessageA("commctrl_DragListMsg");
  dword_438CAC = result;
  return result;
}


// ========== Function: sub_41D343 @ 0x41D343 ==========
int sub_41D343()
{
  sub_41D34D();
  return atexit(unknown_libname_12);
}


// ========== Function: sub_41D34D @ 0x41D34D ==========
int sub_41D34D()
{
  return sub_41D479(0);
}


// ========== Function: unknown_libname_12 @ 0x41D366 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_12()
{
  if ( (byte_438C6C & 1) == 0 )
  {
    byte_438C6C |= 1u;
    CWnd::~CWnd((CWnd *)&unk_438C70);
  }
}


// ========== Function: sub_41D381 @ 0x41D381 ==========
int sub_41D381()
{
  sub_41D38B();
  return atexit(unknown_libname_13);
}


// ========== Function: sub_41D38B @ 0x41D38B ==========
int sub_41D38B()
{
  return sub_41D479(1);
}


// ========== Function: unknown_libname_13 @ 0x41D3A4 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_13()
{
  if ( (byte_438C6C & 2) == 0 )
  {
    byte_438C6C |= 2u;
    CWnd::~CWnd((CWnd *)&unk_438C30);
  }
}


// ========== Function: sub_41D3BF @ 0x41D3BF ==========
int sub_41D3BF()
{
  sub_41D3C9();
  return atexit(unknown_libname_14);
}


// ========== Function: sub_41D3C9 @ 0x41D3C9 ==========
int sub_41D3C9()
{
  return sub_41D479(-1);
}


// ========== Function: unknown_libname_14 @ 0x41D3E2 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_14()
{
  if ( (byte_438C6C & 4) == 0 )
  {
    byte_438C6C |= 4u;
    CWnd::~CWnd((CWnd *)&unk_438BF0);
  }
}


// ========== Function: sub_41D3FD @ 0x41D3FD ==========
int sub_41D3FD()
{
  sub_41D407();
  return atexit(unknown_libname_15);
}


// ========== Function: sub_41D407 @ 0x41D407 ==========
int sub_41D407()
{
  return sub_41D479(-2);
}


// ========== Function: unknown_libname_15 @ 0x41D420 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_15()
{
  if ( (byte_438C6C & 8) == 0 )
  {
    byte_438C6C |= 8u;
    CWnd::~CWnd((CWnd *)&unk_438BB0);
  }
}


// ========== Function: sub_41D43B @ 0x41D43B ==========
_DWORD *__thiscall sub_41D43B(_DWORD *this)
{
  sub_41C5A3(this);
  *this = &CWnd::`vftable';
  memset(this + 7, 0, 0x20u);
  return this;
}


// ========== Function: sub_41D45D @ 0x41D45D ==========
CWnd *__thiscall sub_41D45D(CWnd *lpMem, char a2)
{
  CWnd::~CWnd(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_41D479 @ 0x41D479 ==========
_DWORD *__thiscall sub_41D479(_DWORD *this, int a2)
{
  sub_41C5A3(this);
  *this = &CWnd::`vftable';
  memset(this + 7, 0, 0x20u);
  this[7] = a2;
  return this;
}


// ========== Function: ?_AfxModifyStyle@@YGHPAUHWND__@@HKKI@Z @ 0x41D4A5 ==========
int __stdcall _AfxModifyStyle(HWND hWnd, int nIndex, unsigned int a3, unsigned int a4, UINT a5)
{
  LONG WindowLongA; // eax
  UINT v7; // eax

  WindowLongA = GetWindowLongA(hWnd, nIndex);
  if ( WindowLongA == (a4 | WindowLongA & ~a3) )
    return 0;
  SetWindowLongA(hWnd, nIndex, a4 | WindowLongA & ~a3);
  v7 = a5;
  if ( a5 )
  {
    LOBYTE(v7) = a5 | 0x17;
    SetWindowPos(hWnd, 0, 0, 0, 0, 0, v7);
  }
  return 1;
}


// ========== Function: ?ModifyStyle@CWnd@@SGHPAUHWND__@@KKI@Z @ 0x41D4F4 ==========
int __stdcall CWnd::ModifyStyle(HWND hWnd, unsigned int a2, unsigned int a3, UINT a4)
{
  return _AfxModifyStyle(hWnd, -16, a2, a3, a4);
}


// ========== Function: ?ModifyStyleEx@CWnd@@SGHPAUHWND__@@KKI@Z @ 0x41D50E ==========
int __stdcall CWnd::ModifyStyleEx(HWND hWnd, unsigned int a2, unsigned int a3, UINT a4)
{
  return _AfxModifyStyle(hWnd, -20, a2, a3, a4);
}


// ========== Function: ?_AfxPreInitDialog@@YGXPAVCWnd@@PAUtagRECT@@PAK@Z @ 0x41D528 ==========
void __stdcall _AfxPreInitDialog(HWND *a1, LPRECT lpRect, unsigned int *a3)
{
  GetWindowRect(a1[7], lpRect);
  *a3 = sub_4204BD(a1);
}


// ========== Function: ?_AfxPostInitDialog@@YGXPAVCWnd@@ABUtagRECT@@K@Z @ 0x41D54B ==========
void __stdcall _AfxPostInitDialog(HWND *a1, const struct tagRECT *a2, int a3)
{
  HWND Window; // eax
  int v4; // eax
  struct tagRECT Rect; // [esp+4h] [ebp-10h] BYREF

  if ( (a3 & 0x10000000) == 0 && (sub_4204BD(a1) & 0x50000000) == 0 )
  {
    GetWindowRect(a1[7], &Rect);
    if ( a2->left == Rect.left && a2->top == Rect.top )
    {
      Window = GetWindow(a1[7], 4u);
      v4 = sub_41D866(Window);
      if ( !v4 || !sub_420619(v4) )
      {
        if ( (*((int (__thiscall **)(HWND *))*a1 + 43))(a1) )
          CWnd::CenterWindow((CWnd *)a1, 0);
      }
    }
  }
}


// ========== Function: ?_AfxHandleActivate@@YGXPAVCWnd@@I0@Z @ 0x41D5C4 ==========
void __stdcall _AfxHandleActivate(LPARAM *a1, WPARAM wParam, struct CWnd *a3)
{
  int v3; // ebx
  LPARAM lParam; // [esp+Ch] [ebp-8h] BYREF
  int v5; // [esp+10h] [ebp-4h]

  if ( (sub_4204BD(a1) & 0x40000000) == 0 )
  {
    v3 = sub_41ED38(a1);
    if ( v3 != sub_41ED38(a3) )
    {
      lParam = a1[7];
      if ( a3 )
        v5 = *((_DWORD *)a3 + 7);
      else
        v5 = 0;
      SendMessageA(*(HWND *)(v3 + 28), 0x36Eu, wParam, (LPARAM)&lParam);
    }
  }
}


// ========== Function: ?_AfxHandleSetCursor@@YGHPAVCWnd@@II@Z @ 0x41D625 ==========
int __stdcall _AfxHandleSetCursor(struct CWnd *a1, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  HWND LastActivePopup; // eax
  int v5; // esi
  HWND ForegroundWindow; // eax

  if ( a2 != -2 || a3 != 513 && a3 != 519 && a3 != 516 )
    return 0;
  v3 = sub_41ED38(a1);
  if ( !v3 )
    return 0;
  LastActivePopup = GetLastActivePopup(*(HWND *)(v3 + 28));
  v5 = sub_41D866(LastActivePopup);
  if ( !v5 )
    return 0;
  ForegroundWindow = GetForegroundWindow();
  if ( v5 == sub_41D866(ForegroundWindow) || !sub_420619(v5) )
    return 0;
  SetForegroundWindow(*(HWND *)(v5 + 28));
  return 1;
}


// ========== Function: sub_41D69B @ 0x41D69B ==========
struct CWnd *__stdcall sub_41D69B(struct CWnd *a1, int a2, CException *a3, int a4, int a5)
{
  struct CNoTrackObject *Data; // ebx
  CException *v6; // esi
  int v8; // eax
  int v9; // ecx
  struct CWnd *result; // eax
  int v11; // [esp+0h] [ebp-4Ch] BYREF
  _BYTE v12[28]; // [esp+Ch] [ebp-40h] BYREF
  struct tagRECT Rect; // [esp+28h] [ebp-24h] BYREF
  struct CNoTrackObject *v14; // [esp+38h] [ebp-14h]
  int *v15; // [esp+3Ch] [ebp-10h]
  int v16; // [esp+48h] [ebp-4h]
  struct CWnd *v17; // [esp+54h] [ebp+8h]

  v15 = &v11;
  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v16 = 0;
  v14 = Data;
  qmemcpy(v12, (char *)Data + 52, sizeof(v12));
  v6 = a3;
  *((_DWORD *)Data + 13) = a2;
  *((_DWORD *)Data + 15) = a4;
  v8 = a5;
  *((_DWORD *)Data + 14) = v6;
  *((_DWORD *)Data + 16) = v8;
  if ( v6 == (CException *)2 )
  {
    v9 = *((_DWORD *)a1 + 13);
    if ( v9 )
      (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 92))(v9, 0);
  }
  a2 = 0;
  if ( v6 == (CException *)272 )
    _AfxPreInitDialog((HWND *)a1, &Rect, (unsigned int *)&a2);
  v17 = (struct CWnd *)(*(int (__thiscall **)(struct CWnd *, CException *, int, int))(*(_DWORD *)a1 + 152))(
                         a1,
                         v6,
                         a4,
                         a5);
  if ( v6 == (CException *)272 )
    _AfxPostInitDialog((HWND *)a1, &Rect, a2);
  result = v17;
  qmemcpy((char *)Data + 52, v12, 0x1Cu);
  return result;
}


// ========== Function: ?GetCurrentMessage@CWnd@@KGPBUtagMSG@@XZ @ 0x41D798 ==========
const struct tagMSG *__stdcall CWnd::GetCurrentMessage()
{
  struct CNoTrackObject *Data; // esi
  DWORD MessagePos; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  *((_DWORD *)Data + 17) = GetMessageTime();
  MessagePos = GetMessagePos();
  *((_DWORD *)Data + 18) = (__int16)MessagePos;
  *((_DWORD *)Data + 19) = SHIWORD(MessagePos);
  return (const struct tagMSG *)((char *)Data + 52);
}


// ========== Function: sub_41D7CD @ 0x41D7CD ==========
int __thiscall sub_41D7CD(void *this)
{
  struct CNoTrackObject *Data; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 160))(
           this,
           *((_DWORD *)Data + 14),
           *((_DWORD *)Data + 15),
           *((_DWORD *)Data + 16));
}


// ========== Function: ?afxMapHWND@@YAPAVCHandleMap@@H@Z @ 0x41D7F4 ==========
struct CHandleMap *__stdcall afxMapHWND(LPVOID lpMem)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // esi
  void (__noreturn *v2)(); // ebx
  int v3; // eax

  ModuleThreadState = AfxGetModuleThreadState();
  if ( !*((_DWORD *)ModuleThreadState + 5) && lpMem )
  {
    v2 = AfxSetNewHandler((void (__noreturn *)())AfxCriticalNewHandler);
    if ( sub_41CA70(0x48u) )
      v3 = sub_420EB7(&off_429FF8, 28, 1);
    else
      v3 = 0;
    *((_DWORD *)ModuleThreadState + 5) = v3;
    AfxSetNewHandler(v2);
  }
  return (struct CHandleMap *)*((_DWORD *)ModuleThreadState + 5);
}


// ========== Function: sub_41D866 @ 0x41D866 ==========
struct CObject *__stdcall sub_41D866(void *a1)
{
  CHandleMap *v1; // esi
  struct CObject *v2; // edi

  v1 = afxMapHWND((LPVOID)1);
  v2 = CHandleMap::FromHandle(v1, a1);
  sub_4206C5(v1);
  return v2;
}


// ========== Function: sub_41D88D @ 0x41D88D ==========
void *__stdcall sub_41D88D(void *a1)
{
  struct CHandleMap *v1; // ecx
  void *result; // eax

  v1 = afxMapHWND(0);
  result = 0;
  if ( v1 )
    return CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v1 + 4), (unsigned int)a1);
  return result;
}


// ========== Function: sub_41D8AB @ 0x41D8AB ==========
int __thiscall sub_41D8AB(_DWORD *this, unsigned int a2)
{
  struct CHandleMap *v4; // edi

  if ( !a2 )
    return 0;
  v4 = afxMapHWND((LPVOID)1);
  this[7] = a2;
  *sub_41BCFD((_DWORD *)v4 + 1, a2) = this;
  sub_4206C5(v4);
  return 1;
}


// ========== Function: sub_41D8E4 @ 0x41D8E4 ==========
unsigned int __thiscall sub_41D8E4(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[7];
  if ( v2 )
  {
    v3 = afxMapHWND(0);
    if ( v3 )
      sub_41BD4D((_DWORD *)v3 + 1, this[7]);
    this[7] = 0;
  }
  this[14] = 0;
  return v2;
}


// ========== Function: sub_41D912 @ 0x41D912 ==========
LRESULT __stdcall sub_41D912(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam)
{
  HWND *v5; // eax

  if ( Msg == (CException *)864 )
    return 1;
  v5 = (HWND *)sub_41D88D(hWnd);
  if ( v5 && v5[7] == hWnd )
    return (LRESULT)sub_41D69B((struct CWnd *)v5, (int)hWnd, Msg, wParam, lParam);
  else
    return DefWindowProcA(hWnd, (UINT)Msg, wParam, lParam);
}


// ========== Function: sub_41D95D @ 0x41D95D ==========
LRESULT (__stdcall *sub_41D95D())(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam)
{
  return sub_41D912;
}


// ========== Function: sub_41D963 @ 0x41D963 ==========
LRESULT __stdcall sub_41D963(HWND hWnd, UINT Msg, WPARAM wParam, unsigned int lParam)
{
  LRESULT (__stdcall *PropA)(HWND, UINT, WPARAM, LPARAM); // eax
  BOOL v5; // ebx
  HWND *v6; // esi
  ATOM AtomA; // ax
  struct CWnd *v9; // eax
  struct CWnd *v10; // esi
  LPARAM *v11; // eax
  int v12; // [esp+0h] [ebp-58h] BYREF
  struct tagRECT Rect; // [esp+28h] [ebp-30h] BYREF
  __int16 v14[2]; // [esp+3Ch] [ebp-1Ch] BYREF
  WNDPROC lpPrevWndFunc; // [esp+40h] [ebp-18h]
  LRESULT v16; // [esp+44h] [ebp-14h]
  int *v17; // [esp+48h] [ebp-10h]
  int v18; // [esp+54h] [ebp-4h]

  v17 = &v12;
  PropA = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))GetPropA(hWnd, "AfxOldWndProc423");
  v16 = 0;
  v18 = 0;
  lpPrevWndFunc = PropA;
  v5 = 1;
  switch ( Msg )
  {
    case 6u:
      v10 = sub_41D866((void *)lParam);
      v11 = (LPARAM *)sub_41D866(hWnd);
      _AfxHandleActivate(v11, wParam, v10);
LABEL_10:
      if ( !v5 )
        return v16;
      return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
    case 0x20u:
      v9 = sub_41D866(hWnd);
      v5 = _AfxHandleSetCursor(v9, (__int16)lParam, HIWORD(lParam)) == 0;
      goto LABEL_10;
    case 0x82u:
      SetWindowLongA(hWnd, -4, (LONG)lpPrevWndFunc);
      RemovePropA(hWnd, "AfxOldWndProc423");
      AtomA = GlobalFindAtomA("AfxOldWndProc423");
      GlobalDeleteAtom(AtomA);
      return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  if ( Msg != 272 )
    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  v6 = (HWND *)sub_41D866(hWnd);
  _AfxPreInitDialog(v6, &Rect, (unsigned int *)v14);
  v16 = CallWindowProcA(lpPrevWndFunc, hWnd, 0x110u, wParam, lParam);
  _AfxPostInitDialog(v6, &Rect, *(int *)v14);
  return v16;
}


// ========== Function: ?_AfxGrayBackgroundWndProc@@YGJPAUHWND__@@IIJ@Z @ 0x41DAC2 ==========
LRESULT __stdcall _AfxGrayBackgroundWndProc(HWND a1, UINT Msg, HDC hdc, HWND hWnd)
{
  int v4; // esi
  HBRUSH v5; // eax

  v4 = sub_424E45(sub_42429E);
  v5 = *(HBRUSH *)(v4 + 4);
  if ( v5
    && (Msg == 309 || Msg == 310 || Msg == 312 || Msg == 311 || Msg == 308)
    && CWnd::GrayCtlColor(hdc, hWnd, Msg - 306, v5, *(_DWORD *)(v4 + 8)) )
  {
    return *(_DWORD *)(v4 + 4);
  }
  else
  {
    return sub_41D963(a1, Msg, (WPARAM)hdc, (unsigned int)hWnd);
  }
}


// ========== Function: sub_41DB3E @ 0x41DB3E ==========
LRESULT __stdcall sub_41DB3E(int code, HWND wParam, int *lParam)
{
  struct CNoTrackObject *Data; // eax
  struct CWnd *v5; // esi
  int v6; // edi
  int v7; // eax
  CHAR *v9; // eax
  int v10; // edi
  BOOL v11; // esi
  LONG v12; // eax
  LRESULT (__stdcall *v13)(HWND, CException *, WPARAM, LPARAM); // esi
  struct CNoTrackObject *v14; // esi
  void *v15; // eax
  LRESULT v16; // edi
  CHAR Buffer[8]; // [esp+0h] [ebp-10h] BYREF
  int v18; // [esp+8h] [ebp-8h]
  struct CNoTrackObject *v19; // [esp+Ch] [ebp-4h]
  LRESULT (__stdcall *nCode)(HWND, CException *, WPARAM, LPARAM); // [esp+18h] [ebp+8h]
  HANDLE nCodea; // [esp+18h] [ebp+8h]
  LONG *wParama; // [esp+1Ch] [ebp+Ch]

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v19 = Data;
  if ( code != 3 )
    return CallNextHookEx(*((HHOOK *)Data + 11), code, (WPARAM)wParam, (LPARAM)lParam);
  v5 = (struct CWnd *)*((_DWORD *)Data + 5);
  v6 = *lParam;
  v7 = *((unsigned __int8 *)AfxGetModuleState() + 20);
  v18 = v7;
  if ( !v5 && ((*(_BYTE *)(v6 + 35) & 0x40) != 0 || v7) )
    goto LABEL_28;
  if ( dword_4392EC )
  {
    if ( (GetClassLongA(wParam, -26) & 0x10000) != 0 )
      goto LABEL_28;
    v9 = *(CHAR **)(v6 + 40);
    if ( !HIWORD(v9) )
    {
      Buffer[0] = 0;
      GlobalGetAtomNameA(*(_WORD *)(v6 + 40), Buffer, 5);
      v9 = Buffer;
    }
    if ( !lstrcmpiA(v9, "ime") )
      goto LABEL_28;
  }
  if ( !v5 )
  {
    nCodea = (HANDLE)GetWindowLongA(wParam, -4);
    if ( nCodea )
    {
      if ( !GetPropA(wParam, "AfxOldWndProc423") )
      {
        SetPropA(wParam, "AfxOldWndProc423", nCodea);
        if ( GetPropA(wParam, "AfxOldWndProc423") == nCodea )
        {
          GlobalAddAtomA("AfxOldWndProc423");
          v15 = _AfxGrayBackgroundWndProc;
          if ( !*((_DWORD *)v19 + 10) )
            v15 = sub_41D963;
          SetWindowLongA(wParam, -4, (LONG)v15);
        }
      }
    }
LABEL_28:
    v14 = v19;
    goto LABEL_29;
  }
  sub_41D8AB(v5, (unsigned int)wParam);
  (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)v5 + 80))(v5);
  wParama = (LONG *)(*(int (__thiscall **)(struct CWnd *))(*(_DWORD *)v5 + 128))(v5);
  if ( !dword_4392D4
    && !v18
    && (v10 = dword_4392E8) != 0
    && *(_DWORD *)(dword_4392E8 + 32)
    && (*(_DWORD *)Buffer = sub_41D69B(v5, (int)wParam, (CException *)0x36F, 0, 0)) != 0 )
  {
    nCode = sub_41D95D();
    v11 = nCode == (LRESULT (__stdcall *)(HWND, CException *, WPARAM, LPARAM))GetWindowLongA(wParam, -4);
    (*(void (__stdcall **)(HWND, _DWORD))(v10 + 32))(wParam, *(_DWORD *)Buffer);
    if ( !v11 )
    {
      v12 = SetWindowLongA(wParam, -4, (LONG)nCode);
LABEL_20:
      *wParama = v12;
    }
  }
  else
  {
    v13 = sub_41D95D();
    v12 = SetWindowLongA(wParam, -4, (LONG)v13);
    if ( (LRESULT (__stdcall *)(HWND, CException *, WPARAM, LPARAM))v12 != v13 )
      goto LABEL_20;
  }
  v14 = v19;
  *((_DWORD *)v19 + 5) = 0;
LABEL_29:
  v16 = CallNextHookEx(*((HHOOK *)v14 + 11), 3, (WPARAM)wParam, (LPARAM)lParam);
  if ( v18 )
  {
    UnhookWindowsHookEx(*((HHOOK *)v14 + 11));
    *((_DWORD *)v14 + 11) = 0;
  }
  return v16;
}


// ========== Function: ?AfxHookWindowCreate@@YGXPAVCWnd@@@Z @ 0x41DD34 ==========
void __stdcall AfxHookWindowCreate(struct CWnd *a1)
{
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v2; // esi
  DWORD CurrentThreadId; // eax
  HHOOK v4; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v2 = Data;
  if ( *((struct CWnd **)Data + 5) != a1 )
  {
    if ( !*((_DWORD *)Data + 11) )
    {
      CurrentThreadId = GetCurrentThreadId();
      v4 = SetWindowsHookExA(5, (HOOKPROC)sub_41DB3E, 0, CurrentThreadId);
      *((_DWORD *)v2 + 11) = v4;
      if ( !v4 )
        sub_41B4F7();
    }
    *((_DWORD *)v2 + 5) = a1;
  }
}


// ========== Function: ?AfxUnhookWindowCreate@@YGHXZ @ 0x41DD80 ==========
int __stdcall AfxUnhookWindowCreate()
{
  struct CNoTrackObject *Data; // esi

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  if ( *((_BYTE *)AfxGetModuleState() + 20) && *((_DWORD *)Data + 11) )
  {
    UnhookWindowsHookEx(*((HHOOK *)Data + 11));
    *((_DWORD *)Data + 11) = 0;
  }
  if ( !*((_DWORD *)Data + 5) )
    return 1;
  *((_DWORD *)Data + 5) = 0;
  return 0;
}


// ========== Function: sub_41DDC2 @ 0x41DDC2 ==========
BOOL __thiscall sub_41DDC2(
        struct CWnd *this,
        DWORD a2,
        const CHAR *a3,
        const CHAR *a4,
        DWORD a5,
        int a6,
        int a7,
        int a8,
        int a9,
        HWND a10,
        HMENU a11,
        void *a12)
{
  HWND Window; // edi
  LPVOID lpParam; // [esp+4h] [ebp-30h] BYREF
  HINSTANCE hInstance; // [esp+8h] [ebp-2Ch]
  HMENU hMenu; // [esp+Ch] [ebp-28h]
  HWND hWndParent; // [esp+10h] [ebp-24h]
  int nHeight; // [esp+14h] [ebp-20h]
  int nWidth; // [esp+18h] [ebp-1Ch]
  int Y; // [esp+1Ch] [ebp-18h]
  int X; // [esp+20h] [ebp-14h]
  DWORD dwStyle; // [esp+24h] [ebp-10h]
  LPCSTR lpWindowName; // [esp+28h] [ebp-Ch]
  LPCSTR lpClassName; // [esp+2Ch] [ebp-8h]
  DWORD dwExStyle; // [esp+30h] [ebp-4h]

  dwExStyle = a2;
  lpClassName = a3;
  lpWindowName = a4;
  dwStyle = a5;
  X = a6;
  Y = a7;
  nWidth = a8;
  nHeight = a9;
  hWndParent = a10;
  hMenu = a11;
  hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  lpParam = a12;
  if ( (*(int (__thiscall **)(struct CWnd *, LPVOID *))(*(_DWORD *)this + 92))(this, &lpParam) )
  {
    AfxHookWindowCreate(this);
    Window = CreateWindowExA(
               dwExStyle,
               lpClassName,
               lpWindowName,
               dwStyle,
               X,
               Y,
               nWidth,
               nHeight,
               hWndParent,
               hMenu,
               hInstance,
               lpParam);
    if ( !AfxUnhookWindowCreate() )
      (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
    return Window != 0;
  }
  else
  {
    (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
    return 0;
  }
}


// ========== Function: sub_41DE88 @ 0x41DE88 ==========
int __stdcall sub_41DE88(int a1)
{
  if ( !*(_DWORD *)(a1 + 40) )
  {
    sub_41FB02(1);
    *(_DWORD *)(a1 + 40) = "AfxWnd42s";
  }
  return 1;
}


// ========== Function: sub_41DEA8 @ 0x41DEA8 ==========
BOOL __thiscall sub_41DEA8(
        struct CWnd *this,
        const CHAR *a2,
        const CHAR *a3,
        int a4,
        int *a5,
        int a6,
        HMENU a7,
        void *a8)
{
  HWND v8; // edi

  if ( a6 )
    v8 = *(HWND *)(a6 + 28);
  else
    v8 = 0;
  return sub_41DDC2(this, 0, a2, a3, a4 | 0x40000000, *a5, a5[1], a5[2] - *a5, a5[3] - a5[1], v8, a7, a8);
}


// ========== Function: ??1CWnd@@UAE@XZ @ 0x41DEF4 ==========
void __thiscall CWnd::~CWnd(CWnd *this)
{
  int v2; // ecx
  int v3; // eax

  *(_DWORD *)this = &CWnd::`vftable';
  if ( *((_DWORD *)this + 7)
    && this != (CWnd *)&unk_438C70
    && this != (CWnd *)&unk_438C30
    && this != (CWnd *)&unk_438BF0
    && this != (CWnd *)&unk_438BB0 )
  {
    sub_41E0B1();
  }
  v2 = *((_DWORD *)this + 13);
  if ( v2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, 1);
  v3 = *((_DWORD *)this + 14);
  if ( v3 && *(CWnd **)(v3 + 36) == this )
    *(_DWORD *)(v3 + 36) = 0;
  sub_41C5BD(this);
}


// ========== Function: ?OnDestroy@CWnd@@IAEXXZ @ 0x41DF70 ==========
void __thiscall CWnd::OnDestroy(CWnd *this)
{
  int v2; // ecx

  v2 = *((_DWORD *)this + 13);
  if ( v2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, 1);
  *((_DWORD *)this + 13) = 0;
  sub_41D7CD(this);
}


// ========== Function: sub_41E0A0 @ 0x41E0A0 ==========
int __thiscall sub_41E0A0(int *this)
{
  int v1; // eax

  v1 = *this;
  if ( this[7] )
    return (*(int (**)(void))(v1 + 88))();
  else
    return (*(int (**)(void))(v1 + 164))();
}


// ========== Function: sub_41E0B1 @ 0x41E0B1 ==========
int __thiscall sub_41E0B1(unsigned int *this)
{
  struct CHandleMap *v3; // eax
  void *ValueAt; // eax
  unsigned int v5; // ecx
  void *v6; // edi
  int v7; // eax
  int v8; // ebx

  if ( !this[7] )
    return 0;
  v3 = afxMapHWND(0);
  ValueAt = CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v3 + 4), this[7]);
  v5 = this[14];
  v6 = ValueAt;
  if ( v5 )
    v7 = (*(int (__thiscall **)(unsigned int))(*(_DWORD *)v5 + 80))(v5);
  else
    v7 = DestroyWindow((HWND)this[7]);
  v8 = v7;
  if ( !v6 )
    sub_41D8E4(this);
  return v8;
}


// ========== Function: sub_41E0FE @ 0x41E0FE ==========
LRESULT __thiscall sub_41E0FE(void *this, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LRESULT (__stdcall *v5)(HWND, UINT, WPARAM, LPARAM); // eax

  v5 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))*((_DWORD *)this + 10);
  if ( v5 )
    return CallWindowProcA(v5, *((HWND *)this + 7), Msg, wParam, lParam);
  v5 = *(LRESULT (__stdcall **)(HWND, UINT, WPARAM, LPARAM))(*(int (__thiscall **)(void *))(*(_DWORD *)this + 128))(this);
  if ( v5 )
    return CallWindowProcA(v5, *((HWND *)this + 7), Msg, wParam, lParam);
  else
    return DefWindowProcA(*((HWND *)this + 7), Msg, wParam, lParam);
}


// ========== Function: sub_41E145 @ 0x41E145 ==========
char *__thiscall sub_41E145(char *this)
{
  return this + 40;
}


// ========== Function: ?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z @ 0x41E149 ==========
int __thiscall CWnd::PreTranslateMessage(CWnd *this, struct tagMSG *a2)
{
  void (__stdcall *v3)(struct tagMSG *, CWnd *); // eax

  v3 = (void (__stdcall *)(struct tagMSG *, CWnd *))*((_DWORD *)AfxGetModuleState() + 1037);
  if ( v3 )
    v3(a2, this);
  return 0;
}


// ========== Function: sub_41E168 @ 0x41E168 ==========
__int16 __stdcall sub_41E168(int a1)
{
  struct _AFX_THREAD_STATE *ThreadState; // esi
  HWND v2; // eax
  int v3; // esi

  ThreadState = AfxGetThreadState();
  v2 = (HWND)*((_DWORD *)ThreadState + 51);
  if ( v2 )
  {
    v2 = (HWND)*((_DWORD *)v2 + 7);
    if ( v2 )
      LOWORD(v2) = SendMessageA(v2, 0x401u, 0, 0);
  }
  v3 = *((_DWORD *)ThreadState + 66);
  if ( a1 )
  {
    if ( v3 )
    {
      LOWORD(v2) = GetKeyState(1);
      if ( (__int16)v2 >= 0 )
        LOWORD(v2) = (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 220))(v3, -1);
    }
  }
  return (__int16)v2;
}


// ========== Function: ?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z @ 0x41E1BF ==========
int __thiscall CWnd::OnToolHitTest(HWND *this, struct tagPOINT Point, _DWORD *a3)
{
  HWND v4; // eax
  HWND v5; // edi
  HWND v6; // eax
  int Point_4; // [esp+14h] [ebp+Ch]

  v4 = _AfxChildWindowFromPoint(this[7], Point);
  v5 = v4;
  if ( !v4 )
    return -1;
  Point_4 = (unsigned __int16)GetDlgCtrlID(v4);
  if ( a3 && *a3 >= 0x28u )
  {
    v6 = this[7];
    a3[1] |= 1u;
    a3[9] = -1;
    a3[2] = v6;
    a3[3] = v5;
    if ( (SendMessageA(v5, 0x87u, 0, 0) & 0x2000) == 0 )
      a3[1] |= 0x80000002;
  }
  return Point_4;
}


// ========== Function: sub_41E230 @ 0x41E230 ==========
int __thiscall sub_41E230(void *this, int a2, int a3)
{
  int v4; // eax
  int result; // eax

  if ( *(_DWORD *)a3 == 1 )
  {
    v4 = sub_421492(*(void **)(a3 + 20));
    if ( v4 )
      return (*(int (__thiscall **)(int, int))(*(_DWORD *)v4 + 12))(v4, a3);
  }
  else
  {
    result = sub_41EF63(*(HWND *)(a3 + 20), 0);
    if ( result )
      return result;
  }
  return sub_41D7CD(this);
}


// ========== Function: ?OnCompareItem@CWnd@@IAEHHPAUtagCOMPAREITEMSTRUCT@@@Z @ 0x41E26D ==========
struct tagCOMPAREITEMSTRUCT *__thiscall CWnd::OnCompareItem(CWnd *this, int a2, struct tagCOMPAREITEMSTRUCT *a3)
{
  if ( sub_41EF63(a3->hwndItem, (int)&a3) )
    return a3;
  else
    return (struct tagCOMPAREITEMSTRUCT *)sub_41D7CD(this);
}


// ========== Function: ?OnDeleteItem@CWnd@@IAEXHPAUtagDELETEITEMSTRUCT@@@Z @ 0x41E297 ==========
void __thiscall CWnd::OnDeleteItem(CWnd *this, int a2, struct tagDELETEITEMSTRUCT *a3)
{
  if ( !sub_41EF63(a3->hwndItem, 0) )
    sub_41D7CD(this);
}


// ========== Function: sub_41E2B7 @ 0x41E2B7 ==========
// ?OnVKeyToItem@CWnd@@IAEHIPAVCListBox@@I@Z
// doubtful name
int __thiscall sub_41E2B7(void *this, int a2, int a3, int a4)
{
  if ( a3 && sub_41EF36(&a3) )
    return a3;
  else
    return sub_41D7CD(this);
}


// ========== Function: sub_41E2E2 @ 0x41E2E2 ==========
int __stdcall sub_41E2E2(int a1, int a2)
{
  int MenuItemCount; // ebx
  int i; // edi
  HMENU SubMenu; // eax
  int v5; // eax
  int result; // eax

  MenuItemCount = GetMenuItemCount(*(HMENU *)(a1 + 4));
  for ( i = 0; i < MenuItemCount; ++i )
  {
    SubMenu = GetSubMenu(*(HMENU *)(a1 + 4), i);
    v5 = sub_42147D(SubMenu);
    if ( v5 )
    {
      result = sub_41E2E2(v5, a2);
      if ( result )
        return result;
    }
    else if ( GetMenuItemID(*(HMENU *)(a1 + 4), i) == a2 )
    {
      return sub_421492(*(void **)(a1 + 4));
    }
  }
  return 0;
}


// ========== Function: sub_41E345 @ 0x41E345 ==========
int __thiscall sub_41E345(HWND *this, int a2, _DWORD *a3)
{
  struct CNoTrackObject *Data; // eax
  int v5; // eax
  int v6; // eax
  int result; // eax
  HMENU Menu; // [esp-4h] [ebp-Ch]

  if ( *a3 == 1 )
  {
    Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
    if ( *((HWND *)Data + 20) == this[7] )
    {
      v5 = sub_42147D(*((void **)Data + 21));
    }
    else
    {
      Menu = GetMenu(this[7]);
      v5 = sub_42147D(Menu);
    }
    v6 = sub_41E2E2(v5, a3[2]);
    if ( v6 )
      (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)v6 + 16))(v6, a3);
    return sub_41D7CD(this);
  }
  if ( !CWnd::GetDescendantWindow(this[7], a3[1], 1) )
    return sub_41D7CD(this);
  result = sub_41EF36(0);
  if ( !result )
    return sub_41D7CD(this);
  return result;
}


// ========== Function: sub_41E3BD @ 0x41E3BD ==========
int __stdcall sub_41E3BD(WNDCLASSA *lpWndClass)
{
  WNDCLASSA *v1; // esi
  CHAR *v3; // edi
  int v4; // [esp+0h] [ebp-48h] BYREF
  tagWNDCLASSA WndClass; // [esp+10h] [ebp-38h] BYREF
  int *v6; // [esp+38h] [ebp-10h]
  int v7; // [esp+44h] [ebp-4h]

  v1 = lpWndClass;
  v6 = &v4;
  if ( !GetClassInfoA(lpWndClass->hInstance, lpWndClass->lpszClassName, &WndClass) )
  {
    if ( !RegisterClassA(v1) )
      return 0;
    if ( *((_BYTE *)AfxGetModuleState() + 20) )
    {
      sub_4250E4(1);
      v7 = 0;
      v3 = (char *)AfxGetModuleState() + 52;
      lstrcatA(v3, v1->lpszClassName);
      HIWORD(lpWndClass) = 10;
      lstrcatA(v3, (LPCSTR)&lpWndClass + 2);
      v7 = -1;
      AfxUnlockGlobals(1);
    }
  }
  return 1;
}


// ========== Function: sub_41E4A4 @ 0x41E4A4 ==========
int __thiscall sub_41E4A4(HWND *this, ULONG_PTR dwData, UINT uCommand)
{
  int v4; // esi
  HWND Capture; // eax
  int v7; // [esp+8h] [ebp-10h]

  v7 = *((_DWORD *)AfxGetModuleState() + 1);
  AfxGetModuleState();
  sub_41C80C();
  if ( (*((int (__thiscall **)(HWND *))*this + 44))(this) )
    (*((void (__thiscall **)(HWND *))*this + 60))(this);
  SendMessageA(this[7], 0x1Fu, 0, 0);
  CWnd::SendMessageToDescendants(this[7], 0x1Fu, 0, 0, 1, 1);
  v4 = sub_41ED38(this);
  SendMessageA(*(HWND *)(v4 + 28), 0x1Fu, 0, 0);
  CWnd::SendMessageToDescendants(*(HWND *)(v4 + 28), 0x1Fu, 0, 0, 1, 1);
  Capture = GetCapture();
  if ( Capture )
    SendMessageA(Capture, 0x1Fu, 0, 0);
  if ( !WinHelpA(*(HWND *)(v4 + 28), *(LPCSTR *)(v7 + 140), uCommand, dwData) )
    sub_42325A(0xF107u, 0, -1);
  AfxGetModuleState();
  return sub_41C821();
}


// ========== Function: sub_41E586 @ 0x41E586 ==========
_UNKNOWN **sub_41E586()
{
  return &off_42A040;
}


// ========== Function: unknown_libname_16 @ 0x41E58C ==========
// MFC 3.1-14.0 32bit
_DWORD *__stdcall unknown_libname_16(_DWORD *a1, int a2, int a3, unsigned int a4)
{
  while ( a1[4] )
  {
    if ( a2 == *a1 && a3 == a1[1] && a4 >= a1[2] && a4 <= a1[3] )
      return a1;
    a1 += 6;
  }
  return 0;
}


// ========== Function: sub_41E5CC @ 0x41E5CC ==========
int __thiscall sub_41E5CC(void *this, int a2, int a3, int a4)
{
  int v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  if ( !(*(int (__thiscall **)(void *, int, int, int, int *))(*(_DWORD *)this + 156))(this, a2, a3, a4, &v6) )
    return (*(int (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 160))(this, a2, a3, a4);
  return v6;
}


// ========== Function: sub_41E610 @ 0x41E610 ==========
int __thiscall sub_41E610(LPARAM *this, unsigned int a2, WPARAM wParam, unsigned int a4, int *a5)
{
  int v6; // eax
  struct CWnd *v8; // eax
  int v9; // ebx
  unsigned int v10; // ecx
  bool v11; // zf
  unsigned int *v12; // ebx
  int v13; // eax
  _DWORD *v14; // ebx
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v18; // ecx
  int (__thiscall *v19)(LPARAM *, int); // ebx
  int v20; // eax
  unsigned __int8 Version; // al
  int v22; // eax
  int v23; // eax
  struct CObject *v24; // eax
  struct CObject *v25; // eax
  int v26; // eax
  void *v27; // eax
  int v28; // esi
  _DWORD *v29; // eax
  LPARAM v30; // eax
  void *ValueAt; // eax
  int v32; // eax
  int v33; // eax
  struct CObject *v34; // eax
  struct CObject *v35; // eax
  int v36; // eax
  struct CObject *v37; // eax
  struct CObject *v38; // eax
  struct CObject *v39; // eax
  struct CObject *v40; // eax
  int v41; // edx
  int v42; // eax
  struct CObject *v43; // [esp-8h] [ebp-74h]
  struct CObject *v44; // [esp-8h] [ebp-74h]
  int v45; // [esp-4h] [ebp-70h]
  unsigned int v46; // [esp-4h] [ebp-70h]
  WPARAM v47; // [esp-4h] [ebp-70h]
  int v48; // [esp-4h] [ebp-70h]
  unsigned int v49; // [esp-4h] [ebp-70h]
  unsigned int v50; // [esp-4h] [ebp-70h]
  struct CObject *v51; // [esp-4h] [ebp-70h]
  struct CObject *v52; // [esp-4h] [ebp-70h]
  struct CObject *v53; // [esp-4h] [ebp-70h]
  _DWORD v54[7]; // [esp+Ch] [ebp-60h] BYREF
  void *v55; // [esp+28h] [ebp-44h]
  void *v56; // [esp+44h] [ebp-28h]
  char v57[4]; // [esp+48h] [ebp-24h] BYREF
  int v58; // [esp+4Ch] [ebp-20h]
  int v59; // [esp+58h] [ebp-14h]
  int v60; // [esp+5Ch] [ebp-10h] BYREF
  int v61; // [esp+68h] [ebp-4h]
  int v62; // [esp+74h] [ebp+8h]
  WPARAM wParama; // [esp+78h] [ebp+Ch]
  _DWORD *v64; // [esp+7Ch] [ebp+10h]
  _DWORD *v65; // [esp+7Ch] [ebp+10h]

  v60 = 0;
  switch ( a2 )
  {
    case 0x111u:
      if ( (*(int (__thiscall **)(LPARAM *, WPARAM, unsigned int))(*this + 120))(this, wParam, a4) )
      {
LABEL_90:
        v60 = 1;
        goto LABEL_96;
      }
      return 0;
    case 0x4Eu:
      if ( *(_DWORD *)a4 )
      {
        v6 = (*(int (__thiscall **)(LPARAM *, WPARAM, unsigned int, int *))(*this + 124))(this, wParam, a4, &v60);
LABEL_7:
        if ( v6 )
          goto LABEL_96;
      }
      return 0;
    case 6u:
      v8 = sub_41D866((void *)a4);
      _AfxHandleActivate(this, wParam, v8);
      break;
  }
  if ( a2 == 32 && _AfxHandleSetCursor((struct CWnd *)this, (__int16)a4, HIWORD(a4)) )
    goto LABEL_90;
  v59 = (*(int (__thiscall **)(LPARAM *))(*this + 40))(this);
  v9 = a2 & 0x1FF ^ v59 & 0x1FF;
  sub_4250E4(7);
  v10 = a2;
  v11 = a2 == dword_437388[3 * v9];
  v12 = (unsigned int *)(12 * v9 + 4420488);
  v13 = v59;
  if ( v11 && v59 == v12[2] )
  {
    v14 = (_DWORD *)v12[1];
    v64 = v14;
    AfxUnlockGlobals(7);
    if ( !v14 )
      return 0;
    if ( a2 >= 0xC000 )
      goto LABEL_93;
LABEL_33:
    v18 = v64;
    v19 = (int (__thiscall *)(LPARAM *, int))v14[5];
    v20 = v64[4];
    if ( v64[2] == 26 )
    {
      Version = GetVersion();
      v18 = v64;
      v22 = -(Version < 4u);
      LOBYTE(v22) = v22 & 0xF0;
      v20 = v22 + 47;
    }
    switch ( v20 )
    {
      case 1:
        v45 = sub_4221FC((void *)wParam);
        v23 = v19(this, v45);
        goto LABEL_95;
      case 2:
        v23 = v19(this, wParam);
        goto LABEL_95;
      case 3:
      case 8:
        v46 = HIWORD(a4);
        v43 = (struct CObject *)(__int16)a4;
        v24 = sub_41D866((void *)wParam);
        goto LABEL_54;
      case 4:
        CDC::CDC((CDC *)v57);
        v26 = *(_DWORD *)(a4 + 4);
        v61 = 0;
        v58 = v26;
        sub_41D43B(v54);
        v27 = *(void **)a4;
        v28 = *(_DWORD *)(a4 + 8);
        LOBYTE(v61) = 1;
        v55 = v27;
        v29 = sub_41D88D(v27);
        if ( !v29 )
        {
          v30 = this[13];
          if ( v30 )
          {
            ValueAt = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(v30 + 32), (unsigned int)v55);
            if ( ValueAt )
              v56 = ValueAt;
          }
          v29 = v54;
        }
        v32 = ((int (__thiscall *)(LPARAM *, char *, _DWORD *, int))v19)(this, v57, v29, v28);
        v58 = 0;
        v55 = 0;
        LOBYTE(v61) = 0;
        v60 = v32;
        CWnd::~CWnd((CWnd *)v54);
        v61 = -1;
        goto LABEL_47;
      case 5:
        CDC::CDC((CDC *)v57);
        v48 = *(_DWORD *)(a4 + 8);
        v58 = *(_DWORD *)(a4 + 4);
        v61 = 2;
        v33 = ((int (__thiscall *)(LPARAM *, char *, int))v19)(this, v57, v48);
        v58 = 0;
        v61 = -1;
        v60 = v33;
LABEL_47:
        sub_42228F(v57);
        goto LABEL_96;
      case 6:
        v46 = HIWORD(wParam);
        v34 = sub_41D866((void *)a4);
        goto LABEL_53;
      case 7:
        v47 = HIWORD(wParam);
        v25 = (struct CObject *)(unsigned __int16)wParam;
        goto LABEL_81;
      case 9:
      case 42:
        v23 = v19(this, a4);
        goto LABEL_95;
      case 10:
      case 33:
        goto LABEL_94;
      case 11:
        v46 = sub_42147D((void *)a4);
        v34 = (struct CObject *)HIWORD(wParam);
LABEL_53:
        v43 = v34;
        v24 = (struct CObject *)(unsigned __int16)wParam;
LABEL_54:
        v23 = ((int (__thiscall *)(LPARAM *, struct CObject *, struct CObject *, unsigned int))v19)(this, v24, v43, v46);
        goto LABEL_95;
      case 12:
        ((void (__thiscall *)(LPARAM *))v19)(this);
        goto LABEL_96;
      case 13:
        v19(this, wParam);
        goto LABEL_96;
      case 14:
      case 18:
      case 37:
      case 47:
        v52 = (struct CObject *)a4;
        goto LABEL_79;
      case 15:
        v49 = SHIWORD(a4);
        v35 = (struct CObject *)(__int16)a4;
        goto LABEL_58;
      case 16:
      case 17:
        v50 = HIWORD(a4);
        v36 = (unsigned __int16)a4;
        goto LABEL_88;
      case 19:
        v51 = sub_41D866((void *)wParam);
        v44 = sub_41D866((void *)a4);
        v37 = (struct CObject *)(this[7] == a4);
        goto LABEL_61;
      case 20:
        v38 = (struct CObject *)sub_4221FC((void *)wParam);
        goto LABEL_63;
      case 21:
        v38 = (struct CObject *)sub_42147D((void *)wParam);
        goto LABEL_63;
      case 22:
        v51 = (struct CObject *)HIWORD(a4);
        v44 = (struct CObject *)(unsigned __int16)a4;
        v37 = (struct CObject *)sub_42147D((void *)wParam);
        goto LABEL_61;
      case 23:
        v38 = sub_41D866((void *)wParam);
        goto LABEL_63;
      case 24:
        v51 = (struct CObject *)HIWORD(a4);
        v39 = (struct CObject *)(unsigned __int16)a4;
        goto LABEL_71;
      case 25:
        v39 = (struct CObject *)(__int16)a4;
        v51 = (struct CObject *)SHIWORD(a4);
LABEL_71:
        v44 = v39;
        v37 = sub_41D866((void *)wParam);
        goto LABEL_61;
      case 26:
        v49 = a4;
        v35 = sub_41D866((void *)wParam);
LABEL_58:
        ((void (__thiscall *)(LPARAM *, struct CObject *, unsigned int))v19)(this, v35, v49);
        goto LABEL_96;
      case 27:
        v52 = sub_41D866((void *)a4);
LABEL_79:
        ((void (__thiscall *)(LPARAM *, WPARAM, struct CObject *))v19)(this, wParam, v52);
        goto LABEL_96;
      case 28:
        v51 = (struct CObject *)HIWORD(wParam);
        v40 = sub_41D866((void *)a4);
        goto LABEL_86;
      case 29:
      case 30:
        v41 = (__int16)wParam;
        v62 = (__int16)wParam;
        v42 = SHIWORD(wParam);
        wParama = SHIWORD(wParam);
        if ( v18[4] == 29 )
        {
          v53 = sub_41D866((void *)a4);
          ((void (__thiscall *)(LPARAM *, int, WPARAM, struct CObject *))v19)(this, v62, wParama, v53);
        }
        else
        {
          ((void (__thiscall *)(LPARAM *, int, int))v19)(this, v41, v42);
        }
        goto LABEL_96;
      case 31:
      case 36:
        v19(this, a4);
        goto LABEL_96;
      case 32:
      case 43:
        ((void (__thiscall *)(LPARAM *, WPARAM, unsigned int))v19)(this, wParam, a4);
        goto LABEL_90;
      case 34:
        v25 = (struct CObject *)(__int16)a4;
        v47 = SHIWORD(a4);
        goto LABEL_81;
      case 35:
        v23 = ((int (__thiscall *)(LPARAM *))v19)(this);
        goto LABEL_95;
      case 44:
        v38 = sub_41D866((void *)a4);
LABEL_63:
        v19(this, (int)v38);
        goto LABEL_96;
      case 45:
        v47 = a4;
        v25 = sub_41D866((void *)wParam);
LABEL_81:
        v23 = ((int (__thiscall *)(LPARAM *, struct CObject *, WPARAM))v19)(this, v25, v47);
        goto LABEL_95;
      case 46:
        v6 = ((int (__thiscall *)(LPARAM *, _DWORD, WPARAM, _DWORD, unsigned int))v19)(
               this,
               (unsigned __int16)wParam,
               HIWORD(wParam),
               (unsigned __int16)a4,
               HIWORD(a4));
        v60 = v6;
        goto LABEL_7;
      case 48:
        v51 = (struct CObject *)a4;
        v40 = (struct CObject *)HIWORD(wParam);
LABEL_86:
        v44 = v40;
        v37 = (struct CObject *)(unsigned __int16)wParam;
LABEL_61:
        ((void (__thiscall *)(LPARAM *, struct CObject *, struct CObject *, struct CObject *))v19)(this, v37, v44, v51);
        goto LABEL_96;
      case 49:
        v36 = (__int16)a4;
        v50 = SHIWORD(a4);
LABEL_88:
        ((void (__thiscall *)(LPARAM *, WPARAM, int, unsigned int))v19)(this, wParam, v36, v50);
        goto LABEL_96;
      default:
        goto LABEL_96;
    }
  }
  *v12 = a2;
  v12[2] = v13;
  if ( !v13 )
  {
LABEL_30:
    v12[1] = 0;
    AfxUnlockGlobals(7);
    return 0;
  }
  while ( v10 < 0xC000 )
  {
    v15 = unknown_libname_16(*(_DWORD **)(v13 + 4), v10, 0, 0);
    v64 = v15;
    if ( v15 )
    {
      v12[1] = (unsigned int)v15;
      AfxUnlockGlobals(7);
      v14 = v64;
      goto LABEL_33;
    }
LABEL_29:
    v59 = *(_DWORD *)v59;
    if ( !v59 )
      goto LABEL_30;
    v13 = v59;
    v10 = a2;
  }
  v16 = unknown_libname_16(*(_DWORD **)(v13 + 4), 49152, 0, 0);
  v65 = v16;
  if ( !v16 )
    goto LABEL_29;
  while ( *(_DWORD *)v16[4] != a2 )
  {
    v65 = unknown_libname_16(v16 + 6, 49152, 0, 0);
    if ( !v65 )
      goto LABEL_29;
    v16 = v65;
  }
  v12[1] = (unsigned int)v16;
  AfxUnlockGlobals(7);
  v14 = v65;
LABEL_93:
  v19 = (int (__thiscall *)(LPARAM *, int))v14[5];
LABEL_94:
  v23 = ((int (__thiscall *)(LPARAM *, WPARAM, unsigned int))v19)(this, wParam, a4);
LABEL_95:
  v60 = v23;
LABEL_96:
  if ( a5 )
    *a5 = v60;
  return 1;
}


// ========== Function: sub_41EB82 @ 0x41EB82 ==========
CCmdUI *__thiscall sub_41EB82(CCmdUI *this)
{
  CCmdUI::CCmdUI(this);
  *(_DWORD *)this = &CTestCmdUI::`vftable';
  *((_DWORD *)this + 10) = 1;
  return this;
}


// ========== Function: ?Enable@CTestCmdUI@@UAEXH@Z @ 0x41EB9B ==========
void __thiscall CTestCmdUI::Enable(CTestCmdUI *this, int a2)
{
  *((_DWORD *)this + 6) = 1;
  *((_DWORD *)this + 10) = a2;
}


// ========== Function: nullsub_12 @ 0x41EBAC ==========
void __stdcall nullsub_12(int a1)
{
  ;
}


// ========== Function: ?OnCommand@CWnd@@MAEHIJ@Z @ 0x41EBAF ==========
int __thiscall CWnd::OnCommand(CWnd *this, unsigned int a2, HWND hWnd)
{
  int v3; // edi
  int v5; // eax
  _BYTE v7[4]; // [esp+Ch] [ebp-2Ch] BYREF
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+34h] [ebp-4h]
  unsigned int v10; // [esp+40h] [ebp+8h]

  v3 = (unsigned __int16)a2;
  v10 = HIWORD(a2);
  if ( hWnd )
  {
    if ( *((_DWORD *)CThreadLocalObject::GetData(
                       (CThreadLocalObject *)&unk_438D7C,
                       CThreadLocal<_AFX_THREAD_STATE>::CreateObject)
         + 46) == *((_DWORD *)this + 7)
      || sub_41EF63(hWnd, 0) )
    {
      return 1;
    }
    if ( v3 )
      return (*(int (__thiscall **)(CWnd *, int, unsigned int, _DWORD, _DWORD))(*(_DWORD *)this + 12))(
               this,
               v3,
               v10,
               0,
               0);
  }
  else if ( v3 )
  {
    sub_41EB82((CCmdUI *)v7);
    v5 = *(_DWORD *)this;
    v8 = v3;
    (*(void (__thiscall **)(CWnd *, int, int, _BYTE *, _DWORD))(v5 + 12))(this, v3, -1, v7, 0);
    if ( v9 )
    {
      v10 = 0;
      return (*(int (__thiscall **)(CWnd *, int, unsigned int, _DWORD, _DWORD))(*(_DWORD *)this + 12))(
               this,
               v3,
               v10,
               0,
               0);
    }
    return 1;
  }
  return 0;
}


// ========== Function: ?OnNotify@CWnd@@MAEHIJPAJ@Z @ 0x41EC3B ==========
int __thiscall CWnd::OnNotify(CWnd *this, unsigned int a2, int a3, int *a4)
{
  HWND v6; // ebx
  int v8; // eax
  _DWORD v9[2]; // [esp+Ch] [ebp-Ch] BYREF
  int DlgCtrlID; // [esp+14h] [ebp-4h]
  int v11; // [esp+24h] [ebp+Ch]

  v6 = *(HWND *)a3;
  DlgCtrlID = (unsigned __int16)GetDlgCtrlID(*(HWND *)a3);
  v11 = *(_DWORD *)(a3 + 8);
  if ( *((_DWORD *)CThreadLocalObject::GetData(
                     (CThreadLocalObject *)&unk_438D7C,
                     CThreadLocal<_AFX_THREAD_STATE>::CreateObject)
       + 46) == *((_DWORD *)this + 7)
    || sub_41EF63(v6, (int)a4) )
  {
    return 1;
  }
  v9[0] = a4;
  v8 = *(_DWORD *)this;
  v9[1] = a3;
  return (*(int (__thiscall **)(CWnd *, int, int, _DWORD *, _DWORD))(v8 + 12))(
           this,
           DlgCtrlID,
           (unsigned __int16)v11 | 0x4E0000,
           v9,
           0);
}


// ========== Function: sub_41ECB5 @ 0x41ECB5 ==========
HWND *__thiscall sub_41ECB5(HWND *this)
{
  HWND i; // eax
  HWND *v2; // esi

  if ( this && this[7] )
  {
    for ( i = GetParent(this[7]); ; i = GetParent(v2[7]) )
    {
      v2 = (HWND *)sub_41D866(i);
      if ( !v2 )
        break;
      if ( (*((int (__thiscall **)(HWND *))*v2 + 44))(v2) )
        return v2;
    }
  }
  return 0;
}


// ========== Function: ?AfxGetParentOwner@@YGPAUHWND__@@PAU1@@Z @ 0x41ECF3 ==========
HWND __stdcall AfxGetParentOwner(HWND hWnd)
{
  CWnd *v1; // eax
  HWND result; // eax

  v1 = (CWnd *)sub_41D88D(hWnd);
  if ( v1 )
  {
    result = (HWND)CWnd::GetOwner(v1);
    if ( result )
      return (HWND)*((_DWORD *)result + 7);
  }
  else if ( (GetWindowLongA(hWnd, -16) & 0x40000000) != 0 )
  {
    return GetParent(hWnd);
  }
  else
  {
    return GetWindow(hWnd, 4u);
  }
  return result;
}


// ========== Function: sub_41ED38 @ 0x41ED38 ==========
struct CObject *__thiscall sub_41ED38(_DWORD *this)
{
  HWND ParentOwner; // eax
  HWND v3; // esi

  if ( !this )
    return 0;
  ParentOwner = (HWND)this[7];
  if ( !ParentOwner )
    return 0;
  do
  {
    v3 = ParentOwner;
    ParentOwner = AfxGetParentOwner(ParentOwner);
  }
  while ( ParentOwner );
  return sub_41D866(v3);
}


// ========== Function: sub_41ED60 @ 0x41ED60 ==========
HWND *__thiscall sub_41ED60(HWND *this)
{
  HWND *v1; // esi
  HWND *i; // ecx
  HWND *v4; // eax

  v1 = this;
  if ( !this || !this[7] )
    return 0;
  if ( !(*((int (__thiscall **)(HWND *))*this + 44))(this) )
    v1 = sub_41ECB5(v1);
  if ( v1 )
  {
    for ( i = v1; ; i = v4 )
    {
      v4 = sub_41ECB5(i);
      if ( !v4 )
        break;
      v1 = v4;
    }
  }
  return v1;
}


// ========== Function: sub_41EDA1 @ 0x41EDA1 ==========
int __thiscall sub_41EDA1(_DWORD *this, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
{
  const CHAR *v4; // eax
  HWND v6; // ecx

  v4 = lpCaption;
  if ( !lpCaption )
    v4 = (const CHAR *)*((_DWORD *)AfxGetModuleState() + 4);
  if ( this )
    v6 = (HWND)this[7];
  else
    v6 = 0;
  return MessageBoxA(v6, lpText, v4, uType);
}


// ========== Function: ?GetDescendantWindow@CWnd@@SGPAV1@PAUHWND__@@HH@Z @ 0x41EDD3 ==========
struct CWnd *__stdcall CWnd::GetDescendantWindow(HWND hDlg, int nIDDlgItem, int a3)
{
  HWND DlgItem; // eax
  HWND v4; // esi
  struct CWnd *result; // eax
  HWND i; // eax
  HWND v7; // esi

  DlgItem = GetDlgItem(hDlg, nIDDlgItem);
  v4 = DlgItem;
  if ( !DlgItem )
    goto LABEL_7;
  if ( !GetTopWindow(DlgItem) || (result = CWnd::GetDescendantWindow(v4, nIDDlgItem, a3)) == 0 )
  {
    if ( !a3 )
      return sub_41D866(v4);
    result = (struct CWnd *)sub_41D88D(v4);
    if ( !result )
    {
LABEL_7:
      for ( i = GetTopWindow(hDlg); ; i = GetWindow(v7, 2u) )
      {
        v7 = i;
        if ( !i )
          break;
        result = CWnd::GetDescendantWindow(i, nIDDlgItem, a3);
        if ( result )
          return result;
      }
      return 0;
    }
  }
  return result;
}


// ========== Function: ?SendMessageToDescendants@CWnd@@SGXPAUHWND__@@IIJHH@Z @ 0x41EE4C ==========
void __stdcall CWnd::SendMessageToDescendants(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam, int a5, int a6)
{
  HWND i; // eax
  HWND v7; // esi
  int *v8; // eax

  for ( i = GetTopWindow(hWnd); ; i = GetWindow(v7, 2u) )
  {
    v7 = i;
    if ( !i )
      break;
    if ( a6 )
    {
      v8 = (int *)sub_41D88D(i);
      if ( v8 )
        sub_41D69B((struct CWnd *)v8, v8[7], Msg, wParam, lParam);
    }
    else
    {
      SendMessageA(i, (UINT)Msg, wParam, lParam);
    }
    if ( a5 )
    {
      if ( GetTopWindow(v7) )
        CWnd::SendMessageToDescendants(v7, (UINT)Msg, wParam, lParam, a5, a6);
    }
  }
}


// ========== Function: ?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z @ 0x41EEC9 ==========
void __thiscall CWnd::CalcWindowRect(CWnd *this, LPRECT lpRect, unsigned int a3)
{
  int v4; // eax
  DWORD v5; // eax
  DWORD v6; // [esp-4h] [ebp-8h]

  v4 = sub_4204D7();
  if ( !a3 )
    BYTE1(v4) &= ~2u;
  v6 = v4;
  v5 = sub_4204BD(this);
  AdjustWindowRectEx(lpRect, v5, 0, v6);
}


// ========== Function: sub_41EEF4 @ 0x41EEF4 ==========
int __stdcall sub_41EEF4(HWND a1, HWND *a2)
{
  HWND i; // esi
  void *v3; // eax

  for ( i = *a2; i; i = GetParent(i) )
  {
    v3 = sub_41D88D(i);
    if ( v3 && (*(int (__thiscall **)(void *, HWND *))(*(_DWORD *)v3 + 144))(v3, a2) )
      return 1;
    if ( i == a1 )
      break;
  }
  return 0;
}


// ========== Function: sub_41EF36 @ 0x41EF36 ==========
int __thiscall sub_41EF36(void *this, int a2)
{
  struct CNoTrackObject *Data; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)this + 168))(
           this,
           *((_DWORD *)Data + 14),
           *((_DWORD *)Data + 15),
           *((_DWORD *)Data + 16),
           a2);
}


// ========== Function: sub_41EF63 @ 0x41EF63 ==========
int __stdcall sub_41EF63(HWND hWnd, int a2)
{
  struct CHandleMap *v2; // eax
  CMapPtrToPtr *v3; // esi
  void *ValueAt; // eax
  HWND Parent; // eax
  _DWORD *v6; // eax
  int v7; // eax
  void *v8; // esi
  int v9; // eax
  int v10; // esi
  _DWORD v12[15]; // [esp+8h] [ebp-48h] BYREF
  int v13; // [esp+4Ch] [ebp-4h]

  v2 = afxMapHWND(0);
  if ( !v2 )
    return 0;
  v3 = (struct CHandleMap *)((char *)v2 + 4);
  ValueAt = CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v2 + 4), (unsigned int)hWnd);
  if ( !ValueAt )
  {
    Parent = GetParent(hWnd);
    v6 = CMapPtrToPtr::GetValueAt(v3, (unsigned int)Parent);
    if ( v6 )
    {
      v7 = v6[13];
      if ( v7 )
      {
        v8 = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(v7 + 32), (unsigned int)hWnd);
        if ( v8 )
        {
          sub_41D479(v12, (int)hWnd);
          v13 = 0;
          v12[14] = v8;
          v9 = sub_41EF36(v12, a2);
          v12[7] = 0;
          v13 = -1;
          v10 = v9;
          CWnd::~CWnd((CWnd *)v12);
          return v10;
        }
      }
    }
    return 0;
  }
  return sub_41EF36(ValueAt, a2);
}


// ========== Function: ?OnChildNotify@CWnd@@MAEHIIJPAJ@Z @ 0x41F007 ==========
LRESULT __thiscall CWnd::OnChildNotify(CWnd *this, unsigned int a2, WPARAM wParam, LPARAM lParam, int *a5)
{
  LRESULT result; // eax

  if ( !*((_DWORD *)this + 14) )
    return sub_41F062(a2, wParam, lParam, (int)a5);
  result = SendMessageA(*((HWND *)this + 7), a2 + 0x2000, wParam, lParam);
  if ( a2 < 0x132 || a2 > 0x138 || result )
  {
    if ( a5 )
      *a5 = result;
    return 1;
  }
  return result;
}


// ========== Function: sub_41F062 @ 0x41F062 ==========
int __thiscall sub_41F062(LPARAM *this, unsigned int a2, WPARAM wParam, unsigned int a4, int *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-Ch] BYREF
  int *Buf1; // [esp+8h] [ebp-8h] BYREF
  unsigned int v8; // [esp+Ch] [ebp-4h]

  if ( a2 > 0x111 )
  {
    if ( a2 < 0x114 || a2 > 0x115 && a2 != 528 )
      goto LABEL_15;
    return sub_41E610(this, a2 + 48128, wParam, a4, a5);
  }
  if ( a2 != 273 )
  {
    if ( a2 < 0x2B )
      goto LABEL_15;
    if ( a2 > 0x2F && a2 != 57 )
    {
      if ( a2 == 78 )
      {
        Buf1 = a5;
        v8 = a4;
        return sub_41C6EF(this, 0, (unsigned __int16)*(_DWORD *)(a4 + 8) | 0xBC4E0000, &Buf1, 0);
      }
LABEL_15:
      if ( a2 < 0x132 )
        return 0;
      if ( a2 > 0x138 )
        return 0;
      v8 = a2 - 306;
      Buf1 = (int *)wParam;
      result = sub_41E610(this, 0xBC19u, 0, (unsigned int)&v6, a5);
      if ( !*a5 )
        return 0;
      return result;
    }
    return sub_41E610(this, a2 + 48128, wParam, a4, a5);
  }
  if ( !sub_41C6EF(this, 0, HIWORD(wParam) | 0xBD110000, 0, 0) )
    return 0;
  result = 1;
  if ( a5 )
    *a5 = 1;
  return result;
}


// ========== Function: ?OnParentNotify@CWnd@@IAEXIJ@Z @ 0x41F14A ==========
void __thiscall CWnd::OnParentNotify(CWnd *this, __int16 a2, HWND hWnd)
{
  if ( a2 != 1 && a2 != 2 || !sub_41EF63(hWnd, 0) )
    sub_41D7CD(this);
}


// ========== Function: ?OnActivateTopLevel@CWnd@@IAEJIJ@Z @ 0x41F177 ==========
int __thiscall CWnd::OnActivateTopLevel(CWnd *this, __int16 a2, int a3)
{
  if ( !a2 && (*((_BYTE *)AfxGetThreadState() + 223) & 0x40) == 0 )
    sub_41E168(1);
  return 0;
}


// ========== Function: ?OnHelpInfo@CWnd@@IAEHPAUtagHELPINFO@@@Z @ 0x41F2B4 ==========
int __thiscall CWnd::OnHelpInfo(CWnd *this, struct tagHELPINFO *a2)
{
  int v3; // esi

  if ( (sub_4204BD(this) & 0x40000000) != 0 )
    return sub_41D7CD(this);
  v3 = sub_404EA0();
  if ( !v3 || GetKeyState(16) < 0 || GetKeyState(17) < 0 || GetKeyState(18) < 0 )
    return sub_41D7CD(this);
  SendMessageA(*(HWND *)(v3 + 28), 0x111u, 0xE146u, 0);
  return 1;
}


// ========== Function: ?OnDisplayChange@CWnd@@IAEJIJ@Z @ 0x41F318 ==========
int __thiscall CWnd::OnDisplayChange(HWND *this, unsigned int a2, int a3)
{
  const struct tagMSG *CurrentMessage; // eax

  if ( (HWND *)sub_404EA0() == this )
    AUX_DATA::UpdateSysMetrics((AUX_DATA *)&dword_439278);
  if ( (sub_4204BD(this) & 0x40000000) == 0 )
  {
    CurrentMessage = CWnd::GetCurrentMessage();
    CWnd::SendMessageToDescendants(
      this[7],
      (CException *)CurrentMessage->message,
      CurrentMessage->wParam,
      CurrentMessage->lParam,
      1,
      1);
  }
  return sub_41D7CD(this);
}


// ========== Function: ?OnDragList@CWnd@@IAEJIJ@Z @ 0x41F361 ==========
int __thiscall CWnd::OnDragList(CWnd *this, unsigned int a2, int a3)
{
  if ( sub_41EF63(*(HWND *)(a3 + 4), (int)&a3) )
    return a3;
  else
    return sub_41D7CD(this);
}


// ========== Function: sub_41F38B @ 0x41F38B ==========
// ?OnVScroll@CWnd@@IAEXIIPAVCScrollBar@@@Z
// doubtful name
int __thiscall sub_41F38B(void *this, int a2, int a3, void *a4)
{
  int result; // eax

  if ( !a4 )
    return sub_41D7CD(this);
  result = sub_41EF36(a4, 0);
  if ( !result )
    return sub_41D7CD(this);
  return result;
}


// ========== Function: ?OnEnterIdle@CWnd@@IAEXIPAV1@@Z @ 0x41F3AC ==========
void __thiscall CWnd::OnEnterIdle(CWnd *this, unsigned int a2, struct CWnd *a3)
{
  BOOL i; // eax
  struct tagMSG Msg; // [esp+Ch] [ebp-1Ch] BYREF

  for ( i = PeekMessageA(&Msg, 0, 0x121u, 0x121u, 1u); i; i = PeekMessageA(&Msg, 0, 0x121u, 0x121u, 1u) )
    DispatchMessageA(&Msg);
  sub_41D7CD(this);
}


// ========== Function: ?OnCtlColor@CWnd@@IAEPAUHBRUSH__@@PAVCDC@@PAV1@I@Z @ 0x41F3F6 ==========
struct CWnd *__thiscall CWnd::OnCtlColor(CWnd *this, struct CDC *a2, struct CWnd *a3, unsigned int a4)
{
  if ( sub_41EF36(a3, (int)&a3) )
    return a3;
  else
    return (struct CWnd *)sub_41D7CD(this);
}


// ========== Function: ?OnGrayCtlColor@CWnd@@QAEPAUHBRUSH__@@PAVCDC@@PAV1@I@Z @ 0x41F41D ==========
HWND __thiscall CWnd::OnGrayCtlColor(CWnd *this, HDC *a2, HWND hWnd, unsigned int a4)
{
  HWND v4; // edi
  int v7; // eax
  int v8; // esi

  v4 = hWnd;
  if ( sub_41EF36(hWnd, (int)&hWnd) )
    return hWnd;
  v7 = sub_424E45(sub_42429E);
  v8 = v7;
  if ( v4 )
    v4 = (HWND)*((_DWORD *)v4 + 7);
  if ( CWnd::GrayCtlColor(a2[1], v4, a4, *(HBRUSH *)(v7 + 4), *(_DWORD *)(v7 + 8)) )
    return *(HWND *)(v8 + 4);
  else
    return (HWND)sub_41D7CD(this);
}


// ========== Function: ?GrayCtlColor@CWnd@@SGHPAUHDC__@@PAUHWND__@@IPAUHBRUSH__@@K@Z @ 0x41F480 ==========
int __stdcall CWnd::GrayCtlColor(HDC hdc, HWND hWnd, unsigned int a3, HANDLE h, COLORREF a5)
{
  COLORREF SysColor; // eax
  _BYTE pv[4]; // [esp+0h] [ebp-Ch] BYREF
  COLORREF color; // [esp+4h] [ebp-8h]

  if ( !hdc || !h || a3 < 2 || a3 == 5 || a3 == 2 && !_AfxIsComboBoxControl(hWnd, 2u) )
    return 0;
  GetObjectA(h, 12, pv);
  SetBkColor(hdc, color);
  SysColor = a5;
  if ( a5 == -1 )
    SysColor = GetSysColor(8);
  SetTextColor(hdc, SysColor);
  return 1;
}


// ========== Function: ?OnQuery3dControls@CWnd@@IAEJIJ@Z @ 0x41F4F5 ==========
int __thiscall CWnd::OnQuery3dControls(CWnd *this, unsigned int a2, int a3)
{
  return 0xFFFF;
}


// ========== Function: sub_41F4FD @ 0x41F4FD ==========
int __thiscall sub_41F4FD(struct CWnd *this, int a2)
{
  struct _AFX_THREAD_STATE *ThreadState; // edi
  int v5; // [esp+0h] [ebp-3Ch] BYREF
  _BYTE v6[16]; // [esp+10h] [ebp-2Ch] BYREF
  int v7; // [esp+24h] [ebp-18h]
  struct _AFX_THREAD_STATE *v8; // [esp+28h] [ebp-14h]
  int *v9; // [esp+2Ch] [ebp-10h]
  int v10; // [esp+38h] [ebp-4h]

  v9 = &v5;
  CDataExchange::CDataExchange((CDataExchange *)v6, this, a2);
  ThreadState = AfxGetThreadState();
  v10 = 0;
  v8 = ThreadState;
  v7 = *((_DWORD *)ThreadState + 46);
  *((_DWORD *)ThreadState + 46) = *((_DWORD *)this + 7);
  (*(void (__thiscall **)(struct CWnd *, _BYTE *))(*(_DWORD *)this + 132))(this, v6);
  *((_DWORD *)ThreadState + 46) = v7;
  return 1;
}


// ========== Function: ??0CDataExchange@@QAE@PAVCWnd@@H@Z @ 0x41F59F ==========
CDataExchange *__thiscall CDataExchange::CDataExchange(CDataExchange *this, struct CWnd *a2, int a3)
{
  CDataExchange *result; // eax

  result = this;
  *((_DWORD *)this + 2) = 0;
  *(_DWORD *)this = a3;
  *((_DWORD *)this + 1) = a2;
  return result;
}


// ========== Function: ?CenterWindow@CWnd@@QAEXPAV1@@Z @ 0x41F5B5 ==========
void __thiscall CWnd::CenterWindow(HWND *this, struct CWnd *a2)
{
  HWND v3; // edi
  HWND Parent; // eax
  LRESULT v5; // eax
  LONG WindowLongA; // eax
  HWND v7; // eax
  HMONITOR v8; // eax
  HMONITOR v9; // eax
  HWND v10; // ebx
  LONG left; // ecx
  LONG top; // esi
  _DWORD v13[5]; // [esp+Ch] [ebp-60h] BYREF
  RECT rcSrc; // [esp+20h] [ebp-4Ch] BYREF
  struct tagRECT rcDst; // [esp+34h] [ebp-38h] BYREF
  struct tagRECT Rect; // [esp+44h] [ebp-28h] BYREF
  struct tagRECT v17; // [esp+54h] [ebp-18h] BYREF
  CWnd *v18; // [esp+64h] [ebp-8h]
  int v19; // [esp+68h] [ebp-4h]

  v18 = (CWnd *)this;
  v19 = sub_4204BD(this);
  if ( a2 )
  {
    v3 = (HWND)*((_DWORD *)a2 + 7);
  }
  else
  {
    if ( (v19 & 0x40000000) != 0 )
      Parent = GetParent(this[7]);
    else
      Parent = GetWindow(this[7], 4u);
    v3 = Parent;
    if ( Parent )
    {
      v5 = SendMessageA(Parent, 0x36Bu, 0, 0);
      if ( v5 )
        v3 = (HWND)v5;
    }
  }
  GetWindowRect(this[7], &Rect);
  if ( (v19 & 0x40000000) != 0 )
  {
    v10 = GetParent(this[7]);
    GetClientRect(v10, &v17);
    GetClientRect(v3, &rcDst);
    MapWindowPoints(v3, v10, (LPPOINT)&rcDst, 2u);
  }
  else
  {
    if ( v3 )
    {
      WindowLongA = GetWindowLongA(v3, -16);
      if ( (WindowLongA & 0x10000000) == 0 || (WindowLongA & 0x20000000) != 0 )
        v3 = 0;
    }
    v13[0] = 40;
    if ( v3 )
    {
      GetWindowRect(v3, &rcDst);
      v9 = xMonitorFromWindow(v3, 2u);
      sub_40505D(v9, (int)v13);
      CopyRect(&v17, &rcSrc);
    }
    else
    {
      v7 = (HWND)sub_404EA0();
      if ( v7 )
        v7 = (HWND)*((_DWORD *)v7 + 7);
      v8 = xMonitorFromWindow(v7, 1u);
      sub_40505D(v8, (int)v13);
      CopyRect(&rcDst, &rcSrc);
      CopyRect(&v17, &rcSrc);
    }
  }
  left = (rcDst.right + rcDst.left) / 2 - (Rect.right - Rect.left) / 2;
  top = (rcDst.bottom + rcDst.top) / 2 - (Rect.bottom - Rect.top) / 2;
  if ( left >= v17.left )
  {
    if ( left + Rect.right - Rect.left > v17.right )
      left = Rect.left + v17.right - Rect.right;
  }
  else
  {
    left = v17.left;
  }
  if ( top >= v17.top )
  {
    if ( top + Rect.bottom - Rect.top > v17.bottom )
      top = v17.bottom + Rect.top - Rect.bottom;
  }
  else
  {
    top = v17.top;
  }
  CWnd::SetWindowPos(v18, 0, left, top, -1, -1, 0x15u);
}


// ========== Function: sub_41F76A @ 0x41F76A ==========
int sub_41F76A()
{
  return 1;
}


// ========== Function: ?ExecuteDlgInit@CWnd@@QAEHPBD@Z @ 0x41F76E ==========
int __thiscall CWnd::ExecuteDlgInit(CWnd *this, const char *lpName)
{
  LPVOID v2; // edi
  HMODULE v3; // esi
  HRSRC ResourceA; // eax
  HGLOBAL Resource; // eax

  v2 = 0;
  if ( lpName )
  {
    v3 = (HMODULE)*((_DWORD *)AfxGetModuleState() + 3);
    ResourceA = FindResourceA(v3, lpName, (LPCSTR)0xF0);
    if ( ResourceA )
    {
      Resource = LoadResource(v3, ResourceA);
      if ( !Resource )
        return 0;
      v2 = LockResource(Resource);
    }
  }
  return sub_41F7BE(v2);
}


// ========== Function: sub_41F7BE @ 0x41F7BE ==========
int __thiscall sub_41F7BE(HWND *this, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // esi
  unsigned __int16 v4; // cx
  unsigned __int16 *v5; // esi
  unsigned __int16 v6; // ax
  int v7; // edx
  LPARAM v8; // esi
  LRESULT v9; // eax
  _DWORD v11[9]; // [esp+8h] [ebp-28h] BYREF
  int v12; // [esp+2Ch] [ebp-4h]
  int v13; // [esp+38h] [ebp+8h]

  v2 = a2;
  v12 = 1;
  if ( !a2 )
  {
LABEL_17:
    CWnd::SendMessageToDescendants(this[7], (CException *)0x364, 0, 0, 0, 0);
    return v12;
  }
  do
  {
    v4 = *v2;
    if ( !*v2 )
      break;
    v5 = v2 + 1;
    v6 = *v5++;
    v7 = *(_DWORD *)v5;
    v8 = (LPARAM)(v5 + 2);
    v13 = v7;
    if ( v6 == 4660 )
    {
      v11[1] = -1;
      v11[0] = 1;
      v11[2] = v8;
      v9 = SendDlgItemMessageA(this[7], v4, 0x401u, 0, (LPARAM)v11);
    }
    else
    {
      if ( v6 == 1025 )
      {
        v6 = 384;
      }
      else
      {
        if ( v6 == 1027 )
          v6 = 323;
        if ( v6 != 384 && v6 != 323 )
          goto LABEL_15;
      }
      v9 = SendDlgItemMessageA(this[7], v4, v6, 0, v8);
    }
    if ( v9 == -1 )
      v12 = 0;
LABEL_15:
    v2 = (unsigned __int16 *)(v13 + v8);
  }
  while ( v12 );
  if ( v12 )
    goto LABEL_17;
  return v12;
}


// ========== Function: ?PreTranslateInput@CWnd@@QAEHPAUtagMSG@@@Z @ 0x41F890 ==========
int __thiscall CWnd::PreTranslateInput(CWnd *this, struct tagMSG *a2)
{
  UINT message; // eax

  message = a2->message;
  if ( (message < 0x100 || message > 0x108) && (message < 0x200 || message > 0x209) )
    return 0;
  else
    return CWnd::IsDialogMessageA(this, a2);
}


// ========== Function: ?RunModalLoop@CWnd@@QAEHK@Z @ 0x41F8C0 ==========
HWND __thiscall CWnd::RunModalLoop(HWND *this, char a2)
{
  HWND Parent; // eax
  struct tagMSG *v4; // ebp
  LPARAM v5; // eax
  struct CWinThread *Thread; // eax
  UINT message; // eax
  struct CWinThread *v8; // eax
  int v10; // [esp+10h] [ebp-10h]
  LPARAM lParam; // [esp+14h] [ebp-Ch]
  int v12; // [esp+18h] [ebp-8h]
  HWND hWnd; // [esp+1Ch] [ebp-4h]

  v12 = 1;
  lParam = 0;
  if ( (a2 & 4) == 0 || (v10 = 1, (sub_4204BD(this) & 0x10000000) != 0) )
    v10 = 0;
  Parent = GetParent(this[7]);
  this[9] = (HWND)((unsigned int)this[9] | 0x18);
  hWnd = Parent;
  v4 = (struct tagMSG *)((char *)AfxGetThread() + 48);
LABEL_5:
  while ( v12 && !PeekMessageA(v4, 0, 0, 0, 0) )
  {
    if ( v10 )
    {
      sub_4205F2(1);
      UpdateWindow(this[7]);
      v10 = 0;
    }
    if ( (a2 & 1) == 0 && hWnd && !lParam )
      SendMessageA(hWnd, 0x121u, 0, (LPARAM)this[7]);
    if ( (a2 & 2) == 0 )
    {
      v5 = lParam++;
      if ( SendMessageA(this[7], 0x36Au, 0, v5) )
        continue;
    }
    v12 = 0;
  }
  while ( 1 )
  {
    Thread = AfxGetThread();
    if ( !(*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 92))(Thread) )
    {
      AfxPostQuitMessage(0);
      return HWND_MESSAGE|0x2;
    }
    if ( v10 )
    {
      message = v4->message;
      if ( message == 280 || message == 260 )
      {
        sub_4205F2(1);
        UpdateWindow(this[7]);
        v10 = 0;
      }
    }
    if ( !(*((int (__thiscall **)(HWND *))*this + 28))(this) )
      break;
    v8 = AfxGetThread();
    if ( (*(int (__thiscall **)(struct CWinThread *, struct tagMSG *))(*(_DWORD *)v8 + 100))(v8, v4) )
    {
      v12 = 1;
      lParam = 0;
    }
    if ( !PeekMessageA(v4, 0, 0, 0, 0) )
      goto LABEL_5;
  }
  this[9] = (HWND)((unsigned int)this[9] & 0xFFFFFFE7);
  return this[11];
}


// ========== Function: ?ContinueModal@CWnd@@UAEHXZ @ 0x41FA1F ==========
int __thiscall CWnd::ContinueModal(CWnd *this)
{
  return *((_DWORD *)this + 9) & 0x10;
}


// ========== Function: ?EndModalLoop@CWnd@@UAEXH@Z @ 0x41FA26 ==========
void __thiscall CWnd::EndModalLoop(CWnd *this, int a2)
{
  int v2; // eax

  *((_DWORD *)this + 11) = a2;
  v2 = *((_DWORD *)this + 9);
  if ( (v2 & 0x10) != 0 )
  {
    LOBYTE(v2) = v2 & 0xEF;
    *((_DWORD *)this + 9) = v2;
    PostMessageA(*((HWND *)this + 7), 0, 0, 0);
  }
}


// ========== Function: unknown_libname_22 @ 0x41FA4A ==========
// MFC 3.1-14.0 32bit
int __stdcall unknown_libname_22(WNDCLASSA *lpWndClass, const CHAR *a2, unsigned __int16 a3)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  HICON IconA; // eax

  lpWndClass->lpszClassName = a2;
  ModuleState = AfxGetModuleState();
  IconA = LoadIconA(*((HINSTANCE *)ModuleState + 3), (LPCSTR)a3);
  lpWndClass->hIcon = IconA;
  if ( !IconA )
    lpWndClass->hIcon = LoadIconA(0, (LPCSTR)0x7F00);
  return sub_41E3BD(lpWndClass);
}


// ========== Function: sub_41FA8B @ 0x41FA8B ==========
HMODULE __stdcall sub_41FA8B(const INITCOMMONCONTROLSEX *a1, int a2)
{
  HMODULE ModuleHandleA; // edi
  HMODULE result; // eax
  HMODULE v4; // ebx
  int v5; // esi
  BOOL (__stdcall *InitCommonControlsEx)(const INITCOMMONCONTROLSEX *); // eax

  ModuleHandleA = GetModuleHandleA("COMCTL32.DLL");
  result = LoadLibraryA("COMCTL32.DLL");
  v4 = result;
  if ( result )
  {
    v5 = 0;
    InitCommonControlsEx = (BOOL (__stdcall *)(const INITCOMMONCONTROLSEX *))GetProcAddress(
                                                                               result,
                                                                               "InitCommonControlsEx");
    if ( InitCommonControlsEx )
    {
      if ( InitCommonControlsEx(a1) )
      {
        v5 = a2;
        if ( !ModuleHandleA )
        {
          InitCommonControls();
          LOWORD(v5) = a2 | 0x3FC0;
        }
      }
    }
    else if ( (a2 & 0x3FC0) == a2 )
    {
      InitCommonControls();
      v5 = 16320;
    }
    FreeLibrary(v4);
    return (HMODULE)v5;
  }
  return result;
}


// ========== Function: sub_41FB02 @ 0x41FB02 ==========
BOOL __stdcall sub_41FB02(int a1)
{
  int v2; // esi
  struct AFX_MODULE_STATE *v3; // ecx
  int v4; // eax
  WNDCLASSA WndClass; // [esp+0h] [ebp-34h] BYREF
  INITCOMMONCONTROLSEX v6; // [esp+28h] [ebp-Ch] BYREF
  struct AFX_MODULE_STATE *ModuleState; // [esp+30h] [ebp-4h]
  int v8; // [esp+3Ch] [ebp+8h]

  ModuleState = AfxGetModuleState();
  v8 = ~*((_DWORD *)ModuleState + 6) & a1;
  if ( !v8 )
    return 1;
  v2 = 0;
  memset(&WndClass, 0, sizeof(WndClass));
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  WndClass.hCursor = (HCURSOR)dword_4392B8;
  v6.dwSize = 8;
  if ( (v8 & 1) != 0 )
  {
    WndClass.style = 11;
    WndClass.lpszClassName = "AfxWnd42s";
    v2 = sub_41E3BD(&WndClass) != 0;
  }
  if ( (v8 & 0x20) != 0 )
  {
    LOBYTE(WndClass.style) |= 0x8Bu;
    WndClass.lpszClassName = "AfxOleControl42s";
    if ( sub_41E3BD(&WndClass) )
      v2 |= 0x20u;
  }
  if ( (v8 & 2) != 0 )
  {
    WndClass.style = 0;
    WndClass.lpszClassName = "AfxControlBar42s";
    WndClass.hbrBackground = (HBRUSH)16;
    if ( sub_41E3BD(&WndClass) )
      v2 |= 2u;
  }
  if ( (v8 & 4) != 0 )
  {
    WndClass.style = 8;
    WndClass.hbrBackground = 0;
    if ( unknown_libname_22(&WndClass, "AfxMDIFrame42s", 0x7A01u) )
      v2 |= 4u;
  }
  if ( (v8 & 8) != 0 )
  {
    WndClass.style = 11;
    WndClass.hbrBackground = (HBRUSH)6;
    if ( unknown_libname_22(&WndClass, "AfxFrameOrView42s", 0x7A02u) )
      v2 |= 8u;
  }
  if ( (v8 & 0x10) != 0 )
  {
    v6.dwICC = 255;
    v2 |= (unsigned int)sub_41FA8B(&v6, 16320);
    LOWORD(v8) = v8 & 0xC03F;
  }
  if ( (v8 & 0x40) != 0 )
  {
    v6.dwICC = 16;
    v2 |= (unsigned int)sub_41FA8B(&v6, 64);
  }
  if ( (v8 & 0x80u) != 0 )
  {
    v6.dwICC = 2;
    v2 |= (unsigned int)sub_41FA8B(&v6, 128);
  }
  if ( (v8 & 0x100) != 0 )
  {
    v6.dwICC = 8;
    v2 |= (unsigned int)sub_41FA8B(&v6, 256);
  }
  if ( (v8 & 0x200) != 0 )
  {
    v6.dwICC = 32;
    v2 |= (unsigned int)sub_41FA8B(&v6, 512);
  }
  if ( (v8 & 0x400) != 0 )
  {
    v6.dwICC = 1;
    v2 |= (unsigned int)sub_41FA8B(&v6, 1024);
  }
  if ( (v8 & 0x800) != 0 )
  {
    v6.dwICC = 64;
    v2 |= (unsigned int)sub_41FA8B(&v6, 2048);
  }
  if ( (v8 & 0x1000) != 0 )
  {
    v6.dwICC = 4;
    v2 |= (unsigned int)sub_41FA8B(&v6, 4096);
  }
  if ( (v8 & 0x2000) != 0 )
  {
    v6.dwICC = 128;
    v2 |= (unsigned int)sub_41FA8B(&v6, 0x2000);
  }
  if ( (v8 & 0x4000) != 0 )
  {
    v6.dwICC = 2048;
    v2 |= (unsigned int)sub_41FA8B(&v6, 0x4000);
  }
  if ( (v8 & 0x8000) != 0 )
  {
    v6.dwICC = 1024;
    v2 |= (unsigned int)sub_41FA8B(&v6, 0x8000);
  }
  if ( (v8 & 0x10000) != 0 )
  {
    v6.dwICC = 512;
    v2 |= (unsigned int)sub_41FA8B(&v6, 0x10000);
  }
  if ( (v8 & 0x20000) != 0 )
  {
    v6.dwICC = 256;
    v2 |= (unsigned int)sub_41FA8B(&v6, 0x20000);
  }
  v3 = ModuleState;
  *((_DWORD *)ModuleState + 6) |= v2;
  v4 = *((_DWORD *)v3 + 6);
  if ( (v4 & 0x3FC0) == 0x3FC0 )
  {
    LOBYTE(v4) = v4 | 0x10;
    v2 |= 0x10u;
    *((_DWORD *)v3 + 6) = v4;
  }
  return v8 == (v8 & v2);
}


// ========== Function: ?IsTracking@CFrameWnd@@QBEHXZ @ 0x41FDB9 ==========
BOOL __thiscall CFrameWnd::IsTracking(CFrameWnd *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 36);
  return v1 && v1 != 57346 && v1 != 57345;
}


// ========== Function: sub_41FDD8 @ 0x41FDD8 ==========
int __thiscall sub_41FDD8(_DWORD *this, HWND hWnd)
{
  int result; // eax
  LONG *v4; // esi
  LRESULT (__stdcall *v5)(HWND, CException *, WPARAM, LPARAM); // eax
  LONG v6; // eax

  result = sub_41D8AB(this, (unsigned int)hWnd);
  if ( result )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 80))(this);
    v4 = (LONG *)(*(int (__thiscall **)(_DWORD *))(*this + 128))(this);
    v5 = sub_41D95D();
    v6 = SetWindowLongA(hWnd, -4, (LONG)v5);
    if ( !*v4 )
      *v4 = v6;
    return 1;
  }
  return result;
}


// ========== Function: sub_41FE1B @ 0x41FE1B ==========
unsigned int __thiscall sub_41FE1B(HWND *this)
{
  LONG *v2; // edi

  v2 = (LONG *)(*((int (__thiscall **)(HWND *))*this + 32))(this);
  SetWindowLongA(this[7], -4, *v2);
  *v2 = 0;
  return sub_41D8E4((unsigned int *)this);
}


// ========== Function: sub_41FE43 @ 0x41FE43 ==========
void __cdecl sub_41FE43(_DWORD *a1)
{
  sub_406C12((int)&byte_438B88, a1);
}


// ========== Function: sub_41FE52 @ 0x41FE52 ==========
CString *__thiscall sub_41FE52(CString *this, LPCSTR *a2)
{
  LPCSTR v3; // eax

  v3 = *a2;
  if ( *((int *)*a2 - 3) < 0 )
  {
    *(_DWORD *)this = off_433548;
    CString::operator=(this, *a2);
  }
  else
  {
    *(_DWORD *)this = v3;
    InterlockedIncrement((volatile LONG *)v3 - 3);
  }
  return this;
}


// ========== Function: sub_41FE85 @ 0x41FE85 ==========
int sub_41FE85()
{
  sub_41FE8F();
  return atexit(sub_41FEAA);
}


// ========== Function: sub_41FE8F @ 0x41FE8F ==========
char *sub_41FE8F()
{
  return sub_406B1F(byte_438D48, 80, 64);
}


// ========== Function: sub_41FEAA @ 0x41FEAA ==========
void __cdecl sub_41FEAA()
{
  sub_406B5B((int)byte_438D48);
  DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438D48[16]);
}


// ========== Function: sub_41FEB4 @ 0x41FEB4 ==========
int sub_41FEB4()
{
  sub_41FEBE();
  return atexit(sub_41FEDC);
}


// ========== Function: sub_41FEBE @ 0x41FEBE ==========
char *sub_41FEBE()
{
  return sub_406B1F(byte_438D20, 144, 64);
}


// ========== Function: sub_41FEDC @ 0x41FEDC ==========
void __cdecl sub_41FEDC()
{
  sub_406B5B((int)byte_438D20);
  DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438D20[16]);
}


// ========== Function: sub_41FEE6 @ 0x41FEE6 ==========
int sub_41FEE6()
{
  sub_41FEF0();
  return atexit(sub_41FF0E);
}


// ========== Function: sub_41FEF0 @ 0x41FEF0 ==========
char *sub_41FEF0()
{
  return sub_406B1F(byte_438CF8, 272, 64);
}


// ========== Function: sub_41FF0E @ 0x41FF0E ==========
void __cdecl sub_41FF0E()
{
  sub_406B5B((int)byte_438CF8);
  DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438CF8[16]);
}


// ========== Function: sub_41FF18 @ 0x41FF18 ==========
int sub_41FF18()
{
  sub_41FF22();
  return atexit(sub_41FF40);
}


// ========== Function: sub_41FF22 @ 0x41FF22 ==========
char *sub_41FF22()
{
  return sub_406B1F(byte_438CD0, 528, 64);
}


// ========== Function: sub_41FF40 @ 0x41FF40 ==========
void __cdecl sub_41FF40()
{
  sub_406B5B((int)byte_438CD0);
  DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438CD0[16]);
}


// ========== Function: sub_41FF4A @ 0x41FF4A ==========
void *__thiscall sub_41FF4A(_DWORD *this, int a2)
{
  void *result; // eax
  int v4; // edi
  char *v5; // ecx
  _DWORD *v6; // eax

  if ( !a2 )
  {
    result = off_433548;
    *this = off_433548;
    return result;
  }
  v4 = 64;
  if ( a2 > 64 )
  {
    v4 = 128;
    if ( a2 > 128 )
    {
      v4 = 256;
      if ( a2 > 256 )
      {
        v4 = 512;
        if ( a2 > 512 )
        {
          v6 = sub_41CA70(a2 + 13);
          v6[2] = a2;
          goto LABEL_13;
        }
        v5 = byte_438CD0;
      }
      else
      {
        v5 = byte_438CF8;
      }
    }
    else
    {
      v5 = byte_438D20;
    }
  }
  else
  {
    v5 = byte_438D48;
  }
  v6 = sub_406B83(v5);
  v6[2] = v4;
LABEL_13:
  *v6 = 1;
  *((_BYTE *)v6 + a2 + 12) = 0;
  v6[1] = a2;
  result = v6 + 3;
  *this = result;
  return result;
}


// ========== Function: sub_41FFCC @ 0x41FFCC ==========
void __thiscall sub_41FFCC(_DWORD *lpMem)
{
  int v1; // eax
  char *v2; // ecx
  _DWORD *v3; // [esp-4h] [ebp-4h]

  v1 = lpMem[2];
  switch ( v1 )
  {
    case 64:
      v3 = lpMem;
      v2 = byte_438D48;
      break;
    case 128:
      sub_406C12((int)byte_438D20, lpMem);
      return;
    case 256:
      sub_406C12((int)byte_438CF8, lpMem);
      return;
    default:
      v3 = lpMem;
      if ( v1 != 512 )
      {
        sub_41CA99(lpMem);
        return;
      }
      v2 = byte_438CD0;
      break;
  }
  sub_406C12((int)v2, v3);
}


// ========== Function: sub_420014 @ 0x420014 ==========
volatile LONG *__thiscall sub_420014(void **this)
{
  volatile LONG *result; // eax

  result = (volatile LONG *)*this;
  if ( (char *)*this - 12 != (char *)off_43354C )
  {
    if ( InterlockedDecrement(result - 3) <= 0 )
      sub_41FFCC((_DWORD *)*this - 3);
    result = (volatile LONG *)off_433548;
    *this = off_433548;
  }
  return result;
}


// ========== Function: sub_420045 @ 0x420045 ==========
void __stdcall sub_420045(volatile LONG *lpAddend)
{
  if ( lpAddend != (volatile LONG *)off_43354C && InterlockedDecrement(lpAddend) <= 0 )
    sub_41FFCC(lpAddend);
}


// ========== Function: ?Empty@CString@@QAEXXZ @ 0x420068 ==========
void __thiscall CString::Empty(CString *this)
{
  if ( *(_DWORD *)(*(_DWORD *)this - 8) )
  {
    if ( *(int *)(*(_DWORD *)this - 12) < 0 )
      CString::operator=(this, byte_438D70);
    else
      sub_420014((void **)this);
  }
}


// ========== Function: ?CopyBeforeWrite@CString@@IAEXXZ @ 0x420086 ==========
void __thiscall CString::CopyBeforeWrite(void **this)
{
  _DWORD *v2; // esi

  v2 = *this;
  if ( *((int *)*this - 3) > 1 )
  {
    sub_420014(this);
    sub_41FF4A(this, *(v2 - 2));
    memcpy(*this, v2, *(v2 - 2) + 1);
  }
}


// ========== Function: ?AllocBeforeWrite@CString@@IAEXH@Z @ 0x4200B4 ==========
void __thiscall CString::AllocBeforeWrite(void **this, int a2)
{
  if ( *((int *)*this - 3) > 1 || a2 > *((_DWORD *)*this - 1) )
  {
    sub_420014(this);
    sub_41FF4A(this, a2);
  }
}


// ========== Function: sub_4200DD @ 0x4200DD ==========
void __thiscall sub_4200DD(_DWORD *this)
{
  if ( (_UNKNOWN *)(*this - 12) != off_43354C && InterlockedDecrement((volatile LONG *)(*this - 12)) <= 0 )
    sub_41FFCC((_DWORD *)(*this - 12));
}


// ========== Function: sub_420107 @ 0x420107 ==========
CString *__thiscall sub_420107(CString *this, LPCSTR lpString)
{
  int v3; // eax
  size_t v4; // edi

  *(_DWORD *)this = off_433548;
  if ( lpString )
  {
    if ( HIWORD(lpString) )
    {
      v3 = lstrlenA(lpString);
      v4 = v3;
      if ( v3 )
      {
        sub_41FF4A(this, v3);
        memcpy(*(void **)this, lpString, v4);
      }
    }
    else
    {
      CString::LoadStringA(this, (unsigned __int16)lpString);
    }
  }
  return this;
}


// ========== Function: sub_420159 @ 0x420159 ==========
CString *__thiscall sub_420159(CString *this, wchar_t *String)
{
  size_t v3; // eax
  int v4; // edi

  *(_DWORD *)this = off_433548;
  if ( String )
    v3 = wcslen(String);
  else
    v3 = 0;
  if ( v3 )
  {
    v4 = 2 * v3;
    sub_41FF4A(this, 2 * v3);
    _wcstombsz(*(LPSTR *)this, String, v4 + 1);
    CString::ReleaseBuffer(this, -1);
  }
  return this;
}


// ========== Function: ?AssignCopy@CString@@IAEXHPBD@Z @ 0x4201A5 ==========
void __thiscall CString::AssignCopy(void **this, size_t Size, const char *Src)
{
  CString::AllocBeforeWrite(this, Size);
  memcpy(*this, Src, Size);
  *((_DWORD *)*this - 2) = Size;
  *((_BYTE *)*this + Size) = 0;
}


// ========== Function: sub_4201D2 @ 0x4201D2 ==========
void **__thiscall sub_4201D2(void **this, const char **a2)
{
  int *v3; // ecx
  const char *v4; // eax
  const char *v5; // eax

  v3 = (int *)*this;
  v4 = *a2;
  if ( v3 != (int *)*a2 )
  {
    if ( (*(v3 - 3) >= 0 || v3 - 3 == (int *)off_43354C) && *((int *)v4 - 3) >= 0 )
    {
      sub_420014(this);
      v5 = *a2;
      *this = (void *)*a2;
      InterlockedIncrement((volatile LONG *)v5 - 3);
    }
    else
    {
      CString::AssignCopy(this, *((_DWORD *)v4 - 2), *a2);
    }
  }
  return this;
}


// ========== Function: ??4CString@@QAEABV0@PBD@Z @ 0x420222 ==========
void **__thiscall CString::operator=(void **this, LPCSTR lpString)
{
  size_t v3; // eax

  if ( lpString )
    v3 = lstrlenA(lpString);
  else
    v3 = 0;
  CString::AssignCopy(this, v3, lpString);
  return this;
}


// ========== Function: ??4CString@@QAEABV0@PBG@Z @ 0x420249 ==========
void **__thiscall CString::operator=(void **this, wchar_t *String)
{
  size_t v3; // eax
  int v4; // edi

  if ( String )
    v3 = wcslen(String);
  else
    v3 = 0;
  v4 = 2 * v3;
  CString::AllocBeforeWrite(this, 2 * v3);
  _wcstombsz((LPSTR)*this, String, v4 + 1);
  CString::ReleaseBuffer((CString *)this, -1);
  return this;
}


// ========== Function: sub_42028A @ 0x42028A ==========
void *__thiscall sub_42028A(void **this, size_t Size, void *Src, size_t a4, void *a5)
{
  void *result; // eax

  result = (void *)(Size + a4);
  if ( Size + a4 )
  {
    sub_41FF4A(this, Size + a4);
    memcpy(*this, Src, Size);
    return memcpy((char *)*this + Size, a5, a4);
  }
  return result;
}


// ========== Function: sub_4202C8 @ 0x4202C8 ==========
void __thiscall sub_4202C8(void **this, size_t Size, void *Src)
{
  _DWORD *v4; // eax
  volatile LONG *v5; // ebx
  int v6; // ecx

  if ( Size )
  {
    v4 = *this;
    v5 = (volatile LONG *)((char *)*this - 12);
    if ( *(int *)v5 > 1 || (v6 = *(v4 - 2), (signed int)(v6 + Size) > *(v4 - 1)) )
    {
      sub_42028A(this, *(v4 - 2), v4, Size, Src);
      sub_420045(v5);
    }
    else
    {
      memcpy((char *)v4 + v6, Src, Size);
      *((_DWORD *)*this - 2) += Size;
      *((_BYTE *)*this + *((_DWORD *)*this - 2)) = 0;
    }
  }
}


// ========== Function: sub_420327 @ 0x420327 ==========
void **__thiscall sub_420327(void **this, CHAR *lpString)
{
  size_t v3; // eax

  if ( lpString )
    v3 = lstrlenA(lpString);
  else
    v3 = 0;
  sub_4202C8(this, v3, lpString);
  return this;
}


// ========== Function: sub_42034E @ 0x42034E ==========
_DWORD *__thiscall sub_42034E(_DWORD *this, int a2)
{
  int v3; // ecx
  _DWORD *v4; // eax
  volatile LONG *v5; // ebx
  int v6; // edi

  v3 = a2;
  v4 = (_DWORD *)*this;
  v5 = (volatile LONG *)(*this - 12);
  if ( *(int *)v5 > 1 || a2 > *(v4 - 1) )
  {
    v6 = *(v4 - 2);
    if ( a2 < v6 )
      v3 = *(v4 - 2);
    sub_41FF4A(this, v3);
    memcpy((void *)*this, (const void *)(v5 + 3), v6 + 1);
    *(_DWORD *)(*this - 8) = v6;
    sub_420045(v5);
  }
  return (_DWORD *)*this;
}


// ========== Function: ?ReleaseBuffer@CString@@QAEXH@Z @ 0x42039D ==========
void __thiscall CString::ReleaseBuffer(void **this, int a2)
{
  int v3; // eax

  CString::CopyBeforeWrite(this);
  v3 = a2;
  if ( a2 == -1 )
    v3 = lstrlenA((LPCSTR)*this);
  *((_DWORD *)*this - 2) = v3;
  *((_BYTE *)*this + v3) = 0;
}


// ========== Function: ?GetBufferSetLength@CString@@QAEPADH@Z @ 0x4203C5 ==========
char *__thiscall CString::GetBufferSetLength(CString *this, int a2)
{
  sub_42034E(this, a2);
  *(_DWORD *)(*(_DWORD *)this - 8) = a2;
  *(_BYTE *)(*(_DWORD *)this + a2) = 0;
  return *(char **)this;
}


// ========== Function: ?_wcstombsz@@YAHPADPBGI@Z @ 0x4203E5 ==========
int __cdecl _wcstombsz(LPSTR lpMultiByteStr, LPCWCH lpWideCharStr, unsigned int cbMultiByte)
{
  int result; // eax

  if ( !cbMultiByte && lpMultiByteStr )
    return 0;
  result = WideCharToMultiByte(0, 0, lpWideCharStr, -1, lpMultiByteStr, cbMultiByte, 0, 0);
  if ( result > 0 )
    lpMultiByteStr[result - 1] = 0;
  return result;
}


// ========== Function: sub_42041B @ 0x42041B ==========
int __thiscall sub_42041B(_DWORD **this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(_DWORD *, int, int, int))(*this[13] + 84))(this[13], a2, a3, a4);
}


// ========== Function: sub_420432 @ 0x420432 ==========
struct CObject *__thiscall sub_420432(int this, int nIDDlgItem)
{
  int v2; // eax
  HWND DlgItem; // eax

  v2 = *(_DWORD *)(this + 52);
  if ( v2 )
    return (struct CObject *)(*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 112))(v2, nIDDlgItem);
  DlgItem = GetDlgItem(*(HWND *)(this + 28), nIDDlgItem);
  return sub_41D866(DlgItem);
}


// ========== Function: sub_42045C @ 0x42045C ==========
HWND __thiscall sub_42045C(int this, int nIDDlgItem, HWND *a3)
{
  int v3; // eax
  HWND result; // eax

  v3 = *(_DWORD *)(this + 52);
  if ( v3 )
    return (HWND)(*(int (__thiscall **)(int, int, HWND *))(*(_DWORD *)v3 + 108))(v3, nIDDlgItem, a3);
  result = GetDlgItem(*(HWND *)(this + 28), nIDDlgItem);
  *a3 = result;
  return result;
}


// ========== Function: ?IsDialogMessageA@CWnd@@QAEHPAUtagMSG@@@Z @ 0x42048A ==========
int __thiscall CWnd::IsDialogMessageA(HWND *this, struct tagMSG *lpMsg)
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  if ( (*((_BYTE *)this + 37) & 1) == 0 )
    return IsDialogMessageA(this[7], lpMsg);
  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, HWND *, struct tagMSG *))(**((_DWORD **)ModuleState + 1038) + 36))(
           *((_DWORD *)ModuleState + 1038),
           this,
           lpMsg);
}


// ========== Function: sub_4204BD @ 0x4204BD ==========
LONG __thiscall sub_4204BD(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 112))(*(_DWORD *)(this + 56));
  else
    return GetWindowLongA(*(HWND *)(this + 28), -16);
}


// ========== Function: sub_4204D7 @ 0x4204D7 ==========
LONG __thiscall sub_4204D7(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 116))(*(_DWORD *)(this + 56));
  else
    return GetWindowLongA(*(HWND *)(this + 28), -20);
}


// ========== Function: sub_4204F1 @ 0x4204F1 ==========
int __thiscall sub_4204F1(int this, LPCSTR lpString)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 56);
  if ( v2 )
    return (*(int (__thiscall **)(int, LPCSTR))(*(_DWORD *)v2 + 128))(v2, lpString);
  else
    return SetWindowTextA(*(HWND *)(this + 28), lpString);
}


// ========== Function: sub_420518 @ 0x420518 ==========
int __thiscall sub_420518(int this, LPSTR lpString, int nMaxCount)
{
  int v3; // eax

  v3 = *(_DWORD *)(this + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int, LPSTR, int))(*(_DWORD *)v3 + 132))(v3, lpString, nMaxCount);
  else
    return GetWindowTextA(*(HWND *)(this + 28), lpString, nMaxCount);
}


// ========== Function: sub_420547 @ 0x420547 ==========
int __thiscall sub_420547(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 144))(*(_DWORD *)(this + 56));
  else
    return GetDlgCtrlID(*(HWND *)(this + 28));
}


// ========== Function: ?MoveWindow@CWnd@@QAEXHHHHH@Z @ 0x420562 ==========
void __thiscall CWnd::MoveWindow(CWnd *this, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
{
  int v6; // eax

  v6 = *((_DWORD *)this + 14);
  if ( v6 )
    (*(void (__thiscall **)(int, int, int, int, int, BOOL))(*(_DWORD *)v6 + 152))(v6, X, Y, nWidth, nHeight, bRepaint);
  else
    MoveWindow(*((HWND *)this + 7), X, Y, nWidth, nHeight, bRepaint);
}


// ========== Function: ?SetWindowPos@CWnd@@QAEHPBV1@HHHHI@Z @ 0x4205A3 ==========
int __thiscall CWnd::SetWindowPos(CWnd *this, HWND hWndInsertAfter, int X, int Y, int a5, int cy, UINT uFlags)
{
  int v7; // eax
  HWND v8; // eax

  v7 = *((_DWORD *)this + 14);
  if ( v7 )
    return (*(int (__thiscall **)(int, HWND, int, int, int, int, UINT))(*(_DWORD *)v7 + 156))(
             v7,
             hWndInsertAfter,
             X,
             Y,
             a5,
             cy,
             uFlags);
  v8 = hWndInsertAfter;
  if ( hWndInsertAfter )
    v8 = (HWND)*((_DWORD *)hWndInsertAfter + 7);
  return SetWindowPos(*((HWND *)this + 7), v8, X, Y, a5, cy, uFlags);
}


// ========== Function: sub_4205F2 @ 0x4205F2 ==========
int __thiscall sub_4205F2(int this, int nCmdShow)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 56);
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 160))(v2, nCmdShow);
  else
    return ShowWindow(*(HWND *)(this + 28), nCmdShow);
}


// ========== Function: sub_420619 @ 0x420619 ==========
int __thiscall sub_420619(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 164))(*(_DWORD *)(this + 56));
  else
    return IsWindowEnabled(*(HWND *)(this + 28));
}


// ========== Function: ?ShowWindow@CWnd@@QAEHH@Z @ 0x420634 ==========
int __thiscall CWnd::ShowWindow(CWnd *this, BOOL bEnable)
{
  int v2; // eax

  v2 = *((_DWORD *)this + 14);
  if ( v2 )
    return (*(int (__thiscall **)(int, BOOL))(*(_DWORD *)v2 + 168))(v2, bEnable);
  else
    return EnableWindow(*((HWND *)this + 7), bEnable);
}


// ========== Function: sub_42065B @ 0x42065B ==========
struct CObject *__thiscall sub_42065B(int this)
{
  int v1; // eax
  HWND v2; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (struct CObject *)(*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 172))(*(_DWORD *)(this + 56));
  v2 = SetFocus(*(HWND *)(this + 28));
  return sub_41D866(v2);
}


// ========== Function: sub_42067C @ 0x42067C ==========
int sub_42067C(int a1, int a2, int a3, int a4, int a5, int a6, ...)
{
  int result; // eax
  int v7; // ecx
  va_list va; // [esp+20h] [ebp+20h] BYREF

  va_start(va, a6);
  result = a1;
  v7 = *(_DWORD *)(a1 + 56);
  if ( v7 )
    return (*(int (__thiscall **)(int, int, int, int, int, int, char *))(*(_DWORD *)v7 + 88))(
             v7,
             a2,
             a3,
             a4,
             a5,
             a6,
             va);
  return result;
}


// ========== Function: ?GetProperty@CWnd@@QBEXJGPAX@Z @ 0x4206A3 ==========
void __thiscall CWnd::GetProperty(CWnd *this, int a2, int a3, void *a4)
{
  if ( *((_DWORD *)this + 14) )
    sub_42067C((int)this, a2, 2, a3, (int)a4, 0);
}


// ========== Function: sub_4206C5 @ 0x4206C5 ==========
void __thiscall sub_4206C5(int this, int a2)
{
  HWND Parent; // eax
  _DWORD *ValueAt; // eax
  int v5; // eax

  if ( this )
  {
    if ( !*(_DWORD *)(this + 56) )
    {
      Parent = GetParent(*(HWND *)(this + 28));
      ValueAt = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(a2 + 4), (unsigned int)Parent);
      if ( ValueAt )
      {
        v5 = ValueAt[13];
        if ( v5 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v5 + 140))(v5, this);
      }
    }
  }
}


// ========== Function: sub_420702 @ 0x420702 ==========
void __thiscall sub_420702(_DWORD *this, int a2)
{
  int v2; // eax

  if ( !this[14] )
  {
    v2 = *(_DWORD *)(a2 + 52);
    if ( v2 )
      (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)v2 + 140))(v2, this);
  }
}


// ========== Function: sub_420721 @ 0x420721 ==========
_DWORD *__thiscall sub_420721(int this, int a2)
{
  _DWORD *result; // eax
  int v3; // ecx

  result = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(this + 32), *(_DWORD *)(a2 + 28));
  if ( result )
  {
    v3 = result[9];
    if ( v3 )
    {
      if ( *(_DWORD **)(v3 + 56) == result )
        *(_DWORD *)(v3 + 56) = 0;
    }
    *(_DWORD *)(a2 + 56) = result;
    result[9] = a2;
  }
  return result;
}


// ========== Function: ??0CStdioFile@@QAE@XZ @ 0x42074F ==========
CStdioFile *__thiscall CStdioFile::CStdioFile(CStdioFile *this)
{
  sub_4214F0();
  *((_DWORD *)this + 4) = 0;
  *(_DWORD *)this = &CStdioFile::`vftable';
  return this;
}


// ========== Function: sub_420765 @ 0x420765 ==========
CStdioFile *__thiscall sub_420765(CStdioFile *lpMem, char a2)
{
  CStdioFile::~CStdioFile(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??1CStdioFile@@UAE@XZ @ 0x420781 ==========
void __thiscall CStdioFile::~CStdioFile(CStdioFile *this)
{
  *(_DWORD *)this = &CStdioFile::`vftable';
  if ( *((_DWORD *)this + 4) && *((_DWORD *)this + 2) )
    CStdioFile::Close(this);
  CFile::~CFile(this);
}


// ========== Function: ?Open@CStdioFile@@UAEHPBDIPAVCFileException@@@Z @ 0x4207C4 ==========
int __thiscall CStdioFile::Open(CStdioFile *this, const char *lpFileName, unsigned int a3, struct CFileException *Mode)
{
  struct CFileException *v4; // edi
  unsigned int v5; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  unsigned int *v11; // eax
  struct CFileException *v13; // [esp-4h] [ebp-10h]

  v4 = Mode;
  v5 = a3;
  BYTE1(v5) = BYTE1(a3) & 0xBF;
  v13 = Mode;
  *((_DWORD *)this + 4) = 0;
  if ( !CFile::Open(this, lpFileName, v5, v13) )
    return 0;
  if ( (a3 & 0x1000) != 0 )
  {
    if ( (a3 & 0x2000) == 0 )
    {
      LOBYTE(Mode) = 119;
      goto LABEL_7;
    }
LABEL_6:
    LOBYTE(Mode) = 97;
LABEL_7:
    v7 = 1;
    if ( (a3 & 1) != 0 )
      goto LABEL_9;
    goto LABEL_8;
  }
  if ( (a3 & 1) != 0 )
    goto LABEL_6;
  LOBYTE(Mode) = 114;
  v7 = 1;
  if ( (a3 & 2) != 0 )
  {
LABEL_8:
    BYTE1(Mode) = 43;
    v7 = 2;
  }
LABEL_9:
  v8 = 0x4000;
  if ( (a3 & 0x8000) == 0 )
  {
    *((_BYTE *)&Mode + v7) = 116;
    v9 = v7 + 1;
  }
  else
  {
    *((_BYTE *)&Mode + v7) = 98;
    v9 = v7 + 1;
    v8 = 0;
  }
  *((_BYTE *)&Mode + v9) = 0;
  v10 = _open_osfhandle(*((_DWORD *)this + 1), v8);
  if ( v10 != -1 )
    *((_DWORD *)this + 4) = _fdopen(v10, (const char *)&Mode);
  if ( !*((_DWORD *)this + 4) )
  {
    if ( v4 )
    {
      *((_DWORD *)v4 + 3) = *__doserrno();
      v11 = __doserrno();
      *((_DWORD *)v4 + 2) = sub_421E53(*v11);
    }
    CFile::Abort(this);
    return 0;
  }
  return 1;
}


// ========== Function: ?Read@CStdioFile@@UAEIPAXI@Z @ 0x420898 ==========
size_t __thiscall CStdioFile::Read(FILE **this, void *Buffer, size_t ElementCount)
{
  size_t v5; // edi

  if ( !ElementCount )
    return 0;
  v5 = sub_40EAF3(Buffer, 1u, ElementCount, this[4]);
  if ( !v5 && (this[4]->_flag & 0x10) == 0 )
  {
    __doserrno();
    sub_421DE8(1);
  }
  if ( (this[4]->_flag & 0x20) != 0 )
  {
    clearerr(this[4]);
    __doserrno();
    sub_421DE8(1);
  }
  return v5;
}


// ========== Function: ?Write@CStdioFile@@UAEXPBXI@Z @ 0x420904 ==========
void __thiscall CStdioFile::Write(FILE **this, void *Buffer, size_t ElementCount)
{
  if ( sub_40EC0A(Buffer, 1u, ElementCount, this[4]) != ElementCount )
  {
    __doserrno();
    sub_421DE8(1);
  }
}


// ========== Function: ?WriteString@CStdioFile@@UAEXPBD@Z @ 0x420937 ==========
void __thiscall CStdioFile::WriteString(FILE **this, char *Buffer)
{
  if ( fputs(Buffer, this[4]) == -1 )
  {
    __doserrno();
    sub_421DE8(13);
  }
}


// ========== Function: sub_420962 @ 0x420962 ==========
char *__thiscall sub_420962(FILE **this, char *Buffer, int MaxCount)
{
  char *v4; // edi

  v4 = fgets(Buffer, MaxCount, this[4]);
  if ( !v4 && (this[4]->_flag & 0x10) == 0 )
  {
    clearerr(this[4]);
    __doserrno();
    sub_421DE8(1);
  }
  return v4;
}


// ========== Function: sub_4209A7 @ 0x4209A7 ==========
BOOL __thiscall sub_4209A7(FILE **this, void **a2)
{
  char *i; // esi
  char *v4; // ebp
  int v5; // eax
  int v6; // ebp
  _DWORD *v7; // eax
  int v8; // ecx

  CString::operator=(a2, byte_438D70);
  for ( i = (char *)sub_42034E(a2, 128); ; i = (char *)sub_42034E(a2, v6 + 128) + v6 )
  {
    v4 = fgets(i, 129, this[4]);
    CString::ReleaseBuffer(a2, -1);
    if ( !v4 )
      break;
    v5 = lstrlenA(i);
    if ( v5 < 128 || i[v5 - 1] == 10 )
      goto LABEL_8;
    v6 = *((_DWORD *)*a2 - 2);
  }
  if ( (this[4]->_flag & 0x10) == 0 )
  {
    clearerr(this[4]);
    __doserrno();
    sub_421DE8(1);
  }
LABEL_8:
  v7 = sub_42034E(a2, 0);
  v8 = *((_DWORD *)*a2 - 2);
  if ( v8 && *((_BYTE *)v7 + v8 - 1) == 10 )
    CString::GetBufferSetLength((CString *)a2, v8 - 1);
  return v4 != 0;
}


// ========== Function: ?Seek@CStdioFile@@UAEJJI@Z @ 0x420A6A ==========
int __thiscall CStdioFile::Seek(FILE **this, int Offset, int Origin)
{
  if ( fseek(this[4], Offset, Origin) )
  {
    __doserrno();
    sub_421DE8(9);
  }
  return ftell(this[4]);
}


// ========== Function: ?GetPosition@CStdioFile@@UBEKXZ @ 0x420AA2 ==========
int __thiscall CStdioFile::GetPosition(FILE **this)
{
  int result; // eax

  result = ftell(this[4]);
  if ( result == -1 )
  {
    __doserrno();
    sub_421DE8(6);
  }
  return result;
}


// ========== Function: ?Flush@CStdioFile@@UAEXXZ @ 0x420ACC ==========
void __thiscall CStdioFile::Flush(FILE **this)
{
  if ( this[4] )
  {
    if ( fflush(this[4]) )
    {
      __doserrno();
      sub_421DE8(13);
    }
  }
}


// ========== Function: ?Close@CStdioFile@@UAEXXZ @ 0x420AF4 ==========
void __thiscall CStdioFile::Close(CStdioFile *this)
{
  int v2; // eax
  FILE *v3; // ecx

  v2 = 0;
  v3 = (FILE *)*((_DWORD *)this + 4);
  if ( v3 )
    v2 = fclose(v3);
  *((_DWORD *)this + 1) = -1;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  if ( v2 )
  {
    __doserrno();
    sub_421DE8(13);
  }
}


// ========== Function: ?Abort@CStdioFile@@UAEXXZ @ 0x420B2A ==========
void __thiscall CStdioFile::Abort(FILE **this)
{
  if ( this[4] && this[2] )
    fclose(this[4]);
  this[1] = (FILE *)-1;
  this[4] = 0;
  this[2] = 0;
}


// ========== Function: sub_420B4F @ 0x420B4F ==========
// attributes: thunk
void __noreturn sub_420B4F()
{
  sub_41B510();
}


// ========== Function: sub_420B57 @ 0x420B57 ==========
// attributes: thunk
void __noreturn sub_420B57()
{
  sub_41B510();
}


// ========== Function: nullsub_13 @ 0x420B5C ==========
void __stdcall nullsub_13(int a1, int a2)
{
  ;
}


// ========== Function: ?IsKindOf@CObject@@QBEHPBUCRuntimeClass@@@Z @ 0x420B5F ==========
int __thiscall CObject::IsKindOf(CObject *this, const struct CRuntimeClass *a2)
{
  CRuntimeClass *v2; // eax

  v2 = (CRuntimeClass *)(**(int (__thiscall ***)(CObject *))this)(this);
  return CRuntimeClass::IsDerivedFrom(v2, a2);
}


// ========== Function: ?AfxDynamicDownCast@@YAPAVCObject@@PAUCRuntimeClass@@PAV1@@Z @ 0x420B71 ==========
struct CObject *__cdecl AfxDynamicDownCast(struct CRuntimeClass *a1, struct CObject *a2)
{
  if ( a2 && CObject::IsKindOf(a2, a1) )
    return a2;
  else
    return 0;
}


// ========== Function: sub_420B91 @ 0x420B91 ==========
int __thiscall sub_420B91(_DWORD *this)
{
  int result; // eax
  bool v2; // zf
  int v3; // [esp+0h] [ebp-24h] BYREF
  int v4; // [esp+10h] [ebp-14h]
  int *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  result = 0;
  v2 = this[3] == 0;
  v5 = &v3;
  if ( !v2 )
  {
    v4 = 0;
    v6 = 0;
    return ((int (*)(void))this[3])();
  }
  return result;
}


// ========== Function: ?IsDerivedFrom@CRuntimeClass@@QBEHPBU1@@Z @ 0x420BD7 ==========
int __thiscall CRuntimeClass::IsDerivedFrom(CRuntimeClass *this, const struct CRuntimeClass *a2)
{
  while ( this )
  {
    if ( this == a2 )
      return 1;
    this = (CRuntimeClass *)*((_DWORD *)this + 4);
  }
  return 0;
}


// ========== Function: ??0CException@@QAE@XZ @ 0x420BF0 ==========
CException *__thiscall CException::CException(CException *this)
{
  CException *result; // eax

  result = this;
  *((_DWORD *)this + 1) = 1;
  return result;
}


// ========== Function: ??0CException@@QAE@H@Z @ 0x420BFA ==========
CException *__thiscall CException::CException(CException *this, int a2)
{
  CException *result; // eax

  result = this;
  *((_DWORD *)this + 1) = a2;
  return result;
}


// ========== Function: ?Delete@CException@@QAEXXZ @ 0x420C06 ==========
void __thiscall CException::Delete(CException *this)
{
  if ( *((int *)this + 1) > 0 )
  {
    if ( this )
      (*(void (__thiscall **)(CException *, int))(*(_DWORD *)this + 4))(this, 1);
  }
}


// ========== Function: sub_420C18 @ 0x420C18 ==========
int __thiscall sub_420C18(void *this, UINT uType, unsigned int a3)
{
  CHAR Text[512]; // [esp+0h] [ebp-204h] BYREF
  int v5; // [esp+200h] [ebp-4h] BYREF

  if ( (*(int (__thiscall **)(void *, CHAR *, int, int *))(*(_DWORD *)this + 12))(this, Text, 512, &v5) )
    return sub_423222(Text, uType, v5);
  if ( !a3 )
    a3 = 61472;
  return sub_42325A(a3, uType, v5);
}


// ========== Function: ?UpdateSysColors@AUX_DATA@@QAEXXZ @ 0x420C6D ==========
void __thiscall AUX_DATA::UpdateSysColors(AUX_DATA *this)
{
  *((_DWORD *)this + 10) = GetSysColor(15);
  *((_DWORD *)this + 11) = GetSysColor(16);
  *((_DWORD *)this + 12) = GetSysColor(20);
  *((_DWORD *)this + 13) = GetSysColor(18);
  *((_DWORD *)this + 14) = GetSysColor(6);
  *((_DWORD *)this + 9) = GetSysColorBrush(15);
  *((_DWORD *)this + 8) = GetSysColorBrush(6);
}


// ========== Function: ?UpdateSysMetrics@AUX_DATA@@QAEXXZ @ 0x420CB1 ==========
void __thiscall AUX_DATA::UpdateSysMetrics(AUX_DATA *this)
{
  int SystemMetrics; // eax
  bool v3; // zf
  HDC DC; // edi

  *((_DWORD *)this + 2) = GetSystemMetrics(11);
  SystemMetrics = GetSystemMetrics(12);
  v3 = *((_DWORD *)this + 26) == 0;
  *((_DWORD *)this + 3) = SystemMetrics;
  if ( v3 )
    AfxEnableWin31Compatibility();
  else
    AfxEnableWin40Compatibility();
  DC = GetDC(0);
  *((_DWORD *)this + 6) = GetDeviceCaps(DC, 88);
  *((_DWORD *)this + 7) = GetDeviceCaps(DC, 90);
  ReleaseDC(0, DC);
}


// ========== Function: ?LoadStringA@CString@@QAEHI@Z @ 0x420D09 ==========
BOOL __thiscall CString::LoadStringA(CString *this, UINT uID)
{
  int v2; // edi
  unsigned int v4; // edi
  CHAR *v5; // eax
  int v6; // ebx
  CHAR String[256]; // [esp+8h] [ebp-104h] BYREF
  CString *v8; // [esp+108h] [ebp-4h]

  v8 = this;
  v2 = AfxLoadString(uID, String, 0x100u);
  if ( (unsigned int)(256 - v2) <= 2 )
  {
    v4 = 256;
    do
    {
      v4 += 256;
      v5 = (CHAR *)sub_42034E(v8, v4 - 1);
      v6 = AfxLoadString(uID, v5, v4);
    }
    while ( (int)(v4 - v6) <= 2 );
    CString::ReleaseBuffer((void **)v8, -1);
    return v6 > 0;
  }
  else
  {
    CString::operator=((void **)v8, String);
    return v2 > 0;
  }
}


// ========== Function: ?AfxLoadString@@YGHIPADI@Z @ 0x420D8D ==========
int __stdcall AfxLoadString(UINT uID, LPSTR lpBuffer, unsigned int cchBufferMax)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  int result; // eax

  ModuleState = AfxGetModuleState();
  result = LoadStringA(*((HINSTANCE *)ModuleState + 3), uID, lpBuffer, cchBufferMax);
  if ( !result )
    *lpBuffer = 0;
  return result;
}


// ========== Function: ?AfxLockTempMaps@@YGXXZ @ 0x420DB4 ==========
void __stdcall AfxLockTempMaps()
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // eax

  ModuleThreadState = AfxGetModuleThreadState();
  ++*((_DWORD *)ModuleThreadState + 4);
}


// ========== Function: sub_420DBD @ 0x420DBD ==========
BOOL __stdcall sub_420DBD(size_t Size)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // ebx
  int v2; // eax
  int v3; // eax
  struct CWinThread *Thread; // eax
  void (__stdcall *v5)(_DWORD, _DWORD); // eax
  int v6; // edi
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v8; // esi
  _DWORD *v9; // eax
  void *v10; // eax
  SIZE_T Sizea; // [esp+14h] [ebp+8h]

  ModuleThreadState = AfxGetModuleThreadState();
  v2 = *((_DWORD *)ModuleThreadState + 4);
  if ( v2 )
  {
    v3 = v2 - 1;
    *((_DWORD *)ModuleThreadState + 4) = v3;
    if ( !v3 )
    {
      if ( Size )
      {
        if ( Size != -1 )
        {
          Thread = AfxGetThread();
          if ( Thread )
          {
            v5 = (void (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)Thread + 21);
            if ( v5 )
              v5(0, 0);
          }
        }
        sub_420FDB(*((_DWORD *)ModuleThreadState + 8));
        sub_420FDB(*((_DWORD *)ModuleThreadState + 7));
        sub_420FDB(*((_DWORD *)ModuleThreadState + 6));
        sub_420FDB(*((_DWORD *)ModuleThreadState + 5));
        sub_420FDB(*((_DWORD *)ModuleThreadState + 9));
      }
      v6 = *((_DWORD *)AfxGetModuleState() + 1);
      Data = CThreadLocalObject::GetData(
               (CThreadLocalObject *)&unk_438D7C,
               CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
      v8 = Data;
      if ( v6
        && (!*((_DWORD *)Data + 3) || sub_40F381(*((_DWORD **)Data + 3)) < *(_DWORD *)(v6 + 184))
        && *(_DWORD *)(v6 + 184) )
      {
        v9 = (_DWORD *)*((_DWORD *)v8 + 3);
        Sizea = 0;
        if ( v9 )
        {
          Sizea = sub_40F381(v9);
          sub_40D386(*((LPVOID *)v8 + 3));
        }
        v10 = malloc(*(_DWORD *)(v6 + 184));
        *((_DWORD *)v8 + 3) = v10;
        if ( !v10 && Sizea )
          *((_DWORD *)v8 + 3) = malloc(Sizea);
      }
    }
  }
  return *((_DWORD *)ModuleThreadState + 4) != 0;
}


// ========== Function: sub_420EB7 @ 0x420EB7 ==========
_DWORD *__thiscall sub_420EB7(_DWORD *this, int a2, int a3, int a4)
{
  sub_41BB56(this + 1, 10);
  sub_41BB56(this + 8, 4);
  *this = &CHandleMap::`vftable';
  sub_41BB99((int)(this + 8), 7, 0);
  this[15] = a2;
  this[16] = a3;
  this[17] = a4;
  return this;
}


// ========== Function: ?FromHandle@CHandleMap@@QAEPAVCObject@@PAX@Z @ 0x420F1C ==========
struct CObject *__thiscall CHandleMap::FromHandle(CHandleMap *this, int (__cdecl *a2)(unsigned int))
{
  struct CObject *result; // eax
  int v5; // ecx
  char *v6; // ecx
  void (__noreturn *v7)(); // eax
  _DWORD *v8; // ecx
  int v9; // ebx
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // eax
  _DWORD v13[5]; // [esp+0h] [ebp-20h] BYREF
  int v14; // [esp+1Ch] [ebp-4h]
  void (__noreturn *v15)(); // [esp+28h] [ebp+8h]

  v13[4] = v13;
  if ( !a2 )
    return 0;
  result = (struct CObject *)CMapPtrToPtr::GetValueAt((CHandleMap *)((char *)this + 4), (unsigned int)a2);
  if ( !result )
  {
    result = (struct CObject *)CMapPtrToPtr::GetValueAt((CHandleMap *)((char *)this + 32), (unsigned int)a2);
    if ( result )
    {
      v5 = *((_DWORD *)this + 16);
      *(_DWORD *)((char *)result + v5) = a2;
      v6 = (char *)result + v5;
      if ( *((_DWORD *)this + 17) == 2 )
        *((_DWORD *)v6 + 1) = a2;
    }
    else
    {
      v7 = AfxSetNewHandler((void (__noreturn *)())AfxCriticalNewHandler);
      v8 = (_DWORD *)*((_DWORD *)this + 15);
      v14 = 0;
      v15 = v7;
      v9 = sub_420B91(v8);
      if ( !v9 )
        sub_41B4F7();
      v10 = sub_41BCFD((_DWORD *)this + 8, (unsigned int)a2);
      v14 = -1;
      *v10 = v9;
      AfxSetNewHandler(v15);
      v11 = *((_DWORD *)this + 16);
      *(_DWORD *)(v11 + v9) = a2;
      v12 = v9 + v11;
      if ( *((_DWORD *)this + 17) == 2 )
        *(_DWORD *)(v12 + 4) = a2;
      return (struct CObject *)v9;
    }
  }
  return result;
}


// ========== Function: sub_420FDB @ 0x420FDB ==========
void __thiscall sub_420FDB(_DWORD *this)
{
  bool v2; // zf
  _DWORD *v3; // eax
  int v4; // [esp+4h] [ebp-Ch] BYREF
  int v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  if ( this )
  {
    v2 = this[11] == 0;
    v5 = -(this[11] != 0);
    if ( !v2 )
    {
      do
      {
        sub_41BD8F(this + 8, (_DWORD **)&v5, &v4, &v6);
        v3 = (_DWORD *)(v6 + this[16]);
        *v3 = 0;
        if ( this[17] == 2 )
          v3[1] = 0;
        if ( v6 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 4))(v6, 1);
      }
      while ( v5 );
    }
    sub_41BBDE((int)(this + 8));
  }
}


// ========== Function: ??0CDialogTemplate@@QAE@PBUDLGTEMPLATE@@@Z @ 0x421040 ==========
CDialogTemplate *__thiscall CDialogTemplate::CDialogTemplate(CDialogTemplate *this, const struct DLGTEMPLATE *Src)
{
  unsigned int v3; // eax

  if ( Src )
  {
    v3 = sub_421139(Src);
    CDialogTemplate::SetTemplate(this, Src, v3);
  }
  else
  {
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 2) = 0;
  }
  return this;
}


// ========== Function: ?SetTemplate@CDialogTemplate@@IAEHPBUDLGTEMPLATE@@I@Z @ 0x42106F ==========
int __thiscall CDialogTemplate::SetTemplate(CDialogTemplate *this, const struct DLGTEMPLATE *Src, unsigned int a3)
{
  int result; // eax
  int *v5; // edi
  int v6; // eax
  void *v7; // [esp-8h] [ebp-Ch]

  *((_DWORD *)this + 1) = a3;
  result = (int)GlobalAlloc(0x40u, a3 + 64);
  *(_DWORD *)this = result;
  if ( result )
  {
    v5 = (int *)GlobalLock((HGLOBAL)result);
    memcpy(v5, Src, *((_DWORD *)this + 1));
    if ( *((_WORD *)v5 + 1) == 0xFFFF )
      v6 = v5[3];
    else
      v6 = *v5;
    v7 = *(void **)this;
    *((_DWORD *)this + 2) = ((unsigned int)~v6 >> 6) & 1;
    GlobalUnlock(v7);
    return 1;
  }
  return result;
}


// ========== Function: ??1InitialThreadParam@UMSFreeVirtualProcessorRoot@details@Concurrency@@QAE@XZ @ 0x4210CF ==========
void __thiscall Concurrency::details::UMSFreeVirtualProcessorRoot::InitialThreadParam::~InitialThreadParam(
        HGLOBAL *this)
{
  if ( *this )
    GlobalFree(*this);
}


// ========== Function: ?Detach@?$CComPtrBase@UICustomDestinationList@@@ATL@@QAEPAUICustomDestinationList@@XZ @ 0x4210DD ==========
int __thiscall ATL::CComPtrBase<ICustomDestinationList>::Detach(int *this)
{
  int result; // eax

  result = *this;
  *this = 0;
  return result;
}


// ========== Function: sub_4210E3 @ 0x4210E3 ==========
__int16 *__cdecl sub_4210E3(_WORD *a1)
{
  __int16 *result; // eax
  __int16 v2; // cx
  __int16 v3; // cx

  if ( a1[1] == 0xFFFF )
    result = a1 + 13;
  else
    result = a1 + 9;
  v2 = *result;
  if ( *result == -1 )
  {
    result += 2;
  }
  else
  {
    while ( 1 )
    {
      ++result;
      if ( !v2 )
        break;
      v2 = *result;
    }
  }
  v3 = *result;
  if ( *result == -1 )
  {
    result += 2;
  }
  else
  {
    while ( 1 )
    {
      ++result;
      if ( !v3 )
        break;
      v3 = *result;
    }
  }
  while ( *result++ )
    ;
  return result;
}


// ========== Function: sub_421139 @ 0x421139 ==========
char *__cdecl sub_421139(int *a1)
{
  BOOL v1; // esi
  __int16 *v2; // eax
  int v3; // ecx
  unsigned __int16 v4; // cx
  int v5; // esi
  int v6; // edx
  char *v7; // eax
  char *v8; // eax
  __int16 v9; // cx
  __int16 *v10; // eax
  __int16 v11; // cx
  unsigned __int16 *v12; // eax

  v1 = *((_WORD *)a1 + 1) == 0xFFFF;
  v2 = sub_4210E3(a1);
  if ( *((_WORD *)a1 + 1) == 0xFFFF )
    v3 = a1[3];
  else
    v3 = *a1;
  if ( (v3 & 0x40) != 0 )
    v2 += (v1 ? 3 : 1) + wcslen((const wchar_t *)&v2[v1 ? 3 : 1]) + 1;
  if ( v1 )
    v4 = *((_WORD *)a1 + 8);
  else
    v4 = *((_WORD *)a1 + 4);
  if ( v4 )
  {
    v5 = v1 ? 24 : 18;
    v6 = v4;
    do
    {
      v7 = (char *)v2 + 3;
      LOBYTE(v7) = (unsigned __int8)v7 & 0xFC;
      v8 = &v7[v5];
      v9 = *(_WORD *)v8;
      if ( *(_WORD *)v8 == 0xFFFF )
      {
        v10 = (__int16 *)(v8 + 4);
      }
      else
      {
        v10 = (__int16 *)(v8 + 2);
        while ( v9 )
          v9 = *v10++;
      }
      v11 = *v10;
      if ( *v10 == -1 )
      {
        v12 = (unsigned __int16 *)(v10 + 2);
      }
      else
      {
        v12 = (unsigned __int16 *)(v10 + 1);
        while ( v11 )
          v11 = *v12++;
      }
      --v6;
      v2 = (__int16 *)((char *)v12 + *v12 + 2);
    }
    while ( v6 );
  }
  return (char *)((char *)v2 - (char *)a1);
}


// ========== Function: ?GetFont@CDialogTemplate@@SAHPBUDLGTEMPLATE@@AAVCString@@AAG@Z @ 0x4211F1 ==========
int __cdecl CDialogTemplate::GetFont(struct DLGTEMPLATE *a1, struct CString *a2, unsigned __int16 *a3)
{
  DWORD style; // eax
  __int16 *v5; // eax
  const WCHAR *v6; // esi
  CHAR *BufferSetLength; // eax

  if ( HIWORD(a1->style) == 0xFFFF )
    style = *(_DWORD *)&a1->y;
  else
    style = a1->style;
  if ( (style & 0x40) == 0 )
    return 0;
  v5 = sub_4210E3(a1);
  *a3 = *v5;
  v6 = (const WCHAR *)&v5[HIWORD(a1->style) != 0xFFFF ? 1 : 3];
  BufferSetLength = CString::GetBufferSetLength(a2, 32);
  WideCharToMultiByte(0, 0, v6, -1, BufferSetLength, 32, 0, 0);
  CString::ReleaseBuffer((void **)a2, -1);
  return 1;
}


// ========== Function: sub_421260 @ 0x421260 ==========
int __thiscall sub_421260(int this, LPCCH lpMultiByteStr, __int16 a3)
{
  bool v3; // zf
  _WORD *v5; // ebx
  __int16 v6; // ax
  int v7; // eax
  int v8; // esi
  __int16 *v9; // edi
  size_t v10; // ecx
  int v11; // eax
  char *v12; // edi
  __int16 v13; // dx
  __int16 *v14; // ecx
  int v15; // esi
  void *v16; // [esp-Ch] [ebp-60h]
  WCHAR WideCharStr[32]; // [esp+4h] [ebp-50h] BYREF
  __int16 *v18; // [esp+44h] [ebp-10h]
  int v19; // [esp+48h] [ebp-Ch]
  int v20; // [esp+4Ch] [ebp-8h]
  BOOL v21; // [esp+50h] [ebp-4h]
  LPCCH lpMultiByteStra; // [esp+5Ch] [ebp+8h]

  v3 = *(_DWORD *)(this + 4) == 0;
  v20 = this;
  if ( v3 )
    return 0;
  v5 = GlobalLock(*(HGLOBAL *)this);
  v6 = v5[1];
  v21 = v6 == -1;
  if ( v6 == -1 )
    v7 = *((_DWORD *)v5 + 3);
  else
    v7 = *(_DWORD *)v5;
  v19 = v7 & 0x40;
  v8 = 2 * (v21 ? 3 : 1);
  if ( v21 )
    *((_DWORD *)v5 + 3) |= 0x40u;
  else
    *(_DWORD *)v5 |= 0x40u;
  lpMultiByteStra = (LPCCH)(v8 + 2 * MultiByteToWideChar(0, 0, lpMultiByteStr, -1, WideCharStr, 32));
  v9 = sub_4210E3(v5);
  v10 = 0;
  v18 = v9;
  if ( v19 )
    v10 = v8 + 2 * wcslen((const wchar_t *)&v9[v8 / 2u]) + 2;
  v11 = (int)v9 + v10 + 3;
  LOBYTE(v11) = v11 & 0xFC;
  v19 = v11;
  v12 = (char *)((int)&lpMultiByteStra[(_DWORD)v9 + 3] & 0xFFFFFFFC);
  if ( v21 )
    v13 = v5[8];
  else
    v13 = v5[4];
  if ( lpMultiByteStra != (LPCCH)v10 )
  {
    if ( v13 )
      memcpy_0(v12, (const void *)v11, (size_t)v5 + *(_DWORD *)(v20 + 4) - v11);
  }
  v14 = v18;
  *v18 = a3;
  memcpy_0(&v14[v8 / 2u], WideCharStr, (size_t)&lpMultiByteStra[-v8]);
  v15 = v20;
  v16 = *(void **)v20;
  *(_DWORD *)(v20 + 4) += &v12[-v19];
  GlobalUnlock(v16);
  *(_DWORD *)(v15 + 8) = 0;
  return 1;
}


// ========== Function: ?SetSystemFont@CDialogTemplate@@QAEHG@Z @ 0x42137A ==========
int __thiscall CDialogTemplate::SetSystemFont(CDialogTemplate *this, __int16 a2)
{
  unsigned __int16 v2; // bx
  const CHAR *v3; // edi
  HGDIOBJ StockObject; // eax
  HDC DC; // esi
  int DeviceCaps; // eax
  int pv[7]; // [esp+Ch] [ebp-40h] BYREF
  char v9; // [esp+28h] [ebp-24h] BYREF
  CDialogTemplate *v10; // [esp+48h] [ebp-4h]

  v10 = this;
  v2 = 10;
  v3 = "System";
  StockObject = GetStockObject(17);
  if ( StockObject || (StockObject = GetStockObject(13)) != 0 )
  {
    if ( GetObjectA(StockObject, 60, pv) )
    {
      v3 = &v9;
      DC = GetDC(0);
      if ( pv[0] < 0 )
        pv[0] = -pv[0];
      DeviceCaps = GetDeviceCaps(DC, 90);
      v2 = MulDiv(pv[0], 72, DeviceCaps);
      ReleaseDC(0, DC);
    }
  }
  if ( !a2 )
    a2 = v2;
  return sub_421260((int)v10, v3, a2);
}


// ========== Function: ?afxMapHMENU@@YAPAVCHandleMap@@H@Z @ 0x42140B ==========
struct CHandleMap *__stdcall afxMapHMENU(LPVOID lpMem)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // esi
  void (__noreturn *v2)(); // ebx
  _DWORD *v3; // ecx
  _DWORD *v4; // eax

  ModuleThreadState = AfxGetModuleThreadState();
  if ( !*((_DWORD *)ModuleThreadState + 6) && lpMem )
  {
    v2 = AfxSetNewHandler((void (__noreturn *)())AfxCriticalNewHandler);
    v3 = sub_41CA70(0x48u);
    if ( v3 )
      v4 = sub_420EB7(v3, (int)&off_42AF10, 4, 1);
    else
      v4 = 0;
    *((_DWORD *)ModuleThreadState + 6) = v4;
    AfxSetNewHandler(v2);
  }
  return (struct CHandleMap *)*((_DWORD *)ModuleThreadState + 6);
}


// ========== Function: sub_42147D @ 0x42147D ==========
struct CObject *__stdcall sub_42147D(int (__cdecl *a1)(unsigned int))
{
  CHandleMap *v1; // eax

  v1 = afxMapHMENU((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}


// ========== Function: sub_421492 @ 0x421492 ==========
void *__stdcall sub_421492(void *a1)
{
  struct CHandleMap *v1; // ecx
  void *result; // eax

  v1 = afxMapHMENU(0);
  result = 0;
  if ( v1 )
    return CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v1 + 4), (unsigned int)a1);
  return result;
}


// ========== Function: sub_4214B0 @ 0x4214B0 ==========
unsigned int __thiscall sub_4214B0(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHMENU(0);
    if ( v3 )
      sub_41BD4D((_DWORD *)v3 + 1, this[1]);
  }
  this[1] = 0;
  return v2;
}


// ========== Function: sub_4214DA @ 0x4214DA ==========
BOOL __thiscall sub_4214DA(unsigned int *this)
{
  HMENU v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (HMENU)sub_4214B0(this);
  return DestroyMenu(v2);
}


// ========== Function: sub_4214F0 @ 0x4214F0 ==========
_DWORD *__thiscall sub_4214F0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[3] = off_433548;
  this[1] = -1;
  this[2] = 0;
  *this = &CFile::`vftable';
  return result;
}


// ========== Function: sub_42150A @ 0x42150A ==========
CFile *__thiscall sub_42150A(CFile *lpMem, char a2)
{
  CFile::~CFile(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_421526 @ 0x421526 ==========
_DWORD *__thiscall sub_421526(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[3] = off_433548;
  this[2] = 0;
  *this = &CFile::`vftable';
  this[1] = a2;
  return result;
}


// ========== Function: ??1CFile@@UAE@XZ @ 0x421545 ==========
void __thiscall CFile::~CFile(CFile *this)
{
  *(_DWORD *)this = &CFile::`vftable';
  if ( *((_DWORD *)this + 1) != -1 && *((_DWORD *)this + 2) )
    CFile::Close(this);
  sub_4200DD((_DWORD *)this + 3);
}


// ========== Function: sub_42158D @ 0x42158D ==========
_DWORD *__thiscall sub_42158D(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  HANDLE v4; // eax
  DWORD LastError; // eax
  void *v7; // [esp-1Ch] [ebp-28h]
  HANDLE CurrentProcess; // [esp-18h] [ebp-24h]
  HANDLE TargetHandle; // [esp+8h] [ebp-4h] BYREF

  v2 = sub_41CA70(0x10u);
  if ( v2 )
    v3 = sub_421526(v2, -1);
  else
    v3 = 0;
  CurrentProcess = GetCurrentProcess();
  v7 = (void *)this[1];
  v4 = GetCurrentProcess();
  if ( !DuplicateHandle(v4, v7, CurrentProcess, &TargetHandle, 0, 0, 2u) )
  {
    if ( v3 )
      (*(void (__thiscall **)(_DWORD *, int))(*v3 + 4))(v3, 1);
    LastError = GetLastError();
    unknown_libname_23(LastError, 0);
  }
  v3[1] = TargetHandle;
  v3[2] = this[2];
  return v3;
}


// ========== Function: ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z @ 0x421602 ==========
int __thiscall CFile::Open(CFile *this, LPCSTR lpFileName, unsigned int a3, struct CFileException *a4)
{
  void **v5; // ebx
  DWORD v6; // ecx
  unsigned int v7; // eax
  DWORD v8; // eax
  DWORD v9; // edi
  HANDLE v10; // eax
  DWORD LastError; // eax
  int v13; // [esp-4h] [ebp-120h]
  CHAR String[260]; // [esp+Ch] [ebp-110h] BYREF
  _SECURITY_ATTRIBUTES SecurityAttributes; // [esp+110h] [ebp-Ch] BYREF

  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 1) = -1;
  v5 = (void **)((char *)this + 12);
  CString::Empty((CFile *)((char *)this + 12));
  AfxFullPath(String, lpFileName);
  CString::operator=(v5, String);
  v6 = 0;
  if ( (a3 & 3) != 0 )
  {
    if ( (a3 & 3) == 1 )
    {
      v6 = 0x40000000;
    }
    else if ( (a3 & 3) == 2 )
    {
      v6 = -1073741824;
    }
  }
  else
  {
    v6 = 0x80000000;
  }
  v7 = a3 & 0x70;
  if ( (a3 & 0x70) != 0 && v7 != 16 )
  {
    switch ( v7 )
    {
      case ' ':
        v8 = 1;
        goto LABEL_17;
      case '0':
        v13 = 2;
        goto LABEL_13;
      case '@':
        v13 = 3;
LABEL_13:
        v8 = v13;
        goto LABEL_17;
    }
  }
  v8 = 0;
LABEL_17:
  SecurityAttributes.lpSecurityDescriptor = 0;
  SecurityAttributes.nLength = 12;
  SecurityAttributes.bInheritHandle = (~(a3 & 0xFFFF7FFF) >> 7) & 1;
  if ( (a3 & 0x1000) != 0 )
    v9 = (a3 & 0x2000) != 0 ? 4 : 2;
  else
    v9 = 3;
  v10 = CreateFileA(lpFileName, v6, v8, &SecurityAttributes, v9, 0x80u, 0);
  if ( v10 == (HANDLE)-1 )
  {
    if ( a4 )
    {
      LastError = GetLastError();
      *((_DWORD *)a4 + 3) = LastError;
      *((_DWORD *)a4 + 2) = sub_421E53(LastError);
      CString::operator=((void **)a4 + 4, lpFileName);
    }
    return 0;
  }
  else
  {
    *((_DWORD *)this + 1) = v10;
    *((_DWORD *)this + 2) = 1;
    return 1;
  }
}


// ========== Function: sub_42171F @ 0x42171F ==========
DWORD __thiscall sub_42171F(HANDLE *this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead)
{
  DWORD LastError; // eax

  if ( !nNumberOfBytesToRead )
    return 0;
  if ( !ReadFile(this[1], lpBuffer, nNumberOfBytesToRead, &nNumberOfBytesToRead, 0) )
  {
    LastError = GetLastError();
    unknown_libname_23(LastError, 0);
  }
  return nNumberOfBytesToRead;
}


// ========== Function: ?Write@CFile@@UAEXPBXI@Z @ 0x421759 ==========
void __thiscall CFile::Write(CFile *this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  DWORD v3; // edi
  DWORD LastError; // eax
  int v6; // [esp-4h] [ebp-Ch]

  v3 = nNumberOfBytesToWrite;
  if ( nNumberOfBytesToWrite )
  {
    if ( !WriteFile(*((HANDLE *)this + 1), lpBuffer, nNumberOfBytesToWrite, &nNumberOfBytesToWrite, 0) )
    {
      v6 = *((_DWORD *)this + 3);
      LastError = GetLastError();
      unknown_libname_23(LastError, v6);
    }
    if ( nNumberOfBytesToWrite != v3 )
      sub_421DE8(13);
  }
}


// ========== Function: ?Seek@CFile@@UAEJJI@Z @ 0x4217A4 ==========
DWORD __thiscall CFile::Seek(HANDLE *this, LONG lDistanceToMove, DWORD dwMoveMethod)
{
  DWORD v3; // esi
  DWORD LastError; // eax

  v3 = SetFilePointer(this[1], lDistanceToMove, 0, dwMoveMethod);
  if ( v3 == -1 )
  {
    LastError = GetLastError();
    unknown_libname_23(LastError, 0);
  }
  return v3;
}


// ========== Function: ?GetPosition@CFile@@UBEKXZ @ 0x4217D3 ==========
DWORD __thiscall CFile::GetPosition(HANDLE *this)
{
  DWORD v1; // esi
  DWORD LastError; // eax

  v1 = SetFilePointer(this[1], 0, 0, 1u);
  if ( v1 == -1 )
  {
    LastError = GetLastError();
    unknown_libname_23(LastError, 0);
  }
  return v1;
}


// ========== Function: ?Flush@CFile@@UAEXXZ @ 0x4217FC ==========
void __thiscall CFile::Flush(CFile *this)
{
  DWORD LastError; // eax

  if ( *((_DWORD *)this + 1) != -1 && !FlushFileBuffers(*((HANDLE *)this + 1)) )
  {
    LastError = GetLastError();
    unknown_libname_23(LastError, 0);
  }
}


// ========== Function: ?Close@CFile@@UAEXXZ @ 0x42181D ==========
void __thiscall CFile::Close(HANDLE *this)
{
  BOOL v2; // edi
  DWORD LastError; // eax

  v2 = 0;
  if ( this[1] != (HANDLE)-1 )
    v2 = !CloseHandle(this[1]);
  this[1] = (HANDLE)-1;
  this[2] = 0;
  CString::Empty((CString *)(this + 3));
  if ( v2 )
  {
    LastError = GetLastError();
    unknown_libname_23(LastError, 0);
  }
}


// ========== Function: ?Abort@CFile@@UAEXXZ @ 0x42185E ==========
void __thiscall CFile::Abort(HANDLE *this)
{
  if ( this[1] != (HANDLE)-1 )
  {
    CloseHandle(this[1]);
    this[1] = (HANDLE)-1;
  }
  CString::Empty((CString *)(this + 3));
}


// ========== Function: sub_42187E @ 0x42187E ==========
int __thiscall sub_42187E(HANDLE *this, DWORD dwFileOffsetLow, DWORD nNumberOfBytesToLockLow)
{
  int result; // eax
  DWORD LastError; // eax

  result = LockFile(this[1], dwFileOffsetLow, 0, nNumberOfBytesToLockLow, 0);
  if ( !result )
  {
    LastError = GetLastError();
    return unknown_libname_23(LastError, 0);
  }
  return result;
}


// ========== Function: sub_4218A7 @ 0x4218A7 ==========
int __thiscall sub_4218A7(HANDLE *this, DWORD dwFileOffsetLow, DWORD nNumberOfBytesToUnlockLow)
{
  int result; // eax
  DWORD LastError; // eax

  result = UnlockFile(this[1], dwFileOffsetLow, 0, nNumberOfBytesToUnlockLow, 0);
  if ( !result )
  {
    LastError = GetLastError();
    return unknown_libname_23(LastError, 0);
  }
  return result;
}


// ========== Function: sub_4218D0 @ 0x4218D0 ==========
int __thiscall sub_4218D0(HANDLE *this, int a2)
{
  int result; // eax
  DWORD LastError; // eax

  (*((void (__thiscall **)(HANDLE *, int, _DWORD))*this + 10))(this, a2, 0);
  result = SetEndOfFile(this[1]);
  if ( !result )
  {
    LastError = GetLastError();
    return unknown_libname_23(LastError, 0);
  }
  return result;
}


// ========== Function: sub_4218FC @ 0x4218FC ==========
int __thiscall sub_4218FC(void *this)
{
  int v2; // edi
  int v3; // ebx

  v2 = (*(int (__thiscall **)(void *, _DWORD, int))(*(_DWORD *)this + 40))(this, 0, 1);
  v3 = (*(int (__thiscall **)(void *, _DWORD, int))(*(_DWORD *)this + 40))(this, 0, 2);
  (*(void (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 40))(this, v2, 0);
  return v3;
}


// ========== Function: sub_421929 @ 0x421929 ==========
int __stdcall sub_421929(int a1, int a2, int a3, int a4)
{
  return 0;
}


// ========== Function: ?AfxFullPath@@YGHPADPBD@Z @ 0x42192E ==========
int __stdcall AfxFullPath(LPSTR lpBuffer, LPCSTR lpFileName)
{
  CHAR *v2; // edi
  int v4; // esi
  HANDLE FirstFileA; // eax
  _WIN32_FIND_DATAA FindFileData; // [esp+8h] [ebp-158h] BYREF
  DWORD MaximumComponentLength; // [esp+148h] [ebp-18h] BYREF
  LPSTR FilePart; // [esp+14Ch] [ebp-14h] BYREF
  DWORD FileSystemFlags; // [esp+150h] [ebp-10h] BYREF
  int v10; // [esp+15Ch] [ebp-4h]

  v2 = lpBuffer;
  if ( GetFullPathNameA(lpFileName, 0x104u, lpBuffer, &FilePart) )
  {
    lpBuffer = (LPSTR)off_433548;
    v4 = 0;
    v10 = 0;
    sub_4219FE(v2, (CString *)&lpBuffer);
    if ( GetVolumeInformationA(lpBuffer, 0, 0, 0, &MaximumComponentLength, &FileSystemFlags, 0, 0) )
    {
      if ( (FileSystemFlags & 2) == 0 )
        CharUpperA(v2);
      if ( (FileSystemFlags & 4) == 0 )
      {
        FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
        if ( FirstFileA != (HANDLE)-1 )
        {
          FindClose(FirstFileA);
          lstrcpyA(FilePart, FindFileData.cFileName);
        }
      }
      v4 = 1;
    }
    v10 = -1;
    sub_4200DD(&lpBuffer);
    return v4;
  }
  else
  {
    lstrcpynA(v2, lpFileName, 260);
    return 0;
  }
}


// ========== Function: sub_4219FE @ 0x4219FE ==========
void __stdcall sub_4219FE(LPCSTR lpString2, void **a2)
{
  _DWORD *v2; // edi
  unsigned __int8 v3; // cl
  unsigned __int8 *i; // eax
  unsigned __int8 v5; // cl
  unsigned __int8 *j; // eax
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl

  v2 = sub_42034E(a2, 260);
  memset(v2, 0, 0x104u);
  lstrcpynA((LPSTR)v2, lpString2, 260);
  v3 = *(_BYTE *)v2;
  for ( i = (unsigned __int8 *)v2; v3; v3 = *i )
  {
    if ( v3 == 92 || v3 == 47 )
    {
      v5 = i[1];
      if ( v5 == 92 || v5 == 47 )
        break;
    }
    i = _mbsinc(i);
  }
  if ( *i )
  {
    for ( j = i + 2; ; j = _mbsinc(j) )
    {
      v7 = *j;
      if ( !*j || v7 == 92 || v7 == 47 )
        break;
    }
    if ( !*j )
      goto LABEL_16;
    do
    {
      j = _mbsinc(j);
LABEL_16:
      v8 = *j;
    }
    while ( *j && v8 != 92 && v8 != 47 );
  }
  else
  {
    v9 = *(_BYTE *)v2;
    j = (unsigned __int8 *)v2;
    while ( v9 && v9 != 92 && v9 != 47 )
    {
      j = _mbsinc(j);
      v9 = *j;
    }
  }
  if ( *j )
    j[1] = 0;
  CString::ReleaseBuffer(a2, -1);
}


// ========== Function: ?AfxGetFileTitle@@YGIPBDPADI@Z @ 0x421AC4 ==========
int __stdcall AfxGetFileTitle(LPCSTR lpString, LPSTR Buf, unsigned int cchSize)
{
  CHAR *v3; // esi
  char v5; // [esp+8h] [ebp-104h] BYREF

  v3 = Buf;
  if ( !Buf )
  {
    v3 = &v5;
    cchSize = 260;
  }
  if ( GetFileTitleA(lpString, v3, cchSize) )
    return AfxGetFileName(lpString, Buf, cchSize);
  if ( Buf )
    return 0;
  return lstrlenA(v3) + 1;
}


// ========== Function: sub_421B1A @ 0x421B1A ==========
CString *__thiscall sub_421B1A(CFile *this, CString *a2)
{
  CHAR *v2; // eax
  _BYTE v4[18]; // [esp+4h] [ebp-12Ch] BYREF
  CHAR String[262]; // [esp+16h] [ebp-11Ah] BYREF
  int v6; // [esp+11Ch] [ebp-14h]
  void *v7; // [esp+120h] [ebp-10h] BYREF
  int v8; // [esp+12Ch] [ebp-4h]

  v6 = 0;
  CFile::GetStatus(this, (struct CFileStatus *)v4);
  v7 = off_433548;
  v8 = 1;
  v2 = (CHAR *)sub_42034E(&v7, 256);
  AfxGetFileName(String, v2, 0x100u);
  CString::ReleaseBuffer(&v7, -1);
  sub_41FE52(a2, (LPCSTR *)&v7);
  v6 = 1;
  LOBYTE(v8) = 0;
  sub_4200DD(&v7);
  return a2;
}


// ========== Function: sub_421B9C @ 0x421B9C ==========
CString *__thiscall sub_421B9C(CFile *this, CString *a2)
{
  CHAR *v2; // eax
  _BYTE v4[18]; // [esp+4h] [ebp-12Ch] BYREF
  CHAR String[262]; // [esp+16h] [ebp-11Ah] BYREF
  int v6; // [esp+11Ch] [ebp-14h]
  void *v7; // [esp+120h] [ebp-10h] BYREF
  int v8; // [esp+12Ch] [ebp-4h]

  v6 = 0;
  CFile::GetStatus(this, (struct CFileStatus *)v4);
  v7 = off_433548;
  v8 = 1;
  v2 = (CHAR *)sub_42034E(&v7, 256);
  AfxGetFileTitle(String, v2, 0x100u);
  CString::ReleaseBuffer(&v7, -1);
  sub_41FE52(a2, (LPCSTR *)&v7);
  v6 = 1;
  LOBYTE(v8) = 0;
  sub_4200DD(&v7);
  return a2;
}


// ========== Function: ?GetFilePath@CFile@@UBE?AVCString@@XZ @ 0x421C1E ==========
CString *__thiscall CFile::GetFilePath(CFile *this, CString *a2)
{
  _BYTE v3[18]; // [esp+0h] [ebp-11Ch] BYREF
  CHAR String[262]; // [esp+12h] [ebp-10Ah] BYREF
  int v5; // [esp+118h] [ebp-4h]

  v5 = 0;
  CFile::GetStatus(this, (struct CFileStatus *)v3);
  sub_420107(a2, String);
  return a2;
}


// ========== Function: ?GetStatus@CFile@@QBEHAAUCFileStatus@@@Z @ 0x421C4D ==========
int __thiscall CFile::GetStatus(CFile *this, struct CFileStatus *a2)
{
  struct CFileStatus *v2; // esi
  void *v4; // eax
  DWORD FileSize; // eax
  const CHAR *v7; // edi
  DWORD FileAttributesA; // eax
  int v9; // eax
  struct _FILETIME LastWriteTime; // [esp+Ch] [ebp-18h] BYREF
  struct _FILETIME LastAccessTime; // [esp+14h] [ebp-10h] BYREF
  struct _FILETIME CreationTime; // [esp+1Ch] [ebp-8h] BYREF

  v2 = a2;
  memset(a2, 0, 0x118u);
  lstrcpynA((LPSTR)v2 + 18, *((LPCSTR *)this + 3), 260);
  v4 = (void *)*((_DWORD *)this + 1);
  if ( v4 != (void *)-1 )
  {
    if ( !GetFileTime(v4, &CreationTime, &LastAccessTime, &LastWriteTime) )
      return 0;
    FileSize = GetFileSize(*((HANDLE *)this + 1), 0);
    *((_DWORD *)v2 + 3) = FileSize;
    if ( FileSize == -1 )
      return 0;
    v7 = (const CHAR *)*((_DWORD *)this + 3);
    if ( !*((_DWORD *)v7 - 2) || (FileAttributesA = GetFileAttributesA(v7), FileAttributesA == -1) )
      *((_BYTE *)v2 + 16) = 0;
    else
      *((_BYTE *)v2 + 16) = FileAttributesA;
    *(_DWORD *)v2 = *(_DWORD *)CTime::CTime((CTime *)&a2, &CreationTime, -1);
    *((_DWORD *)v2 + 2) = *(_DWORD *)CTime::CTime((CTime *)&a2, &LastAccessTime, -1);
    v9 = *(_DWORD *)CTime::CTime((CTime *)&a2, &LastWriteTime, -1);
    *((_DWORD *)v2 + 1) = v9;
    if ( !*(_DWORD *)v2 )
      *(_DWORD *)v2 = v9;
    if ( !*((_DWORD *)v2 + 2) )
      *((_DWORD *)v2 + 2) = *((_DWORD *)v2 + 1);
  }
  return 1;
}


// ========== Function: unknown_libname_23 @ 0x421D27 ==========
// MFC 3.1-14.0 32bit
void __stdcall unknown_libname_23(int a1, int a2)
{
  int v2; // eax

  if ( a1 )
  {
    v2 = sub_421E53(a1);
    sub_421DE8(v2);
  }
}


// ========== Function: sub_421D48 @ 0x421D48 ==========
int __thiscall sub_421D48(int this, LPSTR lpString1, int iMaxLength, char *a4)
{
  LPCSTR lpString2; // [esp+8h] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-4h]

  if ( a4 )
    *(_DWORD *)a4 = *(_DWORD *)(this + 8) + 61856;
  lpString2 = (LPCSTR)off_433548;
  v7 = 1;
  sub_41FE52((CString *)&a4, (LPCSTR *)(this + 16));
  if ( !*((_DWORD *)a4 - 2) )
    CString::LoadStringA((CString *)&a4, 0xF006u);
  sub_42397E((struct CString *)&lpString2, *(_DWORD *)(this + 8) + 61856, a4);
  lstrcpynA(lpString1, lpString2, iMaxLength);
  LOBYTE(v7) = 0;
  sub_4200DD(&a4);
  v7 = -1;
  sub_4200DD(&lpString2);
  return 1;
}


// ========== Function: sub_421DE8 @ 0x421DE8 ==========
void __userpurge __noreturn sub_421DE8(int a1, int a2, const CHAR *lpString)
{
  CException *v3; // eax
  CException *v4; // esi
  CException *pExceptionObject; // [esp+8h] [ebp-10h] BYREF
  int v6; // [esp+14h] [ebp-4h]

  v3 = (CException *)sub_41CA70(0x14u);
  v4 = v3;
  v6 = 0;
  if ( v3 )
  {
    CException::CException(v3);
    *((_DWORD *)v4 + 4) = off_433548;
    *((_DWORD *)v4 + 2) = a1;
    LOBYTE(v6) = 2;
    *(_DWORD *)v4 = &CFileException::`vftable';
    *((_DWORD *)v4 + 3) = a2;
    CString::operator=((void **)v4 + 4, lpString);
  }
  else
  {
    v4 = 0;
  }
  v6 = -1;
  pExceptionObject = v4;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&pThrowInfo);
}


// ========== Function: sub_421E53 @ 0x421E53 ==========
int __stdcall sub_421E53(unsigned int a1)
{
  int result; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax

  if ( a1 > 0x10B )
  {
    if ( a1 != 995 && a1 != 996 && a1 != 997 )
    {
      if ( a1 != 999 )
        return 1;
      return 5;
    }
    return 10;
  }
  if ( a1 == 267 )
    return 3;
  if ( a1 > 0x3E )
  {
    if ( a1 > 0x6B )
    {
      if ( a1 > 0x90 )
      {
        if ( a1 <= 0xB6 )
        {
          switch ( a1 )
          {
            case 0xB6u:
              return 6;
            case 0x91u:
              return 7;
            case 0x9Au:
            case 0xA1u:
              return 3;
          }
          if ( a1 != 167 )
          {
            if ( a1 != 170 )
              return 1;
            return 5;
          }
          return 12;
        }
        if ( a1 == 183 )
          return 5;
        if ( a1 == 191 || a1 == 193 )
          return 6;
        v3 = a1 - 206;
        if ( a1 == 206 )
          return 3;
LABEL_78:
        if ( v3 != 2 )
          return 1;
        return 3;
      }
      if ( a1 == 144 )
        return 3;
      if ( a1 > 0x75 )
      {
        if ( a1 != 123 && a1 != 124 && a1 != 125 )
        {
          v2 = a1 - 131;
          if ( a1 == 131 )
            return 9;
LABEL_18:
          if ( v2 == 1 )
            return 9;
          return 1;
        }
        return 3;
      }
      if ( a1 != 117 )
      {
        if ( a1 == 108 )
          return 12;
        if ( a1 == 111 )
          return 3;
        if ( a1 != 112 )
        {
          if ( a1 != 113 )
          {
            if ( a1 != 114 )
              return 1;
            return 6;
          }
          return 4;
        }
        return 13;
      }
    }
    else
    {
      if ( a1 == 107 )
        return 2;
      if ( a1 <= 0x47 )
      {
        switch ( a1 )
        {
          case 'G':
          case '@':
          case 'A':
            return 5;
          case 'B':
            return 6;
          case 'C':
            return 3;
        }
        v3 = a1 - 68;
        if ( a1 == 68 )
          return 4;
        goto LABEL_78;
      }
      switch ( a1 )
      {
        case 'P':
        case 'R':
          return 5;
        case 'U':
          return 3;
        case 'V':
          return 5;
      }
      if ( a1 != 88 )
        return 1;
    }
    return 10;
  }
  if ( a1 == 62 )
    return 8;
  if ( a1 > 0x19 )
  {
    if ( a1 > 0x27 )
    {
      switch ( a1 )
      {
        case '4':
        case '5':
        case '7':
          return 3;
        case '6':
        case ':':
          return 5;
        case '9':
        case ';':
          return 10;
        case '<':
          return 6;
        default:
          return 1;
      }
    }
    if ( a1 != 39 )
    {
      if ( a1 <= 0x20 )
      {
        if ( a1 == 32 )
          return 11;
        if ( a1 != 26 )
        {
          if ( a1 == 27 )
            return 9;
          v2 = a1 - 29;
          if ( a1 != 29 )
            goto LABEL_18;
          return 5;
        }
        return 6;
      }
      if ( a1 != 33 )
      {
        if ( a1 != 34 )
        {
          if ( a1 != 36 )
          {
            if ( a1 == 38 )
              return 14;
            return 1;
          }
          return 4;
        }
        return 3;
      }
      return 12;
    }
    return 13;
  }
  if ( a1 == 25 )
    return 9;
  switch ( a1 )
  {
    case 0u:
      result = 0;
      break;
    case 2u:
    case 6u:
    case 0x12u:
      return 2;
    case 3u:
    case 0xFu:
    case 0x11u:
      return 3;
    case 4u:
      return 4;
    case 5u:
    case 0xCu:
    case 0x13u:
      return 5;
    case 0xBu:
      return 6;
    case 0x10u:
      return 7;
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
      return 10;
    case 0x18u:
      return 9;
    default:
      return 1;
  }
  return result;
}


// ========== Function: sub_4220D1 @ 0x4220D1 ==========
int __stdcall sub_4220D1(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  struct CWinThread *Thread; // esi
  int v6; // edi
  int v7; // ecx
  int v8; // eax

  v4 = -1;
  Thread = AfxGetThread();
  v6 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( sub_42547C(a1, a2, a3, a4) && (!v6 || (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 132))(v6)) )
  {
    if ( (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 80))(Thread) )
    {
      v8 = (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 84))(Thread);
    }
    else
    {
      v7 = *((_DWORD *)Thread + 7);
      if ( v7 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 88))(v7);
      v8 = (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 104))(Thread);
    }
    v4 = v8;
  }
  AfxWinTerm();
  return v4;
}


// ========== Function: ?OnAppExit@CWinApp@@IAEXXZ @ 0x422147 ==========
void __thiscall CWinApp::OnAppExit(CWinApp *this)
{
  SendMessageA(*(HWND *)(*((_DWORD *)this + 7) + 28), 0x10u, 0, 0);
}


// ========== Function: ??0CDC@@QAE@XZ @ 0x42215A ==========
CDC *__thiscall CDC::CDC(CDC *this)
{
  CDC *result; // eax

  result = this;
  *(_DWORD *)this = &CDC::`vftable';
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  return result;
}


// ========== Function: sub_42216E @ 0x42216E ==========
LPVOID __thiscall sub_42216E(LPVOID lpMem, char a2)
{
  sub_42228F(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ?afxMapHDC@@YAPAVCHandleMap@@H@Z @ 0x42218A ==========
struct CHandleMap *__stdcall afxMapHDC(LPVOID lpMem)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // esi
  void (__noreturn *v2)(); // ebx
  _DWORD *v3; // ecx
  _DWORD *v4; // eax

  ModuleThreadState = AfxGetModuleThreadState();
  if ( !*((_DWORD *)ModuleThreadState + 7) && lpMem )
  {
    v2 = AfxSetNewHandler((void (__noreturn *)())AfxCriticalNewHandler);
    v3 = sub_41CA70(0x48u);
    if ( v3 )
      v4 = sub_420EB7(v3, (int)&off_42A8A8, 4, 2);
    else
      v4 = 0;
    *((_DWORD *)ModuleThreadState + 7) = v4;
    AfxSetNewHandler(v2);
  }
  return (struct CHandleMap *)*((_DWORD *)ModuleThreadState + 7);
}


// ========== Function: sub_4221FC @ 0x4221FC ==========
struct CObject *__stdcall sub_4221FC(int (__cdecl *a1)(unsigned int))
{
  CHandleMap *v1; // eax

  v1 = afxMapHDC((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}


// ========== Function: sub_422211 @ 0x422211 ==========
int __thiscall sub_422211(_DWORD *this, unsigned int a2)
{
  struct CHandleMap *v4; // eax

  if ( !a2 )
    return 0;
  v4 = afxMapHDC((LPVOID)1);
  this[1] = a2;
  *sub_41BCFD((_DWORD *)v4 + 1, a2) = this;
  (*(void (__thiscall **)(_DWORD *, _DWORD))(*this + 12))(this, this[1]);
  return 1;
}


// ========== Function: sub_422248 @ 0x422248 ==========
unsigned int __thiscall sub_422248(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHDC(0);
    if ( v3 )
      sub_41BD4D((_DWORD *)v3 + 1, this[1]);
  }
  (*(void (__thiscall **)(unsigned int *))(*this + 20))(this);
  this[1] = 0;
  return v2;
}


// ========== Function: sub_422279 @ 0x422279 ==========
BOOL __thiscall sub_422279(unsigned int *this)
{
  HDC v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (HDC)sub_422248(this);
  return DeleteDC(v2);
}


// ========== Function: sub_42228F @ 0x42228F ==========
void *__thiscall sub_42228F(unsigned int *this)
{
  void *result; // eax
  HDC v2; // eax

  result = &loc_427E10;
  *this = (unsigned int)&CDC::`vftable';
  if ( this[1] )
  {
    v2 = (HDC)sub_422248(this);
    return (void *)DeleteDC(v2);
  }
  return result;
}


// ========== Function: unknown_libname_24 @ 0x4222C5 ==========
// MFC 3.1-14.0 32bit
int __thiscall unknown_libname_24(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[2] = a2;
  return result;
}


// ========== Function: unknown_libname_25 @ 0x4222CF ==========
// MFC 3.1-14.0 32bit
int __thiscall unknown_libname_25(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[1] = a2;
  return result;
}


// ========== Function: ?ReleaseAttribDC@CDC@@UAEXXZ @ 0x4222D9 ==========
void __thiscall CDC::ReleaseAttribDC(CDC *this)
{
  *((_DWORD *)this + 2) = 0;
}


// ========== Function: ?Clear@TaskStack@details@Concurrency@@QAEXXZ @ 0x4222DE ==========
void __thiscall Concurrency::details::TaskStack::Clear(Concurrency::details::TaskStack *this)
{
  *((_DWORD *)this + 1) = 0;
}


// ========== Function: sub_4222E3 @ 0x4222E3 ==========
int __thiscall sub_4222E3(HDC *this)
{
  int v2; // ebx

  v2 = 0;
  if ( this[2] )
    v2 = SaveDC(this[2]);
  if ( this[1] != this[2] && SaveDC(this[1]) )
    return -1;
  return v2;
}


// ========== Function: ?RestoreDC@CDC@@UAEHH@Z @ 0x422314 ==========
BOOL __thiscall CDC::RestoreDC(CDC *this, int nSavedDC)
{
  HDC v3; // ecx
  BOOL result; // eax
  HDC v5; // esi

  v3 = (HDC)*((_DWORD *)this + 1);
  result = 1;
  if ( v3 != *((HDC *)this + 2) )
    result = RestoreDC(v3, nSavedDC);
  v5 = (HDC)*((_DWORD *)this + 2);
  if ( v5 )
    return result && RestoreDC(v5, nSavedDC);
  return result;
}


// ========== Function: sub_422352 @ 0x422352 ==========
int __thiscall sub_422352(_DWORD *this, int i)
{
  HGDIOBJ StockObject; // eax
  HDC v4; // ecx
  void *v5; // ebx
  HGDIOBJ v6; // eax
  HDC v7; // esi

  StockObject = GetStockObject(i);
  v4 = (HDC)this[1];
  v5 = StockObject;
  v6 = 0;
  if ( v4 != (HDC)this[2] )
    v6 = SelectObject(v4, v5);
  v7 = (HDC)this[2];
  if ( v7 )
    v6 = SelectObject(v7, v5);
  return sub_4229B5(v6);
}


// ========== Function: sub_42238E @ 0x42238E ==========
int __thiscall sub_42238E(_DWORD *this, int a2)
{
  HGDIOBJ v3; // eax
  HDC v4; // ecx
  HDC v5; // esi
  void *v6; // eax

  v3 = 0;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
  {
    if ( a2 )
      v3 = *(HGDIOBJ *)(a2 + 4);
    v3 = SelectObject(v4, v3);
  }
  v5 = (HDC)this[2];
  if ( v5 )
  {
    if ( a2 )
      v6 = *(void **)(a2 + 4);
    else
      v6 = 0;
    v3 = SelectObject(v5, v6);
  }
  return sub_4229B5(v3);
}


// ========== Function: sub_4223D4 @ 0x4223D4 ==========
int __thiscall sub_4223D4(_DWORD *this, COLORREF color)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = -1;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetBkColor(v4, color);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetBkColor(v5, color);
  return result;
}


// ========== Function: sub_422403 @ 0x422403 ==========
int __thiscall sub_422403(_DWORD *this, COLORREF color)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = -1;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetTextColor(v4, color);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetTextColor(v5, color);
  return result;
}


// ========== Function: sub_422432 @ 0x422432 ==========
int __thiscall sub_422432(_DWORD *this, int iMode)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = 0;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetMapMode(v4, iMode);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetMapMode(v5, iMode);
  return result;
}


// ========== Function: ?SetViewportOrg@CDC@@UAE?AVCPoint@@HH@Z @ 0x422460 ==========
struct tagPOINT *__thiscall CDC::SetViewportOrg(_DWORD *this, struct tagPOINT *a2, int x, int y)
{
  HDC v5; // eax
  HDC v6; // esi
  struct tagPOINT *result; // eax
  struct tagPOINT pt; // [esp+8h] [ebp-8h] BYREF

  v5 = (HDC)this[1];
  if ( v5 != (HDC)this[2] )
    SetViewportOrgEx(v5, x, y, &pt);
  v6 = (HDC)this[2];
  if ( v6 )
    SetViewportOrgEx(v6, x, y, &pt);
  result = a2;
  *a2 = pt;
  return result;
}


// ========== Function: ?OffsetViewportOrg@CDC@@UAE?AVCPoint@@HH@Z @ 0x4224AC ==========
struct tagPOINT *__thiscall CDC::OffsetViewportOrg(_DWORD *this, struct tagPOINT *a2, int x, int y)
{
  HDC v5; // eax
  HDC v6; // esi
  struct tagPOINT *result; // eax
  struct tagPOINT pt; // [esp+8h] [ebp-8h] BYREF

  v5 = (HDC)this[1];
  if ( v5 != (HDC)this[2] )
    OffsetViewportOrgEx(v5, x, y, &pt);
  v6 = (HDC)this[2];
  if ( v6 )
    OffsetViewportOrgEx(v6, x, y, &pt);
  result = a2;
  *a2 = pt;
  return result;
}


// ========== Function: ?SetViewportExt@CDC@@UAE?AVCSize@@HH@Z @ 0x4224F8 ==========
struct tagSIZE *__thiscall CDC::SetViewportExt(_DWORD *this, struct tagSIZE *a2, int x, int y)
{
  HDC v5; // eax
  HDC v6; // esi
  struct tagSIZE *result; // eax
  struct tagSIZE sz; // [esp+8h] [ebp-8h] BYREF

  v5 = (HDC)this[1];
  if ( v5 != (HDC)this[2] )
    SetViewportExtEx(v5, x, y, &sz);
  v6 = (HDC)this[2];
  if ( v6 )
    SetViewportExtEx(v6, x, y, &sz);
  result = a2;
  *a2 = sz;
  return result;
}


// ========== Function: ?ScaleViewportExt@CDC@@UAE?AVCSize@@HHHH@Z @ 0x422544 ==========
struct tagSIZE *__thiscall CDC::ScaleViewportExt(_DWORD *this, struct tagSIZE *a2, int xn, int a4, int yn, int yd)
{
  HDC v7; // eax
  HDC v8; // esi
  struct tagSIZE *result; // eax
  struct tagSIZE sz; // [esp+8h] [ebp-8h] BYREF

  v7 = (HDC)this[1];
  if ( v7 != (HDC)this[2] )
    ScaleViewportExtEx(v7, xn, a4, yn, yd, &sz);
  v8 = (HDC)this[2];
  if ( v8 )
    ScaleViewportExtEx(v8, xn, a4, yn, yd, &sz);
  result = a2;
  *a2 = sz;
  return result;
}


// ========== Function: ?SetWindowExt@CDC@@UAE?AVCSize@@HH@Z @ 0x42259C ==========
struct tagSIZE *__thiscall CDC::SetWindowExt(_DWORD *this, struct tagSIZE *a2, int x, int y)
{
  HDC v5; // eax
  HDC v6; // esi
  struct tagSIZE *result; // eax
  struct tagSIZE sz; // [esp+8h] [ebp-8h] BYREF

  v5 = (HDC)this[1];
  if ( v5 != (HDC)this[2] )
    SetWindowExtEx(v5, x, y, &sz);
  v6 = (HDC)this[2];
  if ( v6 )
    SetWindowExtEx(v6, x, y, &sz);
  result = a2;
  *a2 = sz;
  return result;
}


// ========== Function: ?ScaleWindowExt@CDC@@UAE?AVCSize@@HHHH@Z @ 0x4225E8 ==========
struct tagSIZE *__thiscall CDC::ScaleWindowExt(_DWORD *this, struct tagSIZE *a2, int xn, int xd, int yn, int yd)
{
  HDC v7; // eax
  HDC v8; // esi
  struct tagSIZE *result; // eax
  struct tagSIZE sz; // [esp+8h] [ebp-8h] BYREF

  v7 = (HDC)this[1];
  if ( v7 != (HDC)this[2] )
    ScaleWindowExtEx(v7, xn, xd, yn, yd, &sz);
  v8 = (HDC)this[2];
  if ( v8 )
    ScaleWindowExtEx(v8, xn, xd, yn, yd, &sz);
  result = a2;
  *a2 = sz;
  return result;
}


// ========== Function: sub_422640 @ 0x422640 ==========
int __thiscall sub_422640(HDC *this, LPRECT lprect)
{
  return GetClipBox(this[1], lprect);
}


// ========== Function: ?LPtoDP@CDC@@QBEXPAUtagSIZE@@@Z @ 0x422650 ==========
void __thiscall CDC::LPtoDP(HDC *this, struct tagSIZE *a2)
{
  int v3; // eax
  LONG v4; // eax
  int v5; // eax
  int v6; // [esp-4h] [ebp-1Ch]
  LONG cy; // [esp-4h] [ebp-1Ch]
  int v8; // [esp-4h] [ebp-1Ch]
  struct tagSIZE v9; // [esp+8h] [ebp-10h] BYREF
  tagSIZE size; // [esp+10h] [ebp-8h] BYREF

  GetWindowExtEx(this[2], &size);
  GetViewportExtEx(this[2], &v9);
  v6 = abs(size.cx);
  v3 = abs(v9.cx);
  v4 = MulDiv(a2->cx, v3, v6);
  cy = size.cy;
  a2->cx = v4;
  v8 = abs(cy);
  v5 = abs(v9.cy);
  a2->cy = MulDiv(a2->cy, v5, v8);
}


// ========== Function: ?DPtoLP@CDC@@QBEXPAUtagSIZE@@@Z @ 0x4226B9 ==========
void __thiscall CDC::DPtoLP(HDC *this, struct tagSIZE *a2)
{
  int v3; // eax
  LONG v4; // eax
  int v5; // eax
  int v6; // [esp-4h] [ebp-1Ch]
  LONG cy; // [esp-4h] [ebp-1Ch]
  int v8; // [esp-4h] [ebp-1Ch]
  struct tagSIZE size; // [esp+8h] [ebp-10h] BYREF
  struct tagSIZE v10; // [esp+10h] [ebp-8h] BYREF

  GetWindowExtEx(this[2], &size);
  GetViewportExtEx(this[2], &v10);
  v6 = abs(v10.cx);
  v3 = abs(size.cx);
  v4 = MulDiv(a2->cx, v3, v6);
  cy = v10.cy;
  a2->cx = v4;
  v8 = abs(cy);
  v5 = abs(size.cy);
  a2->cy = MulDiv(a2->cy, v5, v8);
}


// ========== Function: sub_422722 @ 0x422722 ==========
CDC *__thiscall sub_422722(CDC *this, HWND hWnd)
{
  HWND v3; // eax
  HDC DC; // eax
  int v6; // [esp+0h] [ebp-14h]

  CDC::CDC(this);
  v3 = hWnd;
  *(_DWORD *)this = &CClientDC::`vftable';
  if ( hWnd )
    v3 = (HWND)*((_DWORD *)hWnd + 7);
  *((_DWORD *)this + 4) = v3;
  DC = GetDC(v3);
  if ( !sub_422211(this, (unsigned int)DC) )
    sub_422A37(v6, this);
  return this;
}


// ========== Function: sub_422778 @ 0x422778 ==========
LPVOID __thiscall sub_422778(LPVOID lpMem, char a2)
{
  sub_422794(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_422794 @ 0x422794 ==========
void *__thiscall sub_422794(int this)
{
  HDC v2; // eax

  *(_DWORD *)this = &CClientDC::`vftable';
  v2 = (HDC)sub_422248((unsigned int *)this);
  ReleaseDC(*(HWND *)(this + 16), v2);
  return sub_42228F((unsigned int *)this);
}


// ========== Function: sub_4227D6 @ 0x4227D6 ==========
CDC *__thiscall sub_4227D6(CDC *this, HWND hWnd)
{
  HWND v3; // eax
  HDC WindowDC; // eax
  int v6; // [esp+0h] [ebp-14h]

  CDC::CDC(this);
  v3 = hWnd;
  *(_DWORD *)this = &CWindowDC::`vftable';
  if ( hWnd )
    v3 = (HWND)*((_DWORD *)hWnd + 7);
  *((_DWORD *)this + 4) = v3;
  WindowDC = GetWindowDC(v3);
  if ( !sub_422211(this, (unsigned int)WindowDC) )
    sub_422A37(v6, this);
  return this;
}


// ========== Function: sub_42282C @ 0x42282C ==========
LPVOID __thiscall sub_42282C(LPVOID lpMem, char a2)
{
  sub_422848(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_422848 @ 0x422848 ==========
void *__thiscall sub_422848(int this)
{
  HDC v2; // eax

  *(_DWORD *)this = &CWindowDC::`vftable';
  v2 = (HDC)sub_422248((unsigned int *)this);
  ReleaseDC(*(HWND *)(this + 16), v2);
  return sub_42228F((unsigned int *)this);
}


// ========== Function: ??0CPaintDC@@QAE@PAVCWnd@@@Z @ 0x42288A ==========
CPaintDC *__thiscall CPaintDC::CPaintDC(CPaintDC *this, struct CWnd *a2)
{
  HDC v3; // eax
  HWND v5; // [esp-8h] [ebp-1Ch]
  int v6; // [esp+0h] [ebp-14h]

  CDC::CDC(this);
  *(_DWORD *)this = &CPaintDC::`vftable';
  v5 = (HWND)*((_DWORD *)a2 + 7);
  *((_DWORD *)this + 4) = v5;
  v3 = BeginPaint(v5, (LPPAINTSTRUCT)((char *)this + 20));
  if ( !sub_422211(this, (unsigned int)v3) )
    sub_422A37(v6, this);
  return this;
}


// ========== Function: sub_4228E0 @ 0x4228E0 ==========
CPaintDC *__thiscall sub_4228E0(CPaintDC *lpMem, char a2)
{
  CPaintDC::~CPaintDC(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??1CPaintDC@@UAE@XZ @ 0x4228FC ==========
void __thiscall CPaintDC::~CPaintDC(CPaintDC *this)
{
  *(_DWORD *)this = &CPaintDC::`vftable';
  EndPaint(*((HWND *)this + 4), (const PAINTSTRUCT *)((char *)this + 20));
  sub_422248((unsigned int *)this);
  sub_42228F((unsigned int *)this);
}


// ========== Function: ?afxMapHGDIOBJ@@YAPAVCHandleMap@@H@Z @ 0x422943 ==========
struct CHandleMap *__stdcall afxMapHGDIOBJ(LPVOID lpMem)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // esi
  void (__noreturn *v2)(); // ebx
  _DWORD *v3; // ecx
  _DWORD *v4; // eax

  ModuleThreadState = AfxGetModuleThreadState();
  if ( !*((_DWORD *)ModuleThreadState + 8) && lpMem )
  {
    v2 = AfxSetNewHandler((void (__noreturn *)())AfxCriticalNewHandler);
    v3 = sub_41CA70(0x48u);
    if ( v3 )
      v4 = sub_420EB7(v3, (int)&off_42A880, 4, 1);
    else
      v4 = 0;
    *((_DWORD *)ModuleThreadState + 8) = v4;
    AfxSetNewHandler(v2);
  }
  return (struct CHandleMap *)*((_DWORD *)ModuleThreadState + 8);
}


// ========== Function: sub_4229B5 @ 0x4229B5 ==========
struct CObject *__stdcall sub_4229B5(int (__cdecl *a1)(unsigned int))
{
  CHandleMap *v1; // eax

  v1 = afxMapHGDIOBJ((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}


// ========== Function: sub_4229CA @ 0x4229CA ==========
int __thiscall sub_4229CA(_DWORD *this, unsigned int a2)
{
  struct CHandleMap *v4; // eax

  if ( !a2 )
    return 0;
  v4 = afxMapHGDIOBJ((LPVOID)1);
  this[1] = a2;
  *sub_41BCFD((_DWORD *)v4 + 1, a2) = this;
  return 1;
}


// ========== Function: sub_4229F7 @ 0x4229F7 ==========
unsigned int __thiscall sub_4229F7(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHGDIOBJ(0);
    if ( v3 )
      sub_41BD4D((_DWORD *)v3 + 1, this[1]);
  }
  this[1] = 0;
  return v2;
}


// ========== Function: sub_422A21 @ 0x422A21 ==========
BOOL __thiscall sub_422A21(unsigned int *this)
{
  void *v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (void *)sub_4229F7(this);
  return DeleteObject(v2);
}


// ========== Function: sub_422A37 @ 0x422A37 ==========
void __stdcall __noreturn sub_422A37(int a1, int a2)
{
  void *pExceptionObject; // [esp+0h] [ebp-4h] BYREF

  pExceptionObject = &dword_438E20;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI5PAVCResourceException__);
}


// ========== Function: ?_AfxIsComboBoxControl@@YGHPAUHWND__@@I@Z @ 0x422A50 ==========
BOOL __stdcall _AfxIsComboBoxControl(HWND hWnd, unsigned int a2)
{
  CHAR ClassName[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( !hWnd || (GetWindowLongA(hWnd, -16) & 0xF) != a2 )
    return 0;
  GetClassNameA(hWnd, ClassName, 10);
  return lstrcmpiA(ClassName, "combobox") == 0;
}


// ========== Function: ?_AfxCompareClassName@@YGHPAUHWND__@@PBD@Z @ 0x422A9A ==========
BOOL __stdcall _AfxCompareClassName(HWND hWnd, LPCSTR lpString2)
{
  CHAR ClassName[32]; // [esp+0h] [ebp-20h] BYREF

  GetClassNameA(hWnd, ClassName, 32);
  return lstrcmpiA(ClassName, lpString2) == 0;
}


// ========== Function: ?_AfxChildWindowFromPoint@@YGPAUHWND__@@PAU1@UtagPOINT@@@Z @ 0x422AC5 ==========
HWND __stdcall _AfxChildWindowFromPoint(HWND hWnd, POINT Point)
{
  HWND i; // eax
  HWND v3; // esi
  struct tagRECT Rect; // [esp+8h] [ebp-10h] BYREF

  ClientToScreen(hWnd, &Point);
  for ( i = GetWindow(hWnd, 5u); ; i = GetWindow(v3, 2u) )
  {
    v3 = i;
    if ( !i )
      break;
    if ( (unsigned __int16)GetDlgCtrlID(i) != 0xFFFF && (GetWindowLongA(v3, -16) & 0x10000000) != 0 )
    {
      GetWindowRect(v3, &Rect);
      if ( PtInRect(&Rect, Point) )
        return v3;
    }
  }
  return 0;
}


// ========== Function: ?AfxSetWindowText@@YGXPAUHWND__@@PBD@Z @ 0x422B3A ==========
void __stdcall AfxSetWindowText(HWND hWnd, LPCSTR lpString)
{
  unsigned int v2; // esi
  CHAR String[256]; // [esp+4h] [ebp-100h] BYREF

  v2 = lstrlenA(lpString);
  if ( v2 > 0x100 || GetWindowTextA(hWnd, String, 256) != v2 || lstrcmpA(String, lpString) )
    SetWindowTextA(hWnd, lpString);
}


// ========== Function: ?AfxDeleteObject@@YGXPAPAX@Z @ 0x422B92 ==========
void __stdcall AfxDeleteObject(void **a1)
{
  if ( *a1 )
  {
    DeleteObject(*a1);
    *a1 = 0;
  }
}


// ========== Function: ?AfxGlobalFree@@YGXPAX@Z @ 0x422BAB ==========
void __stdcall AfxGlobalFree(HGLOBAL hMem)
{
  int v1; // ecx
  int v2; // esi

  if ( hMem )
  {
    v1 = (unsigned __int8)GlobalFlags(hMem);
    if ( v1 )
    {
      v2 = v1;
      do
      {
        GlobalUnlock(hMem);
        --v2;
      }
      while ( v2 );
    }
    GlobalFree(hMem);
  }
}


// ========== Function: ?AfxCriticalNewHandler@@YAHI@Z @ 0x422BE1 ==========
int __cdecl AfxCriticalNewHandler(unsigned int a1)
{
  struct _AFX_THREAD_STATE *ThreadState; // eax
  struct _AFX_THREAD_STATE *v2; // esi
  SIZE_T v3; // eax

  ThreadState = AfxGetThreadState();
  v2 = ThreadState;
  if ( !ThreadState || !*((_DWORD *)ThreadState + 3) )
    sub_41B4F7();
  v3 = sub_40F381(*((_DWORD **)ThreadState + 3));
  if ( v3 > a1 + 4 )
  {
    sub_40F21D(*((LPVOID *)v2 + 3), v3 - a1 - 4);
  }
  else
  {
    sub_40D386(*((LPVOID *)v2 + 3));
    *((_DWORD *)v2 + 3) = 0;
  }
  return 1;
}


// ========== Function: sub_422C33 @ 0x422C33 ==========
_DWORD *__thiscall sub_422C33(_DWORD *this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // eax
  bool v8; // zf
  int v10; // [esp+2Ch] [ebp+10h]

  (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)a2 + 24))(a2, this + 4);
  this[3] = -1;
  this[5] = a3;
  this[8] = a2;
  this[14] = 0;
  this[13] = 0;
  *this = 0;
  this[1] = 1;
  if ( (a3 & 1) != 0 )
    this[15] = 64;
  else
    this[15] = 16;
  this[6] = 1;
  this[11] = a5;
  this[16] = 137;
  this[2] = 0;
  if ( a4 >= 128 )
  {
    this[7] = a4;
  }
  else
  {
    this[7] = 128;
    this[11] = 0;
  }
  v10 = this[7];
  if ( !this[11] )
  {
    v6 = (*(int (__thiscall **)(int, int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)a2 + 80))(a2, 3, 0, 0, 0);
    this[2] = v6;
    if ( v6 )
    {
      v10 = 0;
    }
    else
    {
      this[11] = sub_41CA70(this[7]);
      this[6] = 0;
    }
  }
  v7 = this[11];
  v8 = (this[5] & 1) == 0;
  this[10] = v7 + v10;
  if ( !v8 )
    v7 += v10;
  this[9] = v7;
  return this;
}


// ========== Function: ??1CArchive@@QAE@XZ @ 0x422D0F ==========
void __thiscall CArchive::~CArchive(CArchive *this)
{
  if ( *((_DWORD *)this + 8) && (*((_BYTE *)this + 20) & 2) == 0 )
    CArchive::Close(this);
  CArchive::Abort(this);
  sub_4200DD((_DWORD *)this + 4);
}


// ========== Function: ?Abort@CArchive@@QAEXXZ @ 0x422D55 ==========
void __thiscall CArchive::Abort(CArchive *this)
{
  bool v2; // zf
  int v3; // ecx
  int v4; // ecx

  v2 = *((_DWORD *)this + 6) == 0;
  *((_DWORD *)this + 8) = 0;
  if ( v2 )
  {
    sub_41CA99(*((LPVOID *)this + 11));
    *((_DWORD *)this + 11) = 0;
    *((_DWORD *)this + 9) = 0;
  }
  v3 = *((_DWORD *)this + 14);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 4))(v3, 1);
  v4 = *((_DWORD *)this + 13);
  *((_DWORD *)this + 14) = 0;
  if ( v4 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v4 + 4))(v4, 1);
  *((_DWORD *)this + 13) = 0;
}


// ========== Function: ?Close@CArchive@@QAEXXZ @ 0x422D97 ==========
void __thiscall CArchive::Close(CArchive *this)
{
  sub_422F44();
  *((_DWORD *)this + 8) = 0;
}


// ========== Function: sub_422DA5 @ 0x422DA5 ==========
unsigned int __thiscall sub_422DA5(int this, char *a2, unsigned int a3)
{
  const void *v5; // eax
  size_t v6; // edi
  unsigned int v7; // ebx
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  char *v12; // eax
  size_t v13; // edi
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+8h] [ebp-8h]
  unsigned int v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+Ch] [ebp-4h]
  char *v18; // [esp+18h] [ebp+8h]

  if ( !a3 )
    return 0;
  v5 = *(const void **)(this + 36);
  v6 = *(_DWORD *)(this + 40) - (_DWORD)v5;
  if ( a3 < v6 )
    v6 = a3;
  memcpy(a2, v5, v6);
  *(_DWORD *)(this + 36) += v6;
  v18 = &a2[v6];
  v7 = a3 - v6;
  if ( a3 != v6 )
  {
    v8 = v7 - v7 % *(_DWORD *)(this + 28);
    v14 = 0;
    v16 = v8;
    do
    {
      v9 = (*(int (__thiscall **)(_DWORD, char *, unsigned int))(**(_DWORD **)(this + 32) + 52))(
             *(_DWORD *)(this + 32),
             v18,
             v16);
      v18 += v9;
      v14 += v9;
      v16 -= v9;
    }
    while ( v9 && v16 );
    v7 -= v14;
    if ( v14 == v8 )
    {
      v10 = 0;
      if ( *(_DWORD *)(this + 8) )
      {
        (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, int, int))(**(_DWORD **)(this + 32) + 80))(
          *(_DWORD *)(this + 32),
          0,
          *(_DWORD *)(this + 28),
          this + 44,
          this + 40);
        v12 = *(char **)(this + 44);
        *(_DWORD *)(this + 36) = v12;
      }
      else
      {
        v17 = v7;
        if ( v7 <= *(_DWORD *)(this + 28) )
          v17 = *(_DWORD *)(this + 28);
        v15 = *(_DWORD *)(this + 44);
        do
        {
          v11 = (*(int (__thiscall **)(_DWORD, int, unsigned int))(**(_DWORD **)(this + 32) + 52))(
                  *(_DWORD *)(this + 32),
                  v15,
                  v17);
          v15 += v11;
          v17 -= v11;
          v10 += v11;
        }
        while ( v11 && v17 && v10 < v7 );
        v12 = *(char **)(this + 44);
        *(_DWORD *)(this + 36) = v12;
        *(_DWORD *)(this + 40) = &v12[v10];
      }
      v13 = *(_DWORD *)(this + 40) - (_DWORD)v12;
      if ( v7 < v13 )
        v13 = v7;
      memcpy(v18, v12, v13);
      *(_DWORD *)(this + 36) += v13;
      v7 -= v13;
    }
  }
  return a3 - v7;
}


// ========== Function: ?Write@CArchive@@QAEXPBXI@Z @ 0x422EB4 ==========
void __thiscall CArchive::Write(CArchive *this, char *Src, unsigned int a3)
{
  void *v4; // eax
  size_t v5; // edi
  unsigned int v6; // ebx
  unsigned int v7; // edi
  size_t v8; // ebx
  char *Srca; // [esp+14h] [ebp+8h]
  char *Srcb; // [esp+14h] [ebp+8h]

  if ( a3 )
  {
    v4 = (void *)*((_DWORD *)this + 9);
    v5 = *((_DWORD *)this + 10) - (_DWORD)v4;
    if ( a3 < v5 )
      v5 = a3;
    memcpy(v4, Src, v5);
    *((_DWORD *)this + 9) += v5;
    Srca = &Src[v5];
    v6 = a3 - v5;
    if ( a3 != v5 )
    {
      sub_422F44(this);
      v7 = v6 - v6 % *((_DWORD *)this + 7);
      (*(void (__thiscall **)(_DWORD, char *, unsigned int))(**((_DWORD **)this + 8) + 56))(
        *((_DWORD *)this + 8),
        Srca,
        v7);
      Srcb = &Srca[v7];
      v8 = v6 - v7;
      if ( *((_DWORD *)this + 2) )
      {
        (*(void (__thiscall **)(_DWORD, int, _DWORD, char *, char *))(**((_DWORD **)this + 8) + 80))(
          *((_DWORD *)this + 8),
          1,
          *((_DWORD *)this + 7),
          (char *)this + 44,
          (char *)this + 40);
        *((_DWORD *)this + 9) = *((_DWORD *)this + 11);
      }
      memcpy(*((void **)this + 9), Srcb, v8);
      *((_DWORD *)this + 9) += v8;
    }
  }
}


// ========== Function: sub_422F44 @ 0x422F44 ==========
int __thiscall sub_422F44(int this)
{
  int v2; // edx
  int v3; // eax
  int result; // eax
  int v5; // eax
  int v6; // edx
  int *v7; // edi

  if ( (*(_BYTE *)(this + 20) & 1) != 0 )
  {
    v2 = *(_DWORD *)(this + 40);
    v3 = *(_DWORD *)(this + 36);
    if ( v2 != v3 )
      (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(this + 32) + 40))(*(_DWORD *)(this + 32), v3 - v2, 1);
    result = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 36) = result;
  }
  else
  {
    v5 = *(_DWORD *)(this + 36);
    v6 = *(_DWORD *)(this + 44);
    v7 = (int *)(this + 44);
    if ( *(_DWORD *)(this + 8) )
    {
      if ( v5 != v6 )
        (*(void (__stdcall **)(int, int, _DWORD, _DWORD))(**(_DWORD **)(this + 32) + 80))(2, v5 - v6, 0, 0);
      (*(void (__thiscall **)(_DWORD, int, _DWORD, int, int))(**(_DWORD **)(this + 32) + 80))(
        *(_DWORD *)(this + 32),
        1,
        *(_DWORD *)(this + 28),
        this + 44,
        this + 40);
    }
    else if ( v5 != v6 )
    {
      (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(this + 32) + 56))(*(_DWORD *)(this + 32), v6, v5 - v6);
    }
    result = *v7;
    *(_DWORD *)(this + 36) = *v7;
  }
  return result;
}


// ========== Function: ?DoWaitCursor@CWinApp@@UAEXH@Z @ 0x423004 ==========
void __thiscall CWinApp::DoWaitCursor(CWinApp *this, int a2)
{
  HCURSOR v3; // eax
  HCURSOR v4; // [esp-4h] [ebp-Ch]

  sub_4250E4(2);
  *((_DWORD *)this + 40) += a2;
  if ( *((int *)this + 40) <= 0 )
  {
    v4 = (HCURSOR)*((_DWORD *)this + 41);
    *((_DWORD *)this + 40) = 0;
    SetCursor(v4);
  }
  else
  {
    v3 = SetCursor(hCursor);
    if ( a2 > 0 && *((_DWORD *)this + 40) == 1 )
      *((_DWORD *)this + 41) = v3;
  }
  AfxUnlockGlobals(2);
}


// ========== Function: sub_423063 @ 0x423063 ==========
int __thiscall sub_423063(_DWORD *this)
{
  int v1; // ecx

  v1 = this[32];
  if ( v1 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
  else
    return 1;
}


// ========== Function: sub_423076 @ 0x423076 ==========
int __thiscall sub_423076(_DWORD *this, int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = this[42];
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, a2);
  return result;
}


// ========== Function: ?GetNextDocTemplate@CWinApp@@QBEPAVCDocTemplate@@AAPAU__POSITION@@@Z @ 0x42308C ==========
struct CDocTemplate *__thiscall CWinApp::GetNextDocTemplate(CWinApp *this, struct __POSITION **a2)
{
  return (struct CDocTemplate *)(*(int (__thiscall **)(_DWORD, struct __POSITION **))(**((_DWORD **)this + 32) + 28))(
                                  *((_DWORD *)this + 32),
                                  a2);
}


// ========== Function: ?OnUpdateRecentFileMenu@CWinApp@@IAEXPAVCCmdUI@@@Z @ 0x42309E ==========
void __thiscall CWinApp::OnUpdateRecentFileMenu(CWinApp *this, struct CCmdUI *a2)
{
  int v2; // ecx

  v2 = *((_DWORD *)this + 42);
  if ( v2 )
    (*(void (__thiscall **)(int, struct CCmdUI *))(*(_DWORD *)v2 + 8))(v2, a2);
  else
    (**(void (__thiscall ***)(struct CCmdUI *, _DWORD))a2)(a2, 0);
}


// ========== Function: sub_4230C0 @ 0x4230C0 ==========
int __thiscall sub_4230C0(_DWORD *this, int a2)
{
  int v2; // ecx

  v2 = this[32];
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 48))(v2, a2);
  else
    return 0;
}


// ========== Function: sub_42310D @ 0x42310D ==========
int __stdcall sub_42310D(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // ecx

  result = sub_404EA0();
  v2 = result;
  if ( result )
  {
    result = (*(int (__thiscall **)(int))(*(_DWORD *)result + 176))(result);
    if ( result )
    {
      v3 = *(_DWORD *)(v2 + 104);
      if ( v3 )
        return (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 100))(v3, a1);
    }
  }
  return result;
}


// ========== Function: sub_42313B @ 0x42313B ==========
int __thiscall sub_42313B(_DWORD *this, LPCSTR lpText, UINT uType, int a4)
{
  int *v5; // esi
  LRESULT v6; // eax
  UINT v7; // ebx
  UINT v8; // eax
  CHAR *v9; // edi
  int v10; // edi
  CHAR Filename[260]; // [esp+Ch] [ebp-114h] BYREF
  _DWORD *v13; // [esp+110h] [ebp-10h]
  HWND v14; // [esp+114h] [ebp-Ch]
  int v15; // [esp+118h] [ebp-8h]
  HWND hWnd; // [esp+11Ch] [ebp-4h] BYREF

  v13 = this;
  sub_42310D(0);
  v5 = 0;
  v14 = (HWND)sub_4232B3(0, (int)&hWnd);
  if ( v14 && (v6 = SendMessageA(hWnd, 0x376u, 0, 0)) != 0 )
  {
    v5 = (int *)v6;
  }
  else if ( this )
  {
    v5 = this + 39;
  }
  v15 = 0;
  if ( v5 )
  {
    v15 = *v5;
    if ( a4 )
      *v5 = a4 + 196608;
  }
  v7 = uType;
  if ( (uType & 0xF0) == 0 )
  {
    v8 = uType & 0xF;
    if ( v8 <= 1 || v8 > 2 && v8 <= 4 )
      v7 = uType | 0x30;
  }
  if ( this )
  {
    v9 = (CHAR *)this[30];
  }
  else
  {
    v9 = Filename;
    GetModuleFileNameA(0, Filename, 0x104u);
  }
  v10 = MessageBoxA(v14, lpText, v9, v7);
  if ( v5 )
    *v5 = v15;
  if ( hWnd )
    EnableWindow(hWnd, 1);
  sub_42310D(1);
  return v10;
}


// ========== Function: sub_423222 @ 0x423222 ==========
int __stdcall sub_423222(LPCSTR lpText, UINT uType, int a3)
{
  int v3; // eax

  v3 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( v3 )
    return (*(int (__thiscall **)(int, LPCSTR, UINT, int))(*(_DWORD *)v3 + 140))(v3, lpText, uType, a3);
  else
    return sub_42313B(0, lpText, uType, a3);
}


// ========== Function: sub_42325A @ 0x42325A ==========
int __stdcall sub_42325A(UINT a1, UINT uType, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // esi
  LPCSTR lpText; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+Ch] [ebp-4h]

  lpText = (LPCSTR)off_433548;
  v8 = 0;
  CString::LoadStringA((CString *)&lpText, a1);
  v3 = a3;
  if ( a3 == -1 )
    v3 = a1;
  v4 = sub_423222(lpText, uType, v3);
  v8 = -1;
  v5 = v4;
  sub_4200DD(&lpText);
  return v5;
}


// ========== Function: sub_4232B3 @ 0x4232B3 ==========
HWND __stdcall sub_4232B3(HWND hWnd, HWND *a2)
{
  HWND i; // esi
  int v3; // eax
  HWND v4; // edi
  HWND j; // eax

  i = hWnd;
  if ( hWnd )
    goto LABEL_17;
  v3 = unknown_libname_26();
  if ( v3 || (v3 = sub_404EA0()) != 0 )
  {
    for ( i = *(HWND *)(v3 + 28); i; i = GetParent(i) )
    {
LABEL_17:
      if ( (GetWindowLongA(i, -16) & 0x40000000) == 0 )
        break;
    }
  }
  else
  {
    i = 0;
  }
  v4 = i;
  for ( j = i; j; j = GetParent(j) )
    v4 = j;
  if ( !hWnd && i )
    i = GetLastActivePopup(i);
  if ( a2 )
  {
    if ( v4 && IsWindowEnabled(v4) && v4 != i )
    {
      *a2 = v4;
      EnableWindow(v4, 0);
    }
    else
    {
      *a2 = 0;
    }
  }
  return i;
}


// ========== Function: unknown_libname_26 @ 0x42334F ==========
// MFC 3.1-14.0 32bit
int unknown_libname_26()
{
  return *((_DWORD *)AfxGetThreadState() + 49);
}


// ========== Function: ?PrepareCtrl@CDataExchange@@QAEPAUHWND__@@H@Z @ 0x42335B ==========
HWND __thiscall CDataExchange::PrepareCtrl(CDataExchange *this, HWND nIDDlgItem)
{
  HWND result; // eax

  sub_42045C(*((_DWORD *)this + 1), (int)nIDDlgItem, &nIDDlgItem);
  if ( !nIDDlgItem )
    sub_41B510();
  result = nIDDlgItem;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 2) = result;
  return result;
}


// ========== Function: ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z @ 0x42338A ==========
void __stdcall DDX_Control(struct CDataExchange *a1, HWND a2, HWND *a3)
{
  HWND v3; // eax
  int v4; // esi

  if ( !a3[7] )
  {
    v3 = CDataExchange::PrepareCtrl(a1, a2);
    if ( !sub_41FDD8(a3, v3) )
      sub_41B510();
    v4 = *((_DWORD *)a1 + 1);
    if ( *(HWND *)(v4 + 28) != GetParent(a3[7]) )
      sub_420702(a3, v4);
  }
}


// ========== Function: ?OnHelp@CWnd@@QAEXXZ @ 0x4233D6 ==========
void __thiscall CWnd::OnHelp(HWND *this)
{
  HWND Capture; // edi
  HWND i; // eax
  HWND v3; // edi
  struct CObject *v4; // eax
  HWND v5; // eax
  HWND j; // eax
  HWND v7; // edi

  Capture = GetCapture();
  if ( Capture )
  {
    while ( !SendMessageA(Capture, 0x365u, 0, 0) )
    {
      Capture = AfxGetParentOwner(Capture);
      if ( !Capture )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    for ( i = GetFocus(); ; i = AfxGetParentOwner(v3) )
    {
      v3 = i;
      if ( !i )
        break;
      if ( SendMessageA(i, 0x365u, 0, 0) )
        return;
    }
    v4 = sub_41ED38(this);
    if ( v4 )
      v5 = (HWND)*((_DWORD *)v4 + 7);
    else
      v5 = 0;
    for ( j = GetLastActivePopup(v5); ; j = AfxGetParentOwner(v7) )
    {
      v7 = j;
      if ( !j )
        break;
      if ( SendMessageA(j, 0x365u, 0, 0) )
        return;
    }
    SendMessageA(this[7], 0x111u, 0xE147u, 0);
  }
}


// ========== Function: sub_423478 @ 0x423478 ==========
void __thiscall sub_423478(CWnd *this)
{
  int v2; // eax
  struct AFX_MODULE_STATE *ModuleState; // eax

  v2 = *((_DWORD *)this + 19);
  if ( v2 )
  {
    if ( v2 != 258311 )
    {
      ModuleState = AfxGetModuleState();
      (*(void (__thiscall **)(_DWORD, _DWORD, int))(**((_DWORD **)ModuleState + 1) + 152))(
        *((_DWORD *)ModuleState + 1),
        *((_DWORD *)this + 19),
        1);
    }
  }
  else
  {
    CWnd::OnHelp((HWND *)this);
  }
}


// ========== Function: sub_4234AB @ 0x4234AB ==========
HKEY __thiscall sub_4234AB(int this, LPCSTR lpAppName, LPCSTR lpValueName, int Data)
{
  HKEY result; // eax
  HKEY v6; // esi
  LSTATUS v7; // edi
  CHAR String[16]; // [esp+4h] [ebp-10h] BYREF

  if ( *(_DWORD *)(this + 124) )
  {
    result = CWinApp::GetSectionKey((CWinApp *)this, lpAppName);
    v6 = result;
    if ( result )
    {
      v7 = RegSetValueExA(result, lpValueName, 0, 4u, (const BYTE *)&Data, 4u);
      RegCloseKey(v6);
      return (HKEY)(v7 == 0);
    }
  }
  else
  {
    wsprintfA(String, "%d", Data);
    return (HKEY)WritePrivateProfileStringA(lpAppName, lpValueName, String, *(LPCSTR *)(this + 144));
  }
  return result;
}


// ========== Function: sub_423520 @ 0x423520 ==========
CMemFile *__thiscall sub_423520(CMemFile *lpMem, char a2)
{
  CMemFile::~CMemFile(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??0CMemFile@@QAE@PAEII@Z @ 0x42353C ==========
CMemFile *__thiscall CMemFile::CMemFile(CMemFile *this, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  sub_4214F0(this);
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 4) = a4;
  *((_DWORD *)this + 9) = 0;
  *(_DWORD *)this = &CMemFile::`vftable';
  *((_DWORD *)this + 7) = a4 == 0 ? a3 : 0;
  *((_DWORD *)this + 8) = a2;
  *((_DWORD *)this + 6) = a3;
  return this;
}


// ========== Function: ??1CMemFile@@UAE@XZ @ 0x423578 ==========
void __thiscall CMemFile::~CMemFile(CMemFile *this)
{
  *(_DWORD *)this = &CMemFile::`vftable';
  if ( *((_DWORD *)this + 8) )
    sub_42375F();
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 0;
  CFile::~CFile(this);
}


// ========== Function: ?allocate@?$allocator@D@std@@QAEPADI@Z @ 0x4235C4 ==========
void *__stdcall std::allocator<char>::allocate(size_t Size)
{
  return malloc(Size);
}


// ========== Function: sub_4235D1 @ 0x4235D1 ==========
void *__stdcall sub_4235D1(LPVOID lpMem, SIZE_T dwBytes)
{
  return sub_40F8ED(lpMem, dwBytes);
}


// ========== Function: sub_4235E3 @ 0x4235E3 ==========
// ?Memcpy@CMemFile@@MAEPAEPAEPBEI@Z
// doubtful name
void *__stdcall sub_4235E3(void *a1, const void *a2, unsigned int a3)
{
  qmemcpy(a1, a2, a3);
  return a1;
}


// ========== Function: ?allocate@?$allocator@D@std@@QAEPADI@Z_0 @ 0x423608 ==========
void __stdcall std::allocator<char>::allocate(LPVOID lpMem)
{
  sub_40D386(lpMem);
}


// ========== Function: sub_423615 @ 0x423615 ==========
int __thiscall sub_423615(_DWORD *this)
{
  return this[5];
}


// ========== Function: sub_423619 @ 0x423619 ==========
void __thiscall sub_423619(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax

  v3 = this[6];
  if ( a2 > v3 )
  {
    if ( !this[4] )
      sub_41B4F7();
    for ( ; v3 < a2; v3 += this[4] )
      ;
    v4 = this[8];
    if ( v4 )
      v5 = (*(int (__thiscall **)(_DWORD *, int, unsigned int))(*this + 88))(this, v4, v3);
    else
      v5 = (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 84))(this, v3);
    if ( !v5 )
      sub_41B4F7();
    this[8] = v5;
    this[6] = v3;
  }
}


// ========== Function: sub_423672 @ 0x423672 ==========
int __thiscall sub_423672(_DWORD *this, unsigned int a2)
{
  int result; // eax

  if ( a2 > this[6] )
    result = (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 100))(this, a2);
  if ( a2 < this[5] )
    this[5] = a2;
  this[7] = a2;
  return result;
}


// ========== Function: sub_423695 @ 0x423695 ==========
unsigned int __thiscall sub_423695(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int v3; // edi
  unsigned int v5; // ecx
  unsigned int v6; // eax

  v3 = a3;
  if ( !a3 )
    return 0;
  v5 = this[5];
  v6 = this[7];
  if ( v5 > v6 )
    return 0;
  if ( v5 + a3 > v6 )
    v3 = v6 - v5;
  (*(void (__thiscall **)(_DWORD *, int, unsigned int, unsigned int))(*this + 92))(this, a2, v5 + this[8], v3);
  this[5] += v3;
  return v3;
}


// ========== Function: sub_4236D6 @ 0x4236D6 ==========
void __thiscall sub_4236D6(_DWORD *this, int a2, int a3)
{
  unsigned int v4; // eax

  if ( a3 )
  {
    if ( (unsigned int)(a3 + this[5]) > this[6] )
      (*(void (__stdcall **)(int))(*this + 100))(a3 + this[5]);
    (*(void (__thiscall **)(_DWORD *, int, int, int))(*this + 92))(this, this[5] + this[8], a2, a3);
    this[5] += a3;
    v4 = this[5];
    if ( v4 > this[7] )
      this[7] = v4;
  }
}


// ========== Function: ?Seek@CMemFile@@UAEJJI@Z @ 0x423718 ==========
int __thiscall CMemFile::Seek(CMemFile *this, int a2, unsigned int a3)
{
  int v3; // esi
  int v4; // esi

  v3 = *((_DWORD *)this + 5);
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 != 2 )
        return -1;
      v3 = *((_DWORD *)this + 7);
    }
    v4 = a2 + v3;
  }
  else
  {
    v4 = a2;
  }
  if ( v4 < 0 )
    sub_421DE8(9, -1, 0);
  *((_DWORD *)this + 5) = v4;
  return v4;
}


// ========== Function: nullsub_14 @ 0x42375E ==========
void nullsub_14()
{
  ;
}


// ========== Function: sub_42375F @ 0x42375F ==========
int __thiscall sub_42375F(_DWORD *this)
{
  int result; // eax

  result = this[8];
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  if ( result && this[9] )
    result = (*(int (__thiscall **)(_DWORD *, int))(*this + 96))(this, result);
  this[8] = 0;
  return result;
}


// ========== Function: ?Abort@CMemFile@@UAEXXZ @ 0x423789 ==========
void __thiscall CMemFile::Abort(CMemFile *this)
{
  (*(void (__thiscall **)(CMemFile *))(*(_DWORD *)this + 76))(this);
}


// ========== Function: sub_42378E @ 0x42378E ==========
// attributes: thunk
void __noreturn sub_42378E()
{
  sub_41B510();
}


// ========== Function: nullsub_15 @ 0x423793 ==========
void __stdcall nullsub_15(int a1, int a2)
{
  ;
}


// ========== Function: sub_423796 @ 0x423796 ==========
// attributes: thunk
void __noreturn sub_423796()
{
  sub_41B510();
}


// ========== Function: sub_42379E @ 0x42379E ==========
int __thiscall sub_42379E(_DWORD *this, int a2, int a3, _DWORD *a4, unsigned int *a5)
{
  unsigned int v7; // eax
  int v8; // edi
  unsigned int v9; // eax
  unsigned int *v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // eax

  if ( a2 == 3 )
    return 1;
  if ( a2 == 2 )
  {
    this[5] += a3;
    v7 = this[5];
    if ( v7 > this[7] )
      this[7] = v7;
    return 0;
  }
  else
  {
    v8 = a3;
    if ( a2 == 1 && (unsigned int)(a3 + this[5]) > this[6] )
      (*(void (__thiscall **)(_DWORD *, int))(*this + 100))(this, a3 + this[5]);
    *a4 = this[8] + this[5];
    if ( a2 == 1 )
    {
      v9 = a3 + this[5];
      if ( this[6] < v9 )
        v9 = this[6];
      v10 = a5;
      *a5 = this[8] + v9;
    }
    else
    {
      if ( a3 == -1 )
        v8 = this[6] - this[5];
      v11 = v8 + this[5];
      if ( this[7] < v11 )
        v11 = this[7];
      v12 = this[8] + v11;
      v10 = a5;
      *a5 = v12;
      this[5] += v12 - *a4;
    }
    return *v10 - *a4;
  }
}


// ========== Function: ?AfxFormatStrings@@YGXAAVCString@@IPBQBDH@Z @ 0x423845 ==========
void __stdcall AfxFormatStrings(struct CString *a1, UINT uID, const char *const *a3, int a4)
{
  CHAR Buffer[256]; // [esp+0h] [ebp-100h] BYREF

  if ( AfxLoadString(uID, Buffer, 0x100u) )
    AfxFormatStrings(a1, Buffer, a3, a4);
}


// ========== Function: ?AfxFormatStrings@@YGXAAVCString@@PBDPBQBDH@Z @ 0x42387F ==========
void __stdcall AfxFormatStrings(void **a1, const char *a2, const char *const *a3, int a4)
{
  const char *v4; // esi
  int v5; // ebx
  const char *v6; // edi
  char v7; // al
  int v8; // eax
  const CHAR *v9; // eax
  CHAR *v10; // edi
  unsigned __int8 v11; // cl
  char v12; // al
  int v13; // eax
  const CHAR *v14; // eax

  v4 = a2;
  v5 = 0;
  v6 = a2;
  if ( *a2 )
  {
    while ( *v6 == 37 )
    {
      v7 = v6[1];
      if ( v7 >= 48 && v7 <= 57 )
      {
        v8 = v7 - 49;
      }
      else
      {
        if ( v7 < 65 || v7 > 90 )
          break;
        v8 = v7 - 56;
      }
      v6 += 2;
      if ( v8 < a4 )
      {
        v9 = a3[v8];
        if ( v9 )
          v5 += lstrlenA(v9);
        goto LABEL_16;
      }
LABEL_15:
      ++v5;
LABEL_16:
      if ( !*v6 )
        goto LABEL_17;
    }
    if ( (byte_43A9E1[*(unsigned __int8 *)v6] & 4) != 0 )
    {
      ++v5;
      ++v6;
    }
    ++v6;
    goto LABEL_15;
  }
LABEL_17:
  v10 = (CHAR *)sub_42034E(a1, v5);
  while ( *v4 )
  {
    v11 = *v4;
    if ( *v4 != 37 )
      goto LABEL_30;
    v12 = v4[1];
    if ( v12 >= 48 && v12 <= 57 )
    {
      v13 = v12 - 49;
      goto LABEL_26;
    }
    if ( v12 >= 65 && v12 <= 90 )
    {
      v13 = v12 - 56;
LABEL_26:
      v4 += 2;
      if ( v13 < a4 )
      {
        v14 = a3[v13];
        if ( v14 )
        {
          lstrcpyA(v10, v14);
          v10 += lstrlenA(v10);
        }
      }
      else
      {
        *v10++ = 63;
      }
    }
    else
    {
LABEL_30:
      if ( (byte_43A9E1[v11] & 4) != 0 )
      {
        *v10++ = v11;
        ++v4;
      }
      *v10++ = *v4++;
    }
  }
  CString::ReleaseBuffer(a1, v10 - (_BYTE *)*a1);
}


// ========== Function: sub_42397E @ 0x42397E ==========
void __stdcall sub_42397E(struct CString *a1, UINT uID, char *a3)
{
  AfxFormatStrings(a1, uID, (const char *const *)&a3, 1);
}


// ========== Function: sub_423995 @ 0x423995 ==========
void __thiscall sub_423995(unsigned int *this)
{
  *this = (unsigned int)&CComboBox::`vftable';
  sub_41E0B1(this);
  CWnd::~CWnd((CWnd *)this);
}


// ========== Function: sub_4239CD @ 0x4239CD ==========
int __stdcall sub_4239CD(int a1)
{
  return 0;
}


// ========== Function: nullsub_16 @ 0x4239D2 ==========
void __stdcall nullsub_16(int a1)
{
  ;
}


// ========== Function: ?OnChildNotify@CComboBox@@MAEHIIJPAJ@Z @ 0x4239D5 ==========
LRESULT __thiscall CComboBox::OnChildNotify(CComboBox *this, unsigned int a2, WPARAM wParam, LPARAM lParam, int *a5)
{
  switch ( a2 )
  {
    case '+':
      (*(void (__thiscall **)(CComboBox *, LPARAM))(*(_DWORD *)this + 184))(this, lParam);
      break;
    case ',':
      (*(void (__thiscall **)(CComboBox *, LPARAM))(*(_DWORD *)this + 188))(this, lParam);
      break;
    case '-':
      (*(void (__thiscall **)(CComboBox *, LPARAM))(*(_DWORD *)this + 196))(this, lParam);
      break;
    case '9':
      *a5 = (*(int (__thiscall **)(CComboBox *, LPARAM))(*(_DWORD *)this + 192))(this, lParam);
      break;
    default:
      return CWnd::OnChildNotify(this, a2, wParam, lParam, a5);
  }
  return 1;
}


// ========== Function: ?GetLBText@CComboBox@@QBEXHAAVCString@@@Z @ 0x423A3C ==========
void __thiscall CComboBox::GetLBText(HWND *this, WPARAM wParam, struct CString *a3)
{
  LRESULT v4; // eax
  char *BufferSetLength; // eax

  v4 = SendMessageA(this[7], 0x149u, wParam, 0);
  BufferSetLength = CString::GetBufferSetLength(a3, v4);
  SendMessageA(this[7], 0x148u, wParam, (LPARAM)BufferSetLength);
  CString::ReleaseBuffer((void **)a3, -1);
}


// ========== Function: ?AfxOleCanExitApp@@YGHXZ @ 0x423A7F ==========
BOOL __stdcall AfxOleCanExitApp()
{
  return *((_DWORD *)AfxGetModuleState() + 11) == 0;
}


// ========== Function: ?AfxOleGetUserCtrl@@YGHXZ @ 0x423A8F ==========
int __stdcall AfxOleGetUserCtrl()
{
  return *((_DWORD *)AfxGetModuleState() + 12);
}


// ========== Function: j_unknown_libname_27 @ 0x423A98 ==========
// attributes: thunk
int j_unknown_libname_27()
{
  return unknown_libname_27();
}


// ========== Function: unknown_libname_27 @ 0x423A9D ==========
// MFC 3.1-14.0 32bit
unsigned int unknown_libname_27()
{
  unsigned int result; // eax

  dword_439358 = 0;
  dword_43935C = 0;
  result = 0x80000000;
  dword_439350 = 0x80000000;
  dword_439354 = 0x80000000;
  return result;
}


// ========== Function: j_??__E_afxMsgMouseWheel@@YAXXZ @ 0x423ABB ==========
// attributes: thunk
int `dynamic initializer for '_afxMsgMouseWheel''()
{
  return ??__E_afxMsgMouseWheel@@YAXXZ();
}


// ========== Function: ??__E_afxMsgMouseWheel@@YAXXZ @ 0x423AC0 ==========
UINT `dynamic initializer for '_afxMsgMouseWheel''()
{
  UINT result; // eax

  if ( (GetVersion() & 0x80000000) != 0 && (unsigned __int16)GetVersion() == 4
    || (result = GetVersion(), (result & 0x80000000) == 0) && (result = GetVersion(), (_WORD)result == 3) )
  {
    result = RegisterWindowMessageA("MSWHEEL_ROLLMSG");
    dword_439348 = result;
  }
  else
  {
    dword_439348 = 0;
  }
  return result;
}


// ========== Function: sub_423B05 @ 0x423B05 ==========
void __cdecl sub_423B05()
{
  AfxDeleteObject(&dword_439360);
}


// ========== Function: sub_423B10 @ 0x423B10 ==========
// attributes: thunk
int sub_423B10()
{
  return sub_423B15();
}


// ========== Function: sub_423B15 @ 0x423B15 ==========
int sub_423B15()
{
  int result; // eax

  result = atexit(sub_423B05);
  byte_439364 = result;
  return result;
}


// ========== Function: sub_423B26 @ 0x423B26 ==========
LONG __thiscall sub_423B26(HDC *this, struct tagSIZE *a2)
{
  int MapMode; // eax
  int v4; // edi
  LONG result; // eax
  int DeviceCaps; // ebx
  int v7; // eax
  int nDenominator; // [esp+Ch] [ebp-4h]

  if ( this )
  {
    MapMode = GetMapMode(this[2]);
    v4 = MapMode;
    if ( MapMode < 7 && MapMode != 1 )
    {
      (*((void (__thiscall **)(HDC *, int))*this + 13))(this, 3);
      CDC::DPtoLP(this, a2);
      return (*((int (__thiscall **)(HDC *, int))*this + 13))(this, v4);
    }
    DeviceCaps = GetDeviceCaps(this[2], 88);
    v7 = GetDeviceCaps(this[2], 90);
  }
  else
  {
    DeviceCaps = dword_439290;
    v7 = dword_439294;
  }
  nDenominator = v7;
  a2->cx = MulDiv(a2->cx, 2540, DeviceCaps);
  result = MulDiv(a2->cy, 2540, nDenominator);
  a2->cy = result;
  return result;
}


// ========== Function: sub_423BB4 @ 0x423BB4 ==========
LONG __thiscall sub_423BB4(HDC *this, struct tagSIZE *a2)
{
  int MapMode; // eax
  int v4; // edi
  LONG result; // eax
  int DeviceCaps; // edi
  int v7; // eax
  int nNumerator; // [esp+Ch] [ebp-4h]

  if ( this )
  {
    MapMode = GetMapMode(this[2]);
    v4 = MapMode;
    if ( MapMode < 7 && MapMode != 1 )
    {
      (*((void (__thiscall **)(HDC *, int))*this + 13))(this, 3);
      CDC::LPtoDP(this, a2);
      return (*((int (__thiscall **)(HDC *, int))*this + 13))(this, v4);
    }
    DeviceCaps = GetDeviceCaps(this[2], 88);
    v7 = GetDeviceCaps(this[2], 90);
  }
  else
  {
    DeviceCaps = dword_439290;
    v7 = dword_439294;
  }
  nNumerator = v7;
  a2->cx = MulDiv(a2->cx, DeviceCaps, 2540);
  result = MulDiv(a2->cy, nNumerator, 2540);
  a2->cy = result;
  return result;
}


// ========== Function: sub_423C42 @ 0x423C42 ==========
_DWORD *__thiscall sub_423C42(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &_AFX_WIN_STATE::`vftable';
  return result;
}


// ========== Function: sub_423C4B @ 0x423C4B ==========
HLOCAL __thiscall sub_423C4B(HLOCAL hMem, char a2)
{
  sub_4272E6();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: ??0CWinApp@@QAE@PBD@Z @ 0x423C66 ==========
CWinApp *__thiscall CWinApp::CWinApp(CWinApp *this, char *Source)
{
  struct AFX_MODULE_STATE *ModuleState; // ebx

  CWinThread::CWinThread(this);
  *(_DWORD *)this = &CWinApp::`vftable';
  if ( Source )
    *((_DWORD *)this + 30) = _strdup(Source);
  else
    *((_DWORD *)this + 30) = 0;
  ModuleState = AfxGetModuleState();
  *((_DWORD *)CThreadLocalObject::GetData((struct AFX_MODULE_STATE *)((char *)ModuleState + 4208), sub_423F73) + 1) = this;
  *((_DWORD *)this + 10) = GetCurrentThread();
  *((_DWORD *)this + 11) = GetCurrentThreadId();
  *((_DWORD *)ModuleState + 1) = this;
  *((_DWORD *)this + 26) = 0;
  *((_DWORD *)this + 35) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 31) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_WORD *)this + 89) = 0;
  *((_WORD *)this + 88) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 41) = 0;
  *((_DWORD *)this + 37) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 45) = 0;
  *((_DWORD *)this + 47) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_DWORD *)this + 46) = 512;
  return this;
}


// ========== Function: sub_423D50 @ 0x423D50 ==========
LPVOID __thiscall sub_423D50(LPVOID lpMem, char a2)
{
  sub_423DB0();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ?InitApplication@CWinApp@@UAEHXZ @ 0x423D6C ==========
int __thiscall CWinApp::InitApplication(CWinApp *this)
{
  int v1; // ecx

  if ( dword_437378 )
  {
    if ( !*((_DWORD *)this + 32) )
      *((_DWORD *)this + 32) = dword_437378;
    dword_437378 = 0;
  }
  v1 = *((_DWORD *)this + 32);
  if ( v1 )
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v1 + 12))(v1, 0);
  else
    dword_433360 = 0;
  return 1;
}


// ========== Function: sub_423DAC @ 0x423DAC ==========
int sub_423DAC()
{
  return 1;
}


// ========== Function: sub_423DB0 @ 0x423DB0 ==========
void __thiscall sub_423DB0(int this)
{
  int v2; // ecx
  int v3; // ecx
  ATOM v4; // ax
  ATOM v5; // ax
  int v6; // ecx
  struct AFX_MODULE_STATE *ModuleState; // eax

  *(_DWORD *)this = &CWinApp::`vftable';
  v2 = *(_DWORD *)(this + 128);
  if ( v2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, 1);
  v3 = *(_DWORD *)(this + 168);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 20))(v3, 1);
  if ( !*((_BYTE *)AfxGetModuleState() + 20) )
  {
    if ( dword_43737C )
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_43737C + 4))(dword_43737C, 1);
      dword_43737C = 0;
    }
    if ( dword_437378 )
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_437378 + 4))(dword_437378, 1);
      dword_437378 = 0;
    }
  }
  if ( *(_DWORD *)(this + 148) )
    AfxGlobalFree(*(HGLOBAL *)(this + 148));
  if ( *(_DWORD *)(this + 152) )
    AfxGlobalFree(*(HGLOBAL *)(this + 152));
  v4 = *(_WORD *)(this + 176);
  if ( v4 )
    GlobalDeleteAtom(v4);
  v5 = *(_WORD *)(this + 178);
  if ( v5 )
    GlobalDeleteAtom(v5);
  v6 = *(_DWORD *)(this + 172);
  if ( v6 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 4))(v6, 1);
  ModuleState = AfxGetModuleState();
  if ( *((_DWORD *)ModuleState + 4) == *(_DWORD *)(this + 120) )
    *((_DWORD *)ModuleState + 4) = 0;
  if ( *((_DWORD *)ModuleState + 1) == this )
    *((_DWORD *)ModuleState + 1) = 0;
  sub_40D386(*(LPVOID *)(this + 120));
  sub_40D386(*(LPVOID *)(this + 124));
  sub_40D386(*(LPVOID *)(this + 136));
  sub_40D386(*(LPVOID *)(this + 140));
  sub_40D386(*(LPVOID *)(this + 144));
  *(_DWORD *)(this + 40) = 0;
  CWinThread::~CWinThread((CWinThread *)this);
}


// ========== Function: sub_423EE6 @ 0x423EE6 ==========
HKEY __thiscall sub_423EE6(_DWORD *this)
{
  int v2; // ecx
  HKEY result; // eax

  v2 = this[42];
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 16))(v2);
  result = (HKEY)this[45];
  if ( result )
    return sub_4234AB((int)this, "Settings", "PreviewPages", this[45]);
  return result;
}


// ========== Function: ?ExitInstance@CWinApp@@UAEHXZ @ 0x423F16 ==========
int __thiscall CWinApp::ExitInstance(CWinApp *this)
{
  int v2; // eax
  void (*v3)(void); // eax

  v2 = *((_DWORD *)this + 43);
  if ( (!v2 || *(_DWORD *)(v2 + 16) != 5) && !*((_BYTE *)AfxGetModuleState() + 20) )
    sub_423EE6(this);
  v3 = (void (*)(void))*((_DWORD *)this + 47);
  if ( v3 )
    v3();
  return *((_DWORD *)this + 14);
}


// ========== Function: sub_423F4C @ 0x423F4C ==========
char **sub_423F4C()
{
  return &off_4299F0;
}


// ========== Function: sub_423F52 @ 0x423F52 ==========
int sub_423F52()
{
  nullsub_17();
  return atexit(sub_423F69);
}


// ========== Function: nullsub_17 @ 0x423F5C ==========
void nullsub_17()
{
  ;
}


// ========== Function: sub_423F69 @ 0x423F69 ==========
void __stdcall sub_423F69(int a1)
{
  sub_424653(a1);
}


// ========== Function: sub_423F73 @ 0x423F73 ==========
struct CNoTrackObject *__stdcall sub_423F73()
{
  struct CNoTrackObject *result; // eax
  HLOCAL hMem; // [esp+0h] [ebp-10h]

  hMem = CNoTrackObject::operator new(0x3Cu);
  result = 0;
  if ( hMem )
    return (struct CNoTrackObject *)sub_42454A();
  return result;
}


// ========== Function: sub_423FA4 @ 0x423FA4 ==========
CWinThread *__thiscall sub_423FA4(CWinThread *lpMem, char a2)
{
  CWinThread::~CWinThread(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??0CWinThread@@QAE@XZ @ 0x423FC0 ==========
CWinThread *__thiscall CWinThread::CWinThread(CWinThread *this)
{
  sub_41C5A3(this);
  *(_DWORD *)this = &CWinThread::`vftable';
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  CWinThread::CommonConstruct(this);
  return this;
}


// ========== Function: ?CommonConstruct@CWinThread@@QAEXXZ @ 0x423FFD ==========
void __thiscall CWinThread::CommonConstruct(CWinThread *this)
{
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 25) = 0;
  GetCursorPos((LPPOINT)((char *)this + 92));
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 9) = 1;
}


// ========== Function: sub_42402F @ 0x42402F ==========
char **sub_42402F()
{
  return &off_429B40;
}


// ========== Function: ?CreateObject@?$CThreadLocal@V_AFX_THREAD_STATE@@@@SGPAVCNoTrackObject@@XZ @ 0x424035 ==========
struct CNoTrackObject *__stdcall CThreadLocal<_AFX_THREAD_STATE>::CreateObject()
{
  _AFX_THREAD_STATE *v0; // ecx
  struct CNoTrackObject *result; // eax

  v0 = (_AFX_THREAD_STATE *)CNoTrackObject::operator new(0x118u);
  result = 0;
  if ( v0 )
    return _AFX_THREAD_STATE::_AFX_THREAD_STATE(v0);
  return result;
}


// ========== Function: ?CreateObject@?$CProcessLocal@V_AFX_CTL3D_STATE@@@@SGPAVCNoTrackObject@@XZ @ 0x424069 ==========
_DWORD *CProcessLocal<_AFX_CTL3D_STATE>::CreateObject()
{
  _DWORD *result; // eax

  result = CNoTrackObject::operator new(0x30u);
  if ( !result )
    return 0;
  *result = &_AFX_CTL3D_STATE::`vftable';
  return result;
}


// ========== Function: sub_42407E @ 0x42407E ==========
struct CNoTrackObject *__stdcall sub_42407E()
{
  struct CNoTrackObject *result; // eax

  result = (struct CNoTrackObject *)CNoTrackObject::operator new(4u);
  if ( !result )
    return 0;
  *(_DWORD *)result = &_AFX_CTL3D_THREAD::`vftable';
  return result;
}


// ========== Function: sub_424093 @ 0x424093 ==========
HLOCAL __thiscall sub_424093(HLOCAL hMem, char a2)
{
  sub_42528C();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_4240AE @ 0x4240AE ==========
HLOCAL __thiscall sub_4240AE(HLOCAL hMem, char a2)
{
  sub_4252CD();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: ?_AfxLoadDotBitmap@@YGXXZ @ 0x4240C9 ==========
void __stdcall _AfxLoadDotBitmap()
{
  unsigned int v0; // eax
  int v1; // ebx
  unsigned int v2; // eax
  int v3; // esi
  int v4; // edi
  int v5; // eax
  int v6; // esi
  _BYTE *v7; // edx
  int v8; // eax
  int v9; // eax
  _WORD Bits[66]; // [esp+Ch] [ebp-90h] BYREF
  int nHeight; // [esp+90h] [ebp-Ch]
  int v12; // [esp+94h] [ebp-8h]
  unsigned __int8 *v13; // [esp+98h] [ebp-4h]

  v0 = GetMenuCheckMarkDimensions();
  v1 = (__int16)v0;
  v2 = HIWORD(v0);
  nHeight = (__int16)v2;
  if ( v1 > 32 )
    v1 = 32;
  v3 = (v1 + 15) >> 4;
  v4 = 16 * v3 + (v1 - 4) / 2 - v1;
  if ( v4 > 12 )
    LOBYTE(v4) = 12;
  if ( (__int16)v2 > 32 )
    nHeight = 32;
  memset(Bits, 255, 0x80u);
  v13 = (unsigned __int8 *)&unk_429C1C;
  v5 = v3 * ((nHeight - 6) >> 1);
  v6 = 2 * v3;
  v12 = 5;
  v7 = &Bits[v5];
  do
  {
    HIWORD(v8) = HIWORD(v13);
    LOWORD(v8) = *v13++;
    v9 = ~(v8 << v4);
    v7[1] = v9;
    *v7 = BYTE1(v9);
    v7 += v6;
    --v12;
  }
  while ( v12 );
  hBitmapChecked = CreateBitmap(v1, nHeight, 1u, 1u, Bits);
  if ( !hBitmapChecked )
    hBitmapChecked = LoadBitmapA(0, (LPCSTR)0x7FE3);
}


// ========== Function: sub_4241A9 @ 0x4241A9 ==========
char **sub_4241A9()
{
  return &off_429BF8;
}


// ========== Function: sub_4241AF @ 0x4241AF ==========
char **sub_4241AF()
{
  return &off_429D00;
}


// ========== Function: sub_4241B5 @ 0x4241B5 ==========
char **sub_4241B5()
{
  return &off_429F08;
}


// ========== Function: ?CreateObject@CWnd@@SGPAVCObject@@XZ @ 0x4241BB ==========
struct CObject *__stdcall CWnd::CreateObject()
{
  _DWORD *v0; // ecx
  struct CObject *result; // eax

  v0 = sub_41CA70(0x3Cu);
  result = 0;
  if ( v0 )
    return (struct CObject *)sub_41D43B(v0);
  return result;
}


// ========== Function: sub_4241ED @ 0x4241ED ==========
char **sub_4241ED()
{
  return &off_42A020;
}


// ========== Function: sub_4241F3 @ 0x4241F3 ==========
_DWORD *sub_4241F3()
{
  _DWORD *v0; // esi
  _DWORD *result; // eax

  v0 = sub_406B83(byte_438B88);
  result = 0;
  if ( v0 )
  {
    sub_41D43B(v0);
    *v0 = &CTempWnd::`vftable';
    return v0;
  }
  return result;
}


// ========== Function: sub_424233 @ 0x424233 ==========
CWnd *__thiscall sub_424233(CWnd *this, char a2)
{
  CWnd::~CWnd(this);
  if ( (a2 & 1) != 0 )
    sub_406C12((int)byte_438B88, this);
  return this;
}


// ========== Function: j_??1CWnd@@UAE@XZ_0 @ 0x424253 ==========
// attributes: thunk
void __thiscall CWnd::~CWnd(CWnd *this)
{
  ??1CWnd@@UAE@XZ(this);
}


// ========== Function: sub_424258 @ 0x424258 ==========
char **sub_424258()
{
  return &off_429FF8;
}


// ========== Function: sub_42425E @ 0x42425E ==========
int sub_42425E()
{
  sub_424268();
  return atexit(unknown_libname_28);
}


// ========== Function: sub_424268 @ 0x424268 ==========
char *sub_424268()
{
  return sub_406B1F(byte_438B88, 60, 64);
}


// ========== Function: unknown_libname_28 @ 0x424283 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_28()
{
  if ( (byte_437380 & 1) == 0 )
  {
    byte_437380 |= 1u;
    sub_406B5B((int)byte_438B88);
    DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438B88[16]);
  }
}


// ========== Function: sub_42429E @ 0x42429E ==========
_DWORD *sub_42429E()
{
  _DWORD *v0; // ecx
  _DWORD *result; // eax

  v0 = CNoTrackObject::operator new(0x10u);
  result = 0;
  if ( v0 )
    return sub_423C42(v0);
  return result;
}


// ========== Function: ?Enable3dControlsStatic@CWinApp@@IAEHXZ @ 0x4242CF ==========
int __thiscall CWinApp::Enable3dControlsStatic(CWinApp *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  struct AFX_MODULE_STATE *ModuleState; // eax
  struct AFX_MODULE_STATE *v5; // eax

  if ( dword_4392D4 )
    return 1;
  v2 = (_DWORD *)sub_424E45(CProcessLocal<_AFX_CTL3D_STATE>::CreateObject);
  v3 = v2;
  if ( !v2[1] )
  {
    v2[3] = Ctl3dRegister;
    v2[4] = Ctl3dUnregister;
    v2[5] = Ctl3dAutoSubclass;
    v2[6] = Ctl3dUnAutoSubclass;
    v2[7] = Ctl3dColorChange;
    v2[8] = Ctl3dSubclassDlgEx;
    v2[9] = Ctl3dWinIniChange;
    v2[10] = Ctl3dSubclassCtl;
    v2[11] = Ctl3dSubclassCtlEx;
    ModuleState = AfxGetModuleState();
    if ( !((int (__stdcall *)(_DWORD))v3[3])(*((_DWORD *)ModuleState + 2)) )
    {
      v3[3] = 0;
      v3[4] = 0;
      v3[5] = 0;
      v3[6] = 0;
      v3[7] = 0;
      v3[8] = 0;
      v3[9] = 0;
      v3[10] = 0;
      v3[11] = 0;
    }
    v3[1] = 1;
  }
  if ( !v3[5] )
    return 0;
  v5 = AfxGetModuleState();
  return ((int (__stdcall *)(_DWORD))v3[5])(*((_DWORD *)v5 + 2));
}


// ========== Function: ??0_AFX_THREAD_STATE@@QAE@XZ @ 0x424380 ==========
_AFX_THREAD_STATE *__thiscall _AFX_THREAD_STATE::_AFX_THREAD_STATE(_AFX_THREAD_STATE *this)
{
  _AFX_THREAD_STATE *result; // eax

  result = this;
  *((_DWORD *)this + 53) = -1;
  *((_DWORD *)this + 65) = -1;
  *(_DWORD *)this = &_AFX_THREAD_STATE::`vftable';
  return result;
}


// ========== Function: sub_424397 @ 0x424397 ==========
HLOCAL __thiscall sub_424397(HLOCAL hMem, char a2)
{
  sub_4243B2();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_4243B2 @ 0x4243B2 ==========
void __thiscall sub_4243B2(char *this)
{
  int v2; // ecx
  _DWORD *v3; // edi
  void *v4; // esi

  *(_DWORD *)this = &_AFX_THREAD_STATE::`vftable';
  v2 = *((_DWORD *)this + 51);
  v3 = this + 204;
  if ( v2 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 88))(v2);
    if ( *v3 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v3 + 4))(*v3, 1);
  }
  if ( *((_DWORD *)this + 12) )
    UnhookWindowsHookEx(*((HHOOK *)this + 12));
  if ( *((_DWORD *)this + 11) )
    UnhookWindowsHookEx(*((HHOOK *)this + 11));
  v4 = (void *)*((_DWORD *)this + 3);
  if ( v4 )
    sub_40D386(v4);
}


// ========== Function: ?AfxGetThreadState@@YGPAV_AFX_THREAD_STATE@@XZ @ 0x424426 ==========
struct _AFX_THREAD_STATE *__stdcall AfxGetThreadState()
{
  return CThreadLocalObject::GetData((CThreadLocalObject *)&unk_438D7C, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
}


// ========== Function: sub_424436 @ 0x424436 ==========
int sub_424436()
{
  nullsub_18();
  return atexit(sub_42444D);
}


// ========== Function: nullsub_18 @ 0x424440 ==========
void nullsub_18()
{
  ;
}


// ========== Function: sub_42444D @ 0x42444D ==========
void __cdecl sub_42444D()
{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&unk_438D7C);
}


// ========== Function: ??0AFX_MODULE_STATE@@QAE@H@Z @ 0x424457 ==========
AFX_MODULE_STATE *__thiscall AFX_MODULE_STATE::AFX_MODULE_STATE(AFX_MODULE_STATE *this, char a2)
{
  AFX_MODULE_STATE *result; // eax
  _DWORD *v3; // ecx

  result = this;
  v3 = (_DWORD *)((char *)this + 4156);
  *((_DWORD *)result + 7) = 0;
  *((_DWORD *)result + 8) = 0;
  *((_DWORD *)result + 9) = 0;
  *((_DWORD *)result + 10) = 0;
  *v3 = 0;
  v3[1] = 0;
  *((_DWORD *)result + 1043) = -1;
  *((_DWORD *)result + 1044) = 0;
  *((_DWORD *)result + 1049) = 0;
  *((_DWORD *)result + 1050) = 0;
  *(_DWORD *)result = &AFX_MODULE_STATE::`vftable';
  *((_DWORD *)result + 10) = 28;
  *((_DWORD *)result + 8) = 20;
  *((_DWORD *)result + 6) = 0;
  *((_BYTE *)result + 20) = a2;
  *((_DWORD *)result + 12) = 1;
  *((_DWORD *)result + 1040) = 24;
  return result;
}


// ========== Function: sub_4244BA @ 0x4244BA ==========
HLOCAL __thiscall sub_4244BA(HLOCAL hMem, char a2)
{
  sub_4244D5();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_4244D5 @ 0x4244D5 ==========
void __thiscall sub_4244D5(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  int v3; // ecx
  _DWORD *v4; // edi

  *this = &AFX_MODULE_STATE::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[1041];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = this[1051];
  v4 = this + 1051;
  if ( v3 )
  {
    (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)v3 + 12))(v3, this + 1042);
    if ( *v4 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v4 + 4))(*v4, 1);
  }
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)(this + 1052));
}


// ========== Function: sub_42454A @ 0x42454A ==========
_DWORD *__thiscall sub_42454A(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[2] = 0;
  this[3] = 0;
  *this = &AFX_MODULE_THREAD_STATE::`vftable';
  this[3] = 84;
  this[10] = sub_41CA56;
  return result;
}


// ========== Function: sub_424569 @ 0x424569 ==========
HLOCAL __thiscall sub_424569(HLOCAL hMem, char a2)
{
  sub_424584();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_424584 @ 0x424584 ==========
void __thiscall sub_424584(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void (__thiscall ***v5)(_DWORD, int); // ecx
  void (__thiscall ***v6)(_DWORD, int); // ecx
  _DWORD *v7; // ecx
  void *v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx

  *this = &AFX_MODULE_THREAD_STATE::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[5];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = (void (__thiscall ***)(_DWORD, int))this[6];
  if ( v3 )
    (**v3)(v3, 1);
  v4 = (void (__thiscall ***)(_DWORD, int))this[7];
  if ( v4 )
    (**v4)(v4, 1);
  v5 = (void (__thiscall ***)(_DWORD, int))this[8];
  if ( v5 )
    (**v5)(v5, 1);
  v6 = (void (__thiscall ***)(_DWORD, int))this[9];
  if ( v6 )
    (**v6)(v6, 1);
  v7 = (_DWORD *)this[14];
  if ( v7 )
  {
    while ( v7[3] )
    {
      v8 = (void *)sub_41BAA2(v7);
      sub_41CA99(v8);
      v7 = (_DWORD *)this[14];
    }
  }
  v9 = this[12];
  if ( v9 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v9 + 4))(v9, 1);
  v10 = this[13];
  if ( v10 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v10 + 4))(v10, 1);
  v11 = this[14];
  if ( v11 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v11 + 4))(v11, 1);
}


// ========== Function: sub_424632 @ 0x424632 ==========
int sub_424632()
{
  nullsub_19();
  return atexit(sub_424649);
}


// ========== Function: nullsub_19 @ 0x42463C ==========
void nullsub_19()
{
  ;
}


// ========== Function: sub_424649 @ 0x424649 ==========
void __stdcall sub_424649(int a1)
{
  sub_424653(a1);
}


// ========== Function: sub_424653 @ 0x424653 ==========
// attributes: thunk
void __stdcall sub_424653(int a1)
{
  JUMPOUT(0x424EA0);
}


// ========== Function: ?AfxGetModuleState@@YGPAVAFX_MODULE_STATE@@XZ @ 0x424658 ==========
struct AFX_MODULE_STATE *__stdcall AfxGetModuleState()
{
  struct AFX_MODULE_STATE *result; // eax

  result = (struct AFX_MODULE_STATE *)*((_DWORD *)CThreadLocalObject::GetData(
                                                    (CThreadLocalObject *)&unk_438D7C,
                                                    CThreadLocal<_AFX_THREAD_STATE>::CreateObject)
                                      + 1);
  if ( !result )
    return (struct AFX_MODULE_STATE *)sub_424E45(sub_4246CA);
  return result;
}


// ========== Function: ?AfxGetModuleThreadState@@YGPAVAFX_MODULE_THREAD_STATE@@XZ @ 0x42467E ==========
struct AFX_MODULE_THREAD_STATE *__stdcall AfxGetModuleThreadState()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return CThreadLocalObject::GetData((struct AFX_MODULE_STATE *)((char *)ModuleState + 4208), sub_423F73);
}


// ========== Function: ?Unlock@CTypeLibCache@@QAEXXZ @ 0x424695 ==========
void __thiscall CTypeLibCache::Unlock(CTypeLibCache *this)
{
  int v2; // eax
  int v3; // eax

  if ( !InterlockedDecrement((volatile LONG *)this + 8) )
  {
    v2 = *((_DWORD *)this + 7);
    if ( v2 )
    {
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v2 + 8))(*((_DWORD *)this + 7));
      *((_DWORD *)this + 7) = 0;
    }
    v3 = *((_DWORD *)this + 2);
    if ( v3 )
    {
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v3 + 8))(*((_DWORD *)this + 2));
      *((_DWORD *)this + 2) = 0;
    }
  }
}


// ========== Function: sub_4246CA @ 0x4246CA ==========
AFX_MODULE_STATE *sub_4246CA()
{
  AFX_MODULE_STATE *v0; // eax
  AFX_MODULE_STATE *v1; // esi

  v0 = (AFX_MODULE_STATE *)CNoTrackObject::operator new(0x1074u);
  v1 = v0;
  if ( !v0 )
    return 0;
  AFX_MODULE_STATE::AFX_MODULE_STATE(v0, 1);
  *(_DWORD *)v1 = &_AFX_BASE_MODULE_STATE::`vftable';
  return v1;
}


// ========== Function: sub_4246F2 @ 0x4246F2 ==========
_DWORD *__thiscall sub_4246F2(_DWORD *hMem, char a2)
{
  sub_42470D(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_42470D @ 0x42470D ==========
// attributes: thunk
void __thiscall sub_42470D(_DWORD *this)
{
  sub_4244D5(this);
}


// ========== Function: sub_424712 @ 0x424712 ==========
char **sub_424712()
{
  return &off_42A7E0;
}


// ========== Function: sub_424718 @ 0x424718 ==========
char **sub_424718()
{
  return &off_42A9F0;
}


// ========== Function: sub_42471E @ 0x42471E ==========
int sub_42471E()
{
  unknown_libname_29();
  return atexit(sub_424746);
}


// ========== Function: unknown_libname_29 @ 0x424728 ==========
// MFC 3.1-14.0 32bit
CException *unknown_libname_29()
{
  return sub_40683D((CException *)&dword_438E20, 0, 61474);
}


// ========== Function: sub_424746 @ 0x424746 ==========
void __cdecl sub_424746()
{
  sub_406883(dword_438E20);
}


// ========== Function: sub_424750 @ 0x424750 ==========
char **sub_424750()
{
  return &off_42A9C8;
}


// ========== Function: sub_424756 @ 0x424756 ==========
int sub_424756()
{
  unknown_libname_30();
  return atexit(sub_42477E);
}


// ========== Function: unknown_libname_30 @ 0x424760 ==========
// MFC 3.1-14.0 32bit
CException *unknown_libname_30()
{
  return sub_40688A((CException *)&dword_438D88, 0, 61476);
}


// ========== Function: sub_42477E @ 0x42477E ==========
void __cdecl sub_42477E()
{
  sub_4068D0(dword_438D88);
}


// ========== Function: sub_42479F @ 0x42479F ==========
_UNKNOWN ***sub_42479F()
{
  return &off_42A9A8;
}


// ========== Function: sub_4247A5 @ 0x4247A5 ==========
char **sub_4247A5()
{
  return &off_42A980;
}


// ========== Function: sub_4247AB @ 0x4247AB ==========
char **sub_4247AB()
{
  return &off_42A958;
}


// ========== Function: sub_4247B1 @ 0x4247B1 ==========
char **sub_4247B1()
{
  return &off_42A930;
}


// ========== Function: sub_4247D1 @ 0x4247D1 ==========
char **sub_4247D1()
{
  return &off_42A908;
}


// ========== Function: sub_4247D7 @ 0x4247D7 ==========
char **sub_4247D7()
{
  return &off_42A8E8;
}


// ========== Function: sub_4247DD @ 0x4247DD ==========
char **sub_4247DD()
{
  return &off_42A8C8;
}


// ========== Function: sub_424809 @ 0x424809 ==========
unsigned int *__thiscall sub_424809(unsigned int *this, char a2)
{
  sub_424829(this);
  if ( (a2 & 1) != 0 )
    sub_406C12((int)&byte_438EE0, this);
  return this;
}


// ========== Function: sub_424829 @ 0x424829 ==========
// attributes: thunk
void *__thiscall sub_424829(unsigned int *this)
{
  return sub_42228F(this);
}


// ========== Function: sub_42482E @ 0x42482E ==========
char **sub_42482E()
{
  return &off_42A8A8;
}


// ========== Function: sub_424850 @ 0x424850 ==========
_DWORD *__thiscall sub_424850(_DWORD *this, char a2)
{
  sub_424870();
  if ( (a2 & 1) != 0 )
    sub_406C12((int)&byte_438EB8, this);
  return this;
}


// ========== Function: sub_424870 @ 0x424870 ==========
BOOL __thiscall sub_424870(unsigned int *this)
{
  *this = (unsigned int)&CGdiObject::`vftable';
  return sub_422A21(this);
}


// ========== Function: sub_424899 @ 0x424899 ==========
char **sub_424899()
{
  return &off_42A880;
}


// ========== Function: sub_42489F @ 0x42489F ==========
int sub_42489F()
{
  sub_4248A9();
  return atexit(unknown_libname_31);
}


// ========== Function: sub_4248A9 @ 0x4248A9 ==========
char *sub_4248A9()
{
  return sub_406B1F(byte_438EE0, 16, 64);
}


// ========== Function: unknown_libname_31 @ 0x4248C4 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_31()
{
  if ( (byte_438D80 & 1) == 0 )
  {
    byte_438D80 |= 1u;
    sub_406B5B((int)byte_438EE0);
    DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438EE0[16]);
  }
}


// ========== Function: sub_4248DF @ 0x4248DF ==========
int sub_4248DF()
{
  sub_4248E9();
  return atexit(unknown_libname_32);
}


// ========== Function: sub_4248E9 @ 0x4248E9 ==========
char *sub_4248E9()
{
  return sub_406B1F(byte_438EB8, 8, 64);
}


// ========== Function: unknown_libname_32 @ 0x424904 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_32()
{
  if ( (byte_438D80 & 2) == 0 )
  {
    byte_438D80 |= 2u;
    sub_406B5B((int)byte_438EB8);
    DeleteCriticalSection((LPCRITICAL_SECTION)&byte_438EB8[16]);
  }
}


// ========== Function: sub_42491F @ 0x42491F ==========
char **sub_42491F()
{
  return &off_42ACB8;
}


// ========== Function: ?AddHead@CSimpleList@@QAEXPAX@Z @ 0x424925 ==========
void __thiscall CSimpleList::AddHead(CSimpleList *this, char *a2)
{
  *(_DWORD *)&a2[*((_DWORD *)this + 1)] = *(_DWORD *)this;
  *(_DWORD *)this = a2;
}


// ========== Function: sub_424938 @ 0x424938 ==========
int __thiscall sub_424938(int *this, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ecx
  int v5; // edi

  v2 = *this;
  if ( !*this )
    return 0;
  result = 0;
  if ( v2 == a2 )
  {
    *this = *(_DWORD *)(this[1] + a2);
    return 1;
  }
  if ( v2 )
  {
    v4 = this[1];
    do
    {
      v5 = *(_DWORD *)(v4 + v2);
      if ( v5 == a2 )
        break;
      v2 = *(_DWORD *)(v4 + v2);
    }
    while ( v5 );
    if ( v2 )
    {
      *(_DWORD *)(v4 + v2) = *(_DWORD *)(v4 + a2);
      return 1;
    }
  }
  return result;
}


// ========== Function: ??2CNoTrackObject@@SGPAXI@Z @ 0x42497E ==========
HLOCAL __stdcall CNoTrackObject::operator new(SIZE_T uBytes)
{
  HLOCAL result; // eax

  result = LocalAlloc(0x40u, uBytes);
  if ( !result )
    sub_41B4F7();
  return result;
}


// ========== Function: ??3CNoTrackObject@@SGXPAX@Z @ 0x42499C ==========
void __stdcall CNoTrackObject::operator delete(HLOCAL hMem)
{
  if ( hMem )
    LocalFree(hMem);
}


// ========== Function: ??0CThreadSlotData@@QAE@XZ @ 0x4249B0 ==========
CThreadSlotData *__thiscall CThreadSlotData::CThreadSlotData(CThreadSlotData *this)
{
  DWORD v2; // eax

  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 6) = 4;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  v2 = TlsAlloc();
  *(_DWORD *)this = v2;
  if ( v2 == -1 )
    sub_41B4F7();
  InitializeCriticalSection((LPCRITICAL_SECTION)((char *)this + 28));
  return this;
}


// ========== Function: ??1CThreadSlotData@@QAE@XZ @ 0x4249F2 ==========
void __thiscall CThreadSlotData::~CThreadSlotData(CThreadSlotData *this)
{
  int v2; // eax
  int v3; // edi
  HGLOBAL v4; // edi

  if ( *(_DWORD *)this != -1 )
    TlsFree(*(_DWORD *)this);
  v2 = *((_DWORD *)this + 5);
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 4);
      sub_424CBE(v2, 0);
      v2 = v3;
    }
    while ( v3 );
  }
  if ( *((_DWORD *)this + 4) )
  {
    v4 = GlobalHandle(*((LPCVOID *)this + 4));
    GlobalUnlock(v4);
    GlobalFree(v4);
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 28));
}


// ========== Function: sub_424A49 @ 0x424A49 ==========
int __thiscall sub_424A49(int this)
{
  int v2; // ebp
  int v3; // edi
  _BYTE *v4; // eax
  const void *v5; // eax
  int v6; // ebp
  HGLOBAL v7; // eax
  HGLOBAL v8; // ebx
  HGLOBAL v9; // eax
  char *v10; // ebx
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [esp+10h] [ebp-4h]

  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(this + 28);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(this + 8);
  if ( v3 >= v2 || (*(_BYTE *)(*(_DWORD *)(this + 16) + 8 * v3) & 1) != 0 )
  {
    v3 = 1;
    if ( v2 <= 1 )
      goto LABEL_8;
    v4 = (_BYTE *)(*(_DWORD *)(this + 16) + 8);
    do
    {
      if ( (*v4 & 1) == 0 )
        break;
      ++v3;
      v4 += 8;
    }
    while ( v3 < v2 );
    if ( v3 >= v2 )
    {
LABEL_8:
      v5 = *(const void **)(this + 16);
      v6 = v2 + 32;
      if ( v5 )
      {
        v8 = GlobalHandle(v5);
        GlobalUnlock(v8);
        v7 = GlobalReAlloc(v8, 8 * v6, 0x2002u);
      }
      else
      {
        v7 = GlobalAlloc(0x2002u, 8 * v6);
      }
      if ( !v7 )
      {
        v9 = GlobalHandle(*(LPCVOID *)(this + 16));
        GlobalLock(v9);
        LeaveCriticalSection(lpCriticalSection);
        sub_41B4F7();
      }
      v10 = (char *)GlobalLock(v7);
      memset(&v10[8 * *(_DWORD *)(this + 4)], 0, 8 * (v6 + 0x1FFFFFFF * *(_DWORD *)(this + 4)));
      *(_DWORD *)(this + 16) = v10;
      *(_DWORD *)(this + 4) = v6;
    }
  }
  if ( v3 >= *(_DWORD *)(this + 12) )
    *(_DWORD *)(this + 12) = v3 + 1;
  *(_DWORD *)(*(_DWORD *)(this + 16) + 8 * v3) |= 1u;
  *(_DWORD *)(this + 8) = v3 + 1;
  LeaveCriticalSection(lpCriticalSection);
  return v3;
}


// ========== Function: ?FreeSlot@CThreadSlotData@@QAEXH@Z @ 0x424B5B ==========
void __thiscall CThreadSlotData::FreeSlot(CThreadSlotData *this, int a2)
{
  _DWORD *i; // esi
  void (__thiscall ***v4)(_DWORD, int); // ecx
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [esp+Ch] [ebp-4h]

  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)((char *)this + 28);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 28));
  for ( i = (_DWORD *)*((_DWORD *)this + 5); i; i = (_DWORD *)i[1] )
  {
    if ( a2 < i[2] )
    {
      v4 = *(void (__thiscall ****)(_DWORD, int))(i[3] + 4 * a2);
      if ( v4 )
        (**v4)(v4, 1);
      *(_DWORD *)(i[3] + 4 * a2) = 0;
    }
  }
  *(_DWORD *)(*((_DWORD *)this + 4) + 8 * a2) &= ~1u;
  LeaveCriticalSection(lpCriticalSection);
}


// ========== Function: sub_424BB8 @ 0x424BB8 ==========
int __thiscall sub_424BB8(int this, int a2, int a3)
{
  _DWORD *Value; // edi
  _DWORD *v5; // ebx
  _DWORD *v6; // eax
  void *v7; // eax
  HLOCAL v8; // eax
  int result; // eax

  Value = TlsGetValue(*(_DWORD *)this);
  if ( Value )
  {
    v5 = Value + 2;
    if ( a2 < Value[2] || !a3 )
      goto LABEL_15;
  }
  else
  {
    v6 = CNoTrackObject::operator new(0x10u);
    if ( v6 )
    {
      *v6 = &CThreadData::`vftable';
      Value = v6;
    }
    else
    {
      Value = 0;
    }
    Value[2] = 0;
    Value[3] = 0;
    v5 = Value + 2;
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
    CSimpleList::AddHead((CSimpleList *)(this + 20), (char *)Value);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
  }
  v7 = (void *)Value[3];
  if ( v7 )
    v8 = LocalReAlloc(v7, 4 * *(_DWORD *)(this + 12), 2u);
  else
    v8 = LocalAlloc(0, 4 * *(_DWORD *)(this + 12));
  Value[3] = v8;
  if ( !v8 )
    sub_41B4F7();
  memset((void *)(Value[3] + 4 * *v5), 0, 4 * (*(_DWORD *)(this + 12) + 0x3FFFFFFF * *v5));
  *v5 = *(_DWORD *)(this + 12);
  TlsSetValue(*(_DWORD *)this, Value);
LABEL_15:
  result = Value[3];
  *(_DWORD *)(result + 4 * a2) = a3;
  return result;
}


// ========== Function: sub_424CA2 @ 0x424CA2 ==========
HLOCAL __thiscall sub_424CA2(HLOCAL hMem, char a2)
{
  nullsub_1();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: nullsub_1 @ 0x424CBD ==========
void nullsub_1()
{
  ;
}


// ========== Function: sub_424CBE @ 0x424CBE ==========
int __thiscall sub_424CBE(int this, int a2, int a3)
{
  int v4; // edi
  int result; // eax
  void (__thiscall ***v6)(_DWORD, int); // ecx
  int v7; // [esp+Ch] [ebp-4h]

  v4 = 1;
  v7 = 1;
  if ( *(int *)(a2 + 8) <= 1 )
    goto LABEL_11;
  do
  {
    if ( !a3 || *(_DWORD *)(*(_DWORD *)(this + 16) + 8 * v4 + 4) == a3 )
    {
      v6 = *(void (__thiscall ****)(_DWORD, int))(*(_DWORD *)(a2 + 12) + 4 * v4);
      if ( v6 )
        (**v6)(v6, 1);
      result = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(result + 4 * v4) = 0;
    }
    else
    {
      result = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(result + 4 * v4) )
        v7 = 0;
    }
    ++v4;
  }
  while ( v4 < *(_DWORD *)(a2 + 8) );
  if ( v7 )
  {
LABEL_11:
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
    sub_424938((int *)(this + 20), a2);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
    LocalFree(*(HLOCAL *)(a2 + 12));
    if ( a2 )
      (**(void (__thiscall ***)(int, int))a2)(a2, 1);
    return TlsSetValue(*(_DWORD *)this, 0);
  }
  return result;
}


// ========== Function: ?DeleteValues@CThreadSlotData@@QAEXPAUHINSTANCE__@@H@Z @ 0x424D57 ==========
void __thiscall CThreadSlotData::DeleteValues(CThreadSlotData *this, HINSTANCE a2, int a3)
{
  struct _RTL_CRITICAL_SECTION *v4; // ebx
  LPVOID Value; // eax
  int v6; // eax
  int v7; // edi

  v4 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 28);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 28));
  if ( a3 )
  {
    v6 = *((_DWORD *)this + 5);
    if ( v6 )
    {
      do
      {
        v7 = *(_DWORD *)(v6 + 4);
        sub_424CBE((int)this, v6, (int)a2);
        v6 = v7;
      }
      while ( v7 );
    }
  }
  else
  {
    Value = TlsGetValue(*(_DWORD *)this);
    if ( Value )
      sub_424CBE((int)this, (int)Value, (int)a2);
  }
  LeaveCriticalSection(v4);
}


// ========== Function: ?GetData@CThreadLocalObject@@QAEPAVCNoTrackObject@@P6GPAV2@XZ@Z @ 0x424DB0 ==========
struct CNoTrackObject *__thiscall CThreadLocalObject::GetData(
        CThreadLocalObject *this,
        struct CNoTrackObject *(__stdcall *a2)())
{
  CThreadSlotData *v3; // ecx
  int v4; // esi
  _DWORD *Value; // eax
  struct CNoTrackObject *v6; // esi

  if ( !*(_DWORD *)this )
  {
    v3 = dword_438F0C;
    if ( !dword_438F0C )
    {
      if ( &unk_438F10 )
        v3 = CThreadSlotData::CThreadSlotData((CThreadSlotData *)&unk_438F10);
      else
        v3 = 0;
      dword_438F0C = v3;
    }
    *(_DWORD *)this = sub_424A49((int)v3);
  }
  v4 = *(_DWORD *)this;
  Value = TlsGetValue(*(_DWORD *)dword_438F0C);
  if ( Value && v4 < Value[2] )
    v6 = *(struct CNoTrackObject **)(Value[3] + 4 * v4);
  else
    v6 = 0;
  if ( !v6 )
  {
    v6 = a2();
    sub_424BB8((int)dword_438F0C, *(_DWORD *)this, (int)v6);
  }
  return v6;
}


// ========== Function: ??1CThreadLocalObject@@QAE@XZ @ 0x424E27 ==========
void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *this)
{
  if ( *(_DWORD *)this && dword_438F0C )
    CThreadSlotData::FreeSlot(dword_438F0C, *(_DWORD *)this);
  *(_DWORD *)this = 0;
}


// ========== Function: sub_424E45 @ 0x424E45 ==========
int __thiscall sub_424E45(void *this, int (*a2)(void))
{
  _DWORD v4[5]; // [esp+0h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-4h]

  v4[4] = v4;
  if ( !*(_DWORD *)this )
  {
    sub_4250E4(16);
    v5 = 0;
    if ( !*(_DWORD *)this )
      *(_DWORD *)this = a2();
    v5 = -1;
    AfxUnlockGlobals(16);
  }
  return *(_DWORD *)this;
}


// ========== Function: ?AfxTermLocalData@@YGXPAUHINSTANCE__@@H@Z @ 0x424EC5 ==========
void __stdcall AfxTermLocalData(HINSTANCE a1, int a2)
{
  if ( dword_438F0C )
    CThreadSlotData::DeleteValues(dword_438F0C, a1, a2);
}


// ========== Function: ?AfxTlsRelease@@YGXXZ @ 0x424EDF ==========
void __stdcall AfxTlsRelease()
{
  if ( !dword_438F08 || (--dword_438F08, !dword_438F08) )
  {
    if ( dword_438F0C )
    {
      CThreadSlotData::~CThreadSlotData(dword_438F0C);
      dword_438F0C = 0;
    }
  }
}


// ========== Function: ?GetAppRegistryKey@CWinApp@@QAEPAUHKEY__@@XZ @ 0x424F07 ==========
HKEY __thiscall CWinApp::GetAppRegistryKey(LPCSTR *this)
{
  DWORD dwDisposition; // [esp+10h] [ebp-10h] BYREF
  HKEY v5; // [esp+14h] [ebp-Ch] BYREF
  HKEY hKey; // [esp+18h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+1Ch] [ebp-4h] BYREF

  v5 = 0;
  phkResult = 0;
  hKey = 0;
  if ( !RegOpenKeyExA(HKEY_CURRENT_USER, "software", 0, 0x2001Fu, &phkResult)
    && !RegCreateKeyExA(phkResult, this[31], 0, 0, 0, 0x2001Fu, 0, &hKey, &dwDisposition) )
  {
    RegCreateKeyExA(hKey, this[36], 0, 0, 0, 0x2001Fu, 0, &v5, &dwDisposition);
  }
  if ( phkResult )
    RegCloseKey(phkResult);
  if ( hKey )
    RegCloseKey(hKey);
  return v5;
}


// ========== Function: ?GetSectionKey@CWinApp@@QAEPAUHKEY__@@PBD@Z @ 0x424F9B ==========
HKEY __thiscall CWinApp::GetSectionKey(LPCSTR *this, const char *lpSubKey)
{
  HKEY AppRegistryKey; // edi
  DWORD dwDisposition; // [esp+8h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+Ch] [ebp-4h] BYREF

  phkResult = 0;
  AppRegistryKey = CWinApp::GetAppRegistryKey(this);
  if ( !AppRegistryKey )
    return 0;
  RegCreateKeyExA(AppRegistryKey, lpSubKey, 0, 0, 0, 0x2001Fu, 0, &phkResult, &dwDisposition);
  RegCloseKey(AppRegistryKey);
  return phkResult;
}


// ========== Function: sub_424FE1 @ 0x424FE1 ==========
char **sub_424FE1()
{
  return &off_42AE40;
}


// ========== Function: sub_424FE7 @ 0x424FE7 ==========
int sub_424FE7()
{
  unknown_libname_33();
  return atexit(sub_42500F);
}


// ========== Function: unknown_libname_33 @ 0x424FF1 ==========
// MFC 3.1-14.0 32bit
CException *unknown_libname_33()
{
  return sub_4069DC((CException *)&dword_438FE0, 0, 61475);
}


// ========== Function: sub_42500F @ 0x42500F ==========
void __cdecl sub_42500F()
{
  sub_406A22(dword_438FE0);
}


// ========== Function: sub_425019 @ 0x425019 ==========
char **sub_425019()
{
  return &off_42AE10;
}


// ========== Function: sub_42501F @ 0x42501F ==========
int sub_42501F()
{
  unknown_libname_34();
  return atexit(sub_425047);
}


// ========== Function: unknown_libname_34 @ 0x425029 ==========
// MFC 3.1-14.0 32bit
CException *unknown_libname_34()
{
  return sub_406A29((CException *)&dword_438F48, 0, 61473);
}


// ========== Function: sub_425047 @ 0x425047 ==========
void __cdecl sub_425047()
{
  sub_406A6F(dword_438F48);
}


// ========== Function: sub_425051 @ 0x425051 ==========
int sub_425051()
{
  signed int Version; // eax

  if ( !dword_439274 )
  {
    dword_439274 = 1;
    Version = GetVersion();
    if ( (unsigned __int8)Version >= 4u || Version >= 0 )
    {
      dword_439270 = 0;
      InitializeCriticalSection(&CriticalSection);
    }
    else
    {
      dword_439270 = 1;
    }
  }
  return dword_439274;
}


// ========== Function: sub_425096 @ 0x425096 ==========
void sub_425096()
{
  int *v0; // esi
  struct _RTL_CRITICAL_SECTION *v1; // ebx

  if ( dword_439274 )
  {
    --dword_439274;
    if ( !dword_439270 )
    {
      DeleteCriticalSection(&CriticalSection);
      v0 = &dword_439078;
      v1 = &stru_4390D8;
      do
      {
        if ( *v0 )
        {
          DeleteCriticalSection(v1);
          --*v0;
        }
        ++v1;
        ++v0;
      }
      while ( (int)v1 < (int)&dword_439270 );
    }
  }
}


// ========== Function: sub_4250E4 @ 0x4250E4 ==========
void __stdcall sub_4250E4(int a1)
{
  if ( !dword_439274 )
    sub_425051();
  if ( !dword_439270 )
  {
    if ( !dword_439078[a1] )
    {
      EnterCriticalSection(&CriticalSection);
      if ( !dword_439078[a1] )
      {
        InitializeCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4427992));
        ++dword_439078[a1];
      }
      LeaveCriticalSection(&CriticalSection);
    }
    EnterCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4427992));
  }
}


// ========== Function: ?AfxUnlockGlobals@@YGXH@Z @ 0x425154 ==========
void __stdcall AfxUnlockGlobals(int a1)
{
  if ( !dword_439270 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4427992));
}


// ========== Function: sub_425175 @ 0x425175 ==========
int sub_425175()
{
  sub_42517F();
  return atexit(sub_425195);
}


// ========== Function: sub_42517F @ 0x42517F ==========
AUX_DATA *sub_42517F()
{
  return AUX_DATA::AUX_DATA((AUX_DATA *)&dword_439278);
}


// ========== Function: sub_425195 @ 0x425195 ==========
void __cdecl sub_425195()
{
  AfxDeleteObject((void **)&dword_439278 + 20);
}


// ========== Function: ?AfxEnableWin40Compatibility@@YGXXZ @ 0x42519F ==========
void __stdcall AfxEnableWin40Compatibility()
{
  int SystemMetrics; // eax

  if ( dword_4392D4 )
  {
    dword_439278 = GetSystemMetrics(2) + 1;
    SystemMetrics = GetSystemMetrics(3);
    dword_4392E0 = 1;
    dword_43927C = SystemMetrics + 1;
  }
}


// ========== Function: ?AfxEnableWin31Compatibility@@YGXXZ @ 0x4251CF ==========
void __stdcall AfxEnableWin31Compatibility()
{
  int SystemMetrics; // eax

  dword_439278 = GetSystemMetrics(2);
  SystemMetrics = GetSystemMetrics(3);
  dword_4392E0 = 0;
  dword_43927C = SystemMetrics;
}


// ========== Function: ??0AUX_DATA@@QAE@XZ @ 0x4251F1 ==========
AUX_DATA *__thiscall AUX_DATA::AUX_DATA(AUX_DATA *this)
{
  DWORD Version; // eax
  BOOL v3; // eax
  bool v4; // zf
  int v5; // eax

  Version = GetVersion();
  *((_DWORD *)this + 21) = ((unsigned __int8)Version << 8) + BYTE1(Version);
  *((_DWORD *)this + 22) = Version >> 31;
  v3 = (unsigned __int8)Version >= 4u;
  *((_DWORD *)this + 23) = v3;
  *((_DWORD *)this + 24) = 1 - v3;
  *((_DWORD *)this + 25) = v3;
  *((_DWORD *)this + 26) = 0;
  if ( v3 )
    *((_DWORD *)this + 26) = GetProcessVersion(0) >= 0x40000;
  AUX_DATA::UpdateSysMetrics(this);
  *((_DWORD *)this + 9) = 0;
  AUX_DATA::UpdateSysColors(this);
  *((_DWORD *)this + 15) = LoadCursorA(0, (LPCSTR)0x7F02);
  *((_DWORD *)this + 16) = LoadCursorA(0, (LPCSTR)0x7F00);
  v4 = *((_DWORD *)this + 23) == 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 17) = 0;
  v5 = !v4 + 1;
  *((_DWORD *)this + 4) = v5;
  *((_DWORD *)this + 5) = v5;
  return this;
}


// ========== Function: sub_42528C @ 0x42528C ==========
int (__stdcall *__thiscall sub_42528C(_DWORD *this))(_DWORD)
{
  int (__stdcall *result)(_DWORD); // eax
  HMODULE v3; // esi

  *this = &_AFX_CTL3D_STATE::`vftable';
  result = (int (__stdcall *)(_DWORD))this[4];
  if ( result )
    result = (int (__stdcall *)(_DWORD))result(0);
  v3 = (HMODULE)this[2];
  if ( v3 )
    return (int (__stdcall *)(_DWORD))FreeLibrary(v3);
  return result;
}


// ========== Function: sub_4252CD @ 0x4252CD ==========
int (__cdecl *__thiscall sub_4252CD(_DWORD *this))(_DWORD *)
{
  int (__cdecl *result)(_DWORD *); // eax

  *this = &_AFX_CTL3D_THREAD::`vftable';
  result = (int (__cdecl *)(_DWORD *))dword_4392E8;
  if ( dword_4392E8 )
  {
    result = *(int (__cdecl **)(_DWORD *))(dword_4392E8 + 24);
    if ( result )
      return (int (__cdecl *)(_DWORD *))result(this);
  }
  return result;
}


// ========== Function: sub_425303 @ 0x425303 ==========
int sub_425303()
{
  return sub_424E45(&dword_4392E8, (int (*)(void))CProcessLocal<_AFX_CTL3D_STATE>::CreateObject);
}


// ========== Function: sub_425313 @ 0x425313 ==========
int sub_425313()
{
  nullsub_20();
  return atexit(sub_42532A);
}


// ========== Function: nullsub_20 @ 0x42531D ==========
void nullsub_20()
{
  ;
}


// ========== Function: sub_42532A @ 0x42532A ==========
void __cdecl sub_42532A()
{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&unk_4392E4);
}


// ========== Function: j_??1CThreadLocalObject@@QAE@XZ @ 0x425334 ==========
// attributes: thunk
void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *this)
{
  ??1CThreadLocalObject@@QAE@XZ(this);
}


// ========== Function: sub_425339 @ 0x425339 ==========
int sub_425339()
{
  nullsub_21();
  return atexit(sub_425350);
}


// ========== Function: nullsub_21 @ 0x425343 ==========
void nullsub_21()
{
  ;
}


// ========== Function: sub_425350 @ 0x425350 ==========
void __stdcall sub_425350(int a1)
{
  sub_424653(a1);
}


// ========== Function: sub_42535A @ 0x42535A ==========
char **sub_42535A()
{
  return &off_42AED8;
}


// ========== Function: ?AfxInitDBCS@@YGHXZ @ 0x425360 ==========
BOOL __stdcall AfxInitDBCS()
{
  UINT OEMCP; // eax
  struct _cpinfo CPInfo; // [esp+0h] [ebp-14h] BYREF

  OEMCP = GetOEMCP();
  GetCPInfo(OEMCP, &CPInfo);
  return CPInfo.MaxCharSize > 1;
}


// ========== Function: sub_425383 @ 0x425383 ==========
// attributes: thunk
int sub_425383()
{
  return sub_425388();
}


// ========== Function: sub_425388 @ 0x425388 ==========
BOOL sub_425388()
{
  BOOL result; // eax

  result = AfxInitDBCS();
  dword_4392EC = result;
  return result;
}


// ========== Function: sub_4253AD @ 0x4253AD ==========
char **sub_4253AD()
{
  return &off_42AF38;
}


// ========== Function: sub_4253CF @ 0x4253CF ==========
_DWORD *__thiscall sub_4253CF(_DWORD *this, char a2)
{
  sub_4253EF();
  if ( (a2 & 1) != 0 )
    sub_406C12((int)&byte_4392F8, this);
  return this;
}


// ========== Function: sub_4253EF @ 0x4253EF ==========
BOOL __thiscall sub_4253EF(unsigned int *this)
{
  *this = (unsigned int)&CMenu::`vftable';
  return sub_4214DA(this);
}


// ========== Function: sub_425418 @ 0x425418 ==========
char **sub_425418()
{
  return &off_42AF10;
}


// ========== Function: sub_42541E @ 0x42541E ==========
int sub_42541E()
{
  sub_425428();
  return atexit(unknown_libname_35);
}


// ========== Function: sub_425428 @ 0x425428 ==========
char *sub_425428()
{
  return sub_406B1F(byte_4392F8, 8, 64);
}


// ========== Function: unknown_libname_35 @ 0x425443 ==========
// MFC 3.1-14.0 32bit
void __cdecl unknown_libname_35()
{
  if ( (byte_4392F0 & 1) == 0 )
  {
    byte_4392F0 |= 1u;
    sub_406B5B((int)byte_4392F8);
    DeleteCriticalSection((LPCRITICAL_SECTION)&byte_4392F8[16]);
  }
}


// ========== Function: sub_42545E @ 0x42545E ==========
char **sub_42545E()
{
  return &off_42B270;
}


// ========== Function: sub_425464 @ 0x425464 ==========
char **sub_425464()
{
  return &off_42B300;
}


// ========== Function: sub_42546A @ 0x42546A ==========
char **sub_42546A()
{
  return &off_42B338;
}


// ========== Function: sub_425470 @ 0x425470 ==========
char **sub_425470()
{
  return &off_42B4B8;
}


// ========== Function: sub_425476 @ 0x425476 ==========
char **sub_425476()
{
  return &off_42B530;
}


// ========== Function: sub_42547C @ 0x42547C ==========
// ?AfxWinInit@@YGHPAUHINSTANCE__@@0PAGH@Z
// doubtful name
int __stdcall sub_42547C(int a1, int a2, int a3, int a4)
{
  UINT v4; // eax
  struct AFX_MODULE_STATE *ModuleState; // eax
  CWinApp *v6; // eax

  v4 = SetErrorMode(0);
  LOWORD(v4) = v4 | 0x8001;
  SetErrorMode(v4);
  ModuleState = AfxGetModuleState();
  *((_DWORD *)ModuleState + 2) = a1;
  *((_DWORD *)ModuleState + 3) = a1;
  v6 = (CWinApp *)*((_DWORD *)AfxGetModuleState() + 1);
  if ( v6 )
  {
    *((_DWORD *)v6 + 26) = a1;
    *((_DWORD *)v6 + 27) = a2;
    *((_DWORD *)v6 + 28) = a3;
    *((_DWORD *)v6 + 29) = a4;
    CWinApp::SetCurrentHandles(v6);
  }
  if ( !*((_BYTE *)AfxGetModuleState() + 20) )
    AfxInitThread();
  return 1;
}


// ========== Function: ?SetCurrentHandles@CWinApp@@QAEXXZ @ 0x4254DF ==========
void __thiscall CWinApp::SetCurrentHandles(CWinApp *this)
{
  struct AFX_MODULE_STATE *ModuleState; // edi
  CHAR *v3; // eax
  char *v4; // eax
  LPSTR v5; // ebx
  CHAR Buffer[256]; // [esp+Ch] [ebp-30Ch] BYREF
  CHAR Filename[260]; // [esp+10Ch] [ebp-20Ch] BYREF
  CHAR String1[260]; // [esp+210h] [ebp-108h] BYREF
  LPSTR lpString1; // [esp+314h] [ebp-4h]

  ModuleState = AfxGetModuleState();
  *((_DWORD *)ModuleState + 2) = *((_DWORD *)this + 26);
  *((_DWORD *)ModuleState + 3) = *((_DWORD *)this + 26);
  GetModuleFileNameA(*((HMODULE *)this + 26), Filename, 0x104u);
  v3 = (CHAR *)_mbsrchr((const unsigned __int8 *)Filename, 0x2Eu);
  *v3 = 0;
  lpString1 = v3;
  AfxGetFileName(Filename, String1, 0x104u);
  if ( !*((_DWORD *)this + 34) )
    *((_DWORD *)this + 34) = _strdup(String1);
  if ( !*((_DWORD *)this + 30) )
  {
    if ( AfxLoadString(0xE000u, Buffer, 0x100u) )
      v4 = _strdup(Buffer);
    else
      v4 = _strdup(*((const char **)this + 34));
    *((_DWORD *)this + 30) = v4;
  }
  *((_DWORD *)ModuleState + 4) = *((_DWORD *)this + 30);
  if ( !*((_DWORD *)this + 35) )
  {
    v5 = lpString1;
    lstrcpyA(lpString1, ".HLP");
    *((_DWORD *)this + 35) = _strdup(Filename);
    *v5 = 0;
  }
  if ( !*((_DWORD *)this + 36) )
  {
    lstrcatA(String1, ".INI");
    *((_DWORD *)this + 36) = _strdup(String1);
  }
}


// ========== Function: ?AfxGetFileName@@YGIPBDPADI@Z @ 0x4255FC ==========
int __stdcall AfxGetFileName(unsigned __int8 *lpString, LPSTR lpString1, unsigned int iMaxLength)
{
  unsigned __int8 *v3; // esi
  const CHAR *v4; // edi
  unsigned __int8 v5; // al

  v3 = lpString;
  v4 = (const CHAR *)lpString;
  while ( *v3 )
  {
    v5 = *v3;
    if ( *v3 == 92 || v5 == 47 || v5 == 58 )
      v4 = (const CHAR *)_mbsinc(v3);
    v3 = _mbsinc(v3);
  }
  if ( !lpString1 )
    return lstrlenA(v4) + 1;
  lstrcpynA(lpString1, v4, iMaxLength);
  return 0;
}


// ========== Function: sub_425652 @ 0x425652 ==========
// attributes: thunk
int sub_425652()
{
  return sub_425657();
}


// ========== Function: sub_425657 @ 0x425657 ==========
OLE_DATA *sub_425657()
{
  return OLE_DATA::OLE_DATA((OLE_DATA *)&unk_439370);
}


// ========== Function: ??0OLE_DATA@@QAE@XZ @ 0x425661 ==========
OLE_DATA *__thiscall OLE_DATA::OLE_DATA(OLE_DATA *this)
{
  *(_DWORD *)this = RegisterClipboardFormatA("Native");
  *((_DWORD *)this + 1) = RegisterClipboardFormatA("OwnerLink");
  *((_DWORD *)this + 2) = RegisterClipboardFormatA("ObjectLink");
  *((_DWORD *)this + 3) = RegisterClipboardFormatA("Embedded Object");
  *((_DWORD *)this + 4) = RegisterClipboardFormatA("Embed Source");
  *((_DWORD *)this + 5) = RegisterClipboardFormatA("Link Source");
  *((_DWORD *)this + 6) = RegisterClipboardFormatA("Object Descriptor");
  *((_DWORD *)this + 7) = RegisterClipboardFormatA("Link Source Descriptor");
  *((_DWORD *)this + 8) = RegisterClipboardFormatA("FileName");
  *((_DWORD *)this + 9) = RegisterClipboardFormatA("FileNameW");
  *((_DWORD *)this + 10) = RegisterClipboardFormatA("Rich Text Format");
  *((_DWORD *)this + 11) = RegisterClipboardFormatA("RichEdit Text and Objects");
  return this;
}


// ========== Function: ?AfxOleInit@@YGHXZ @ 0x4256E7 ==========
int __stdcall AfxOleInit()
{
  struct _AFX_THREAD_STATE *ThreadState; // esi
  struct CWinThread *Thread; // esi
  bool v3; // zf
  COleMessageFilter *v4; // ecx
  COleMessageFilter *v5; // eax
  struct CWinThread *v6; // eax

  ThreadState = AfxGetThreadState();
  if ( *((_BYTE *)AfxGetModuleState() + 20) )
  {
    *((_DWORD *)ThreadState + 69) = -1;
  }
  else
  {
    if ( OleInitialize(0) < 0 )
    {
      AfxOleTerm(0);
      return 0;
    }
    *((_DWORD *)ThreadState + 69) = 1;
    Thread = AfxGetThread();
    v3 = *((_DWORD *)Thread + 22) == 0;
    *((_DWORD *)Thread + 21) = sub_4257DF;
    if ( v3 )
    {
      v4 = (COleMessageFilter *)sub_41CA70(0x40u);
      if ( v4 )
        v5 = COleMessageFilter::COleMessageFilter(v4);
      else
        v5 = 0;
      *((_DWORD *)Thread + 22) = v5;
      v6 = AfxGetThread();
      COleMessageFilter::Register(*((COleMessageFilter **)v6 + 22));
    }
  }
  return 1;
}


// ========== Function: ?AfxOleTerm@@YGXH@Z @ 0x425784 ==========
void __stdcall AfxOleTerm(int a1)
{
  struct CWinThread *Thread; // eax
  struct CWinThread *v2; // esi
  int v3; // ecx
  _DWORD *v4; // esi

  COleDataSource::FlushClipboard();
  COleObjectFactory::RevokeAll();
  AfxOleUnlockAllControls();
  if ( !a1 )
  {
    Thread = AfxGetThread();
    v2 = Thread;
    if ( Thread )
    {
      v3 = *((_DWORD *)Thread + 22);
      if ( v3 )
        (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 4))(v3, 1);
      *((_DWORD *)v2 + 22) = 0;
    }
    v4 = (_DWORD *)((char *)AfxGetThreadState() + 276);
    if ( *v4 == 1 )
    {
      CoFreeUnusedLibraries();
      OleUninitialize();
      *v4 = 0;
    }
  }
}


// ========== Function: sub_4257DF @ 0x4257DF ==========
void __stdcall sub_4257DF(int a1, int a2)
{
  DWORD TickCount; // eax

  if ( a1 )
  {
    AfxOleTerm(a2);
  }
  else
  {
    if ( !dword_439368 )
    {
      TickCount = GetTickCount();
      ++dword_439368;
      dword_433F8C = TickCount;
    }
    if ( GetTickCount() - dword_433F8C > 0xEA60 )
    {
      CoFreeUnusedLibraries();
      dword_433F8C = GetTickCount();
    }
  }
}


// ========== Function: ?AfxBSTR2CString@@YGXPAVCString@@PAG@Z @ 0x42582E ==========
void __stdcall AfxBSTR2CString(struct CString *a1, BSTR pbstr)
{
  UINT v3; // ebp
  CHAR *BufferSetLength; // eax
  BSTR pbstra; // [esp+18h] [ebp+8h]

  v3 = SysStringLen(pbstr);
  pbstra = (BSTR)WideCharToMultiByte(0, 0, pbstr, v3, 0, 0, 0, 0);
  BufferSetLength = CString::GetBufferSetLength(a1, (int)pbstra);
  WideCharToMultiByte(0, 0, pbstr, v3, BufferSetLength, (int)pbstra, 0, 0);
}


// ========== Function: ?AfxBSTR2ABSTR@@YGPAGPAG@Z @ 0x425873 ==========
CHAR *__stdcall AfxBSTR2ABSTR(BSTR pbstr)
{
  UINT v2; // ebp
  CHAR *v4; // [esp+10h] [ebp-4h]
  BSTR pbstra; // [esp+18h] [ebp+4h]

  v2 = SysStringLen(pbstr);
  pbstra = (BSTR)WideCharToMultiByte(0, 0, pbstr, v2, 0, 0, 0, 0);
  v4 = (CHAR *)SysAllocStringByteLen(0, (UINT)pbstra);
  WideCharToMultiByte(0, 0, pbstr, v2, v4, (int)pbstra, 0, 0);
  return v4;
}


// ========== Function: sub_4258C0 @ 0x4258C0 ==========
char **sub_4258C0()
{
  return &off_42B740;
}


// ========== Function: ??0COleMessageFilter@@QAE@XZ @ 0x4258C6 ==========
COleMessageFilter *__thiscall COleMessageFilter::COleMessageFilter(COleMessageFilter *this)
{
  sub_41C5A3(this);
  *((_DWORD *)this + 15) = &COleMessageFilter::XMessageFilter::`vftable';
  *((_DWORD *)this + 9) = 1;
  *((_DWORD *)this + 10) = 1;
  *(_DWORD *)this = &COleMessageFilter::`vftable';
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 13) = 2;
  *((_DWORD *)this + 12) = 10000;
  *((_DWORD *)this + 14) = 8000;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 7) = 0;
  return this;
}


// ========== Function: sub_425908 @ 0x425908 ==========
LPVOID __thiscall sub_425908(LPVOID lpMem, char a2)
{
  sub_42738F();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ?Register@COleMessageFilter@@QAEHXZ @ 0x425924 ==========
int __thiscall COleMessageFilter::Register(IMessageFilter *this)
{
  int result; // eax

  if ( CoRegisterMessageFilter(this + 15, 0) )
    return 0;
  result = 1;
  this[7].lpVtbl = (struct IMessageFilterVtbl *)1;
  return result;
}


// ========== Function: sub_425943 @ 0x425943 ==========
char **sub_425943()
{
  return &off_42B860;
}


// ========== Function: sub_425949 @ 0x425949 ==========
_DWORD *__thiscall sub_425949(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_42BD14;
  return result;
}


// ========== Function: sub_425952 @ 0x425952 ==========
HLOCAL __thiscall sub_425952(HLOCAL hMem, char a2)
{
  sub_42596D();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}


// ========== Function: sub_42596D @ 0x42596D ==========
void __thiscall sub_42596D(_DWORD *this)
{
  *this = &off_42BD14;
}


// ========== Function: sub_425974 @ 0x425974 ==========
int sub_425974()
{
  nullsub_22();
  return atexit(sub_42598B);
}


// ========== Function: nullsub_22 @ 0x42597E ==========
void nullsub_22()
{
  ;
}


// ========== Function: sub_42598B @ 0x42598B ==========
void __stdcall sub_42598B(int a1)
{
  sub_424653(a1);
}


// ========== Function: ?_AfxRelease@@YGKPAPAUIUnknown@@@Z @ 0x425995 ==========
ULONG __stdcall _AfxRelease(struct IUnknown **a1)
{
  ULONG result; // eax

  if ( !*a1 )
    return 0;
  result = (*a1)->lpVtbl->Release(*a1);
  *a1 = 0;
  return result;
}


// ========== Function: ?ExternalAddRef@CCmdTarget@@QAEKXZ @ 0x4259B1 ==========
LONG __thiscall CCmdTarget::ExternalAddRef(CCmdTarget *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 2);
  if ( v1 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)v1 + 4))(v1);
  else
    return InterlockedIncrement((volatile LONG *)this + 1);
}


// ========== Function: sub_4259CA @ 0x4259CA ==========
LONG __thiscall sub_4259CA(volatile LONG *this)
{
  LONG v3; // edi

  if ( !*((_DWORD *)this + 1) )
    return 0;
  v3 = InterlockedDecrement(this + 1);
  if ( !v3 )
    (*(void (__thiscall **)(volatile LONG *))(*this + 16))(this);
  return v3;
}


// ========== Function: ?ExternalRelease@CCmdTarget@@QAEKXZ @ 0x4259F4 ==========
LONG __thiscall CCmdTarget::ExternalRelease(CCmdTarget *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 2);
  if ( v1 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)v1 + 8))(v1);
  else
    return sub_4259CA((volatile LONG *)this);
}


// ========== Function: sub_425A07 @ 0x425A07 ==========
char *__thiscall sub_425A07(char *this, _DWORD *a2)
{
  char *result; // eax
  _DWORD *v4; // edi
  _DWORD *j; // ecx
  int i; // edx
  _DWORD *v7; // ecx

  result = (char *)(*(int (__thiscall **)(char *, _DWORD *))(*(_DWORD *)this + 68))(this, a2);
  if ( !result )
  {
    v4 = (_DWORD *)(*(int (__thiscall **)(char *))(*(_DWORD *)this + 56))(this);
    if ( *a2 || a2[1] || a2[2] != 192 || a2[3] != 1174405120 )
    {
      do
      {
        for ( i = v4[1]; ; i += 8 )
        {
          v7 = *(_DWORD **)i;
          if ( !*(_DWORD *)i )
            break;
          if ( *v7 == *a2 && v7[1] == a2[1] && v7[2] == a2[2] && v7[3] == a2[3] )
          {
            result = &this[*(_DWORD *)(i + 4)];
            if ( *(_DWORD *)result )
              return result;
          }
        }
        v4 = (_DWORD *)*v4;
      }
      while ( v4 );
    }
    else
    {
      do
      {
        for ( j = (_DWORD *)v4[1]; *j; j += 2 )
        {
          result = &this[j[1]];
          if ( *(_DWORD *)result )
            return result;
        }
        v4 = (_DWORD *)*v4;
      }
      while ( v4 );
    }
    return 0;
  }
  return result;
}


// ========== Function: sub_425AB5 @ 0x425AB5 ==========
int __thiscall sub_425AB5(char *this, int a2)
{
  _DWORD *v2; // edi
  _DWORD *i; // eax
  _DWORD *j; // esi
  int (__stdcall ***v5)(_DWORD, int, int *); // eax
  int (__stdcall **v6)(_DWORD, int, int *); // ecx
  int result; // eax
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v2 = (_DWORD *)(*(int (__fastcall **)(char *))(*(_DWORD *)this + 56))(this);
  do
  {
    for ( i = (_DWORD *)v2[1]; *i; i += 2 )
      ;
    for ( j = i + 1; *j != -1; j += 2 )
    {
      v5 = *(int (__stdcall ****)(_DWORD, int, int *))&this[*j];
      if ( v5 )
      {
        v6 = *v5;
        v9 = 0;
        if ( !(*v6)(v5, a2, &v9) )
        {
          result = v9;
          if ( v9 )
            return result;
        }
      }
    }
    v2 = (_DWORD *)*v2;
  }
  while ( v2 );
  return 0;
}


// ========== Function: ?InternalQueryInterface@CCmdTarget@@QAEKPBXPAPAX@Z @ 0x425B15 ==========
int __thiscall CCmdTarget::InternalQueryInterface(CCmdTarget *this, _DWORD *a2, void **a3)
{
  char *v4; // eax
  void *v6; // eax

  v4 = sub_425A07((char *)this, a2);
  *a3 = v4;
  if ( v4 )
  {
    CCmdTarget::ExternalAddRef(this);
    return 0;
  }
  else
  {
    v6 = (void *)sub_425AB5((char *)this, (int)a2);
    *a3 = v6;
    return v6 != 0 ? 0 : -2147467262;
  }
}


// ========== Function: ?ExternalQueryInterface@CCmdTarget@@QAEKPBXPAPAX@Z @ 0x425B57 ==========
int __thiscall CCmdTarget::ExternalQueryInterface(CCmdTarget *this, _DWORD *a2, void **a3)
{
  int (__stdcall ***v3)(_DWORD, _DWORD *, void **); // eax

  v3 = (int (__stdcall ***)(_DWORD, _DWORD *, void **))*((_DWORD *)this + 2);
  if ( v3 )
    return (**v3)(v3, a2, a3);
  else
    return CCmdTarget::InternalQueryInterface(this, a2, a3);
}


// ========== Function: ?AfxThrowOleException@@YGXJ@Z @ 0x425B7D ==========
void __stdcall __noreturn AfxThrowOleException(CException *lpString1, int iMaxLength, int Buffer)
{
  CException *v3; // eax
  CException *v4; // esi

  v3 = (CException *)sub_41CA70(0xCu);
  v4 = v3;
  if ( v3 )
  {
    CException::CException(v3);
    *((_DWORD *)v4 + 2) = 0;
    *(_DWORD *)v4 = &COleException::`vftable';
  }
  else
  {
    v4 = 0;
  }
  *((_DWORD *)v4 + 2) = lpString1;
  lpString1 = v4;
  _CxxThrowException(&lpString1, (_ThrowInfo *)&_TI4PAVCOleException__);
}


// ========== Function: ?AfxOleHookProc@@YGIPAUHWND__@@IIJ@Z @ 0x425C25 ==========
INT_PTR __stdcall AfxOleHookProc(HWND hWnd, unsigned int a2, WPARAM a3, LPARAM a4)
{
  if ( a2 == 272 )
    return DialogFunc(hWnd, 0x110u, a3, a4);
  if ( a2 != 273 || (_WORD)a3 != 99 )
    return 0;
  SendMessageA(hWnd, 0x111u, 0xE146u, 0);
  return 1;
}


// ========== Function: sub_425C70 @ 0x425C70 ==========
CDialog *__thiscall sub_425C70(CDialog *this, struct CWnd *a2)
{
  CDialog::CDialog(this, 0, a2);
  *((_DWORD *)this + 23) = -1;
  return this;
}


// ========== Function: ?MapResult@COleDialog@@QAEHI@Z @ 0x425C88 ==========
int __thiscall COleDialog::MapResult(COleDialog *this, unsigned int a2)
{
  int result; // eax

  result = a2;
  *((_DWORD *)this + 23) = a2;
  if ( a2 != 1 )
    return a2 != 2 ? -1 : 2;
  return result;
}


// ========== Function: ??0COleBusyDialog@@QAE@PAUHTASK__@@HKPAVCWnd@@@Z @ 0x425CA6 ==========
COleBusyDialog *__thiscall COleBusyDialog::COleBusyDialog(
        COleBusyDialog *this,
        HTASK a2,
        int a3,
        unsigned int a4,
        struct CWnd *a5)
{
  unsigned int v6; // eax

  sub_425C70(this, a5);
  *(_DWORD *)this = &COleBusyDialog::`vftable';
  memset((char *)this + 96, 0, 0x2Cu);
  v6 = a4;
  *((_DWORD *)this + 24) = 44;
  *((_DWORD *)this + 25) = a4;
  if ( a3 )
  {
    LOBYTE(v6) = a4 | 8;
    *((_DWORD *)this + 25) = v6;
  }
  *((_DWORD *)this + 28) = AfxOleHookProc;
  *((_DWORD *)this + 33) = a2;
  return this;
}


// ========== Function: sub_425CFA @ 0x425CFA ==========
LPVOID __thiscall sub_425CFA(LPVOID lpMem, char a2)
{
  sub_425D16();
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_425D16 @ 0x425D16 ==========
void __thiscall sub_425D16(CWnd *this)
{
  *(_DWORD *)this = &COleBusyDialog::`vftable';
  sub_41CC1E(this);
}


// ========== Function: sub_425D21 @ 0x425D21 ==========
int __thiscall sub_425D21(struct CWnd *this)
{
  HWND v2; // eax
  UINT v3; // edi
  int result; // eax
  HWND hWnd; // [esp+8h] [ebp-4h] BYREF

  v2 = (HWND)*((_DWORD *)this + 20);
  if ( v2 )
    v2 = (HWND)*((_DWORD *)v2 + 7);
  *((_DWORD *)this + 26) = sub_4232B3(v2, &hWnd);
  AfxHookWindowCreate(this);
  v3 = OleUIBusyA((LPOLEUIBUSYA)((char *)this + 96));
  AfxUnhookWindowCreate();
  sub_41D8E4((unsigned int *)this);
  if ( hWnd )
    EnableWindow(hWnd, 1);
  result = 2;
  if ( v3 != 2 )
  {
    if ( v3 == 117 )
    {
      *((_DWORD *)this + 35) = 1;
      return 1;
    }
    if ( v3 != 118 )
    {
      if ( v3 == 119 )
      {
        *((_DWORD *)this + 35) = 3;
        return 1;
      }
      result = COleDialog::MapResult(this, v3);
    }
    *((_DWORD *)this + 35) = result;
    return 1;
  }
  return result;
}


// ========== Function: ??0CEnumArray@@QAE@IPBXIH@Z @ 0x425DB1 ==========
CEnumArray *__thiscall CEnumArray::CEnumArray(
        CEnumArray *this,
        unsigned int a2,
        const void *a3,
        unsigned int a4,
        int a5)
{
  sub_41C5A3(this);
  *((_DWORD *)this + 13) = &CEnumArray::XEnumVOID::`vftable';
  *((_DWORD *)this + 7) = a2;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = a4;
  *((_DWORD *)this + 9) = a3;
  *((_DWORD *)this + 12) = a5;
  *(_DWORD *)this = &CEnumArray::`vftable';
  return this;
}


// ========== Function: sub_425DF0 @ 0x425DF0 ==========
CEnumArray *__thiscall sub_425DF0(CEnumArray *lpMem, char a2)
{
  CEnumArray::~CEnumArray(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: ??1CEnumArray@@UAE@XZ @ 0x425E0C ==========
void __thiscall CEnumArray::~CEnumArray(CEnumArray *this)
{
  volatile LONG *v2; // ecx

  *(_DWORD *)this = &CEnumArray::`vftable';
  v2 = (volatile LONG *)*((_DWORD *)this + 8);
  if ( v2 )
    sub_4259CA(v2);
  if ( *((_DWORD *)this + 12) )
    sub_41CA99(*((LPVOID *)this + 9));
  sub_41C5BD(this);
}


// ========== Function: ?OnNext@CEnumArray@@MAEHPAX@Z @ 0x425E5A ==========
int __thiscall CEnumArray::OnNext(CEnumArray *this, void *a2)
{
  unsigned int v3; // ecx

  v3 = *((_DWORD *)this + 10);
  if ( v3 >= *((_DWORD *)this + 11) )
    return 0;
  memcpy(a2, (const void *)(*((_DWORD *)this + 9) + v3 * *((_DWORD *)this + 7)), *((_DWORD *)this + 7));
  ++*((_DWORD *)this + 10);
  return 1;
}


// ========== Function: ?OnSkip@CEnumArray@@MAEHXZ @ 0x425E8A ==========
BOOL __thiscall CEnumArray::OnSkip(CEnumArray *this)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  unsigned int v4; // eax

  v1 = *((_DWORD *)this + 10);
  v2 = *((_DWORD *)this + 11);
  if ( v1 >= v2 )
    return 0;
  v4 = v1 + 1;
  *((_DWORD *)this + 10) = v4;
  return v4 < v2;
}


// ========== Function: ?OnReset@CEnumArray@@MAEXXZ @ 0x425EA2 ==========
void __thiscall CEnumArray::OnReset(CEnumArray *this)
{
  *((_DWORD *)this + 10) = 0;
}


// ========== Function: ?OnClone@CEnumArray@@MAEPAV1@XZ @ 0x425EA7 ==========
struct CEnumArray *__thiscall CEnumArray::OnClone(CEnumArray *this)
{
  CEnumArray *v2; // ecx
  struct CEnumArray *result; // eax

  v2 = (CEnumArray *)sub_41CA70(0x38u);
  result = 0;
  if ( v2 )
    result = CEnumArray::CEnumArray(v2, *((_DWORD *)this + 7), *((const void **)this + 9), *((_DWORD *)this + 11), 0);
  *((_DWORD *)result + 10) = *((_DWORD *)this + 10);
  return result;
}


// ========== Function: sub_425EED @ 0x425EED ==========
LONG __stdcall sub_425EED(int a1)
{
  return CCmdTarget::ExternalAddRef((CCmdTarget *)(a1 - 52));
}


// ========== Function: sub_425EFC @ 0x425EFC ==========
LONG __stdcall sub_425EFC(int a1)
{
  return CCmdTarget::ExternalRelease((CCmdTarget *)(a1 - 52));
}


// ========== Function: sub_425F0B @ 0x425F0B ==========
// ?QueryInterface@XEnumVOID@CEnumArray@@UAGJABU_GUID@@PAPAX@Z
// doubtful name
int __stdcall sub_425F0B(int a1, _DWORD *a2, void **a3)
{
  return CCmdTarget::ExternalQueryInterface((CCmdTarget *)(a1 - 52), a2, a3);
}


// ========== Function: sub_425F22 @ 0x425F22 ==========
BOOL __stdcall sub_425F22(int a1, CException *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // edi
  _DWORD v7[7]; // [esp+0h] [ebp-1Ch] BYREF
  CException *i; // [esp+24h] [ebp+8h]

  v4 = (_DWORD *)(a1 - 52);
  v7[3] = v7;
  if ( a4 )
    *a4 = 0;
  v7[6] = 0;
  for ( i = a2; i && (*(int (__thiscall **)(_DWORD *, int))(*v4 + 80))(v4, a3); i = (CException *)((char *)i - 1) )
    a3 += v4[7];
  if ( a4 )
    *a4 = a2 - i;
  return i != 0;
}


// ========== Function: sub_425FAA @ 0x425FAA ==========
BOOL __stdcall sub_425FAA(int a1, CException *a2)
{
  int v2; // esi
  _DWORD v4[7]; // [esp+0h] [ebp-1Ch] BYREF

  v4[6] = 0;
  v2 = a1 - 52;
  v4[3] = v4;
  while ( a2 && (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 84))(v2) )
    a2 = (CException *)((char *)a2 - 1);
  return a2 != 0;
}


// ========== Function: sub_426008 @ 0x426008 ==========
int __stdcall sub_426008(int a1)
{
  (*(void (__thiscall **)(int))(*(_DWORD *)(a1 - 52) + 88))(a1 - 52);
  return 0;
}


// ========== Function: sub_42601A @ 0x42601A ==========
int __stdcall sub_42601A(int a1, CException *a2)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax
  _DWORD v6[7]; // [esp+0h] [ebp-1Ch] BYREF

  v6[6] = 0;
  *(_DWORD *)a2 = 0;
  v2 = *(_DWORD *)(a1 - 52);
  v6[3] = v6;
  v3 = (*(int (__thiscall **)(int))(v2 + 92))(a1 - 52);
  v4 = *(_DWORD *)(a1 - 52 + 32);
  if ( v4 )
    *(_DWORD *)(v3 + 32) = v4;
  else
    *(_DWORD *)(v3 + 32) = a1 - 52;
  InterlockedIncrement((volatile LONG *)(*(_DWORD *)(v3 + 32) + 4));
  *(_DWORD *)a2 = v3 + 52;
  return 0;
}


// ========== Function: ?FlushClipboard@COleDataSource@@SGXXZ @ 0x426092 ==========
void __stdcall COleDataSource::FlushClipboard()
{
  if ( COleDataSource::GetClipboardOwner() )
    OleFlushClipboard();
}


// ========== Function: ?GetClipboardOwner@COleDataSource@@SGPAV1@XZ @ 0x4260A2 ==========
struct COleDataSource *__stdcall COleDataSource::GetClipboardOwner()
{
  int v0; // esi
  char *v1; // ecx
  char *v2; // eax

  v0 = sub_424E45(&unk_4393A0, sub_4260DD);
  v1 = *(char **)(v0 + 8);
  if ( !v1 )
    return 0;
  v2 = sub_425A07(v1, dword_42CBA8);
  if ( OleIsCurrentClipboard((LPDATAOBJECT)v2) )
  {
    *(_DWORD *)(v0 + 8) = 0;
    return 0;
  }
  return *(struct COleDataSource **)(v0 + 8);
}


// ========== Function: sub_4260DD @ 0x4260DD ==========
_DWORD *sub_4260DD()
{
  _DWORD *v0; // ecx
  _DWORD *result; // eax

  v0 = CNoTrackObject::operator new(0x14u);
  result = 0;
  if ( v0 )
    return sub_425949(v0);
  return result;
}


// ========== Function: sub_42610E @ 0x42610E ==========
void __thiscall sub_42610E(_DWORD *this)
{
  ++this[8];
}


// ========== Function: ?EndBusyState@COleMessageFilter@@UAEXXZ @ 0x426112 ==========
void __thiscall COleMessageFilter::EndBusyState(COleMessageFilter *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 8);
  if ( v1 )
    *((_DWORD *)this + 8) = v1 - 1;
}


// ========== Function: ?OnMessagePending@COleMessageFilter@@UAEHPBUtagMSG@@@Z @ 0x42611E ==========
int __thiscall COleMessageFilter::OnMessagePending(COleMessageFilter *this, const struct tagMSG *a2)
{
  int v2; // ebx
  struct tagMSG Msg; // [esp+8h] [ebp-1Ch] BYREF

  v2 = 0;
  if ( PeekMessageA(&Msg, 0, 0xFu, 0xFu, 3u) )
  {
    v2 = 1;
    do
      DispatchMessageA(&Msg);
    while ( PeekMessageA(&Msg, 0, 0xFu, 0xFu, 3u) );
  }
  return v2;
}


// ========== Function: ?IsSignificantMessage@COleMessageFilter@@UAEHPAUtagMSG@@@Z @ 0x426166 ==========
int __thiscall COleMessageFilter::IsSignificantMessage(COleMessageFilter *this, struct tagMSG *a2)
{
  UINT *v2; // esi
  struct tagMSG Msg; // [esp+4h] [ebp-1Ch] BYREF

  v2 = (UINT *)&unk_42B798;
  while ( !PeekMessageA(&Msg, 0, *v2, *v2, 2u)
       || (Msg.message == 256 || Msg.message == 260) && (Msg.lParam & 0x40000000) != 0 )
  {
    if ( ++v2 >= (UINT *)&off_42B7D4 )
      return 0;
  }
  return 1;
}


// ========== Function: sub_4261BC @ 0x4261BC ==========
int __stdcall sub_4261BC(HTASK a1)
{
  int v2; // [esp+0h] [ebp-B0h] BYREF
  _BYTE v3[140]; // [esp+Ch] [ebp-A4h] BYREF
  int v4; // [esp+98h] [ebp-18h]
  int *v5; // [esp+A0h] [ebp-10h]
  int v6; // [esp+ACh] [ebp-4h]
  int v7; // [esp+B8h] [ebp+8h]

  v5 = &v2;
  COleBusyDialog::COleBusyDialog((COleBusyDialog *)v3, a1, 0, 0, 0);
  v7 = -1;
  v6 = 1;
  if ( sub_425D21((struct CWnd *)v3) == 1 )
    v7 = v4;
  v6 = -1;
  sub_425D16((CWnd *)v3);
  return v7;
}


// ========== Function: sub_426237 @ 0x426237 ==========
int __stdcall sub_426237(HTASK a1)
{
  int v2; // [esp+0h] [ebp-B0h] BYREF
  _BYTE v3[140]; // [esp+Ch] [ebp-A4h] BYREF
  int v4; // [esp+98h] [ebp-18h]
  int *v5; // [esp+A0h] [ebp-10h]
  int v6; // [esp+ACh] [ebp-4h]
  int v7; // [esp+B8h] [ebp+8h]

  v5 = &v2;
  COleBusyDialog::COleBusyDialog((COleBusyDialog *)v3, a1, 1, 0, 0);
  v7 = -1;
  v6 = 1;
  if ( sub_425D21((struct CWnd *)v3) == 1 )
    v7 = v4;
  v6 = -1;
  sub_425D16((CWnd *)v3);
  return v7;
}


// ========== Function: sub_4262B3 @ 0x4262B3 ==========
_UNKNOWN **sub_4262B3()
{
  return &off_42B780;
}


// ========== Function: sub_4262B9 @ 0x4262B9 ==========
LONG __stdcall sub_4262B9(int a1)
{
  return CCmdTarget::ExternalAddRef((CCmdTarget *)(a1 - 60));
}


// ========== Function: sub_4262C8 @ 0x4262C8 ==========
LONG __stdcall sub_4262C8(int a1)
{
  return CCmdTarget::ExternalRelease((CCmdTarget *)(a1 - 60));
}


// ========== Function: ?QueryInterface@XMessageFilter@COleMessageFilter@@UAGJABU_GUID@@PAPAX@Z @ 0x4262D7 ==========
int __stdcall COleMessageFilter::XMessageFilter::QueryInterface(
        COleMessageFilter::XMessageFilter *this,
        struct _GUID *a2,
        void **a3)
{
  return CCmdTarget::ExternalQueryInterface((COleMessageFilter::XMessageFilter *)((char *)this - 60), a2, a3);
}


// ========== Function: sub_4262EE @ 0x4262EE ==========
int __stdcall sub_4262EE(int a1, int a2, int a3, int a4, int a5)
{
  DWORD CurrentThreadId; // eax
  struct tagMSG Msg; // [esp+4h] [ebp-1Ch] BYREF

  if ( *(_DWORD *)(a1 - 28) )
  {
    if ( a2 == 1 || a2 == 4 )
      return *(_DWORD *)(a1 - 8);
    else
      return 0;
  }
  else
  {
    if ( (a2 == 1 || a2 == 4) && !PeekMessageA(&Msg, 0, 0x36Au, 0x36Au, 0) )
    {
      CurrentThreadId = GetCurrentThreadId();
      PostThreadMessageA(CurrentThreadId, 0x36Au, 0, 0);
    }
    return 0;
  }
}


// ========== Function: sub_426350 @ 0x426350 ==========
int __stdcall sub_426350(int a1, int a2, unsigned int a3, int a4)
{
  _DWORD *v4; // esi
  int v5; // eax

  v4 = (_DWORD *)(a1 - 60);
  if ( a4 == 1 )
    return -1;
  if ( a3 <= v4[12] )
    return 0;
  if ( !v4[9] )
    return v4[12];
  v5 = (*(int (__thiscall **)(int, int))(*v4 + 96))(a1 - 60, a2);
  if ( v5 == -1 )
    return -1;
  if ( v5 == 2 )
    return 0;
  return v4[12];
}


// ========== Function: sub_426393 @ 0x426393 ==========
int __stdcall sub_426393(int a1, int a2, unsigned int a3, int a4)
{
  _DWORD *v4; // edi
  BOOL i; // eax
  struct tagMSG Msg; // [esp+8h] [ebp-1Ch] BYREF

  v4 = (_DWORD *)(a1 - 60);
  if ( a3 <= *(_DWORD *)(a1 - 60 + 56) )
    goto LABEL_10;
  if ( v4[11] )
    return 2;
  if ( !(*(int (__thiscall **)(int, struct tagMSG *))(*v4 + 92))(a1 - 60, &Msg) || !v4[10] )
  {
LABEL_10:
    if ( !v4[11] )
    {
      if ( PeekMessageA(&Msg, 0, 0, 0, 2u) )
        (*(void (__thiscall **)(_DWORD *, struct tagMSG *))(*v4 + 88))(v4, &Msg);
      return 1;
    }
    return 2;
  }
  v4[11] = 1;
  for ( i = PeekMessageA(&Msg, 0, 0x200u, 0x209u, 3u); i; i = PeekMessageA(&Msg, 0, 0x200u, 0x209u, 3u) )
    ;
  while ( PeekMessageA(&Msg, 0, 0x100u, 0x108u, 3u) )
    ;
  (*(void (__thiscall **)(_DWORD *, int))(*v4 + 100))(v4, a2);
  v4[11] = 0;
  return 1;
}


// ========== Function: ??0COleDispatchDriver@@QAE@XZ @ 0x426468 ==========
COleDispatchDriver *__thiscall COleDispatchDriver::COleDispatchDriver(COleDispatchDriver *this)
{
  COleDispatchDriver *result; // eax

  result = this;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 1;
  return result;
}


// ========== Function: ?AttachDispatch@COleDispatchDriver@@QAEXPAUIDispatch@@H@Z @ 0x426475 ==========
void __thiscall COleDispatchDriver::AttachDispatch(COleDispatchDriver *this, struct IDispatch *a2, int a3)
{
  COleDispatchDriver::ReleaseDispatch(this);
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
}


// ========== Function: ?ReleaseDispatch@COleDispatchDriver@@QAEXXZ @ 0x42648E ==========
void __thiscall COleDispatchDriver::ReleaseDispatch(COleDispatchDriver *this)
{
  if ( *(_DWORD *)this )
  {
    if ( *((_DWORD *)this + 1) )
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)this + 8))(*(_DWORD *)this);
    *(_DWORD *)this = 0;
  }
}


// ========== Function: sub_4264A8 @ 0x4264A8 ==========
void __thiscall sub_4264A8(
        int *this,
        int a2,
        int a3,
        VARTYPE vt,
        struct CString *pExceptionObject,
        CHAR *lpString,
        double *a7)
{
  int *v7; // ebx
  bool v8; // zf
  CHAR *v9; // edi
  int v10; // eax
  void *v11; // esi
  int v12; // esi
  CHAR *v13; // esi
  char *v14; // ebx
  _WORD *v15; // ecx
  __int16 v16; // ax
  __int16 v17; // ax
  CHAR v18; // al
  int v19; // eax
  _DWORD *v20; // eax
  const CHAR *v21; // eax
  BSTR v22; // eax
  const CHAR *v23; // eax
  int v24; // eax
  void *v25; // esp
  BSTR v26; // eax
  int v27; // eax
  _DWORD *v28; // esi
  _DWORD *v29; // edi
  _DWORD *v30; // eax
  VARIANTARG *p_pvarg; // esi
  int v32; // eax
  CHAR *v33; // esi
  VARIANTARG *i; // ebx
  struct CString *v35; // esi
  CException *v36; // esi
  struct CString *v37; // edi
  int v38; // [esp+0h] [ebp-78h] BYREF
  int v39; // [esp+4h] [ebp-74h]
  __int16 v40[16]; // [esp+Ch] [ebp-6Ch] BYREF
  LPVOID lpMem[4]; // [esp+2Ch] [ebp-4Ch] BYREF
  VARIANTARG pvarg; // [esp+3Ch] [ebp-3Ch] BYREF
  int v43; // [esp+4Ch] [ebp-2Ch] BYREF
  int *v44; // [esp+50h] [ebp-28h]
  int *v45; // [esp+54h] [ebp-24h]
  int cchWideChar; // [esp+58h] [ebp-20h]
  int v47; // [esp+5Ch] [ebp-1Ch] BYREF
  LPCSTR lpMultiByteStr; // [esp+60h] [ebp-18h]
  CHAR *v49; // [esp+64h] [ebp-14h]
  _WORD *v50; // [esp+68h] [ebp-10h]
  int v51; // [esp+74h] [ebp-4h]

  v7 = this;
  v8 = *this == 0;
  v44 = this;
  if ( !v8 )
  {
    memset(lpMem, 0, sizeof(lpMem));
    v9 = lpString;
    if ( lpString )
    {
      v10 = lstrlenA(lpString);
      lpMem[2] = (LPVOID)v10;
    }
    else
    {
      v10 = (int)lpMem[2];
    }
    v47 = -3;
    if ( (a3 & 0xC) != 0 )
    {
      lpMem[3] = (LPVOID)1;
      lpMem[1] = &v47;
    }
    if ( v10 )
    {
      v11 = sub_41CA70(16 * v10);
      lpMem[0] = v11;
      memset(v11, 0, 16 * (int)lpMem[2]);
      v8 = *v9 == 0;
      v49 = v9;
      v12 = (int)v11 + 16 * (int)lpMem[2] - 16;
      v50 = (_WORD *)v12;
      if ( !v8 )
      {
        v13 = (CHAR *)(v12 + 8);
        lpMultiByteStr = v13;
        v14 = (char *)a7-- - 4;
        do
        {
          v15 = v50;
          v16 = (unsigned __int8)*v49;
          *v50 = v16;
          if ( (v16 & 0x40) != 0 )
          {
            v17 = v16 & 0xFFBF;
            HIBYTE(v17) |= 0x40u;
            *v15 = v17;
          }
          if ( (unsigned __int16)*v15 > 0x4002u )
          {
            switch ( *v15 )
            {
              case 0x4003:
              case 0x4004:
              case 0x4005:
              case 0x4006:
              case 0x4007:
              case 0x4008:
              case 0x4009:
              case 0x400A:
              case 0x400C:
              case 0x400D:
              case 0x4011:
                goto LABEL_34;
              case 0x400B:
                v30 = (_DWORD *)*((_DWORD *)v14 + 1);
                a7 = (double *)((char *)a7 + 4);
                v14 += 4;
                *v30 = (unsigned __int16)-(*v30 != 0);
                goto LABEL_35;
              default:
                break;
            }
          }
          else if ( *v15 == 16386 )
          {
LABEL_34:
            a7 = (double *)((char *)a7 + 4);
            v30 = (_DWORD *)*((_DWORD *)v14 + 1);
            v14 += 4;
LABEL_35:
            *(_DWORD *)v13 = v30;
          }
          else
          {
            switch ( *v15 )
            {
              case 2:
                a7 = (double *)((char *)a7 + 4);
                LOWORD(v19) = *((_WORD *)v14 + 2);
                v14 += 4;
                goto LABEL_17;
              case 3:
              case 9:
              case 0xA:
              case 0xD:
                goto LABEL_34;
              case 4:
                ++a7;
                v14 += 8;
                *(float *)v13 = *a7;
                break;
              case 5:
              case 7:
                ++a7;
                v14 += 8;
                *(double *)v13 = *a7;
                break;
              case 6:
                a7 = (double *)((char *)a7 + 4);
                v20 = (_DWORD *)*((_DWORD *)v14 + 1);
                v14 += 4;
                *(_DWORD *)v13 = *v20;
                *((_DWORD *)v13 + 1) = v20[1];
                break;
              case 8:
                v21 = (const CHAR *)*((_DWORD *)v14 + 1);
                a7 = (double *)((char *)a7 + 4);
                v14 += 4;
                lpMultiByteStr = v21;
                v22 = SysAllocString((const OLECHAR *)v21);
                v8 = lpMultiByteStr == 0;
                *(_DWORD *)v13 = v22;
                if ( !v8 && !v22 )
                  sub_41B4F7();
                break;
              case 0xB:
                v27 = *((_DWORD *)v14 + 1);
                a7 = (double *)((char *)a7 + 4);
                v14 += 4;
                v19 = -(v27 != 0);
LABEL_17:
                *(_WORD *)v13 = v19;
                break;
              case 0xC:
                a7 = (double *)((char *)a7 + 4);
                v28 = (_DWORD *)*((_DWORD *)v14 + 1);
                v29 = v50;
                v14 += 4;
                *(_DWORD *)v50 = *v28++;
                *++v29 = *v28++;
                *++v29 = *v28;
                v29[1] = v28[1];
                v13 = (CHAR *)lpMultiByteStr;
                break;
              case 0xE:
                v23 = (const CHAR *)*((_DWORD *)v14 + 1);
                a7 = (double *)((char *)a7 + 4);
                v14 += 4;
                lpMultiByteStr = v23;
                if ( v23 )
                {
                  cchWideChar = lstrlenA(lpMultiByteStr) + 1;
                  v24 = 2 * cchWideChar + 3;
                  LOBYTE(v24) = v24 & 0xFC;
                  v25 = alloca(v24);
                  v45 = &v38;
                  LOWORD(v38) = 0;
                  MultiByteToWideChar(0, 0, lpMultiByteStr, -1, (LPWSTR)&v38, cchWideChar);
                  v23 = (const CHAR *)v45;
                }
                v26 = SysAllocString((const OLECHAR *)v23);
                v8 = lpMultiByteStr == 0;
                *(_DWORD *)v13 = v26;
                if ( !v8 && !v26 )
                  sub_41B4F7();
                *v50 = 8;
                break;
              case 0x11:
                a7 = (double *)((char *)a7 + 4);
                v18 = v14[4];
                v14 += 4;
                *v13 = v18;
                break;
              default:
                break;
            }
          }
          v50 -= 8;
          v13 -= 16;
          ++v49;
          lpMultiByteStr = v13;
        }
        while ( *v49 );
        v7 = v44;
        v9 = lpString;
      }
    }
    p_pvarg = 0;
    AfxVariantInit(&pvarg);
    if ( vt )
      p_pvarg = &pvarg;
    memset(v40, 0, sizeof(v40));
    v32 = *v7;
    v43 = -1;
    lpString = (CHAR *)(*(int (__stdcall **)(int, int, _DWORD *, _DWORD, int, LPVOID *, VARIANTARG *, __int16 *, int *))(*(_DWORD *)v32 + 24))(
                         v32,
                         a2,
                         dword_42C750,
                         0,
                         a3,
                         lpMem,
                         p_pvarg,
                         v40,
                         &v43);
    if ( lpMem[2] )
    {
      v33 = v9;
      for ( i = (VARIANTARG *)((char *)lpMem[0] + 16 * (int)lpMem[2] - 16); *v33; ++v33 )
      {
        if ( *v33 == 8 || *v33 == 14 )
          VariantClear(i);
        --i;
      }
    }
    sub_41CA99(lpMem[0]);
    if ( (int)lpString < 0 )
    {
      VariantClear(&pvarg);
      if ( lpString != (CHAR *)-2147352567 )
        AfxThrowOleException((CException *)lpString, v38, v39);
      if ( *(_DWORD *)&v40[12] )
        (*(void (__stdcall **)(__int16 *))&v40[12])(v40);
      pExceptionObject = (struct CString *)sub_41CA70(0x20u);
      v51 = 0;
      if ( pExceptionObject )
        v35 = (struct CString *)sub_427225(0, 0, v40[0]);
      else
        v35 = 0;
      v51 = -1;
      if ( *(_DWORD *)&v40[2] )
      {
        CString::operator=((void **)v35 + 6, *(wchar_t **)&v40[2]);
        SysFreeString(*(BSTR *)&v40[2]);
      }
      if ( *(_DWORD *)&v40[4] )
      {
        CString::operator=((void **)v35 + 3, *(wchar_t **)&v40[4]);
        SysFreeString(*(BSTR *)&v40[4]);
      }
      if ( *(_DWORD *)&v40[6] )
      {
        CString::operator=((void **)v35 + 5, *(wchar_t **)&v40[6]);
        SysFreeString(*(BSTR *)&v40[6]);
      }
      *((_DWORD *)v35 + 4) = *(_DWORD *)&v40[8];
      *((_DWORD *)v35 + 7) = *(_DWORD *)&v40[14];
      pExceptionObject = v35;
      _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI4PAVCOleDispatchException__);
    }
    if ( vt )
    {
      if ( vt != 12 )
      {
        v36 = (CException *)VariantChangeType(&pvarg, &pvarg, 0, vt);
        if ( (int)v36 < 0 )
        {
          VariantClear(&pvarg);
          AfxThrowOleException(v36, v38, v39);
        }
      }
      switch ( vt )
      {
        case 2u:
          *(_WORD *)pExceptionObject = pvarg.iVal;
          break;
        case 3u:
        case 4u:
        case 9u:
        case 0xAu:
        case 0xDu:
          *(_DWORD *)pExceptionObject = pvarg.lVal;
          break;
        case 5u:
        case 6u:
        case 7u:
          *(_QWORD *)pExceptionObject = pvarg.llVal;
          break;
        case 8u:
          AfxBSTR2CString(pExceptionObject, pvarg.bstrVal);
          SysFreeString(pvarg.bstrVal);
          break;
        case 0xBu:
          *(_DWORD *)pExceptionObject = pvarg.iVal != 0;
          break;
        case 0xCu:
          v37 = pExceptionObject;
          *(_DWORD *)pExceptionObject = *(_DWORD *)&pvarg.vt;
          v37 = (struct CString *)((char *)v37 + 4);
          *(_DWORD *)v37 = pvarg.decVal.Hi32;
          *(_QWORD *)((char *)v37 + 4) = pvarg.llVal;
          break;
        case 0x11u:
          *(_BYTE *)pExceptionObject = pvarg.bVal;
          break;
        default:
          return;
      }
    }
  }
}


// ========== Function: ?AllocSysString@CString@@QBEPAGXZ @ 0x4269CF ==========
unsigned __int16 *__thiscall CString::AllocSysString(LPCCH *this)
{
  WCHAR *v2; // ebx
  UINT cchWideChar; // [esp+10h] [ebp-4h]

  cchWideChar = MultiByteToWideChar(0, 0, *this, *((_DWORD *)*this - 2), 0, 0);
  v2 = SysAllocStringLen(0, cchWideChar);
  if ( !v2 )
    sub_41B4F7();
  MultiByteToWideChar(0, 0, *this, *((_DWORD *)*this - 2), v2, cchWideChar);
  return v2;
}


// ========== Function: ?GetStackSize@CCmdTarget@@KGIPBEG@Z @ 0x426A18 ==========
int __stdcall CCmdTarget::GetStackSize(const unsigned __int8 *a1, unsigned __int16 a2)
{
  const unsigned __int8 *v2; // edx
  unsigned __int8 v3; // cl
  int result; // eax
  _DWORD *v5; // esi

  v2 = a1;
  v3 = *a1;
  for ( result = dword_42B368[a2] + 4; v3; ++v2 )
  {
    if ( v3 != 0xFF )
    {
      v5 = &unk_42B3A4;
      if ( (v3 & 0x40) == 0 )
        v5 = &unk_42B3E0;
      result += v5[v3 & 0xBF];
    }
    v3 = v2[1];
  }
  return result;
}


// ========== Function: sub_426A5B @ 0x426A5B ==========
HRESULT __fastcall sub_426A5B(int a1, int a2, int *a3, _BYTE *vt, __int16 *a5, __int16 a6, _DWORD *a7, int *a8, int a9)
{
  __int16 **v9; // edi
  _DWORD *v10; // edx
  _BYTE *v11; // eax
  int v12; // eax
  __int16 *v13; // esi
  int v14; // ebx
  HRESULT result; // eax
  OLECHAR *v16; // esi
  __int16 *v17; // eax
  int v18; // [esp+Ch] [ebp-Ch]
  int v19; // [esp+10h] [ebp-8h]
  int v20; // [esp+14h] [ebp-4h]
  int v21; // [esp+20h] [ebp+8h]
  VARTYPE vta; // [esp+24h] [ebp+Ch]
  _BYTE *v23; // [esp+28h] [ebp+10h]
  int v24; // [esp+2Ch] [ebp+14h]

  *a3 = a1;
  v9 = (__int16 **)(a3 + 1);
  if ( a6 == 6 || a6 == 12 )
  {
    *v9 = a5;
    v9 = (__int16 **)(a3 + 2);
  }
  v10 = a7;
  v19 = 0;
  v18 = *a7;
  v24 = a7[2];
  v20 = a7[3];
  v11 = vt;
  v23 = vt;
  while ( *v11 )
  {
    --v24;
    LOWORD(a1) = (unsigned __int8)*v23;
    v21 = a1;
    if ( (_WORD)a1 != 255 && (a1 & 0x40) != 0 )
    {
      a1 &= 0xFFBFu;
      BYTE1(a1) |= 0x40u;
      v21 = a1;
    }
    if ( v24 < v20 )
    {
      if ( (_WORD)a1 == 255 )
      {
        v20 = 0;
        v24 = v10[3];
        v19 = 1;
        goto LABEL_44;
      }
      if ( v19 || (_WORD)a1 != 12 )
        break;
      word_439320 = 10;
      dword_439328 = -2147352572;
      v13 = &word_439320;
    }
    else
    {
      if ( (_WORD)a1 == 255 )
        break;
      v12 = 16 * v24;
      v13 = (__int16 *)(16 * v24 + v18);
      if ( (_WORD)a1 != 12 )
      {
        if ( (_WORD)a1 != *v13 )
        {
          vta = 8;
          v14 = v12 + a9;
          if ( (_WORD)a1 != 14 )
            vta = a1;
          if ( *v13 != vta )
          {
            result = VariantChangeType((VARIANTARG *)(v12 + a9), (const VARIANTARG *)(16 * v24 + v18), 0, vta);
            if ( result < 0 )
              goto LABEL_47;
            a1 = v21;
          }
          if ( (_WORD)a1 == 14 )
          {
            if ( *v13 == vta )
            {
              *(_DWORD *)(v14 + 8) = AfxBSTR2ABSTR(*((BSTR *)v13 + 2));
              *(_WORD *)v14 = 8;
            }
            else
            {
              v16 = *(OLECHAR **)(v14 + 8);
              *(_DWORD *)(v14 + 8) = AfxBSTR2ABSTR(v16);
              SysFreeString(v16);
            }
            a1 = 8;
          }
          v13 = (__int16 *)v14;
        }
        v10 = a7;
      }
    }
    if ( (unsigned __int16)a1 > 0x11u )
    {
      switch ( (__int16)a1 )
      {
        case 16386:
        case 16387:
        case 16388:
        case 16389:
        case 16390:
        case 16391:
        case 16392:
        case 16393:
        case 16394:
        case 16395:
        case 16396:
        case 16397:
        case 16402:
LABEL_41:
          v17 = (__int16 *)*((_DWORD *)v13 + 2);
          goto LABEL_42;
        default:
          break;
      }
    }
    else if ( (unsigned __int16)a1 == 17 )
    {
      v17 = (__int16 *)*((unsigned __int8 *)v13 + 8);
LABEL_42:
      *v9 = v17;
LABEL_43:
      ++v9;
    }
    else
    {
      switch ( (__int16)a1 )
      {
        case 2:
          v17 = (__int16 *)v13[4];
          goto LABEL_42;
        case 3:
        case 4:
        case 8:
        case 9:
        case 10:
        case 13:
          goto LABEL_41;
        case 5:
        case 7:
          *(double *)v9 = *((double *)v13 + 1);
          goto LABEL_36;
        case 6:
          *v9 = (__int16 *)*((_DWORD *)v13 + 2);
          v9[1] = (__int16 *)*((_DWORD *)v13 + 3);
LABEL_36:
          v9 += 2;
          break;
        case 11:
          v17 = (__int16 *)(v13[4] != 0);
          goto LABEL_42;
        case 12:
          *v9 = v13;
          goto LABEL_43;
        default:
          break;
      }
    }
LABEL_44:
    v11 = ++v23;
  }
  if ( v24 > 0 )
  {
    result = -2147352562;
LABEL_47:
    *a8 = v24;
    return result;
  }
  if ( !*v23 )
    return 0;
  *a8 = v10[2];
  return -2147352561;
}


// ========== Function: sub_426CDA @ 0x426CDA ==========
HRESULT __fastcall sub_426CDA(int a1, int a2, LPCSTR lpString, VARIANTARG *pvarg, int a5, _DWORD *a6, int *a7)
{
  CHAR *v8; // eax
  size_t v9; // esi
  int v10; // eax
  void *v11; // esp
  __int16 v12; // ax
  size_t v13; // esi
  int v14; // eax
  int v15; // eax
  void *v16; // esp
  int v17; // edx
  int StackSize; // esi
  int v19; // eax
  void *v20; // esp
  HRESULT result; // eax
  OLECHAR *v22; // ebx
  unsigned int i; // edi
  unsigned __int16 v24; // cx
  int v26[4]; // [esp+0h] [ebp-44h] BYREF
  VARIANTARG v27; // [esp+10h] [ebp-34h] BYREF
  double v28; // [esp+20h] [ebp-24h]
  int v29; // [esp+28h] [ebp-1Ch]
  unsigned __int16 v30[3]; // [esp+2Ch] [ebp-18h]
  char v31; // [esp+33h] [ebp-11h] BYREF
  int *v32; // [esp+34h] [ebp-10h]
  int v33; // [esp+40h] [ebp-4h]
  CHAR *lpStringa; // [esp+4Ch] [ebp+8h]
  float lpStringb; // [esp+4Ch] [ebp+8h]
  VARIANTARG *pvarga; // [esp+50h] [ebp+Ch]
  HRESULT v37; // [esp+5Ch] [ebp+18h]

  v31 = 0;
  HIDWORD(v28) = a1;
  v8 = (CHAR *)*((_DWORD *)lpString + 2);
  v32 = v26;
  lpStringa = v8;
  if ( !v8 )
    lpStringa = &v31;
  v9 = lstrlenA(lpStringa);
  v29 = *((_DWORD *)lpString + 4);
  v30[0] = *((_WORD *)lpString + 6);
  if ( ((unsigned __int8)pvarg & 0xC) != 0 )
  {
    v10 = v9 + 6;
    LOBYTE(v10) = (v9 + 6) & 0xFC;
    v11 = alloca(v10);
    memcpy(v26, lpStringa, v9);
    v12 = *((_WORD *)lpString + 6);
    lpStringa = (CHAR *)v26;
    if ( v12 == 8 )
      LOBYTE(v12) = 14;
    *((_BYTE *)v26 + v9) = -1;
    v13 = v9 + 1;
    *((_BYTE *)v26 + v13) = v12;
    *((_BYTE *)v26 + v13 + 1) = 0;
    v14 = *((_DWORD *)lpString + 5);
    *(_DWORD *)v30 = 0;
    v29 = v14;
  }
  v15 = 16 * a6[2] + 3;
  LOBYTE(v15) = v15 & 0xFC;
  v16 = alloca(v15);
  pvarga = (VARIANTARG *)v26;
  if ( !v26 )
    return -2147024882;
  memset(v26, 0, 16 * a6[2]);
  StackSize = CCmdTarget::GetStackSize((const unsigned __int8 *)lpStringa, v30[0]);
  v19 = StackSize + 19;
  LOBYTE(v19) = (StackSize + 19) & 0xFC;
  v20 = alloca(v19);
  v22 = 0;
  v37 = sub_426A5B(SHIDWORD(v28), v17, v26, lpStringa, (__int16 *)&v27, v30[0], a6, a7, (int)v26);
  if ( !v37 )
  {
    v33 = 0;
    switch ( v30[0] )
    {
      case 4u:
        unknown_libname_36(v29, v26, StackSize);
        __asm { fstp    [ebp+lpString] }
        *(float *)&v27.vt = lpStringb;
        goto LABEL_19;
      case 5u:
        unknown_libname_36(v29, v26, StackSize);
        __asm { fst     qword ptr [ebp-24h] }
        break;
      case 7u:
        unknown_libname_36(v29, v26, StackSize);
        __asm { fst     qword ptr [ebp-24h] }
        break;
      default:
        v22 = (OLECHAR *)unknown_libname_36(v29, v26, StackSize);
LABEL_19:
        v33 = -1;
        goto LABEL_20;
    }
    __asm { fstp    qword ptr [ebp+var_34] }
    goto LABEL_19;
  }
LABEL_20:
  for ( i = 0; i < a6[2]; ++i )
    VariantClear(pvarga++);
  result = v37;
  if ( !v37 )
  {
    if ( a5 )
    {
      v24 = v30[0];
      *(_WORD *)a5 = v30[0];
      switch ( v24 )
      {
        case 2u:
          goto LABEL_31;
        case 3u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xDu:
          *(_DWORD *)(a5 + 8) = v22;
          break;
        case 4u:
          *(_DWORD *)(a5 + 8) = *(_DWORD *)&v27.vt;
          break;
        case 5u:
        case 7u:
          __asm
          {
            fld     qword ptr [ebp+var_34]; jumptable 00426E82 cases 5,7
            fstp    qword ptr [eax+8]
          }
          *(double *)(a5 + 8) = _RT1;
          break;
        case 6u:
          *(_QWORD *)(a5 + 8) = *(_QWORD *)&v27.vt;
          break;
        case 0xBu:
          v22 = (OLECHAR *)-(v22 != 0);
LABEL_31:
          *(_WORD *)(a5 + 8) = (_WORD)v22;
          break;
        case 0xCu:
          *(VARIANTARG *)a5 = v27;
          break;
        case 0x12u:
          *(_BYTE *)(a5 + 8) = (_BYTE)v22;
          break;
        default:
          return 0;
      }
      return 0;
    }
    if ( v30[0] == 8 )
    {
      if ( v22 )
        SysFreeString(v22);
      return 0;
    }
    if ( v30[0] != 9 )
    {
      if ( v30[0] == 12 )
      {
        VariantClear(&v27);
        return 0;
      }
      if ( v30[0] != 13 )
        return 0;
    }
    if ( v22 )
      (*(void (__cdecl **)(OLECHAR *))(*(_DWORD *)v22 + 8))(v22);
    return 0;
  }
  return result;
}


// ========== Function: ??1COleDispatchException@@UAE@XZ @ 0x426F82 ==========
void __thiscall COleDispatchException::~COleDispatchException(COleDispatchException *this)
{
  *(_DWORD *)this = &off_42B420;
  sub_4200DD((_DWORD *)this + 6);
  sub_4200DD((_DWORD *)this + 5);
  sub_4200DD((_DWORD *)this + 3);
}


// ========== Function: sub_426FCD @ 0x426FCD ==========
COleDispatchException *__thiscall sub_426FCD(COleDispatchException *lpMem, char a2)
{
  COleDispatchException::~COleDispatchException(lpMem);
  if ( (a2 & 1) != 0 )
    sub_41CA99(lpMem);
  return lpMem;
}


// ========== Function: sub_426FE9 @ 0x426FE9 ==========
BSTR __stdcall sub_426FE9(_WORD *a1, CHAR *a2)
{
  const OLECHAR *v2; // esi
  CHAR *v3; // eax
  __int16 v4; // dx
  const CHAR *v5; // ecx
  const OLECHAR *v6; // eax
  int v7; // eax
  void *v8; // esp
  const CHAR *v9; // eax
  const OLECHAR *v10; // eax
  int v11; // eax
  void *v12; // esp
  const OLECHAR *v13; // eax
  int v14; // eax
  void *v15; // esp
  BSTR result; // eax
  _WORD *v17; // ecx
  bool v18; // zf
  const CHAR *v19; // eax
  const OLECHAR *v20; // eax
  int v21; // eax
  void *v22; // esp
  const CHAR *v23; // eax
  int v24; // edi
  int v25; // eax
  void *v26; // esp
  WCHAR v27[6]; // [esp+0h] [ebp-11Ch] BYREF
  CHAR Buffer[256]; // [esp+Ch] [ebp-110h] BYREF
  LPCCH lpMultiByteStr; // [esp+10Ch] [ebp-10h]
  LPCSTR lpString; // [esp+110h] [ebp-Ch]
  WCHAR *v31; // [esp+114h] [ebp-8h]
  int cchWideChar; // [esp+118h] [ebp-4h]
  const CHAR *v33; // [esp+128h] [ebp+Ch]
  const CHAR *v34; // [esp+128h] [ebp+Ch]
  const CHAR *v35; // [esp+128h] [ebp+Ch]

  v2 = 0;
  memset(a1, 0, 0x20u);
  lpString = Buffer;
  if ( CObject::IsKindOf((CObject *)a2, (const struct CRuntimeClass *)&off_42B338) )
  {
    v3 = a2;
    v4 = *((_WORD *)a2 + 4);
    lpString = (LPCSTR)*((_DWORD *)a2 + 3);
    *a1 = v4;
    *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
    *((_DWORD *)a1 + 7) = *((_DWORD *)a2 + 7);
    v5 = (const CHAR *)*((_DWORD *)a2 + 5);
    lpMultiByteStr = v5;
    if ( *((_DWORD *)v5 - 2) )
    {
      if ( v5 )
      {
        cchWideChar = lstrlenA(v5) + 1;
        v7 = 2 * cchWideChar + 3;
        LOBYTE(v7) = v7 & 0xFC;
        v8 = alloca(v7);
        v31 = v27;
        v27[0] = 0;
        MultiByteToWideChar(0, 0, lpMultiByteStr, -1, v27, cchWideChar);
        v6 = v31;
      }
      else
      {
        v6 = 0;
      }
      *((_DWORD *)a1 + 3) = SysAllocString(v6);
      v3 = a2;
    }
    v9 = (const CHAR *)*((_DWORD *)v3 + 6);
    v33 = v9;
    if ( *((_DWORD *)v9 - 2) )
    {
      if ( v9 )
      {
        cchWideChar = lstrlenA(v9) + 1;
        v11 = 2 * cchWideChar + 3;
        LOBYTE(v11) = v11 & 0xFC;
        v12 = alloca(v11);
        v31 = v27;
        v27[0] = 0;
        MultiByteToWideChar(0, 0, v33, -1, v27, cchWideChar);
        v10 = v31;
      }
      else
      {
        v10 = 0;
      }
      *((_DWORD *)a1 + 1) = SysAllocString(v10);
    }
  }
  else if ( CObject::IsKindOf((CObject *)a2, (const struct CRuntimeClass *)&off_42AE40) )
  {
    AfxLoadString(0xF10Au, Buffer, 0x100u);
    *a1 = -3830;
  }
  else
  {
    AfxLoadString(0xF108u, Buffer, 0x100u);
    *a1 = -3832;
  }
  if ( lpString )
  {
    cchWideChar = lstrlenA(lpString) + 1;
    v14 = 2 * cchWideChar + 3;
    LOBYTE(v14) = v14 & 0xFC;
    v15 = alloca(v14);
    v27[0] = 0;
    MultiByteToWideChar(0, 0, lpString, -1, v27, cchWideChar);
    v13 = v27;
  }
  else
  {
    v13 = 0;
  }
  result = SysAllocString(v13);
  v17 = a1;
  v18 = *((_DWORD *)a1 + 1) == 0;
  *((_DWORD *)a1 + 2) = result;
  if ( v18 )
  {
    v19 = (const CHAR *)*((_DWORD *)AfxGetModuleState() + 4);
    v34 = v19;
    if ( v19 )
    {
      cchWideChar = lstrlenA(v19) + 1;
      v21 = 2 * cchWideChar + 3;
      LOBYTE(v21) = v21 & 0xFC;
      v22 = alloca(v21);
      v31 = v27;
      v27[0] = 0;
      MultiByteToWideChar(0, 0, v34, -1, v27, cchWideChar);
      v20 = v31;
    }
    else
    {
      v20 = 0;
    }
    result = SysAllocString(v20);
    v17 = a1;
    *((_DWORD *)a1 + 1) = result;
  }
  if ( !*((_DWORD *)v17 + 3) && *((_DWORD *)v17 + 4) )
  {
    v23 = *(const CHAR **)(*((_DWORD *)AfxGetModuleState() + 1) + 140);
    v35 = v23;
    if ( v23 )
    {
      v24 = lstrlenA(v23) + 1;
      v25 = 2 * v24 + 3;
      LOBYTE(v25) = v25 & 0xFC;
      v26 = alloca(v25);
      v31 = v27;
      v27[0] = 0;
      MultiByteToWideChar(0, 0, v35, -1, v27, v24);
      v2 = v31;
    }
    result = SysAllocString(v2);
    *((_DWORD *)a1 + 3) = result;
  }
  return result;
}


// ========== Function: sub_427225 @ 0x427225 ==========
int __thiscall sub_427225(int this, LPCSTR lpString, int a3, __int16 a4)
{
  int result; // eax

  CException::CException((CException *)this);
  *(_DWORD *)(this + 12) = off_433548;
  *(_DWORD *)(this + 20) = off_433548;
  *(_DWORD *)(this + 24) = off_433548;
  *(_DWORD *)this = &off_42B420;
  *(_DWORD *)(this + 16) = a3 != 0 ? a3 + 393216 : 0;
  *(_WORD *)(this + 8) = a4;
  if ( lpString )
    CString::operator=((void **)(this + 12), lpString);
  result = this;
  *(_DWORD *)(this + 28) = a4 != 0 ? 0 : -2147418113;
  return result;
}


// ========== Function: sub_4272B3 @ 0x4272B3 ==========
int __thiscall sub_4272B3(LPCSTR *this, LPSTR lpString1, int iMaxLength, _DWORD *a4)
{
  if ( a4 )
    *a4 = 0;
  lstrcpynA(lpString1, this[3], iMaxLength);
  return 1;
}


// ========== Function: unknown_libname_36 @ 0x4272D5 ==========
// MFC 3.1-14.0 32bit
// positive sp value has been detected, the output may be wrong!
int unknown_libname_36()
{
  int v1; // [esp-10h] [ebp-10h]
  int (*v2)(void); // [esp-Ch] [ebp-Ch]
  int v3; // [esp-8h] [ebp-8h]
  int v4; // [esp-4h] [ebp-4h]

  *(_DWORD *)(v4 + v3) = v1;
  return v2();
}


// ========== Function: sub_4272E6 @ 0x4272E6 ==========
void __thiscall sub_4272E6(void **this)
{
  *this = &_AFX_WIN_STATE::`vftable';
  AfxDeleteObject(this + 1);
}


// ========== Function: ?AfxPostQuitMessage@@YGXH@Z @ 0x427313 ==========
void __stdcall AfxPostQuitMessage(int nExitCode)
{
  struct CWinThread *Thread; // eax
  void (__stdcall *v2)(int, int); // eax

  Thread = AfxGetThread();
  if ( Thread )
  {
    v2 = (void (__stdcall *)(int, int))*((_DWORD *)Thread + 21);
    if ( v2 )
      v2(1, 1);
  }
  PostQuitMessage(nExitCode);
}


// ========== Function: ??1CWinThread@@UAE@XZ @ 0x427336 ==========
void __thiscall CWinThread::~CWinThread(CWinThread *this)
{
  void *v2; // eax
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // eax

  *(_DWORD *)this = &CWinThread::`vftable';
  v2 = (void *)*((_DWORD *)this + 10);
  if ( v2 )
    CloseHandle(v2);
  ModuleThreadState = AfxGetModuleThreadState();
  if ( *((CWinThread **)ModuleThreadState + 1) == this )
    *((_DWORD *)ModuleThreadState + 1) = 0;
  sub_41C5BD(this);
}


// ========== Function: sub_42738F @ 0x42738F ==========
int __thiscall sub_42738F(COleMessageFilter *this)
{
  *(_DWORD *)this = &COleMessageFilter::`vftable';
  COleMessageFilter::Revoke(this);
  return sub_41C5BD(this);
}


// ========== Function: ?Revoke@COleMessageFilter@@QAEXXZ @ 0x4273C7 ==========
void __thiscall COleMessageFilter::Revoke(COleMessageFilter *this)
{
  if ( *((_DWORD *)this + 7) )
  {
    CoRegisterMessageFilter(0, 0);
    *((_DWORD *)this + 7) = 0;
  }
}


// ========== Function: ?Revoke@COleObjectFactory@@QAEXXZ @ 0x4273E0 ==========
void __thiscall COleObjectFactory::Revoke(COleObjectFactory *this)
{
  if ( *((_BYTE *)this + 66) )
  {
    if ( *((_DWORD *)this + 8) )
    {
      CoRevokeClassObject(*((_DWORD *)this + 8));
      *((_DWORD *)this + 8) = 0;
    }
    *((_BYTE *)this + 66) = 0;
  }
}


// ========== Function: ?RevokeAll@COleObjectFactory@@SGXXZ @ 0x427401 ==========
void __stdcall COleObjectFactory::RevokeAll()
{
  struct AFX_MODULE_STATE *ModuleState; // esi
  COleObjectFactory *i; // esi

  ModuleState = AfxGetModuleState();
  sub_4250E4(0);
  for ( i = (COleObjectFactory *)*((_DWORD *)ModuleState + 9); i; i = (COleObjectFactory *)*((_DWORD *)i + 7) )
    COleObjectFactory::Revoke(i);
  AfxUnlockGlobals(0);
}


// ========== Function: ?AfxWinTerm@@YGXXZ @ 0x42742C ==========
void __stdcall AfxWinTerm()
{
  struct AFX_MODULE_STATE *ModuleState; // ebp
  const unsigned __int8 *v1; // ebp
  const unsigned __int8 *i; // esi
  unsigned __int8 *v3; // edi
  struct AFX_MODULE_STATE *v4; // eax
  int v5; // eax
  void (__stdcall *v6)(int, _DWORD); // eax
  struct _AFX_THREAD_STATE *ThreadState; // esi
  int v8; // ecx

  ModuleState = AfxGetModuleState();
  sub_4250E4(1);
  v1 = (const unsigned __int8 *)ModuleState + 52;
  for ( i = v1; *i; i = v3 + 1 )
  {
    v3 = _mbschr(i, 0xAu);
    *v3 = 0;
    v4 = AfxGetModuleState();
    UnregisterClassA((LPCSTR)i, *((HINSTANCE *)v4 + 2));
  }
  *v1 = 0;
  AfxUnlockGlobals(1);
  v5 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( v5 )
  {
    v6 = *(void (__stdcall **)(int, _DWORD))(v5 + 84);
    if ( v6 )
      v6(1, 0);
  }
  ThreadState = AfxGetThreadState();
  v8 = *((_DWORD *)ThreadState + 51);
  if ( v8 && (*(int (__thiscall **)(int))(*(_DWORD *)v8 + 184))(v8) )
    *((_DWORD *)ThreadState + 51) = 0;
  if ( !*((_BYTE *)AfxGetModuleState() + 20) )
  {
    if ( *((_DWORD *)ThreadState + 12) )
    {
      UnhookWindowsHookEx(*((HHOOK *)ThreadState + 12));
      *((_DWORD *)ThreadState + 12) = 0;
    }
    if ( *((_DWORD *)ThreadState + 11) )
    {
      UnhookWindowsHookEx(*((HHOOK *)ThreadState + 11));
      *((_DWORD *)ThreadState + 11) = 0;
    }
  }
}


============================================================
// Segment: .idata
============================================================


// Data @ 0x429000
uint8_t RegCloseKey[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429004
uint8_t RegSetValueExA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429008
uint8_t RegCreateKeyExA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42900C
uint8_t RegOpenKeyA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429010
uint8_t RegOpenKeyExA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429014
uint8_t RegEnumValueA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42901C
uint8_t InitCommonControls[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429024
uint8_t SetBkMode[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429028
uint8_t SetMapMode[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42902C
uint8_t SetViewportOrgEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429030
uint8_t OffsetViewportOrgEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429034
uint8_t SetViewportExtEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429038
uint8_t ScaleViewportExtEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42903C
uint8_t SetWindowExtEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429040
uint8_t ScaleWindowExtEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429044
uint8_t IntersectClipRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429048
uint8_t DeleteObject[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42904C
uint8_t GetViewportExtEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429050
uint8_t GetWindowExtEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429054
uint8_t CreateSolidBrush[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429058
uint8_t PtVisible[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42905C
uint8_t RectVisible[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429060
uint8_t TextOutA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429064
uint8_t ExtTextOutA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429068
uint8_t Escape[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42906C
uint8_t DPtoLP[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429070
uint8_t LPtoDP[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429074
uint8_t GetMapMode[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429078
uint8_t PatBlt[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42907C
uint8_t SelectObject[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429080
uint8_t RestoreDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429084
uint8_t SaveDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429088
uint8_t DeleteDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42908C
uint8_t GetStockObject[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429090
uint8_t GetDeviceCaps[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429094
uint8_t GetBkColor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429098
uint8_t GetTextColor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42909C
uint8_t GetObjectA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290A0
uint8_t SetBkColor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290A4
uint8_t SetTextColor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290A8
uint8_t GetClipBox[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290AC
uint8_t CreateDIBitmap[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290B0
uint8_t GetTextExtentPointA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290B4
uint8_t BitBlt[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290B8
uint8_t CreateCompatibleDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290BC
uint8_t CreateBitmap[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290C4
uint8_t TerminateProcess[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290C8
uint8_t HeapFree[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290CC
uint8_t HeapAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290D0
uint8_t RaiseException[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290D4
uint8_t SetStdHandle[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290D8
uint8_t GetFileType[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290DC
uint8_t HeapReAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290E0
uint8_t HeapSize[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290E4
uint8_t GetACP[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290E8
uint8_t GetTimeZoneInformation[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290EC
uint8_t UnhandledExceptionFilter[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290F0
uint8_t FreeEnvironmentStringsA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290F4
uint8_t FreeEnvironmentStringsW[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290F8
uint8_t GetEnvironmentStrings[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4290FC
uint8_t GetEnvironmentStringsW[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429100
uint8_t SetHandleCount[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429104
uint8_t GetStdHandle[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429108
uint8_t GetEnvironmentVariableA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42910C
uint8_t GetVersionExA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429110
uint8_t ExitProcess[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429114
uint8_t HeapCreate[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429118
uint8_t VirtualFree[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42911C
uint8_t VirtualAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429120
uint8_t IsBadWritePtr[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429124
uint8_t SetUnhandledExceptionFilter[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429128
uint8_t LCMapStringA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42912C
uint8_t LCMapStringW[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429130
uint8_t GetStringTypeA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429134
uint8_t GetStringTypeW[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429138
uint8_t IsBadReadPtr[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42913C
uint8_t IsBadCodePtr[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429140
uint8_t CompareStringA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429144
uint8_t CompareStringW[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429148
uint8_t SetEnvironmentVariableA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42914C
uint8_t GetCommandLineA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429150
uint8_t GetStartupInfoA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429154
uint8_t __imp_RtlUnwind[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429158
uint8_t GetProfileStringA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42915C
uint8_t GetTickCount[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429160
uint8_t FileTimeToLocalFileTime[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429164
uint8_t FileTimeToSystemTime[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429168
uint8_t SetErrorMode[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42916C
uint8_t GetFileTime[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429170
uint8_t GetFileSize[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429174
uint8_t GetFileAttributesA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429178
uint8_t GetFullPathNameA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42917C
uint8_t GetVolumeInformationA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429180
uint8_t FindFirstFileA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429184
uint8_t FindClose[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429188
uint8_t SetEndOfFile[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42918C
uint8_t UnlockFile[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429190
uint8_t LockFile[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429194
uint8_t FlushFileBuffers[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429198
uint8_t SetFilePointer[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42919C
uint8_t WriteFile[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291A0
uint8_t ReadFile[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291A4
uint8_t CreateFileA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291A8
uint8_t GetCurrentProcess[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291AC
uint8_t DuplicateHandle[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291B0
uint8_t GetOEMCP[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291B4
uint8_t GetCPInfo[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291B8
uint8_t SizeofResource[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291BC
uint8_t GetProcessVersion[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291C0
uint8_t GetLastError[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291C4
uint8_t WritePrivateProfileStringA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291C8
uint8_t GlobalFlags[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291CC
uint8_t TlsGetValue[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291D0
uint8_t LocalReAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291D4
uint8_t TlsSetValue[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291D8
uint8_t EnterCriticalSection[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291DC
uint8_t GlobalReAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291E0
uint8_t LeaveCriticalSection[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291E4
uint8_t TlsFree[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291E8
uint8_t GlobalHandle[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291EC
uint8_t DeleteCriticalSection[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291F0
uint8_t TlsAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291F4
uint8_t InitializeCriticalSection[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291F8
uint8_t LocalAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4291FC
uint8_t lstrcpynA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429200
uint8_t MulDiv[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429204
uint8_t SetLastError[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429208
uint8_t GetThreadLocale[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42920C
uint8_t FormatMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429210
uint8_t LocalFree[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429214
uint8_t MultiByteToWideChar[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429218
uint8_t WideCharToMultiByte[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42921C
uint8_t lstrlenA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429220
uint8_t InterlockedDecrement[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429224
uint8_t InterlockedIncrement[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429228
uint8_t LoadLibraryA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42922C
uint8_t FreeLibrary[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429230
uint8_t GetVersion[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429234
uint8_t lstrcatA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429238
uint8_t GlobalGetAtomNameA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42923C
uint8_t GlobalAddAtomA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429240
uint8_t GlobalFindAtomA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429244
uint8_t lstrcpyA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429248
uint8_t GetModuleHandleA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42924C
uint8_t GetProcAddress[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429250
uint8_t GlobalFree[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429254
uint8_t LockResource[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429258
uint8_t FindResourceA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42925C
uint8_t LoadResource[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429260
uint8_t CloseHandle[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429264
uint8_t GetModuleFileNameA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429268
uint8_t GlobalDeleteAtom[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42926C
uint8_t lstrcmpA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429270
uint8_t lstrcmpiA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429274
uint8_t GetCurrentThread[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429278
uint8_t GetCurrentThreadId[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42927C
uint8_t SetCurrentDirectoryA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429280
uint8_t WinExec[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429284
uint8_t GlobalAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429288
uint8_t GlobalLock[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42928C
uint8_t GlobalUnlock[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429290
uint8_t HeapDestroy[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429294
uint8_t GetCurrentDirectoryA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42929C
uint8_t VariantTimeToSystemTime[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292A0
uint8_t SysAllocStringLen[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292A4
uint8_t SysFreeString[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292A8
uint8_t VariantChangeType[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292AC
uint8_t SysAllocString[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292B0
uint8_t VariantCopy[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292B4
uint8_t SysAllocStringByteLen[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292B8
uint8_t SysStringLen[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292BC
uint8_t VariantClear[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292C4
uint8_t OleCreateFontIndirect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292CC
uint8_t ShellExecuteA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292D4
uint8_t GetSysColorBrush[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292D8
uint8_t LoadStringA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292DC
uint8_t DestroyMenu[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292E0
uint8_t CopyAcceleratorTableA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292E4
uint8_t SetRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292E8
uint8_t GetNextDlgGroupItem[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292EC
uint8_t MessageBeep[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292F0
uint8_t CharUpperA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292F4
uint8_t InvalidateRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292F8
uint8_t InflateRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4292FC
uint8_t RegisterClipboardFormatA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429300
uint8_t PostThreadMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429304
uint8_t CopyRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429308
uint8_t GetTopWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42930C
uint8_t IsChild[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429310
uint8_t GetCapture[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429314
uint8_t WinHelpA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429318
uint8_t wsprintfA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42931C
uint8_t GetClassInfoA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429320
uint8_t RegisterClassA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429324
uint8_t GetMenu[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429328
uint8_t GetMenuItemCount[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42932C
uint8_t GetSubMenu[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429330
uint8_t GetMenuItemID[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429334
uint8_t GetWindowTextLengthA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429338
uint8_t GetWindowTextA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42933C
uint8_t GetDlgCtrlID[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429340
uint8_t CreateWindowExA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429344
uint8_t GetClassLongA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429348
uint8_t SetPropA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42934C
uint8_t UnhookWindowsHookEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429350
uint8_t GetPropA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429354
uint8_t CallWindowProcA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429358
uint8_t RemovePropA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42935C
uint8_t DefWindowProcA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429360
uint8_t GetMessageTime[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429364
uint8_t GetMessagePos[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429368
uint8_t GetForegroundWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42936C
uint8_t GetWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429370
uint8_t SetWindowPos[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429374
uint8_t RegisterWindowMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429378
uint8_t OffsetRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42937C
uint8_t IntersectRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429380
uint8_t SystemParametersInfoA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429384
uint8_t GetWindowPlacement[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429388
uint8_t EndDialog[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42938C
uint8_t SetActiveWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429390
uint8_t IsWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429394
uint8_t CreateDialogIndirectParamA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429398
uint8_t DestroyWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42939C
uint8_t GetDlgItem[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293A0
uint8_t GetMenuCheckMarkDimensions[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293A4
uint8_t GetMenuState[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293A8
uint8_t ModifyMenuA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293AC
uint8_t CheckMenuItem[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293B0
uint8_t EnableMenuItem[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293B4
uint8_t GetFocus[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293B8
uint8_t GetNextDlgTabItem[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293BC
uint8_t GetMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293C0
uint8_t TranslateMessage[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293C4
uint8_t DispatchMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293C8
uint8_t GetActiveWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293CC
uint8_t GetKeyState[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293D0
uint8_t CallNextHookEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293D4
uint8_t ValidateRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293D8
uint8_t IsWindowVisible[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293DC
uint8_t PeekMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293E0
uint8_t GetCursorPos[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293E4
uint8_t SetWindowsHookExA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293E8
uint8_t GetParent[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293EC
uint8_t GetLastActivePopup[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293F0
uint8_t IsWindowEnabled[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293F4
uint8_t GetWindowLongA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293F8
uint8_t MessageBoxA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4293FC
uint8_t SetCursor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429400
uint8_t PostQuitMessage[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429404
uint8_t PostMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429408
uint8_t LoadIconA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42940C
uint8_t GetWindowRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429410
uint8_t SetTimer[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429414
uint8_t UnregisterClassA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429418
uint8_t HideCaret[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42941C
uint8_t ShowCaret[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429420
uint8_t ExcludeUpdateRgn[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429424
uint8_t DrawFocusRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429428
uint8_t EnableWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42942C
uint8_t RegisterHotKey[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429430
uint8_t KillTimer[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429434
uint8_t UnregisterHotKey[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429438
uint8_t LoadBitmapA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42943C
uint8_t GetDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429440
uint8_t DrawStateA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429444
uint8_t keybd_event[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429448
uint8_t OpenClipboard[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42944C
uint8_t EmptyClipboard[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429450
uint8_t SetClipboardData[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429454
uint8_t CloseClipboard[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429458
uint8_t IsIconic[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42945C
uint8_t GetSystemMetrics[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429460
uint8_t PtInRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429464
uint8_t GetClassNameA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429468
uint8_t SetForegroundWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42946C
uint8_t GetDesktopWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429470
uint8_t GetClientRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429474
uint8_t DrawIcon[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429478
uint8_t DefDlgProcA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42947C
uint8_t IsWindowUnicode[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429480
uint8_t SendMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429484
uint8_t LoadCursorA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429488
uint8_t GrayStringA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42948C
uint8_t DrawTextA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429490
uint8_t TabbedTextOutA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429494
uint8_t EndPaint[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429498
uint8_t BeginPaint[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42949C
uint8_t GetWindowDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294A0
uint8_t ReleaseDC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294A4
uint8_t ClientToScreen[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294A8
uint8_t CharNextA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294AC
uint8_t ShowWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294B0
uint8_t MoveWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294B4
uint8_t SetWindowTextA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294B8
uint8_t IsDialogMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294BC
uint8_t MapDialogRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294C0
uint8_t SetWindowContextHelpId[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294C4
uint8_t UpdateWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294C8
uint8_t SendDlgItemMessageA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294CC
uint8_t MapWindowPoints[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294D0
uint8_t GetSysColor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294D4
uint8_t SetFocus[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294D8
uint8_t SetMenuItemBitmaps[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294DC
uint8_t AdjustWindowRectEx[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294E0
uint8_t ScreenToClient[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294E4
uint8_t SetWindowLongA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294EC
uint8_t __imp_ClosePrinter[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294F0
uint8_t __imp_DocumentPropertiesA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294F4
uint8_t __imp_OpenPrinterA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4294FC
uint8_t __imp_GetOpenFileNameA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429500
uint8_t __imp_GetSaveFileNameA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429504
uint8_t __imp_GetFileTitleA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42950C
uint8_t CoFreeUnusedLibraries[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429510
uint8_t OleInitialize[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429514
uint8_t CoTaskMemAlloc[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429518
uint8_t CoTaskMemFree[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42951C
uint8_t CreateILockBytesOnHGlobal[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429520
uint8_t StgCreateDocfileOnILockBytes[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429524
uint8_t StgOpenStorageOnILockBytes[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429528
uint8_t CoGetClassObject[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42952C
uint8_t CLSIDFromString[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429530
uint8_t CLSIDFromProgID[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429534
uint8_t CoRegisterMessageFilter[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429538
uint8_t CoRevokeClassObject[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42953C
uint8_t OleFlushClipboard[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429540
uint8_t OleIsCurrentClipboard[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x429544
uint8_t OleUninitialize[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42954C
uint8_t __imp_OleUIBusyA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

============================================================
// Segment: .rdata
============================================================


// Data @ 0x429558
uint8_t off_429558[4] = {
    0x10, 0x9A, 0x42, 0x00
};

// Data @ 0x429560
uint8_t unk_429560[1] = {
    0x11
};

// Data @ 0x429590
const char off_429590[] = "L?B";

// Data @ 0x429630
const char off_429630[] = " ";

// Data @ 0x429638
uint8_t unk_429638[1] = {
    0x0F
};

// Data @ 0x429830
uint8_t off_429830[4] = {
    0xAF, 0x41, 0x42, 0x00
};

// Data @ 0x429900
const char off_429900[] = "@N@";

// Data @ 0x4299B8
const char unk_4299B8[] = "a";

// Data @ 0x4299C8
uint8_t off_4299C8[4] = {
    0xDD, 0x47, 0x42, 0x00
};

// Data @ 0x4299D8
const char off_4299D8[] = "P3C";

// Data @ 0x4299F0
const char off_4299F0[] = "\x08";

// Data @ 0x429A08
const char aCwinapp[] = "CWinApp";

// Data @ 0x429A10
const char off_429A10[] = "(";

// Data @ 0x429A18
uint8_t unk_429A18[1] = {
    0x11
};

// Data @ 0x429A78
const char ValueName[] = "PreviewPages";

// Data @ 0x429A88
const char aSettings[] = "Settings";

// Data @ 0x429A98
const char ??_7_AFX_WIN_STATE@@6B@[] = "K<B";

// Data @ 0x429AA0
const char ??_7CWinApp@@6B@[] = "L?B";

// Data @ 0x429B40
const char off_429B40[] = "X";

// Data @ 0x429B58
const char aCwinthread[] = "CWinThread";

// Data @ 0x429B68
const char ??_7CWinThread@@6B@[] = "/@B";

// Data @ 0x429BE8
uint8_t ??_7_AFX_CTL3D_STATE@@6B@[4] = {
    0x93, 0x40, 0x42, 0x00
};

// Data @ 0x429BF0
uint8_t ??_7_AFX_CTL3D_THREAD@@6B@[4] = {
    0xAE, 0x40, 0x42, 0x00
};

// Data @ 0x429BF8
uint8_t off_429BF8[4] = {
    0x10, 0x9C, 0x42, 0x00
};

// Data @ 0x429C10
const char aCcmdtarget[] = "CCmdTarget";

// Data @ 0x429C1C
uint8_t unk_429C1C[1] = {
    0x06
};

// Data @ 0x429C28
uint8_t unk_429C28[1] = {
    0x00
};

// Data @ 0x429C48
uint8_t unk_429C48[1] = {
    0x00
};

// Data @ 0x429C78
uint8_t unk_429C78[1] = {
    0x00
};

// Data @ 0x429CB0
uint8_t unk_429CB0[1] = {
    0x00
};

// Data @ 0x429CC8
uint8_t unk_429CC8[1] = {
    0x00
};

// Data @ 0x429CD8
uint8_t unk_429CD8[1] = {
    0x00
};

// Data @ 0x429CF0
uint8_t off_429CF0[4] = {
    0xB7, 0xC8, 0x41, 0x00
};

// Data @ 0x429D00
uint8_t off_429D00[4] = {
    0x18, 0x9D, 0x42, 0x00
};

// Data @ 0x429D18
const char aCdialog[] = "CDialog";

// Data @ 0x429D20
const char off_429D20[] = "@";

// Data @ 0x429D28
uint8_t unk_429D28[1] = {
    0x19
};

// Data @ 0x429E00
const char aEdit_0[] = "Edit";

// Data @ 0x429E0C
uint8_t ??_7CDialog@@6B@[4] = {
    0xAF, 0x41, 0x42, 0x00
};

// Data @ 0x429EDC
const char aHelv[] = "Helv";

// Data @ 0x429EE4
const char aMsSansSerif[] = "MS Sans Serif";

// Data @ 0x429EF4
const char aMsShellDlg[] = "MS Shell Dlg";

// Data @ 0x429F08
const char off_429F08[] = " ";

// Data @ 0x429F20
const char aCcombobox[] = "CComboBox";

// Data @ 0x429F30
uint8_t ??_7CComboBox@@6B@[4] = {
    0xB5, 0x41, 0x42, 0x00
};

// Data @ 0x429FF8
uint8_t off_429FF8[4] = {
    0x10, 0xA0, 0x42, 0x00
};

// Data @ 0x42A010
const char aCtempwnd[] = "CTempWnd";

// Data @ 0x42A020
const char off_42A020[] = "8";

// Data @ 0x42A038
const char aCwnd[] = "CWnd";

// Data @ 0x42A040
const char off_42A040[] = "(";

// Data @ 0x42A048
const char unk_42A048[] = "8";

// Data @ 0x42A2E8
const char String[] = "AfxOldWndProc423";

// Data @ 0x42A2FC
const char aAfxwnd42s[] = "AfxWnd42s";

// Data @ 0x42A308
const char aAfxcontrolbar4[] = "AfxControlBar42s";

// Data @ 0x42A31C
const char aAfxmdiframe42s[] = "AfxMDIFrame42s";

// Data @ 0x42A32C
const char aAfxframeorview[] = "AfxFrameOrView42s";

// Data @ 0x42A340
const char aAfxolecontrol4[] = "AfxOleControl42s";

// Data @ 0x42A354
const char aGetmonitorinfo[] = "GetMonitorInfoA";

// Data @ 0x42A364
const char aEnumdisplaymon[] = "EnumDisplayMonitors";

// Data @ 0x42A378
const char aMonitorfrompoi[] = "MonitorFromPoint";

// Data @ 0x42A38C
const char aMonitorfromrec[] = "MonitorFromRect";

// Data @ 0x42A39C
const char aMonitorfromwin[] = "MonitorFromWindow";

// Data @ 0x42A3B0
const char ProcName[] = "GetSystemMetrics";

// Data @ 0x42A3C4
const char ModuleName[] = "USER32";

// Data @ 0x42A3CC
const char String2[] = "DISPLAY";

// Data @ 0x42A3D4
const char aCommctrlDragli[] = "commctrl_DragListMsg";

// Data @ 0x42A3F0
uint8_t ??_7CWnd@@6B@[4] = {
    0xED, 0x41, 0x42, 0x00
};

// Data @ 0x42A4A8
const char aIme[] = "ime";

// Data @ 0x42A4B0
uint8_t ??_7CTestCmdUI@@6B@[4] = {
    0x9B, 0xEB, 0x41, 0x00
};

// Data @ 0x42A4C0
const char aInitcommoncont[] = "InitCommonControlsEx";

// Data @ 0x42A4D8
const char aComctl32Dll_0[] = "COMCTL32.DLL";

// Data @ 0x42A4EC
const char ??_7CTempWnd@@6B@[] = "XBB";

// Data @ 0x42A5A8
const char ??_7COccManager@@6B@[] = ""Z@";

// Data @ 0x42A5D0
const char Format[] = "%*.*f";

// Data @ 0x42A5D8
const char aI64[] = "I64";

// Data @ 0x42A5E0
uint8_t ??_7_AFX_THREAD_STATE@@6B@[4] = {
    0x97, 0x43, 0x42, 0x00
};

// Data @ 0x42A5E8
uint8_t ??_7AFX_MODULE_STATE@@6B@[4] = {
    0xBA, 0x44, 0x42, 0x00
};

// Data @ 0x42A5F0
const char ??_7AFX_MODULE_THREAD_STATE@@6B@[] = "iEB";

// Data @ 0x42A5F8
uint8_t ??_7_AFX_BASE_MODULE_STATE@@6B@[4] = {
    0xF2, 0x46, 0x42, 0x00
};

// Data @ 0x42A600
uint8_t off_42A600[4] = {
    0xB0, 0x9C, 0x42, 0x00
};

// Data @ 0x42A608
const char off_42A608[] = "@";

// Data @ 0x42A618
const char off_42A618[] = "H";

// Data @ 0x42A628
uint8_t unk_42A628[1] = {
    0x00
};

// Data @ 0x42A648
uint8_t off_42A648[4] = {
    0xB0, 0x9C, 0x42, 0x00
};

// Data @ 0x42A650
const char off_42A650[] = "`";

// Data @ 0x42A66C
uint8_t off_42A66C[4] = {
    0xA9, 0x41, 0x42, 0x00
};

// Data @ 0x42A700
uint8_t ??_7XOleContainer@COleControlContainer@@6B@[4] = {
    0x82, 0x66, 0x40, 0x00
};

// Data @ 0x42A71C
const char ??_7XOleIPFrame@COleControlContainer@@6B@[] = "ie@";

// Data @ 0x42A75C
uint8_t ??_7CGdiObject@@6B@[4] = {
    0xD1, 0x47, 0x42, 0x00
};

// Data @ 0x42A76C
uint8_t ??_7CFont@@6B@[4] = {
    0xD7, 0x47, 0x42, 0x00
};

// Data @ 0x42A77C
uint8_t ??_7CEnumUnknown@@6B@[4] = {
    0xA9, 0x41, 0x42, 0x00
};

// Data @ 0x42A7DC
const char aD[] = "%d";

// Data @ 0x42A7E0
uint8_t off_42A7E0[4] = {
    0xF8, 0xA7, 0x42, 0x00
};

// Data @ 0x42A7F8
const char aCstdiofile[] = "CStdioFile";

// Data @ 0x42A808
uint8_t ??_7CStdioFile@@6B@[4] = {
    0x12, 0x47, 0x42, 0x00
};

// Data @ 0x42A86C
const char ??_7CFileException@@6B@[] = "vTB";

// Data @ 0x42A880
uint8_t off_42A880[4] = {
    0x98, 0xA8, 0x42, 0x00
};

// Data @ 0x42A898
const char aCtempgdiobject[] = "CTempGdiObject";

// Data @ 0x42A8A8
uint8_t off_42A8A8[4] = {
    0xC0, 0xA8, 0x42, 0x00
};

// Data @ 0x42A8C0
const char aCtempdc[] = "CTempDC";

// Data @ 0x42A8C8
uint8_t off_42A8C8[4] = {
    0xE0, 0xA8, 0x42, 0x00
};

// Data @ 0x42A8E0
const char aCbitmap[] = "CBitmap";

// Data @ 0x42A8E8
uint8_t off_42A8E8[4] = {
    0x00, 0xA9, 0x42, 0x00
};

// Data @ 0x42A900
const char aCfont[] = "CFont";

// Data @ 0x42A908
const char off_42A908[] = " ";

// Data @ 0x42A920
const char aCgdiobject[] = "CGdiObject";

// Data @ 0x42A930
const char off_42A930[] = "H";

// Data @ 0x42A948
const char aCpaintdc[] = "CPaintDC";

// Data @ 0x42A958
const char off_42A958[] = "p";

// Data @ 0x42A970
const char aCwindowdc[] = "CWindowDC";

// Data @ 0x42A980
uint8_t off_42A980[4] = {
    0x98, 0xA9, 0x42, 0x00
};

// Data @ 0x42A998
const char aCclientdc[] = "CClientDC";

// Data @ 0x42A9A8
uint8_t off_42A9A8[4] = {
    0xC0, 0xA9, 0x42, 0x00
};

// Data @ 0x42A9C0
const char off_42A9C0[] = "CDC";

// Data @ 0x42A9C8
uint8_t off_42A9C8[4] = {
    0xE0, 0xA9, 0x42, 0x00
};

// Data @ 0x42A9E0
const char aCuserexception[] = "CUserException";

// Data @ 0x42A9F0
const char off_42A9F0[] = "\x08";

// Data @ 0x42AA08
const char aCresourceexcep[] = "CResourceException";

// Data @ 0x42AA20
uint8_t ??_7CDC@@6B@[4] = {
    0x9F, 0x47, 0x42, 0x00
};

// Data @ 0x42AA98
uint8_t ??_7CClientDC@@6B@[4] = {
    0xA5, 0x47, 0x42, 0x00
};

// Data @ 0x42AB10
uint8_t ??_7CWindowDC@@6B@[4] = {
    0xAB, 0x47, 0x42, 0x00
};

// Data @ 0x42AB88
uint8_t ??_7CPaintDC@@6B@[4] = {
    0xB1, 0x47, 0x42, 0x00
};

// Data @ 0x42AC00
const char ??_7CTempDC@@6B@[] = ".HB";

// Data @ 0x42AC78
uint8_t ??_7CTempGdiObject@@6B@[4] = {
    0x99, 0x48, 0x42, 0x00
};

// Data @ 0x42AC88
uint8_t ??_7CResourceException@@6B@[4] = {
    0x18, 0x47, 0x42, 0x00
};

// Data @ 0x42ACA0
const char ??_7CUserException@@6B@[] = "PGB";

// Data @ 0x42ACB8
uint8_t off_42ACB8[4] = {
    0xD0, 0xAC, 0x42, 0x00
};

// Data @ 0x42ACD0
const char aCfiledialog[] = "CFileDialog";

// Data @ 0x42ACE0
uint8_t ??_7CFileDialog@@6B@[4] = {
    0x1F, 0x49, 0x42, 0x00
};

// Data @ 0x42ADD0
uint8_t ??_7CThreadData@@6B@[4] = {
    0xA2, 0x4C, 0x42, 0x00
};

// Data @ 0x42ADD4
const char aCombobox[] = "combobox";

// Data @ 0x42ADE0
const char SubKey[] = "software";

// Data @ 0x42AE08
const char aCobject[] = "CObject";

// Data @ 0x42AE10
const char off_42AE10[] = "(";

// Data @ 0x42AE28
const char aCnotsupportede[] = "CNotSupportedException";

// Data @ 0x42AE40
const char off_42AE40[] = "X";

// Data @ 0x42AE58
const char aCmemoryexcepti[] = "CMemoryException";

// Data @ 0x42AE88
const char aCexception[] = "CException";

// Data @ 0x42AE98
uint8_t ??_7CMemoryException@@6B@[4] = {
    0xE1, 0x4F, 0x42, 0x00
};

// Data @ 0x42AEB0
uint8_t ??_7CNotSupportedException@@6B@[4] = {
    0x19, 0x50, 0x42, 0x00
};

// Data @ 0x42AEC8
const char ??_7CHandleMap@@6B@[] = "vj@";

// Data @ 0x42AECC
const char MultiByteStr[] = "System";

// Data @ 0x42AED8
uint8_t off_42AED8[4] = {
    0xF0, 0xAE, 0x42, 0x00
};

// Data @ 0x42AEF0
const char aCmapptrtoptr[] = "CMapPtrToPtr";

// Data @ 0x42AF04
const char ??_7CMapPtrToPtr@@6B@[] = "ZSB";

// Data @ 0x42AF10
const char off_42AF10[] = "(";

// Data @ 0x42AF28
const char aCtempmenu[] = "CTempMenu";

// Data @ 0x42AF38
const char off_42AF38[] = "P";

// Data @ 0x42AF50
const char aCmenu[] = "CMenu";

// Data @ 0x42AF5C
uint8_t ??_7CMenu@@6B@[4] = {
    0xAD, 0x53, 0x42, 0x00
};

// Data @ 0x42AF74
uint8_t ??_7CTempMenu@@6B@[4] = {
    0x18, 0x54, 0x42, 0x00
};

// Data @ 0x42AF98
uint8_t unk_42AF98[1] = {
    0xB3
};

// Data @ 0x42AFA8
const char unk_42AFA8[] = "@"";

// Data @ 0x42AFBC
uint8_t unk_42AFBC[1] = {
    0x04
};

// Data @ 0x42AFF8
uint8_t off_42AFF8[4] = {
    0xB0, 0x9C, 0x42, 0x00
};

// Data @ 0x42AFFC
uint8_t off_42AFFC[4] = {
    0x00, 0xB0, 0x42, 0x00
};

// Data @ 0x42B000
const char off_42B000[] = "`";

// Data @ 0x42B044
uint8_t off_42B044[4] = {
    0xA9, 0x41, 0x42, 0x00
};

// Data @ 0x42B108
const char ??_7XRowsetNotify@COleControlSite@@6B@[] = "G";

// Data @ 0x42B124
const char ??_7XNotifyDBEvents@COleControlSite@@6B@[] = "|";

// Data @ 0x42B150
const char ??_7XBoundObjectSite@COleControlSite@@6B@[] = "D";

// Data @ 0x42B164
uint8_t ??_7XEventSink@COleControlSite@@6B@[4] = {
    0x9B, 0x8D, 0x40, 0x00
};

// Data @ 0x42B184
uint8_t ??_7XPropertyNotifySink@COleControlSite@@6B@[4] = {
    0xDB, 0x8B, 0x40, 0x00
};

// Data @ 0x42B19C
uint8_t ??_7XAmbientProps@COleControlSite@@6B@[4] = {
    0x90, 0x8B, 0x40, 0x00
};

// Data @ 0x42B1BC
const char ??_7XOleControlSite@COleControlSite@@6B@[] = ".";

// Data @ 0x42B1E8
uint8_t ??_7XOleIPSite@COleControlSite@@6B@[4] = {
    0x97, 0x88, 0x40, 0x00
};

// Data @ 0x42B228
uint8_t ??_7XOleClientSite@COleControlSite@@6B@[4] = {
    0x19, 0x88, 0x40, 0x00
};

// Data @ 0x42B250
uint8_t ??_7CDataSourceControl@@6B@[4] = {
    0x87, 0x93, 0x40, 0x00
};

// Data @ 0x42B268
uint8_t dbl_42B268[8] = {
    0x9A, 0x99, 0x99, 0x99, 0x99, 0x99, 0xB9, 0x3F
};

// Data @ 0x42B270
uint8_t off_42B270[4] = {
    0x88, 0xB2, 0x42, 0x00
};

// Data @ 0x42B288
const char aCmemfile[] = "CMemFile";

// Data @ 0x42B298
const char ??_7CMemFile@@6B@[] = "^TB";

// Data @ 0x42B300
uint8_t off_42B300[4] = {
    0x18, 0xB3, 0x42, 0x00
};

// Data @ 0x42B318
const char aCptrlist[] = "CPtrList";

// Data @ 0x42B328
const char ??_7CPtrList@@6B@[] = "dTB";

// Data @ 0x42B338
const char off_42B338[] = "P";

// Data @ 0x42B350
const char aColedispatchex[] = "COleDispatchException";

// Data @ 0x42B368
uint8_t dword_42B368[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42B3A4
uint8_t unk_42B3A4[1] = {
    0x00
};

// Data @ 0x42B3E0
uint8_t unk_42B3E0[1] = {
    0x00
};

// Data @ 0x42B420
const char off_42B420[] = "jTB";

// Data @ 0x42B438
uint8_t ??_7CEnumArray@@6B@[4] = {
    0xA9, 0x41, 0x42, 0x00
};

// Data @ 0x42B49C
const char ??_7XEnumVOID@CEnumArray@@6B@[] = "\x0b_B";

// Data @ 0x42B4B8
uint8_t off_42B4B8[4] = {
    0xD0, 0xB4, 0x42, 0x00
};

// Data @ 0x42B4D0
const char aCfile[] = "CFile";

// Data @ 0x42B4DC
const char ??_7CFile@@6B@[] = "pTB";

// Data @ 0x42B530
const char off_42B530[] = "H";

// Data @ 0x42B548
const char aCfileexception[] = "CFileException";

// Data @ 0x42B558
const char off_42B558[] = " ";

// Data @ 0x42B560
const char unk_42B560[] = "S";

// Data @ 0x42B590
const char aCommdlgSetrgbc[] = "commdlg_SetRGBColor";

// Data @ 0x42B5A4
const char aCommdlgHelp[] = "commdlg_help";

// Data @ 0x42B5B4
const char aCommdlgColorok[] = "commdlg_ColorOK";

// Data @ 0x42B5C4
const char aCommdlgFilenam[] = "commdlg_FileNameOK";

// Data @ 0x42B5D8
const char aCommdlgSharevi[] = "commdlg_ShareViolation";

// Data @ 0x42B5F0
const char aCommdlgLbselch[] = "commdlg_LBSelChangedNotify";

// Data @ 0x42B60C
const char aMswheelRollmsg[] = "MSWHEEL_ROLLMSG";

// Data @ 0x42B61C
const char aIni[] = ".INI";

// Data @ 0x42B624
const char aHlp[] = ".HLP";

// Data @ 0x42B630
const char dbl_42B630[] = ")Q";

// Data @ 0x42B638
uint8_t dbl_42B638[8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42B640
const char aRicheditTextAn[] = "RichEdit Text and Objects";

// Data @ 0x42B65C
const char aRichTextFormat[] = "Rich Text Format";

// Data @ 0x42B670
const char aFilenamew[] = "FileNameW";

// Data @ 0x42B67C
const char aFilename[] = "FileName";

// Data @ 0x42B688
const char aLinkSourceDesc[] = "Link Source Descriptor";

// Data @ 0x42B6A0
const char aObjectDescript[] = "Object Descriptor";

// Data @ 0x42B6B4
const char aLinkSource[] = "Link Source";

// Data @ 0x42B6C0
const char aEmbedSource[] = "Embed Source";

// Data @ 0x42B6D0
const char aEmbeddedObject[] = "Embedded Object";

// Data @ 0x42B6E0
const char aObjectlink[] = "ObjectLink";

// Data @ 0x42B6EC
const char aOwnerlink[] = "OwnerLink";

// Data @ 0x42B6F8
const char szFormat[] = "Native";

// Data @ 0x42B704
uint8_t ??_7CArchiveStream@@6B@[4] = {
    0xEB, 0xB7, 0x41, 0x00
};

// Data @ 0x42B740
const char off_42B740[] = "X";

// Data @ 0x42B758
const char aColeexception[] = "COleException";

// Data @ 0x42B76C
uint8_t ??_7COleException@@6B@[4] = {
    0xC0, 0x58, 0x42, 0x00
};

// Data @ 0x42B780
uint8_t off_42B780[4] = {
    0xB0, 0x9C, 0x42, 0x00
};

// Data @ 0x42B788
uint8_t off_42B788[4] = {
    0x98, 0xCB, 0x42, 0x00
};

// Data @ 0x42B798
uint8_t unk_42B798[1] = {
    0x00
};

// Data @ 0x42B7D4
uint8_t off_42B7D4[4] = {
    0xC8, 0xE1, 0x42, 0x00
};

// Data @ 0x42B7D8
uint8_t ??_7COleMessageFilter@@6B@[4] = {
    0xA9, 0x41, 0x42, 0x00
};

// Data @ 0x42B844
uint8_t ??_7XMessageFilter@COleMessageFilter@@6B@[4] = {
    0xD7, 0x62, 0x42, 0x00
};

// Data @ 0x42B860
const char off_42B860[] = "x";

// Data @ 0x42B878
const char aColebusydialog[] = "COleBusyDialog";

// Data @ 0x42B8A0
const char aColedialog[] = "COleDialog";

// Data @ 0x42B8B0
const char ??_7COleBusyDialog@@6B@[] = "CYB";

// Data @ 0x42BD14
const char off_42BD14[] = "RYB";

// Data @ 0x42BD18
uint8_t stru_42BD18[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x5B, 0xCA, 0x40, 0x00
};

// Data @ 0x42BD28
uint8_t stru_42BD28[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xAF, 0xCA, 0x40, 0x00, 0xB9, 0xCA, 0x40, 0x00
};

// Data @ 0x42BD38
uint8_t stru_42BD38[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x28, 0xCF, 0x40, 0x00
};

// Data @ 0x42BD48
uint8_t stru_42BD48[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x6E, 0xD1, 0x40, 0x00, 0x82, 0xD1, 0x40, 0x00
};

// Data @ 0x42BD58
uint8_t ??_7type_info@@6B@[4] = {
    0xFF, 0xD1, 0x40, 0x00
};

// Data @ 0x42BD60
uint8_t stru_42BD60[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xD3, 0x40, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x48, 0xD4, 0x40, 0x00
};

// Data @ 0x42BD78
uint8_t stru_42BD78[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x21, 0xD6, 0x40, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x7D, 0xD6, 0x40, 0x00
};

// Data @ 0x42BD90
const char unk_42BD90[] = "csm";

// Data @ 0x42BDB0
uint8_t stru_42BDB0[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xF2, 0x40, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x41, 0xF3, 0x40, 0x00
};

// Data @ 0x42BDC8
uint8_t stru_42BDC8[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xE8, 0xF3, 0x40, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x63, 0xF4, 0x40, 0x00
};

// Data @ 0x42BDE0
uint8_t stru_42BDE0[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x70, 0xFA, 0x40, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0xFB, 0x40, 0x00
};

// Data @ 0x42BDF8
uint8_t dbl_42BDF8[8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F
};

// Data @ 0x42BE00
const char aHMmSs[] = "H:mm:ss";

// Data @ 0x42BE08
const char aDdddMmmmDdYyyy[] = "dddd, MMMM dd, yyyy";

// Data @ 0x42BE1C
const char aMDYy[] = "M/d/yy";

// Data @ 0x42BE24
const char aPm[] = "PM";

// Data @ 0x42BE28
const char aAm[] = "AM";

// Data @ 0x42BE2C
const char aDecember[] = "December";

// Data @ 0x42BE38
const char aNovember[] = "November";

// Data @ 0x42BE44
const char aOctober[] = "October";

// Data @ 0x42BE4C
const char aSeptember[] = "September";

// Data @ 0x42BE58
const char aAugust[] = "August";

// Data @ 0x42BE60
const char aJuly[] = "July";

// Data @ 0x42BE68
const char aJune[] = "June";

// Data @ 0x42BE70
const char aApril[] = "April";

// Data @ 0x42BE78
const char aMarch[] = "March";

// Data @ 0x42BE80
const char aFebruary[] = "February";

// Data @ 0x42BE8C
const char aJanuary[] = "January";

// Data @ 0x42BE94
const char aDec[] = "Dec";

// Data @ 0x42BE98
const char aNov[] = "Nov";

// Data @ 0x42BE9C
const char aOct[] = "Oct";

// Data @ 0x42BEA0
const char aSep[] = "Sep";

// Data @ 0x42BEA4
const char aAug[] = "Aug";

// Data @ 0x42BEA8
const char aJul[] = "Jul";

// Data @ 0x42BEAC
const char aJun[] = "Jun";

// Data @ 0x42BEB0
const char aMay[] = "May";

// Data @ 0x42BEB4
const char aApr[] = "Apr";

// Data @ 0x42BEB8
const char aMar[] = "Mar";

// Data @ 0x42BEBC
const char aFeb[] = "Feb";

// Data @ 0x42BEC0
const char aJan[] = "Jan";

// Data @ 0x42BEC4
const char aSaturday[] = "Saturday";

// Data @ 0x42BED0
const char aFriday[] = "Friday";

// Data @ 0x42BED8
const char aThursday[] = "Thursday";

// Data @ 0x42BEE4
const char aWednesday[] = "Wednesday";

// Data @ 0x42BEF0
const char aTuesday[] = "Tuesday";

// Data @ 0x42BEF8
const char aMonday[] = "Monday";

// Data @ 0x42BF00
const char aSunday[] = "Sunday";

// Data @ 0x42BF08
const char aSat[] = "Sat";

// Data @ 0x42BF0C
const char aFri[] = "Fri";

// Data @ 0x42BF10
const char aThu[] = "Thu";

// Data @ 0x42BF14
const char aWed[] = "Wed";

// Data @ 0x42BF18
const char aTue[] = "Tue";

// Data @ 0x42BF1C
const char aMon[] = "Mon";

// Data @ 0x42BF20
const char aSun[] = "Sun";

// Data @ 0x42BF28
uint8_t stru_42BF28[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x01, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x01, 0x41, 0x00, 0xA4, 0x01, 0x41, 0x00
};

// Data @ 0x42BF40
uint8_t stru_42BF40[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x02, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF6, 0x01, 0x41, 0x00, 0xFA, 0x01, 0x41, 0x00
};

// Data @ 0x42BF58
uint8_t stru_42BF58[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xCB, 0x05, 0x41, 0x00, 0xD5, 0x05, 0x41, 0x00
};

// Data @ 0x42BF68
uint8_t stru_42BF68[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x44, 0x07, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x22, 0x07, 0x41, 0x00, 0x2C, 0x07, 0x41, 0x00
};

// Data @ 0x42BF80
uint8_t stru_42BF80[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x7A, 0x09, 0x41, 0x00, 0x7E, 0x09, 0x41, 0x00
};

// Data @ 0x42BF90
uint8_t stru_42BF90[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x09, 0x41, 0x00, 0xE5, 0x09, 0x41, 0x00
};

// Data @ 0x42BF9C
const char Str1[] = "__GLOBAL_HEAP_SELECTED";

// Data @ 0x42BFB4
const char Name[] = "__MSVCRT_HEAP_SELECT";

// Data @ 0x42BFCC
const char aRuntimeError[] = "runtime error ";

// Data @ 0x42BFE0
const char aTlossError[] = "TLOSS error\r\n";

// Data @ 0x42BFF0
const char aSingError[] = "SING error\r\n";

// Data @ 0x42C000
const char aDomainError[] = "DOMAIN error\r\n";

// Data @ 0x42C010
const char aR6028UnableToI[] = "R6028\r\n- unable to initialize heap\r\n";

// Data @ 0x42C038
const char aR6027NotEnough[] = "R6027\r\n- not enough space for lowio initialization\r\n";

// Data @ 0x42C070
const char aR6026NotEnough[] = "R6026\r\n- not enough space for stdio initialization\r\n";

// Data @ 0x42C0A8
const char aR6025PureVirtu[] = "R6025\r\n- pure virtual function call\r\n";

// Data @ 0x42C0D0
const char aR6024NotEnough[] = "R6024\r\n- not enough space for _onexit/atexit table\r\n";

// Data @ 0x42C108
const char aR6019UnableToO[] = "R6019\r\n- unable to open console device\r\n";

// Data @ 0x42C134
const char aR6018Unexpecte[] = "R6018\r\n- unexpected heap error\r\n";

// Data @ 0x42C158
const char aR6017Unexpecte[] = "R6017\r\n- unexpected multithread lock error\r\n";

// Data @ 0x42C188
const char aR6016NotEnough[] = "R6016\r\n- not enough space for thread data\r\n";

// Data @ 0x42C1B4
const char aAbnormalProgra[] = "\r\nabnormal program termination\r\n";

// Data @ 0x42C1D8
const char aR6009NotEnough[] = "R6009\r\n- not enough space for environment\r\n";

// Data @ 0x42C204
const char aR6008NotEnough[] = "R6008\r\n- not enough space for arguments\r\n";

// Data @ 0x42C230
const char aR6002FloatingP[] = "R6002\r\n- floating point not loaded\r\n";

// Data @ 0x42C258
const char aMicrosoftVisua[] = "Microsoft Visual C++ Runtime Library";

// Data @ 0x42C280
const char asc_42C280[] = "\n\n";

// Data @ 0x42C284
const char aRuntimeErrorPr[] = "Runtime Error!\n\nProgram: ";

// Data @ 0x42C2A0
const char asc_42C2A0[] = "...";

// Data @ 0x42C2A4
const char aProgramNameUnk[] = "<program name unknown>";

// Data @ 0x42C2C0
uint8_t stru_42C2C0[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x2B, 0x41, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x51, 0x2C, 0x41, 0x00
};

// Data @ 0x42C2D8
uint8_t byte_42C2D8[1] = {
    0x00
};

// Data @ 0x42C2DC
uint8_t String1[2] = {
    0x00, 0x00
};

// Data @ 0x42C2E0
uint8_t stru_42C2E0[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x2F, 0x41, 0x00, 0x0E, 0x2F, 0x41, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0xBE, 0x2F, 0x41, 0x00, 0xC2, 0x2F, 0x41, 0x00
};

// Data @ 0x42C2F8
uint8_t byte_42C2F8[1] = {
    0x06
};

// Data @ 0x42C354
const char aNull_0[] = "(";

// Data @ 0x42C364
const char aNull[] = "(null)";

// Data @ 0x42C370
uint8_t stru_42C370[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x31, 0x3C, 0x41, 0x00, 0x35, 0x3C, 0x41, 0x00
};

// Data @ 0x42C380
uint8_t dbl_42C380[8] = {
    0x00, 0x00, 0x00, 0xC0, 0x7E, 0x01, 0x50, 0x41
};

// Data @ 0x42C388
uint8_t dbl_42C388[8] = {
    0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x47, 0x41
};

// Data @ 0x42C390
const char aIsprocessorfea[] = "IsProcessorFeaturePresent";

// Data @ 0x42C3AC
const char aKernel32[] = "KERNEL32";

// Data @ 0x42C3B8
const char aE000[] = "e+000";

// Data @ 0x42C3C0
const char aYn[] = "_yn";

// Data @ 0x42C3C4
const char aY1[] = "_y1";

// Data @ 0x42C3C8
const char aY0[] = "_y0";

// Data @ 0x42C3CC
const char aFrexp[] = "frexp";

// Data @ 0x42C3D4
const char aFmod[] = "fmod";

// Data @ 0x42C3DC
const char aHypot[] = "_hypot";

// Data @ 0x42C3E4
const char aCabs[] = "_cabs";

// Data @ 0x42C3EC
const char aLdexp[] = "ldexp";

// Data @ 0x42C3F4
const char aModf[] = "modf";

// Data @ 0x42C3FC
const char aFabs[] = "fabs";

// Data @ 0x42C404
const char aFloor[] = "floor";

// Data @ 0x42C40C
const char aCeil[] = "ceil";

// Data @ 0x42C414
const char aTan[] = "tan";

// Data @ 0x42C418
const char aCos[] = "cos";

// Data @ 0x42C41C
const char aSin[] = "sin";

// Data @ 0x42C420
const char aSqrt[] = "sqrt";

// Data @ 0x42C428
const char aAtan2[] = "atan2";

// Data @ 0x42C430
const char aAtan[] = "atan";

// Data @ 0x42C438
const char aAcos[] = "acos";

// Data @ 0x42C440
const char aAsin[] = "asin";

// Data @ 0x42C448
const char aTanh[] = "tanh";

// Data @ 0x42C450
const char aCosh[] = "cosh";

// Data @ 0x42C458
const char aSinh[] = "sinh";

// Data @ 0x42C460
const char aLog10[] = "log10";

// Data @ 0x42C468
const char aLog[] = "log";

// Data @ 0x42C46C
const char aPow[] = "pow";

// Data @ 0x42C470
const char aExp[] = "exp";

// Data @ 0x42C474
const char aSunmontuewedth[] = "SunMonTueWedThuFriSat";

// Data @ 0x42C48C
const char aJanfebmaraprma[] = "JanFebMarAprMayJunJulAugSepOctNovDec";

// Data @ 0x42C4B4
const char VarName[] = "TZ";

// Data @ 0x42C4B8
const char aGetlastactivep[] = "GetLastActivePopup";

// Data @ 0x42C4CC
const char aGetactivewindo[] = "GetActiveWindow";

// Data @ 0x42C4DC
const char aMessageboxa[] = "MessageBoxA";

// Data @ 0x42C4E8
const char LibFileName[] = "user32.dll";

// Data @ 0x42C4F4
const char a1Qnan[] = "1#QNAN";

// Data @ 0x42C4FC
const char a1Inf[] = "1#INF";

// Data @ 0x42C504
const char a1Ind[] = "1#IND";

// Data @ 0x42C50C
const char a1Snan[] = "1#SNAN";

// Data @ 0x42C518
uint8_t stru_42C518[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x94, 0x71, 0x41, 0x00, 0x98, 0x71, 0x41, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x03, 0x72, 0x41, 0x00, 0x07, 0x72, 0x41, 0x00
};

// Data @ 0x42C530
uint8_t unk_42C530[1] = {
    0x00
};

// Data @ 0x42C540
uint8_t unk_42C540[1] = {
    0x00
};

// Data @ 0x42C550
const char unk_42C550[] = "\x1b";

// Data @ 0x42C560
uint8_t unk_42C560[1] = {
    0x16
};

// Data @ 0x42C570
uint8_t stru_42C570[16] = {
    0x03, 0xE0, 0xF6, 0xBE, 0x74, 0xA8, 0x1A, 0x10, 0x8B, 0xBA, 0x00, 0xAA, 0x00, 0x30, 0x0C, 0xAB
};

// Data @ 0x42C5E0
uint8_t unk_42C5E0[1] = {
    0x83
};

// Data @ 0x42C5F0
uint8_t unk_42C5F0[1] = {
    0x94
};

// Data @ 0x42C600
const char unk_42C600[] = "|:s";

// Data @ 0x42C610
uint8_t unk_42C610[1] = {
    0x8C
};

// Data @ 0x42C620
uint8_t stru_42C620[16] = {
    0xC0, 0x6C, 0x52, 0xDB, 0x88, 0xD1, 0xCD, 0x11, 0xAD, 0x48, 0x00, 0xAA, 0x00, 0x3C, 0x9C, 0xB6
};

// Data @ 0x42C660
uint8_t unk_42C660[1] = {
    0x18
};

// Data @ 0x42C670
uint8_t stru_42C670[16] = {
    0x02, 0xBC, 0xFB, 0x9B, 0xF1, 0xEF, 0x1A, 0x10, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07
};

// Data @ 0x42C680
uint8_t unk_42C680[1] = {
    0x13
};

// Data @ 0x42C690
uint8_t stru_42C690[16] = {
    0x8F, 0xB2, 0x96, 0xB1, 0xB4, 0xBA, 0x1A, 0x10, 0xB6, 0x9C, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07
};

// Data @ 0x42C6A0
uint8_t riid[16] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
};

// Data @ 0x42C6B0
uint8_t unk_42C6B0[1] = {
    0x02
};

// Data @ 0x42C6C0
uint8_t unk_42C6C0[1] = {
    0x10
};

// Data @ 0x42C6D0
const char unk_42C6D0[] = "\n";

// Data @ 0x42C6E0
uint8_t unk_42C6E0[1] = {
    0x80
};

// Data @ 0x42C6F0
uint8_t unk_42C6F0[1] = {
    0xE0
};

// Data @ 0x42C700
uint8_t stru_42C700[16] = {
    0x12, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
};

// Data @ 0x42C710
uint8_t unk_42C710[1] = {
    0x88
};

// Data @ 0x42C720
uint8_t unk_42C720[1] = {
    0x84
};

// Data @ 0x42C730
uint8_t unk_42C730[1] = {
    0x83
};

// Data @ 0x42C740
uint8_t unk_42C740[1] = {
    0xC0
};

// Data @ 0x42C750
uint8_t dword_42C750[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42C760
uint8_t dword_42C760[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42C764
uint8_t dword_42C764[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42C768
uint8_t dword_42C768[4] = {
    0xC0, 0x00, 0x00, 0x00
};

// Data @ 0x42C76C
uint8_t dword_42C76C[4] = {
    0x00, 0x00, 0x00, 0x46
};

// Data @ 0x42C770
uint8_t unk_42C770[1] = {
    0xA0
};

// Data @ 0x42C780
uint8_t unk_42C780[1] = {
    0x90
};

// Data @ 0x42C790
uint8_t unk_42C790[1] = {
    0x00
};

// Data @ 0x42C860
uint8_t unk_42C860[1] = {
    0x00
};

// Data @ 0x42C938
uint8_t unk_42C938[1] = {
    0x00
};

// Data @ 0x42CB1C
uint8_t unk_42CB1C[1] = {
    0x01
};

// Data @ 0x42CB28
const char dword_42CB28[] = "0:s";

// Data @ 0x42CB38
uint8_t unk_42CB38[1] = {
    0x00
};

// Data @ 0x42CB68
uint8_t unk_42CB68[1] = {
    0x0C
};

// Data @ 0x42CB98
uint8_t unk_42CB98[1] = {
    0x16
};

// Data @ 0x42CBA8
uint8_t dword_42CBA8[52] = {
    0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    0x42, 0x75, 0x74, 0x74, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CBDC
uint8_t off_42CBDC[4] = {
    0xB0, 0x9B, 0x41, 0x00
};

// Data @ 0x42CBE0
const char off_42CBE0[] = " ";

// Data @ 0x42CBE4
uint8_t unk_42CBE4[1] = {
    0x01
};

// Data @ 0x42CC28
const char aCombobox_0[] = "ComboBox";

// Data @ 0x42CC88
uint8_t nIndex[2] = {
    0x14, 0x00
};

// Data @ 0x42CC98
const char ??_R1A@?0A@A@CNoTrackObject@@8[] = "h3C";

// Data @ 0x42CC9C
uint8_t dword_42CC9C[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CCA4
uint8_t dword_42CCA4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x42CCB0
uint8_t ??_R1A@?0A@A@_AFX_WIN_STATE@@8[4] = {
    0x88, 0x33, 0x43, 0x00
};

// Data @ 0x42CCC8
uint8_t ??_R2_AFX_WIN_STATE@@8[4] = {
    0xB0, 0xCC, 0x42, 0x00
};

// Data @ 0x42CCD8
uint8_t ??_R3_AFX_WIN_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CCE8
uint8_t ??_R4_AFX_WIN_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CD00
uint8_t ??_R1A@?0A@A@CObject@@8[4] = {
    0xA8, 0x33, 0x43, 0x00
};

// Data @ 0x42CD18
uint8_t ??_R1A@?0A@A@CCmdTarget@@8[4] = {
    0xC0, 0x33, 0x43, 0x00
};

// Data @ 0x42CD30
uint8_t ??_R1A@?0A@A@CWinThread@@8[4] = {
    0xE0, 0x33, 0x43, 0x00
};

// Data @ 0x42CD48
uint8_t ??_R1A@?0A@A@CWinApp@@8[4] = {
    0x00, 0x34, 0x43, 0x00
};

// Data @ 0x42CD60
const char ??_R2CWinApp@@8[] = "H";

// Data @ 0x42CD78
uint8_t ??_R3CWinApp@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CD88
uint8_t ??_R4CWinApp@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CDA0
const char ??_R2CWinThread@@8[] = "0";

// Data @ 0x42CDB0
uint8_t ??_R3CWinThread@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CDC0
uint8_t ??_R4CWinThread@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CDD8
const char ??_R1A@?0A@A@_AFX_CTL3D_STATE@@8[] = "84C";

// Data @ 0x42CDF0
uint8_t ??_R2_AFX_CTL3D_STATE@@8[4] = {
    0xD8, 0xCD, 0x42, 0x00
};

// Data @ 0x42CE00
uint8_t ??_R3_AFX_CTL3D_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CE10
uint8_t ??_R4_AFX_CTL3D_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CE28
const char ??_R1A@?0A@A@_AFX_CTL3D_THREAD@@8[] = "X4C";

// Data @ 0x42CE40
const char ??_R2_AFX_CTL3D_THREAD@@8[] = "(";

// Data @ 0x42CE50
uint8_t ??_R3_AFX_CTL3D_THREAD@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CE60
uint8_t ??_R4_AFX_CTL3D_THREAD@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CE78
uint8_t ??_R1A@?0A@A@CCmdUI@@8[4] = {
    0x88, 0x34, 0x43, 0x00
};

// Data @ 0x42CE90
const char ??_R2CCmdUI@@8[] = "x";

// Data @ 0x42CE98
uint8_t ??_R3CCmdUI@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CEA8
uint8_t ??_R4CCmdUI@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CEC0
uint8_t ??_R1A@?0A@A@CWnd@@8[4] = {
    0xA8, 0x34, 0x43, 0x00
};

// Data @ 0x42CED8
uint8_t ??_R1A@?0A@A@CDialog@@8[4] = {
    0xC0, 0x34, 0x43, 0x00
};

// Data @ 0x42CEF0
uint8_t ??_R2CDialog@@8[4] = {
    0xD8, 0xCE, 0x42, 0x00
};

// Data @ 0x42CF08
uint8_t ??_R3CDialog@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CF18
uint8_t ??_R4CDialog@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CF30
uint8_t ??_R1A@?0A@A@CComboBox@@8[4] = {
    0xD8, 0x34, 0x43, 0x00
};

// Data @ 0x42CF48
const char ??_R2CComboBox@@8[] = "0";

// Data @ 0x42CF60
uint8_t ??_R3CComboBox@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CF70
uint8_t ??_R4CComboBox@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CF88
uint8_t ??_R2CWnd@@8[4] = {
    0xC0, 0xCE, 0x42, 0x00
};

// Data @ 0x42CF98
uint8_t ??_R3CWnd@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CFA8
uint8_t ??_R4CWnd@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CFC0
uint8_t ??_R1A@?0A@A@CTestCmdUI@@8[4] = {
    0xF0, 0x34, 0x43, 0x00
};

// Data @ 0x42CFD8
uint8_t ??_R2CTestCmdUI@@8[4] = {
    0xC0, 0xCF, 0x42, 0x00
};

// Data @ 0x42CFE8
uint8_t ??_R3CTestCmdUI@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42CFF8
uint8_t ??_R4CTestCmdUI@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D010
const char ??_R1A@?0A@A@CTempWnd@@8[] = "05C";

// Data @ 0x42D028
uint8_t ??_R2CTempWnd@@8[4] = {
    0x10, 0xD0, 0x42, 0x00
};

// Data @ 0x42D040
uint8_t ??_R3CTempWnd@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D050
uint8_t ??_R4CTempWnd@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D068
const char ??_R1A@?0A@A@COccManager@@8[] = "`5C";

// Data @ 0x42D080
const char ??_R2COccManager@@8[] = "h";

// Data @ 0x42D090
uint8_t ??_R3COccManager@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D0A0
uint8_t ??_R4COccManager@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D0B8
uint8_t ??_R1A@?0A@A@_AFX_THREAD_STATE@@8[4] = {
    0x80, 0x35, 0x43, 0x00
};

// Data @ 0x42D0D0
uint8_t ??_R2_AFX_THREAD_STATE@@8[4] = {
    0xB8, 0xD0, 0x42, 0x00
};

// Data @ 0x42D0E0
uint8_t ??_R3_AFX_THREAD_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D0F0
uint8_t ??_R4_AFX_THREAD_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D108
uint8_t ??_R1A@?0A@A@AFX_MODULE_STATE@@8[4] = {
    0xA0, 0x35, 0x43, 0x00
};

// Data @ 0x42D120
const char ??_R2AFX_MODULE_STATE@@8[] = "\x08";

// Data @ 0x42D130
uint8_t ??_R3AFX_MODULE_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D140
uint8_t ??_R4AFX_MODULE_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D158
uint8_t ??_R1A@?0A@A@AFX_MODULE_THREAD_STATE@@8[4] = {
    0xC0, 0x35, 0x43, 0x00
};

// Data @ 0x42D170
const char ??_R2AFX_MODULE_THREAD_STATE@@8[] = "X";

// Data @ 0x42D180
uint8_t ??_R3AFX_MODULE_THREAD_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D190
uint8_t ??_R4AFX_MODULE_THREAD_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D1A8
uint8_t ??_R1A@?0A@A@_AFX_BASE_MODULE_STATE@@8[4] = {
    0xE8, 0x35, 0x43, 0x00
};

// Data @ 0x42D1C0
uint8_t ??_R2_AFX_BASE_MODULE_STATE@@8[4] = {
    0xA8, 0xD1, 0x42, 0x00
};

// Data @ 0x42D1D0
uint8_t ??_R3_AFX_BASE_MODULE_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D1E0
uint8_t ??_R4_AFX_BASE_MODULE_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D1F8
uint8_t ??_R1A@?0A@A@IOleWindow@@8[4] = {
    0x18, 0x36, 0x43, 0x00
};

// Data @ 0x42D210
const char ??_R1A@?0A@A@IOleInPlaceUIWindow@@8[] = "86C";

// Data @ 0x42D228
const char ??_R1A@?0A@A@IOleInPlaceFrame@@8[] = "`6C";

// Data @ 0x42D240
uint8_t ??_R1A@?0A@A@XOleIPFrame@COleControlContainer@@8[4] = {
    0x80, 0x36, 0x43, 0x00
};

// Data @ 0x42D258
const char ??_R2XOleIPFrame@COleControlContainer@@8[] = "@";

// Data @ 0x42D270
uint8_t ??_R3XOleIPFrame@COleControlContainer@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D280
uint8_t ??_R4XOleIPFrame@COleControlContainer@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D298
uint8_t ??_R1A@?0A@A@COleControlContainer@@8[4] = {
    0xB0, 0x36, 0x43, 0x00
};

// Data @ 0x42D2B0
uint8_t ??_R2COleControlContainer@@8[4] = {
    0x98, 0xD2, 0x42, 0x00
};

// Data @ 0x42D2C0
uint8_t ??_R3COleControlContainer@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D2D0
uint8_t ??_R4COleControlContainer@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D2E8
uint8_t ??_R1A@?0A@A@IUnknown@@8[4] = {
    0xD8, 0x36, 0x43, 0x00
};

// Data @ 0x42D300
uint8_t ??_R1A@?0A@A@IParseDisplayName@@8[4] = {
    0xF0, 0x36, 0x43, 0x00
};

// Data @ 0x42D318
uint8_t ??_R1A@?0A@A@IOleContainer@@8[4] = {
    0x10, 0x37, 0x43, 0x00
};

// Data @ 0x42D330
const char ??_R1A@?0A@A@XOleContainer@COleControlContainer@@8[] = "07C";

// Data @ 0x42D348
const char ??_R2XOleContainer@COleControlContainer@@8[] = "0";

// Data @ 0x42D360
uint8_t ??_R3XOleContainer@COleControlContainer@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D370
uint8_t ??_R4XOleContainer@COleControlContainer@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D388
const char ??_R1A@?0A@A@CFont@@8[] = "h7C";

// Data @ 0x42D3A0
uint8_t ??_R2CFont@@8[4] = {
    0x88, 0xD3, 0x42, 0x00
};

// Data @ 0x42D3B0
uint8_t ??_R3CFont@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D3C0
uint8_t ??_R4CFont@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D3D8
uint8_t ??_R1A@?0A@A@CGdiObject@@8[4] = {
    0x80, 0x37, 0x43, 0x00
};

// Data @ 0x42D3F0
uint8_t ??_R2CGdiObject@@8[4] = {
    0xD8, 0xD3, 0x42, 0x00
};

// Data @ 0x42D400
uint8_t ??_R3CGdiObject@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D410
uint8_t ??_R4CGdiObject@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D428
uint8_t ??_R1A@?0A@A@CEnumArray@@8[4] = {
    0xA0, 0x37, 0x43, 0x00
};

// Data @ 0x42D440
uint8_t ??_R1A@?0A@A@CEnumUnknown@@8[4] = {
    0xC0, 0x37, 0x43, 0x00
};

// Data @ 0x42D458
const char ??_R2CEnumUnknown@@8[] = "@";

// Data @ 0x42D470
uint8_t ??_R3CEnumUnknown@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D480
uint8_t ??_R4CEnumUnknown@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D498
uint8_t ??_R1A@?0A@A@CFile@@8[4] = {
    0xE0, 0x37, 0x43, 0x00
};

// Data @ 0x42D4B0
uint8_t ??_R1A@?0A@A@CStdioFile@@8[4] = {
    0xF8, 0x37, 0x43, 0x00
};

// Data @ 0x42D4C8
uint8_t ??_R2CStdioFile@@8[4] = {
    0xB0, 0xD4, 0x42, 0x00
};

// Data @ 0x42D4D8
uint8_t ??_R3CStdioFile@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D4E8
uint8_t ??_R4CStdioFile@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D500
uint8_t ??_R1A@?0A@A@CException@@8[4] = {
    0x18, 0x38, 0x43, 0x00
};

// Data @ 0x42D518
const char ??_R1A@?0A@A@CFileException@@8[] = "88C";

// Data @ 0x42D530
uint8_t ??_R2CFileException@@8[4] = {
    0x18, 0xD5, 0x42, 0x00
};

// Data @ 0x42D540
uint8_t ??_R3CFileException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D550
uint8_t ??_R4CFileException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D568
const char ??_R1A@?0A@A@CDC@@8[] = "X8C";

// Data @ 0x42D580
const char ??_R2CDC@@8[] = "h";

// Data @ 0x42D590
uint8_t ??_R3CDC@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D5A0
uint8_t ??_R4CDC@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D5B8
const char ??_R1A@?0A@A@CClientDC@@8[] = "p8C";

// Data @ 0x42D5D0
uint8_t ??_R2CClientDC@@8[4] = {
    0xB8, 0xD5, 0x42, 0x00
};

// Data @ 0x42D5E0
uint8_t ??_R3CClientDC@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D5F0
uint8_t ??_R4CClientDC@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D608
uint8_t ??_R1A@?0A@A@CWindowDC@@8[4] = {
    0x88, 0x38, 0x43, 0x00
};

// Data @ 0x42D620
const char ??_R2CWindowDC@@8[] = "\x08";

// Data @ 0x42D630
uint8_t ??_R3CWindowDC@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D640
uint8_t ??_R4CWindowDC@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D658
uint8_t ??_R1A@?0A@A@CPaintDC@@8[4] = {
    0xA0, 0x38, 0x43, 0x00
};

// Data @ 0x42D670
const char ??_R2CPaintDC@@8[] = "X";

// Data @ 0x42D680
uint8_t ??_R3CPaintDC@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D690
uint8_t ??_R4CPaintDC@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D6A8
uint8_t ??_R1A@?0A@A@CTempDC@@8[4] = {
    0xB8, 0x38, 0x43, 0x00
};

// Data @ 0x42D6C0
uint8_t ??_R2CTempDC@@8[4] = {
    0xA8, 0xD6, 0x42, 0x00
};

// Data @ 0x42D6D0
uint8_t ??_R3CTempDC@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D6E0
uint8_t ??_R4CTempDC@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D6F8
uint8_t ??_R1A@?0A@A@CTempGdiObject@@8[4] = {
    0xD0, 0x38, 0x43, 0x00
};

// Data @ 0x42D710
uint8_t ??_R2CTempGdiObject@@8[4] = {
    0xF8, 0xD6, 0x42, 0x00
};

// Data @ 0x42D720
uint8_t ??_R3CTempGdiObject@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D730
uint8_t ??_R4CTempGdiObject@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D748
const char ??_R1A@?0A@A@CSimpleException@@8[] = "`9C";

// Data @ 0x42D760
uint8_t ??_R1A@?0A@A@CResourceException@@8[4] = {
    0x80, 0x39, 0x43, 0x00
};

// Data @ 0x42D778
const char ??_R2CResourceException@@8[] = "`";

// Data @ 0x42D790
uint8_t ??_R3CResourceException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D7A0
uint8_t ??_R4CResourceException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D7B8
uint8_t ??_R1A@?0A@A@CUserException@@8[4] = {
    0xA8, 0x39, 0x43, 0x00
};

// Data @ 0x42D7D0
uint8_t ??_R2CUserException@@8[4] = {
    0xB8, 0xD7, 0x42, 0x00
};

// Data @ 0x42D7E8
uint8_t ??_R3CUserException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D7F8
uint8_t ??_R4CUserException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D810
uint8_t ??_R1A@?0A@A@CCommonDialog@@8[4] = {
    0xC8, 0x39, 0x43, 0x00
};

// Data @ 0x42D828
uint8_t ??_R1A@?0A@A@CFileDialog@@8[4] = {
    0xE8, 0x39, 0x43, 0x00
};

// Data @ 0x42D840
const char ??_R2CFileDialog@@8[] = "(";

// Data @ 0x42D860
uint8_t ??_R3CFileDialog@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D870
uint8_t ??_R4CFileDialog@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D888
const char ??_R1A@?0A@A@CThreadData@@8[] = "\x08:C";

// Data @ 0x42D8A0
uint8_t ??_R2CThreadData@@8[4] = {
    0x88, 0xD8, 0x42, 0x00
};

// Data @ 0x42D8B0
uint8_t ??_R3CThreadData@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D8C0
uint8_t ??_R4CThreadData@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D8D8
const char ??_R1A@?0A@A@CMemoryException@@8[] = "p:C";

// Data @ 0x42D8F0
uint8_t ??_R2CMemoryException@@8[4] = {
    0xD8, 0xD8, 0x42, 0x00
};

// Data @ 0x42D908
uint8_t ??_R3CMemoryException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D918
uint8_t ??_R4CMemoryException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D930
uint8_t ??_R1A@?0A@A@CNotSupportedException@@8[4] = {
    0x90, 0x3A, 0x43, 0x00
};

// Data @ 0x42D948
const char ??_R2CNotSupportedException@@8[] = "0";

// Data @ 0x42D960
uint8_t ??_R3CNotSupportedException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D970
uint8_t ??_R4CNotSupportedException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D988
uint8_t ??_R1A@?0A@A@CHandleMap@@8[4] = {
    0xB8, 0x3A, 0x43, 0x00
};

// Data @ 0x42D9A0
uint8_t ??_R2CHandleMap@@8[4] = {
    0x88, 0xD9, 0x42, 0x00
};

// Data @ 0x42D9A8
uint8_t ??_R3CHandleMap@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D9B8
uint8_t ??_R4CHandleMap@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42D9D0
uint8_t ??_R1A@?0A@A@CMapPtrToPtr@@8[4] = {
    0xD8, 0x3A, 0x43, 0x00
};

// Data @ 0x42D9E8
uint8_t ??_R2CMapPtrToPtr@@8[4] = {
    0xD0, 0xD9, 0x42, 0x00
};

// Data @ 0x42D9F8
uint8_t ??_R3CMapPtrToPtr@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DA08
uint8_t ??_R4CMapPtrToPtr@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DA20
uint8_t ??_R1A@?0A@A@CMenu@@8[4] = {
    0xF8, 0x3A, 0x43, 0x00
};

// Data @ 0x42DA38
const char ??_R2CMenu@@8[] = " ";

// Data @ 0x42DA48
uint8_t ??_R3CMenu@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DA58
uint8_t ??_R4CMenu@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DA70
uint8_t ??_R1A@?0A@A@CTempMenu@@8[4] = {
    0x10, 0x3B, 0x43, 0x00
};

// Data @ 0x42DA88
const char ??_R2CTempMenu@@8[] = "p";

// Data @ 0x42DA98
uint8_t ??_R3CTempMenu@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DAA8
uint8_t ??_R4CTempMenu@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DAC0
const char ??_R1A@?0A@A@IRowsetNotify@@8[] = "(;C";

// Data @ 0x42DAD8
const char ??_R1A@?0A@A@XRowsetNotify@COleControlSite@@8[] = "H;C";

// Data @ 0x42DAF0
uint8_t ??_R2XRowsetNotify@COleControlSite@@8[4] = {
    0xD8, 0xDA, 0x42, 0x00
};

// Data @ 0x42DB00
uint8_t ??_R3XRowsetNotify@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DB10
uint8_t ??_R4XRowsetNotify@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DB28
const char ??_R1A@?0A@A@IOleInPlaceSite@@8[] = "x;C";

// Data @ 0x42DB40
uint8_t ??_R1A@?0A@A@XOleIPSite@COleControlSite@@8[4] = {
    0x98, 0x3B, 0x43, 0x00
};

// Data @ 0x42DB58
const char ??_R2XOleIPSite@COleControlSite@@8[] = "@";

// Data @ 0x42DB70
uint8_t ??_R3XOleIPSite@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DB80
uint8_t ??_R4XOleIPSite@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DB98
uint8_t ??_R1A@?0A@A@INotifyDBEvents@@8[4] = {
    0xC8, 0x3B, 0x43, 0x00
};

// Data @ 0x42DBB0
uint8_t ??_R1A@?0A@A@XNotifyDBEvents@COleControlSite@@8[4] = {
    0xE8, 0x3B, 0x43, 0x00
};

// Data @ 0x42DBC8
uint8_t ??_R2XNotifyDBEvents@COleControlSite@@8[4] = {
    0xB0, 0xDB, 0x42, 0x00
};

// Data @ 0x42DBD8
uint8_t ??_R3XNotifyDBEvents@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DBE8
uint8_t ??_R4XNotifyDBEvents@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DC00
uint8_t ??_R1A@?0A@A@IOleClientSite@@8[4] = {
    0x18, 0x3C, 0x43, 0x00
};

// Data @ 0x42DC18
const char ??_R1A@?0A@A@XOleClientSite@COleControlSite@@8[] = "8<C";

// Data @ 0x42DC30
uint8_t ??_R2XOleClientSite@COleControlSite@@8[4] = {
    0x18, 0xDC, 0x42, 0x00
};

// Data @ 0x42DC40
uint8_t ??_R3XOleClientSite@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DC50
uint8_t ??_R4XOleClientSite@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DC68
const char ??_R1A@?0A@A@IBoundObjectSite@@8[] = "h<C";

// Data @ 0x42DC80
uint8_t ??_R1A@?0A@A@XBoundObjectSite@COleControlSite@@8[4] = {
    0x88, 0x3C, 0x43, 0x00
};

// Data @ 0x42DC98
uint8_t ??_R2XBoundObjectSite@COleControlSite@@8[4] = {
    0x80, 0xDC, 0x42, 0x00
};

// Data @ 0x42DCA8
uint8_t ??_R3XBoundObjectSite@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DCB8
uint8_t ??_R4XBoundObjectSite@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DCD0
uint8_t ??_R1A@?0A@A@XEventSink@COleControlSite@@8[4] = {
    0xB8, 0x3C, 0x43, 0x00
};

// Data @ 0x42DCE8
uint8_t ??_R2XEventSink@COleControlSite@@8[4] = {
    0xD0, 0xDC, 0x42, 0x00
};

// Data @ 0x42DCF8
uint8_t ??_R3XEventSink@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DD08
uint8_t ??_R4XEventSink@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DD20
uint8_t ??_R1A@?0A@A@COleControlSite@@8[4] = {
    0xE8, 0x3C, 0x43, 0x00
};

// Data @ 0x42DD38
const char ??_R2COleControlSite@@8[] = " ";

// Data @ 0x42DD48
uint8_t ??_R3COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DD58
uint8_t ??_R4COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DD70
const char ??_R1A@?0A@A@IPropertyNotifySink@@8[] = "\x08=C";

// Data @ 0x42DD88
const char ??_R1A@?0A@A@XPropertyNotifySink@COleControlSite@@8[] = "0=C";

// Data @ 0x42DDA0
uint8_t ??_R2XPropertyNotifySink@COleControlSite@@8[4] = {
    0x88, 0xDD, 0x42, 0x00
};

// Data @ 0x42DDB0
uint8_t ??_R3XPropertyNotifySink@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DDC0
uint8_t ??_R4XPropertyNotifySink@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DDD8
const char ??_R1A@?0A@A@IDispatch@@8[] = "h=C";

// Data @ 0x42DDF0
uint8_t ??_R1A@?0A@A@XAmbientProps@COleControlSite@@8[4] = {
    0x80, 0x3D, 0x43, 0x00
};

// Data @ 0x42DE08
uint8_t ??_R2XAmbientProps@COleControlSite@@8[4] = {
    0xF0, 0xDD, 0x42, 0x00
};

// Data @ 0x42DE18
uint8_t ??_R3XAmbientProps@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DE28
uint8_t ??_R4XAmbientProps@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DE40
uint8_t ??_R1A@?0A@A@IOleControlSite@@8[4] = {
    0xB0, 0x3D, 0x43, 0x00
};

// Data @ 0x42DE58
uint8_t ??_R1A@?0A@A@XOleControlSite@COleControlSite@@8[4] = {
    0xD0, 0x3D, 0x43, 0x00
};

// Data @ 0x42DE70
const char ??_R2XOleControlSite@COleControlSite@@8[] = "X";

// Data @ 0x42DE80
uint8_t ??_R3XOleControlSite@COleControlSite@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DE90
uint8_t ??_R4XOleControlSite@COleControlSite@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DEA8
uint8_t ??_R1A@?0A@A@CDataSourceControl@@8[4] = {
    0x00, 0x3E, 0x43, 0x00
};

// Data @ 0x42DEC0
uint8_t ??_R2CDataSourceControl@@8[4] = {
    0xA8, 0xDE, 0x42, 0x00
};

// Data @ 0x42DEC8
uint8_t ??_R3CDataSourceControl@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DED8
uint8_t ??_R4CDataSourceControl@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DEF0
const char ??_R1A@?0A@A@CMemFile@@8[] = "X>C";

// Data @ 0x42DF08
uint8_t ??_R2CMemFile@@8[4] = {
    0xF0, 0xDE, 0x42, 0x00
};

// Data @ 0x42DF18
uint8_t ??_R3CMemFile@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DF28
uint8_t ??_R4CMemFile@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DF40
const char ??_R1A@?0A@A@CPtrList@@8[] = "p>C";

// Data @ 0x42DF58
const char ??_R2CPtrList@@8[] = "@";

// Data @ 0x42DF68
uint8_t ??_R3CPtrList@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DF78
uint8_t ??_R4CPtrList@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DF90
uint8_t ??_R1A@?0A@A@COleDispatchException@@8[4] = {
    0xD0, 0x3E, 0x43, 0x00
};

// Data @ 0x42DFA8
uint8_t ??_R2COleDispatchException@@8[4] = {
    0x90, 0xDF, 0x42, 0x00
};

// Data @ 0x42DFB8
uint8_t ??_R3COleDispatchException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DFC8
uint8_t ??_R4COleDispatchException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42DFE0
uint8_t ??_R1A@?0A@A@IEnumVOID@@8[4] = {
    0xF8, 0x3E, 0x43, 0x00
};

// Data @ 0x42DFF8
uint8_t ??_R1A@?0A@A@XEnumVOID@CEnumArray@@8[4] = {
    0x10, 0x3F, 0x43, 0x00
};

// Data @ 0x42E010
uint8_t ??_R2XEnumVOID@CEnumArray@@8[4] = {
    0xF8, 0xDF, 0x42, 0x00
};

// Data @ 0x42E020
uint8_t ??_R3XEnumVOID@CEnumArray@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E030
uint8_t ??_R4XEnumVOID@CEnumArray@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E048
const char ??_R2CEnumArray@@8[] = "(";

// Data @ 0x42E058
uint8_t ??_R3CEnumArray@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E068
uint8_t ??_R4CEnumArray@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E080
uint8_t ??_R2CFile@@8[4] = {
    0x98, 0xD4, 0x42, 0x00
};

// Data @ 0x42E090
uint8_t ??_R3CFile@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E0A0
uint8_t ??_R4CFile@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E0B8
uint8_t ??_R1A@?0A@A@ISequentialStream@@8[4] = {
    0x90, 0x3F, 0x43, 0x00
};

// Data @ 0x42E0D0
uint8_t ??_R1A@?0A@A@IStream@@8[4] = {
    0xB0, 0x3F, 0x43, 0x00
};

// Data @ 0x42E0E8
uint8_t ??_R1A@?0A@A@CArchiveStream@@8[4] = {
    0xC8, 0x3F, 0x43, 0x00
};

// Data @ 0x42E100
uint8_t ??_R2CArchiveStream@@8[4] = {
    0xE8, 0xE0, 0x42, 0x00
};

// Data @ 0x42E118
uint8_t ??_R3CArchiveStream@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E128
uint8_t ??_R4CArchiveStream@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E140
uint8_t ??_R1A@?0A@A@COleException@@8[4] = {
    0xE8, 0x3F, 0x43, 0x00
};

// Data @ 0x42E158
const char ??_R2COleException@@8[] = "@";

// Data @ 0x42E168
uint8_t ??_R3COleException@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E178
uint8_t ??_R4COleException@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E190
const char ??_R1A@?0A@A@COleMessageFilter@@8[] = "\x08@C";

// Data @ 0x42E1A8
uint8_t ??_R2COleMessageFilter@@8[4] = {
    0x90, 0xE1, 0x42, 0x00
};

// Data @ 0x42E1B8
uint8_t ??_R3COleMessageFilter@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E1C8
uint8_t ??_R4COleMessageFilter@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E1E0
const char ??_R1A@?0A@A@IMessageFilter@@8[] = "(@C";

// Data @ 0x42E1F8
const char ??_R1A@?0A@A@XMessageFilter@COleMessageFilter@@8[] = "H@C";

// Data @ 0x42E210
uint8_t ??_R2XMessageFilter@COleMessageFilter@@8[4] = {
    0xF8, 0xE1, 0x42, 0x00
};

// Data @ 0x42E220
uint8_t ??_R3XMessageFilter@COleMessageFilter@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E230
uint8_t ??_R4XMessageFilter@COleMessageFilter@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E248
const char ??_R1A@?0A@A@COleDialog@@8[] = "x@C";

// Data @ 0x42E260
uint8_t ??_R1A@?0A@A@COleBusyDialog@@8[4] = {
    0x98, 0x40, 0x43, 0x00
};

// Data @ 0x42E278
const char ??_R2COleBusyDialog@@8[] = "`";

// Data @ 0x42E298
uint8_t ??_R3COleBusyDialog@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E2A8
uint8_t ??_R4COleBusyDialog@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E2C0
uint8_t ??_R1A@?0A@A@_AFX_OLE_STATE@@8[4] = {
    0xB8, 0x40, 0x43, 0x00
};

// Data @ 0x42E2D8
uint8_t ??_R2_AFX_OLE_STATE@@8[4] = {
    0xC0, 0xE2, 0x42, 0x00
};

// Data @ 0x42E2E8
uint8_t ??_R3_AFX_OLE_STATE@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E2F8
uint8_t ??_R4_AFX_OLE_STATE@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E310
uint8_t ??_R1A@?0A@A@type_info@@8[4] = {
    0xF0, 0x40, 0x43, 0x00
};

// Data @ 0x42E328
uint8_t ??_R2type_info@@8[4] = {
    0x10, 0xE3, 0x42, 0x00
};

// Data @ 0x42E330
uint8_t ??_R3type_info@@8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E340
uint8_t ??_R4type_info@@6B@[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42E358
const char stru_42E358[] = " ";

// Data @ 0x42E378
uint8_t stru_42E378[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x74, 0x42, 0x00
};

// Data @ 0x42E3F0
const char stru_42E3F0[] = " ";

// Data @ 0x42E410
uint8_t stru_42E410[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x75, 0x42, 0x00
};

// Data @ 0x42E480
const char stru_42E480[] = " ";

// Data @ 0x42E4A0
uint8_t stru_42E4A0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x76, 0x42, 0x00
};

// Data @ 0x42E530
const char stru_42E530[] = " ";

// Data @ 0x42E550
uint8_t stru_42E550[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x77, 0x42, 0x00
};

// Data @ 0x42E560
const char stru_42E560[] = " ";

// Data @ 0x42E580
uint8_t stru_42E580[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x77, 0x42, 0x00
};

// Data @ 0x42E590
const char stru_42E590[] = " ";

// Data @ 0x42E5B0
uint8_t stru_42E5B0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x77, 0x42, 0x00
};

// Data @ 0x42E5C0
const char stru_42E5C0[] = " ";

// Data @ 0x42E5E0
uint8_t stru_42E5E0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x78, 0x42, 0x00
};

// Data @ 0x42E5F0
const char stru_42E5F0[] = " ";

// Data @ 0x42E610
uint8_t stru_42E610[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x20, 0x78, 0x42, 0x00
};

// Data @ 0x42E640
const char stru_42E640[] = " ";

// Data @ 0x42E660
uint8_t stru_42E660[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x70, 0x78, 0x42, 0x00
};

// Data @ 0x42E668
const char stru_42E668[] = " ";

// Data @ 0x42E688
uint8_t stru_42E688[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x90, 0x78, 0x42, 0x00
};

// Data @ 0x42E698
const char stru_42E698[] = " ";

// Data @ 0x42E6B8
uint8_t stru_42E6B8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xB0, 0x78, 0x42, 0x00
};

// Data @ 0x42E6C8
const char stru_42E6C8[] = " ";

// Data @ 0x42E6E8
uint8_t stru_42E6E8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xD0, 0x78, 0x42, 0x00
};

// Data @ 0x42E6F8
const char stru_42E6F8[] = " ";

// Data @ 0x42E718
uint8_t stru_42E718[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x78, 0x42, 0x00
};

// Data @ 0x42E728
const char stru_42E728[] = " ";

// Data @ 0x42E748
uint8_t stru_42E748[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x79, 0x42, 0x00
};

// Data @ 0x42E758
const char stru_42E758[] = " ";

// Data @ 0x42E778
uint8_t stru_42E778[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x79, 0x42, 0x00
};

// Data @ 0x42E788
const char stru_42E788[] = " ";

// Data @ 0x42E7A8
uint8_t stru_42E7A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x50, 0x79, 0x42, 0x00
};

// Data @ 0x42E7B8
const char stru_42E7B8[] = " ";

// Data @ 0x42E7D8
uint8_t stru_42E7D8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x70, 0x79, 0x42, 0x00
};

// Data @ 0x42E7E8
const char stru_42E7E8[] = " ";

// Data @ 0x42E808
uint8_t stru_42E808[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x90, 0x79, 0x42, 0x00
};

// Data @ 0x42E818
const char stru_42E818[] = " ";

// Data @ 0x42E838
uint8_t stru_42E838[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xB0, 0x79, 0x42, 0x00
};

// Data @ 0x42E848
const char stru_42E848[] = " ";

// Data @ 0x42E868
uint8_t stru_42E868[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xD0, 0x79, 0x42, 0x00
};

// Data @ 0x42E898
const char stru_42E898[] = " ";

// Data @ 0x42E8B8
uint8_t stru_42E8B8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x20, 0x7A, 0x42, 0x00
};

// Data @ 0x42E8C0
const char stru_42E8C0[] = " ";

// Data @ 0x42E8E0
uint8_t stru_42E8E0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x7A, 0x42, 0x00
};

// Data @ 0x42E8E8
const char stru_42E8E8[] = " ";

// Data @ 0x42E908
uint8_t stru_42E908[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x7A, 0x42, 0x00
};

// Data @ 0x42E910
const char stru_42E910[] = " ";

// Data @ 0x42E930
uint8_t stru_42E930[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x74, 0x7A, 0x42, 0x00
};

// Data @ 0x42E938
const char stru_42E938[] = " ";

// Data @ 0x42E958
uint8_t stru_42E958[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x88, 0x7A, 0x42, 0x00
};

// Data @ 0x42E960
const char stru_42E960[] = " ";

// Data @ 0x42E980
uint8_t stru_42E980[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x9C, 0x7A, 0x42, 0x00
};

// Data @ 0x42E988
const char stru_42E988[] = " ";

// Data @ 0x42E9A8
uint8_t stru_42E9A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xB0, 0x7A, 0x42, 0x00
};

// Data @ 0x42E9B0
const char stru_42E9B0[] = " ";

// Data @ 0x42E9D0
uint8_t stru_42E9D0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xC4, 0x7A, 0x42, 0x00
};

// Data @ 0x42E9D8
const char stru_42E9D8[] = " ";

// Data @ 0x42E9F8
uint8_t stru_42E9F8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xD8, 0x7A, 0x42, 0x00
};

// Data @ 0x42EA00
const char stru_42EA00[] = " ";

// Data @ 0x42EA20
uint8_t stru_42EA20[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xEC, 0x7A, 0x42, 0x00
};

// Data @ 0x42EA28
const char stru_42EA28[] = " ";

// Data @ 0x42EA48
uint8_t stru_42EA48[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x7B, 0x42, 0x00
};

// Data @ 0x42EA50
const char stru_42EA50[] = " ";

// Data @ 0x42EA70
uint8_t stru_42EA70[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x14, 0x7B, 0x42, 0x00
};

// Data @ 0x42EA78
const char stru_42EA78[] = " ";

// Data @ 0x42EA98
uint8_t stru_42EA98[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x28, 0x7B, 0x42, 0x00
};

// Data @ 0x42EAA0
const char stru_42EAA0[] = " ";

// Data @ 0x42EAC0
uint8_t stru_42EAC0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42EAE0
uint8_t stru_42EAE0[20] = {
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xF8, 0xEA, 0x42, 0x00
};

// Data @ 0x42EAF8
uint8_t stru_42EAF8[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xD4, 0xFF, 0xFF, 0xFF, 0xE4, 0xCD, 0x41, 0x00
};

// Data @ 0x42EB08
const char stru_42EB08[] = " ";

// Data @ 0x42EB28
uint8_t stru_42EB28[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42EB38
uint8_t stru_42EB38[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x50, 0xEB, 0x42, 0x00
};

// Data @ 0x42EB50
uint8_t stru_42EB50[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xDC, 0xFF, 0xFF, 0xFF, 0x39, 0xD0, 0x41, 0x00
};

// Data @ 0x42EB60
const char stru_42EB60[] = " ";

// Data @ 0x42EB80
uint8_t stru_42EB80[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x7B, 0x42, 0x00
};

// Data @ 0x42EB88
const char stru_42EB88[] = " ";

// Data @ 0x42EBA8
uint8_t stru_42EBA8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42EBB8
uint8_t stru_42EBB8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xD0, 0xEB, 0x42, 0x00
};

// Data @ 0x42EBD0
uint8_t stru_42EBD0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0x10, 0x00, 0x00, 0x00, 0x45, 0xD7, 0x41, 0x00
};

// Data @ 0x42EBE0
const char stru_42EBE0[] = " ";

// Data @ 0x42EC00
uint8_t stru_42EC00[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x84, 0x7B, 0x42, 0x00
};

// Data @ 0x42EC08
const char stru_42EC08[] = " ";

// Data @ 0x42EC28
uint8_t stru_42EC28[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42EC38
uint8_t stru_42EC38[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x50, 0xEC, 0x42, 0x00
};

// Data @ 0x42EC50
uint8_t stru_42EC50[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x86, 0xDA, 0x41, 0x00
};

// Data @ 0x42EC60
const char stru_42EC60[] = " ";

// Data @ 0x42EC80
uint8_t stru_42EC80[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA4, 0x7B, 0x42, 0x00
};

// Data @ 0x42EC88
const char stru_42EC88[] = " ";

// Data @ 0x42ECA8
uint8_t stru_42ECA8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42ECB8
uint8_t stru_42ECB8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xD0, 0xEC, 0x42, 0x00
};

// Data @ 0x42ECD0
uint8_t stru_42ECD0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xC4, 0xFF, 0xFF, 0xFF, 0x4E, 0xE4, 0x41, 0x00
};

// Data @ 0x42ECE0
const char stru_42ECE0[] = " ";

// Data @ 0x42ED00
uint8_t stru_42ED00[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xC4, 0x7B, 0x42, 0x00
};

// Data @ 0x42ED08
const char stru_42ED08[] = " ";

// Data @ 0x42ED28
uint8_t stru_42ED28[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xD8, 0x7B, 0x42, 0x00
};

// Data @ 0x42ED40
const char stru_42ED40[] = " ";

// Data @ 0x42ED60
uint8_t stru_42ED60[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7B, 0x42, 0x00
};

// Data @ 0x42ED68
const char stru_42ED68[] = " ";

// Data @ 0x42ED88
uint8_t stru_42ED88[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42ED98
uint8_t stru_42ED98[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0xB0, 0xED, 0x42, 0x00
};

// Data @ 0x42EDB0
uint8_t stru_42EDB0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x10, 0x35, 0x43, 0x00, 0xD0, 0xFF, 0xFF, 0xFF, 0x5B, 0xF5, 0x41, 0x00
};

// Data @ 0x42EDD0
const char stru_42EDD0[] = " ";

// Data @ 0x42EDF0
uint8_t stru_42EDF0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x7C, 0x42, 0x00
};

// Data @ 0x42EDF8
const char stru_42EDF8[] = " ";

// Data @ 0x42EE18
uint8_t stru_42EE18[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x7C, 0x42, 0x00
};

// Data @ 0x42EE20
const char stru_42EE20[] = " ";

// Data @ 0x42EE40
uint8_t stru_42EE40[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x44, 0x7C, 0x42, 0x00
};

// Data @ 0x42EE48
const char stru_42EE48[] = " ";

// Data @ 0x42EE68
uint8_t stru_42EE68[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x58, 0x7C, 0x42, 0x00
};

// Data @ 0x42EE70
const char stru_42EE70[] = " ";

// Data @ 0x42EE90
uint8_t stru_42EE90[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x6C, 0x7C, 0x42, 0x00
};

// Data @ 0x42EE98
const char stru_42EE98[] = " ";

// Data @ 0x42EEB8
uint8_t stru_42EEB8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x7C, 0x42, 0x00
};

// Data @ 0x42EED0
const char stru_42EED0[] = " ";

// Data @ 0x42EEF0
uint8_t stru_42EEF0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA8, 0x7C, 0x42, 0x00
};

// Data @ 0x42EEF8
const char stru_42EEF8[] = " ";

// Data @ 0x42EF18
uint8_t stru_42EF18[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xBC, 0x7C, 0x42, 0x00
};

// Data @ 0x42EF28
const char stru_42EF28[] = " ";

// Data @ 0x42EF48
uint8_t stru_42EF48[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x7C, 0x42, 0x00
};

// Data @ 0x42EF50
const char stru_42EF50[] = " ";

// Data @ 0x42EF70
uint8_t stru_42EF70[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42EF80
uint8_t stru_42EF80[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x98, 0xEF, 0x42, 0x00
};

// Data @ 0x42EF98
uint8_t stru_42EF98[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0x1C, 0x5B, 0x40, 0x00
};

// Data @ 0x42EFA8
const char stru_42EFA8[] = " ";

// Data @ 0x42EFC8
uint8_t stru_42EFC8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7C, 0x42, 0x00
};

// Data @ 0x42EFD0
const char stru_42EFD0[] = " ";

// Data @ 0x42EFF0
uint8_t stru_42EFF0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x7D, 0x42, 0x00
};

// Data @ 0x42F000
const char stru_42F000[] = " ";

// Data @ 0x42F020
uint8_t stru_42F020[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F030
uint8_t stru_42F030[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x48, 0xF0, 0x42, 0x00
};

// Data @ 0x42F048
uint8_t stru_42F048[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE4, 0xFF, 0xFF, 0xFF, 0x88, 0x5D, 0x40, 0x00
};

// Data @ 0x42F058
const char stru_42F058[] = " ";

// Data @ 0x42F078
uint8_t stru_42F078[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x3C, 0x7D, 0x42, 0x00
};

// Data @ 0x42F088
const char stru_42F088[] = " ";

// Data @ 0x42F0A8
uint8_t stru_42F0A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x58, 0x7D, 0x42, 0x00
};

// Data @ 0x42F0C8
const char stru_42F0C8[] = " ";

// Data @ 0x42F0E8
uint8_t stru_42F0E8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x84, 0x7D, 0x42, 0x00
};

// Data @ 0x42F0F0
const char stru_42F0F0[] = " ";

// Data @ 0x42F110
uint8_t stru_42F110[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F120
uint8_t stru_42F120[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x38, 0xF1, 0x42, 0x00
};

// Data @ 0x42F138
uint8_t stru_42F138[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0x57, 0x65, 0x40, 0x00
};

// Data @ 0x42F148
const char stru_42F148[] = " ";

// Data @ 0x42F168
uint8_t stru_42F168[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA4, 0x7D, 0x42, 0x00
};

// Data @ 0x42F170
const char stru_42F170[] = " ";

// Data @ 0x42F190
uint8_t stru_42F190[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F1A8
uint8_t stru_42F1A8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xC0, 0xF1, 0x42, 0x00
};

// Data @ 0x42F1C0
uint8_t stru_42F1C0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xD4, 0xFF, 0xFF, 0xFF, 0x7A, 0x67, 0x40, 0x00
};

// Data @ 0x42F1D0
const char stru_42F1D0[] = " ";

// Data @ 0x42F1F0
uint8_t stru_42F1F0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xCC, 0x7D, 0x42, 0x00
};

// Data @ 0x42F1F8
const char stru_42F1F8[] = " ";

// Data @ 0x42F218
uint8_t stru_42F218[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x7D, 0x42, 0x00
};

// Data @ 0x42F220
const char stru_42F220[] = " ";

// Data @ 0x42F240
uint8_t stru_42F240[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0x7D, 0x42, 0x00
};

// Data @ 0x42F248
const char stru_42F248[] = " ";

// Data @ 0x42F268
uint8_t stru_42F268[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x08, 0x7E, 0x42, 0x00
};

// Data @ 0x42F270
const char stru_42F270[] = " ";

// Data @ 0x42F290
uint8_t stru_42F290[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x7E, 0x42, 0x00
};

// Data @ 0x42F298
const char stru_42F298[] = " ";

// Data @ 0x42F2B8
uint8_t stru_42F2B8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x7E, 0x42, 0x00
};

// Data @ 0x42F2C0
const char stru_42F2C0[] = " ";

// Data @ 0x42F2E0
uint8_t stru_42F2E0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x44, 0x7E, 0x42, 0x00
};

// Data @ 0x42F2E8
const char stru_42F2E8[] = " ";

// Data @ 0x42F308
uint8_t stru_42F308[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x58, 0x7E, 0x42, 0x00
};

// Data @ 0x42F310
const char stru_42F310[] = " ";

// Data @ 0x42F330
uint8_t stru_42F330[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x6C, 0x7E, 0x42, 0x00
};

// Data @ 0x42F338
const char stru_42F338[] = " ";

// Data @ 0x42F358
uint8_t stru_42F358[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x7E, 0x42, 0x00
};

// Data @ 0x42F360
const char stru_42F360[] = " ";

// Data @ 0x42F380
uint8_t stru_42F380[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x94, 0x7E, 0x42, 0x00
};

// Data @ 0x42F388
const char stru_42F388[] = " ";

// Data @ 0x42F3A8
uint8_t stru_42F3A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA8, 0x7E, 0x42, 0x00
};

// Data @ 0x42F3B0
uint8_t __CT??_R0PAX@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F3D0
uint8_t __CT??_R0PAVCObject@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F3F0
uint8_t __CT??_R0PAVCException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F410
uint8_t __CT??_R0PAVCSimpleException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F430
uint8_t __CT??_R0PAVCResourceException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F450
uint8_t __CTA5PAVCResourceException@@[4] = {
    0x05, 0x00, 0x00, 0x00
};

// Data @ 0x42F468
uint8_t __TI5PAVCResourceException@@[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xF4, 0x42, 0x00
};

// Data @ 0x42F478
const char stru_42F478[] = " ";

// Data @ 0x42F498
uint8_t stru_42F498[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xBC, 0x7E, 0x42, 0x00
};

// Data @ 0x42F4A8
const char stru_42F4A8[] = " ";

// Data @ 0x42F4C8
uint8_t stru_42F4C8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x7E, 0x42, 0x00
};

// Data @ 0x42F4D0
const char stru_42F4D0[] = " ";

// Data @ 0x42F4F0
uint8_t stru_42F4F0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F500
uint8_t stru_42F500[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x18, 0xF5, 0x42, 0x00
};

// Data @ 0x42F518
uint8_t stru_42F518[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0x90, 0x4E, 0x42, 0x00
};

// Data @ 0x42F528
const char stru_42F528[] = " ";

// Data @ 0x42F548
uint8_t stru_42F548[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F558
uint8_t stru_42F558[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x70, 0xF5, 0x42, 0x00
};

// Data @ 0x42F570
uint8_t stru_42F570[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0xC9, 0x0B, 0x42, 0x00
};

// Data @ 0x42F580
uint8_t __CT??_R0PAVCMemoryException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F5A0
uint8_t __CTA5PAVCMemoryException@@[4] = {
    0x05, 0x00, 0x00, 0x00
};

// Data @ 0x42F5B8
uint8_t __TI5PAVCMemoryException@@[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xF5, 0x42, 0x00
};

// Data @ 0x42F5C8
uint8_t __CT??_R0PAVCNotSupportedException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x42F5E8
uint8_t __CTA5PAVCNotSupportedException@@[4] = {
    0x05, 0x00, 0x00, 0x00
};

// Data @ 0x42F600
uint8_t __TI5PAVCNotSupportedException@@[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0xF5, 0x42, 0x00
};

// Data @ 0x42F610
const char stru_42F610[] = " ";

// Data @ 0x42F630
uint8_t stru_42F630[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x08, 0x7F, 0x42, 0x00
};

// Data @ 0x42F638
const char stru_42F638[] = " ";

// Data @ 0x42F658
uint8_t stru_42F658[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x7F, 0x42, 0x00
};

// Data @ 0x42F660
const char stru_42F660[] = " ";

// Data @ 0x42F680
uint8_t stru_42F680[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x7F, 0x42, 0x00
};

// Data @ 0x42F690
const char stru_42F690[] = " ";

// Data @ 0x42F6B0
uint8_t stru_42F6B0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F6C0
uint8_t stru_42F6C0[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xD8, 0xF6, 0x42, 0x00
};

// Data @ 0x42F6D8
uint8_t stru_42F6D8[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0xCA, 0x0F, 0x42, 0x00
};

// Data @ 0x42F6E8
const char stru_42F6E8[] = " ";

// Data @ 0x42F708
uint8_t stru_42F708[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0x7F, 0x42, 0x00
};

// Data @ 0x42F718
const char stru_42F718[] = " ";

// Data @ 0x42F738
uint8_t stru_42F738[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x7C, 0x7F, 0x42, 0x00
};

// Data @ 0x42F740
const char stru_42F740[] = " ";

// Data @ 0x42F760
uint8_t stru_42F760[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x90, 0x7F, 0x42, 0x00
};

// Data @ 0x42F768
const char stru_42F768[] = " ";

// Data @ 0x42F788
uint8_t stru_42F788[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA4, 0x7F, 0x42, 0x00
};

// Data @ 0x42F790
const char stru_42F790[] = " ";

// Data @ 0x42F7B0
uint8_t stru_42F7B0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xB8, 0x7F, 0x42, 0x00
};

// Data @ 0x42F7B8
const char stru_42F7B8[] = " ";

// Data @ 0x42F7D8
uint8_t stru_42F7D8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F7E8
uint8_t stru_42F7E8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0x42, 0x00
};

// Data @ 0x42F800
uint8_t stru_42F800[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0xFC, 0x6B, 0x40, 0x00
};

// Data @ 0x42F810
const char stru_42F810[] = " ";

// Data @ 0x42F830
uint8_t stru_42F830[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F840
uint8_t stru_42F840[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x58, 0xF8, 0x42, 0x00
};

// Data @ 0x42F858
uint8_t stru_42F858[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xF4, 0x6D, 0x40, 0x00
};

// Data @ 0x42F868
const char stru_42F868[] = " ";

// Data @ 0x42F888
uint8_t stru_42F888[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0x7F, 0x42, 0x00
};

// Data @ 0x42F890
const char stru_42F890[] = " ";

// Data @ 0x42F8B0
uint8_t stru_42F8B0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x7F, 0x42, 0x00
};

// Data @ 0x42F8C8
const char stru_42F8C8[] = " ";

// Data @ 0x42F8E8
uint8_t stru_42F8E8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x24, 0x80, 0x42, 0x00
};

// Data @ 0x42F8F0
const char stru_42F8F0[] = " ";

// Data @ 0x42F910
uint8_t stru_42F910[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x38, 0x80, 0x42, 0x00
};

// Data @ 0x42F918
const char stru_42F918[] = " ";

// Data @ 0x42F938
uint8_t stru_42F938[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x4C, 0x80, 0x42, 0x00
};

// Data @ 0x42F940
const char stru_42F940[] = " ";

// Data @ 0x42F960
uint8_t stru_42F960[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x80, 0x42, 0x00
};

// Data @ 0x42F968
const char stru_42F968[] = " ";

// Data @ 0x42F988
uint8_t stru_42F988[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42F998
uint8_t stru_42F998[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xB0, 0xF9, 0x42, 0x00
};

// Data @ 0x42F9B0
uint8_t stru_42F9B0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0x2B, 0x80, 0x40, 0x00
};

// Data @ 0x42F9C0
const char stru_42F9C0[] = " ";

// Data @ 0x42F9E0
uint8_t stru_42F9E0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FA00
uint8_t stru_42FA00[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x28, 0xFA, 0x42, 0x00
};

// Data @ 0x42FA28
uint8_t stru_42FA28[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x9C, 0x80, 0x40, 0x00
};

// Data @ 0x42FA38
uint8_t stru_42FA38[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xE5, 0x80, 0x40, 0x00
};

// Data @ 0x42FA48
const char stru_42FA48[] = " ";

// Data @ 0x42FA68
uint8_t stru_42FA68[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FA78
uint8_t stru_42FA78[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x90, 0xFA, 0x42, 0x00
};

// Data @ 0x42FA90
uint8_t stru_42FA90[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE4, 0xFF, 0xFF, 0xFF, 0x4D, 0x81, 0x40, 0x00
};

// Data @ 0x42FAA0
const char stru_42FAA0[] = " ";

// Data @ 0x42FAC0
uint8_t stru_42FAC0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FAE0
uint8_t stru_42FAE0[20] = {
    0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x08, 0xFB, 0x42, 0x00
};

// Data @ 0x42FB08
uint8_t stru_42FB08[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0xCF, 0x82, 0x40, 0x00
};

// Data @ 0x42FB18
uint8_t stru_42FB18[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0xA8, 0x82, 0x40, 0x00
};

// Data @ 0x42FB28
const char stru_42FB28[] = " ";

// Data @ 0x42FB48
uint8_t stru_42FB48[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA4, 0x80, 0x42, 0x00
};

// Data @ 0x42FB50
const char stru_42FB50[] = " ";

// Data @ 0x42FB70
uint8_t stru_42FB70[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xB8, 0x80, 0x42, 0x00
};

// Data @ 0x42FB78
const char stru_42FB78[] = " ";

// Data @ 0x42FB98
uint8_t stru_42FB98[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FBA8
uint8_t stru_42FBA8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xC0, 0xFB, 0x42, 0x00
};

// Data @ 0x42FBC0
uint8_t stru_42FBC0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0x38, 0x85, 0x40, 0x00
};

// Data @ 0x42FBD0
const char stru_42FBD0[] = " ";

// Data @ 0x42FBF0
uint8_t stru_42FBF0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FC00
uint8_t stru_42FC00[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x18, 0xFC, 0x42, 0x00
};

// Data @ 0x42FC18
uint8_t stru_42FC18[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xE8, 0xFF, 0xFF, 0xFF, 0x9A, 0x85, 0x40, 0x00
};

// Data @ 0x42FC28
const char stru_42FC28[] = " ";

// Data @ 0x42FC48
uint8_t stru_42FC48[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0x80, 0x42, 0x00
};

// Data @ 0x42FC50
const char stru_42FC50[] = " ";

// Data @ 0x42FC70
uint8_t stru_42FC70[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x80, 0x42, 0x00
};

// Data @ 0x42FC78
const char stru_42FC78[] = " ";

// Data @ 0x42FC98
uint8_t stru_42FC98[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0x81, 0x42, 0x00
};

// Data @ 0x42FCA0
const char stru_42FCA0[] = " ";

// Data @ 0x42FCC0
uint8_t stru_42FCC0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x24, 0x81, 0x42, 0x00
};

// Data @ 0x42FCC8
const char stru_42FCC8[] = " ";

// Data @ 0x42FCE8
uint8_t stru_42FCE8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x38, 0x81, 0x42, 0x00
};

// Data @ 0x42FCF8
const char stru_42FCF8[] = " ";

// Data @ 0x42FD18
uint8_t stru_42FD18[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x58, 0x81, 0x42, 0x00
};

// Data @ 0x42FD28
const char stru_42FD28[] = " ";

// Data @ 0x42FD48
uint8_t stru_42FD48[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x78, 0x81, 0x42, 0x00
};

// Data @ 0x42FD58
const char stru_42FD58[] = " ";

// Data @ 0x42FD78
uint8_t stru_42FD78[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x98, 0x81, 0x42, 0x00
};

// Data @ 0x42FDB8
uint8_t stru_42FDB8[20] = {
    0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xF8, 0xFD, 0x42, 0x00
};

// Data @ 0x42FDF8
uint8_t stru_42FDF8[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x99, 0x40, 0x00
};

// Data @ 0x42FE08
uint8_t stru_42FE08[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x99, 0x40, 0x00
};

// Data @ 0x42FE18
uint8_t stru_42FE18[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x9A, 0x40, 0x00
};

// Data @ 0x42FE28
const char stru_42FE28[] = " ";

// Data @ 0x42FE48
uint8_t stru_42FE48[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FE58
uint8_t stru_42FE58[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x70, 0xFE, 0x42, 0x00
};

// Data @ 0x42FE70
uint8_t stru_42FE70[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x9B, 0x40, 0x00
};

// Data @ 0x42FE80
const char stru_42FE80[] = " ";

// Data @ 0x42FEA0
uint8_t stru_42FEA0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x81, 0x42, 0x00
};

// Data @ 0x42FF30
const char stru_42FF30[] = " ";

// Data @ 0x42FF50
uint8_t stru_42FF50[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x82, 0x42, 0x00
};

// Data @ 0x42FF60
const char stru_42FF60[] = " ";

// Data @ 0x42FF80
uint8_t stru_42FF80[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x9C, 0x82, 0x42, 0x00
};

// Data @ 0x42FF98
const char stru_42FF98[] = " ";

// Data @ 0x42FFB8
uint8_t stru_42FFB8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x42FFC8
uint8_t stru_42FFC8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xE0, 0xFF, 0x42, 0x00
};

// Data @ 0x42FFE0
uint8_t stru_42FFE0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0xB3, 0x40, 0x00
};

// Data @ 0x42FFF0
const char stru_42FFF0[] = " ";

// Data @ 0x430010
uint8_t stru_430010[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xD0, 0x82, 0x42, 0x00
};

// Data @ 0x430018
const char stru_430018[] = " ";

// Data @ 0x430038
uint8_t stru_430038[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0x82, 0x42, 0x00
};

// Data @ 0x430040
const char stru_430040[] = " ";

// Data @ 0x430060
uint8_t stru_430060[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x430070
uint8_t stru_430070[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x88, 0x00, 0x43, 0x00
};

// Data @ 0x430088
uint8_t stru_430088[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x81, 0xC5, 0x40, 0x00
};

// Data @ 0x430098
const char stru_430098[] = " ";

// Data @ 0x4300B8
uint8_t stru_4300B8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x83, 0x42, 0x00
};

// Data @ 0x4300C0
uint8_t __CT??_R0PAVCOleDispatchException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x4300E0
uint8_t __CTA4PAVCOleDispatchException@@[4] = {
    0x04, 0x00, 0x00, 0x00
};

// Data @ 0x4300F8
uint8_t __TI4PAVCOleDispatchException@@[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x43, 0x00
};

// Data @ 0x430108
const char stru_430108[] = " ";

// Data @ 0x430128
uint8_t stru_430128[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x18, 0x83, 0x42, 0x00
};

// Data @ 0x430130
const char stru_430130[] = " ";

// Data @ 0x430150
uint8_t stru_430150[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x430160
uint8_t stru_430160[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x01, 0x43, 0x00
};

// Data @ 0x430178
uint8_t stru_430178[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xC8, 0xFF, 0xFF, 0xFF, 0x91, 0x6E, 0x42, 0x00
};

// Data @ 0x430188
const char stru_430188[] = " ";

// Data @ 0x4301A8
uint8_t stru_4301A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x38, 0x83, 0x42, 0x00
};

// Data @ 0x4301C0
const char stru_4301C0[] = " ";

// Data @ 0x4301E0
uint8_t stru_4301E0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x83, 0x42, 0x00
};

// Data @ 0x430200
const char stru_430200[] = " ";

// Data @ 0x430220
uint8_t stru_430220[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x94, 0x83, 0x42, 0x00
};

// Data @ 0x430228
const char stru_430228[] = " ";

// Data @ 0x430248
uint8_t stru_430248[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xA8, 0x83, 0x42, 0x00
};

// Data @ 0x430250
const char stru_430250[] = " ";

// Data @ 0x430270
uint8_t stru_430270[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x430280
uint8_t stru_430280[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x98, 0x02, 0x43, 0x00
};

// Data @ 0x430298
uint8_t stru_430298[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x71, 0x5F, 0x42, 0x00
};

// Data @ 0x4302A8
const char stru_4302A8[] = " ";

// Data @ 0x4302C8
uint8_t stru_4302C8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4302D8
uint8_t stru_4302D8[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xF0, 0x02, 0x43, 0x00
};

// Data @ 0x4302F0
uint8_t stru_4302F0[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xE1, 0x5F, 0x42, 0x00
};

// Data @ 0x430300
const char stru_430300[] = " ";

// Data @ 0x430320
uint8_t stru_430320[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x430330
uint8_t stru_430330[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x48, 0x03, 0x43, 0x00
};

// Data @ 0x430348
uint8_t stru_430348[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x84, 0x60, 0x42, 0x00
};

// Data @ 0x430358
const char stru_430358[] = " ";

// Data @ 0x430378
uint8_t stru_430378[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x83, 0x42, 0x00
};

// Data @ 0x430388
const char stru_430388[] = " ";

// Data @ 0x4303A8
uint8_t stru_4303A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x84, 0x42, 0x00
};

// Data @ 0x4303B0
const char stru_4303B0[] = " ";

// Data @ 0x4303D0
uint8_t stru_4303D0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x84, 0x42, 0x00
};

// Data @ 0x4303E0
const char stru_4303E0[] = " ";

// Data @ 0x430400
uint8_t stru_430400[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x84, 0x42, 0x00
};

// Data @ 0x430410
const char stru_430410[] = " ";

// Data @ 0x430430
uint8_t stru_430430[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x6C, 0x84, 0x42, 0x00
};

// Data @ 0x430460
uint8_t unk_430460[1] = {
    0x04
};

// Data @ 0x430478
uint8_t pThrowInfo[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x04, 0x43, 0x00
};

// Data @ 0x430488
const char stru_430488[] = " ";

// Data @ 0x4304A8
uint8_t stru_4304A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x88, 0x84, 0x42, 0x00
};

// Data @ 0x4304C0
const char stru_4304C0[] = " ";

// Data @ 0x4304E0
uint8_t stru_4304E0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xB0, 0x84, 0x42, 0x00
};

// Data @ 0x4304E8
const char stru_4304E8[] = " ";

// Data @ 0x430508
uint8_t stru_430508[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xC4, 0x84, 0x42, 0x00
};

// Data @ 0x430510
const char stru_430510[] = " ";

// Data @ 0x430530
uint8_t stru_430530[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x84, 0x42, 0x00
};

// Data @ 0x430538
const char stru_430538[] = " ";

// Data @ 0x430558
uint8_t stru_430558[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x430568
uint8_t stru_430568[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x80, 0x05, 0x43, 0x00
};

// Data @ 0x430580
uint8_t stru_430580[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0x63, 0xB8, 0x41, 0x00
};

// Data @ 0x430590
const char stru_430590[] = " ";

// Data @ 0x4305B0
uint8_t stru_4305B0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4305C0
uint8_t stru_4305C0[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xD8, 0x05, 0x43, 0x00
};

// Data @ 0x4305D8
uint8_t stru_4305D8[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0xBC, 0xB8, 0x41, 0x00
};

// Data @ 0x4305E8
const char stru_4305E8[] = " ";

// Data @ 0x430608
uint8_t stru_430608[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x430618
uint8_t stru_430618[20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x30, 0x06, 0x43, 0x00
};

// Data @ 0x430630
uint8_t stru_430630[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0x08, 0x00, 0x00, 0x00, 0x3C, 0xB9, 0x41, 0x00
};

// Data @ 0x430640
uint8_t __CT??_R0PAVCOleException@@@8[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x430660
uint8_t __CTA4PAVCOleException@@[4] = {
    0x04, 0x00, 0x00, 0x00
};

// Data @ 0x430678
uint8_t __TI4PAVCOleException@@[16] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x06, 0x43, 0x00
};

// Data @ 0x430688
const char stru_430688[] = " ";

// Data @ 0x4306A8
uint8_t stru_4306A8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x18, 0x85, 0x42, 0x00
};

// Data @ 0x4306B0
const char stru_4306B0[] = " ";

// Data @ 0x4306D0
uint8_t stru_4306D0[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x2C, 0x85, 0x42, 0x00
};

// Data @ 0x4306D8
const char stru_4306D8[] = " ";

// Data @ 0x4306F8
uint8_t stru_4306F8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x85, 0x42, 0x00
};

// Data @ 0x430710
uint8_t stru_430710[20] = {
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x28, 0x07, 0x43, 0x00
};

// Data @ 0x430728
uint8_t stru_430728[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0x29, 0x62, 0x42, 0x00
};

// Data @ 0x430738
const char stru_430738[] = " ";

// Data @ 0x430758
uint8_t stru_430758[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x58, 0x85, 0x42, 0x00
};

// Data @ 0x430770
uint8_t stru_430770[20] = {
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x88, 0x07, 0x43, 0x00
};

// Data @ 0x430788
uint8_t stru_430788[16] = {
    0x00, 0x00, 0x00, 0x00, 0x18, 0x34, 0x43, 0x00, 0xEC, 0xFF, 0xFF, 0xFF, 0xA5, 0x62, 0x42, 0x00
};

// Data @ 0x430798
const char stru_430798[] = " ";

// Data @ 0x4307B8
uint8_t stru_4307B8[8] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0x70, 0x85, 0x42, 0x00
};

// Data @ 0x4307C0
uint8_t __IMPORT_DESCRIPTOR_KERNEL32[4] = {
    0x88, 0x09, 0x03, 0x00
};

// Data @ 0x4307D4
uint8_t __IMPORT_DESCRIPTOR_USER32[4] = {
    0x98, 0x0B, 0x03, 0x00
};

// Data @ 0x4307E8
uint8_t __IMPORT_DESCRIPTOR_GDI32[4] = {
    0xE8, 0x08, 0x03, 0x00
};

// Data @ 0x4307FC
uint8_t __IMPORT_DESCRIPTOR_comdlg32[4] = {
    0xC0, 0x0D, 0x03, 0x00
};

// Data @ 0x430810
uint8_t __IMPORT_DESCRIPTOR_WINSPOOL.DRV[4] = {
    0xB0, 0x0D, 0x03, 0x00
};

// Data @ 0x430824
uint8_t __IMPORT_DESCRIPTOR_ADVAPI32[4] = {
    0xC4, 0x08, 0x03, 0x00
};

// Data @ 0x430838
uint8_t __IMPORT_DESCRIPTOR_SHELL32[4] = {
    0x90, 0x0B, 0x03, 0x00
};

// Data @ 0x43084C
uint8_t __IMPORT_DESCRIPTOR_COMCTL32[4] = {
    0xE0, 0x08, 0x03, 0x00
};

// Data @ 0x430860
uint8_t __IMPORT_DESCRIPTOR_oledlg[4] = {
    0x10, 0x0E, 0x03, 0x00
};

// Data @ 0x430874
uint8_t __IMPORT_DESCRIPTOR_ole32[4] = {
    0xD0, 0x0D, 0x03, 0x00
};

// Data @ 0x430888
uint8_t __IMPORT_DESCRIPTOR_OLEPRO32[4] = {
    0x88, 0x0B, 0x03, 0x00
};

// Data @ 0x43089C
const char __IMPORT_DESCRIPTOR_OLEAUT32[] = "`\x0b";

// Data @ 0x4308C4
uint8_t off_4308C4[4] = {
    0xF0, 0x20, 0x03, 0x00
};

// Data @ 0x4308E0
uint8_t dword_4308E0[4] = {
    0x11, 0x00, 0x00, 0x80
};

// Data @ 0x4308E8
uint8_t off_4308E8[4] = {
    0x00, 0x1F, 0x03, 0x00
};

// Data @ 0x430988
uint8_t off_430988[4] = {
    0x8E, 0x13, 0x03, 0x00
};

// Data @ 0x430B60
uint8_t dword_430B60[4] = {
    0xB9, 0x00, 0x00, 0x80
};

// Data @ 0x430B88
uint8_t dword_430B88[4] = {
    0xFD, 0x00, 0x00, 0x80
};

// Data @ 0x430B90
const char off_430B90[] = "^!";

// Data @ 0x430B98
const char off_430B98[] = "b";

// Data @ 0x430DB0
uint8_t off_430DB0[4] = {
    0xAC, 0x20, 0x03, 0x00
};

// Data @ 0x430DC0
const char off_430DC0[] = "z ";

// Data @ 0x430DD0
const char off_430DD0[] = "j"";

// Data @ 0x430E10
const char dword_430E10[] = "\x08";

// Data @ 0x430E18
uint8_t word_430E18[2] = {
    0xF5, 0x00
};

// Data @ 0x430E30
uint8_t word_430E30[2] = {
    0x93, 0x01
};

// Data @ 0x430E40
uint8_t word_430E40[2] = {
    0x8C, 0x01
};

// Data @ 0x430E4E
uint8_t word_430E4E[2] = {
    0x81, 0x01
};

// Data @ 0x430E5C
uint8_t word_430E5C[2] = {
    0xD3, 0x02
};

// Data @ 0x430E66
const char word_430E66[] = "]";

// Data @ 0x430E7E
uint8_t word_430E7E[2] = {
    0xFA, 0x00
};

// Data @ 0x430E94
uint8_t word_430E94[2] = {
    0xF9, 0x00
};

// Data @ 0x430EA8
uint8_t word_430EA8[2] = {
    0xFF, 0x02
};

// Data @ 0x430EB4
uint8_t word_430EB4[2] = {
    0xFC, 0x02
};

// Data @ 0x430EC0
uint8_t word_430EC0[2] = {
    0x83, 0x01
};

// Data @ 0x430ED4
const char word_430ED4[] = "$";

// Data @ 0x430EEA
const char word_430EEA[] = "\x1b";

// Data @ 0x430EF8
uint8_t word_430EF8[2] = {
    0xC7, 0x01
};

// Data @ 0x430F08
uint8_t word_430F08[2] = {
    0xA3, 0x00
};

// Data @ 0x430F18
uint8_t word_430F18[2] = {
    0xD5, 0x01
};

// Data @ 0x430F28
uint8_t word_430F28[2] = {
    0x88, 0x01
};

// Data @ 0x430F36
const char word_430F36[] = ">";

// Data @ 0x430F48
const char word_430F48[] = "&";

// Data @ 0x430F5C
uint8_t word_430F5C[2] = {
    0x02, 0x03
};

// Data @ 0x430F68
uint8_t word_430F68[2] = {
    0x84, 0x01
};

// Data @ 0x430F7A
uint8_t word_430F7A[2] = {
    0x7F, 0x01
};

// Data @ 0x430F8C
uint8_t word_430F8C[2] = {
    0x89, 0x01
};

// Data @ 0x430FA2
uint8_t word_430FA2[2] = {
    0xF9, 0x02
};

// Data @ 0x430FAE
const char word_430FAE[] = "t";

// Data @ 0x430FBC
uint8_t word_430FBC[2] = {
    0xB4, 0x00
};

// Data @ 0x430FCA
uint8_t word_430FCA[2] = {
    0xC2, 0x01
};

// Data @ 0x430FDA
uint8_t word_430FDA[2] = {
    0xB0, 0x01
};

// Data @ 0x430FF2
uint8_t word_430FF2[2] = {
    0xAD, 0x01
};

// Data @ 0x43100A
const char word_43100A[] = "\x08";

// Data @ 0x431016
uint8_t word_431016[2] = {
    0xD2, 0x02
};

// Data @ 0x43102C
uint8_t word_43102C[2] = {
    0xE4, 0x01
};

// Data @ 0x431042
uint8_t word_431042[2] = {
    0xCC, 0x01
};

// Data @ 0x43104E
uint8_t word_43104E[2] = {
    0xAF, 0x00
};

// Data @ 0x431060
const char word_431060[] = "h";

// Data @ 0x431072
const char word_431072[] = "q";

// Data @ 0x431082
uint8_t word_431082[2] = {
    0xE3, 0x01
};

// Data @ 0x43108C
uint8_t word_43108C[2] = {
    0x05, 0x03
};

// Data @ 0x431098
uint8_t word_431098[2] = {
    0xC8, 0x01
};

// Data @ 0x4310A6
uint8_t word_4310A6[2] = {
    0xAA, 0x01
};

// Data @ 0x4310C2
uint8_t word_4310C2[2] = {
    0xA2, 0x02
};

// Data @ 0x4310CE
const char word_4310CE[] = "U";

// Data @ 0x4310E6
uint8_t word_4310E6[2] = {
    0x8B, 0x01
};

// Data @ 0x4310F6
uint8_t word_4310F6[2] = {
    0xA3, 0x02
};

// Data @ 0x431100
uint8_t word_431100[2] = {
    0xC1, 0x01
};

// Data @ 0x431118
uint8_t word_431118[2] = {
    0x8F, 0x01
};

// Data @ 0x431128
const char word_431128[] = "f";

// Data @ 0x431140
uint8_t word_431140[2] = {
    0xA5, 0x02
};

// Data @ 0x43114E
uint8_t word_43114E[2] = {
    0xCF, 0x01
};

// Data @ 0x43115E
uint8_t word_43115E[2] = {
    0xA4, 0x02
};

// Data @ 0x43116C
uint8_t word_43116C[2] = {
    0x87, 0x01
};

// Data @ 0x43117A
uint8_t word_43117A[2] = {
    0xE5, 0x02
};

// Data @ 0x431198
uint8_t word_431198[2] = {
    0x1A, 0x01
};

// Data @ 0x4311A8
const char word_4311A8[] = "E";

// Data @ 0x4311BC
uint8_t word_4311BC[2] = {
    0x95, 0x02
};

// Data @ 0x4311CE
uint8_t word_4311CE[2] = {
    0xBF, 0x00
};

// Data @ 0x4311DA
const char word_4311DA[] = "1";

// Data @ 0x4311E6
const char word_4311E6[] = "c";

// Data @ 0x4311F8
uint8_t word_4311F8[2] = {
    0xF7, 0x00
};

// Data @ 0x43120C
const char word_43120C[] = "4";

// Data @ 0x43121A
uint8_t word_43121A[2] = {
    0x18, 0x02
};

// Data @ 0x431226
uint8_t word_431226[2] = {
    0xDF, 0x02
};

// Data @ 0x431232
const char word_431232[] = "j";

// Data @ 0x431244
uint8_t word_431244[2] = {
    0xAA, 0x00
};

// Data @ 0x431258
uint8_t word_431258[2] = {
    0xD3, 0x01
};

// Data @ 0x431264
uint8_t word_431264[2] = {
    0xAE, 0x02
};

// Data @ 0x431272
const char word_431272[] = "a";

// Data @ 0x431282
uint8_t word_431282[2] = {
    0x90, 0x00
};

// Data @ 0x43128E
uint8_t word_43128E[2] = {
    0x94, 0x00
};

// Data @ 0x4312A0
const char word_4312A0[] = "w";

// Data @ 0x4312B8
uint8_t word_4312B8[2] = {
    0x16, 0x01
};

// Data @ 0x4312CC
const char word_4312CC[] = "\r";

// Data @ 0x4312E2
uint8_t word_4312E2[2] = {
    0x12, 0x01
};

// Data @ 0x4312F0
uint8_t word_4312F0[2] = {
    0x14, 0x01
};

// Data @ 0x4312FE
const char word_4312FE[] = "d";

// Data @ 0x43130E
uint8_t word_43130E[2] = {
    0x8A, 0x00
};

// Data @ 0x431326
uint8_t word_431326[2] = {
    0x89, 0x00
};

// Data @ 0x431340
const char word_431340[] = "m";

// Data @ 0x431350
const char word_431350[] = "/";

// Data @ 0x43135C
const char word_43135C[] = "P";

// Data @ 0x43136E
uint8_t word_43136E[2] = {
    0xCA, 0x00
};

// Data @ 0x431380
const char word_431380[] = "}";

// Data @ 0x43138E
uint8_t word_43138E[2] = {
    0x9E, 0x02
};

// Data @ 0x4313A2
uint8_t word_4313A2[2] = {
    0x9F, 0x01
};

// Data @ 0x4313AE
uint8_t word_4313AE[2] = {
    0x99, 0x01
};

// Data @ 0x4313BA
const char word_4313BA[] = "\x0b";

// Data @ 0x4313CC
const char word_4313CC[] = "|";

// Data @ 0x4313DC
uint8_t word_4313DC[2] = {
    0x15, 0x01
};

// Data @ 0x4313EA
uint8_t word_4313EA[2] = {
    0xA2, 0x01
};

// Data @ 0x4313F8
uint8_t word_4313F8[2] = {
    0xA3, 0x01
};

// Data @ 0x431404
uint8_t word_431404[2] = {
    0xB9, 0x00
};

// Data @ 0x43140E
const char word_43140E[] = "p";

// Data @ 0x431428
uint8_t word_431428[2] = {
    0xAD, 0x02
};

// Data @ 0x431444
uint8_t word_431444[2] = {
    0xB2, 0x00
};

// Data @ 0x43145E
uint8_t word_43145E[2] = {
    0xB3, 0x00
};

// Data @ 0x431478
uint8_t word_431478[2] = {
    0x06, 0x01
};

// Data @ 0x431490
const char word_431490[] = "\x08";

// Data @ 0x4314AA
const char word_4314AA[] = "m";

// Data @ 0x4314BC
const char word_4314BC[] = "R";

// Data @ 0x4314CC
const char word_4314CC[] = "\t";

// Data @ 0x4314E6
const char word_4314E6[] = "u";

// Data @ 0x4314F6
uint8_t word_4314F6[2] = {
    0x9D, 0x01
};

// Data @ 0x431504
uint8_t word_431504[2] = {
    0x9B, 0x01
};

// Data @ 0x431512
uint8_t word_431512[2] = {
    0xBF, 0x02
};

// Data @ 0x431520
uint8_t word_431520[2] = {
    0xBB, 0x02
};

// Data @ 0x431530
uint8_t word_431530[2] = {
    0xB8, 0x01
};

// Data @ 0x431540
uint8_t word_431540[2] = {
    0x8B, 0x02
};

// Data @ 0x43155E
uint8_t word_43155E[2] = {
    0xBF, 0x01
};

// Data @ 0x43156E
uint8_t word_43156E[2] = {
    0xC0, 0x01
};

// Data @ 0x43157E
const char word_43157E[] = "S";

// Data @ 0x431590
const char word_431590[] = "V";

// Data @ 0x4315A2
uint8_t word_4315A2[2] = {
    0xB5, 0x01
};

// Data @ 0x4315B2
uint8_t word_4315B2[2] = {
    0xB2, 0x01
};

// Data @ 0x4315C2
const char word_4315C2[] = "!";

// Data @ 0x4315D4
const char word_4315D4[] = """;

// Data @ 0x4315E6
const char word_4315E6[] = "b";

// Data @ 0x431600
const char aKernel32Dll[] = "KERNEL32.dll";

// Data @ 0x43160E
uint8_t word_43160E[2] = {
    0x9E, 0x01
};

// Data @ 0x43161A
const char word_43161A[] = "\\";

// Data @ 0x43162A
const char word_43162A[] = "R";

// Data @ 0x431636
uint8_t word_431636[2] = {
    0x14, 0x02
};

// Data @ 0x431646
uint8_t word_431646[2] = {
    0xA9, 0x00
};

// Data @ 0x431652
uint8_t word_431652[2] = {
    0xF0, 0x00
};

// Data @ 0x431662
const char word_431662[] = "F";

// Data @ 0x431676
uint8_t word_431676[2] = {
    0x8C, 0x01
};

// Data @ 0x431682
const char word_431682[] = "<";

// Data @ 0x431694
const char word_431694[] = "#";

// Data @ 0x4316A8
uint8_t word_4316A8[2] = {
    0xB4, 0x00
};

// Data @ 0x4316BA
uint8_t word_4316BA[2] = {
    0xD3, 0x01
};

// Data @ 0x4316CA
uint8_t word_4316CA[2] = {
    0xAA, 0x02
};

// Data @ 0x4316D8
uint8_t word_4316D8[2] = {
    0xAD, 0x00
};

// Data @ 0x4316E6
uint8_t word_4316E6[2] = {
    0xFD, 0x00
};

// Data @ 0x4316EE
uint8_t word_4316EE[2] = {
    0x98, 0x01
};

// Data @ 0x4316FC
uint8_t word_4316FC[2] = {
    0x8E, 0x02
};

// Data @ 0x431710
uint8_t word_431710[2] = {
    0x95, 0x01
};

// Data @ 0x43171C
uint8_t word_43171C[2] = {
    0xFA, 0x01
};

// Data @ 0x43172E
uint8_t word_43172E[2] = {
    0xB7, 0x00
};

// Data @ 0x43173E
uint8_t word_43173E[2] = {
    0xDE, 0x01
};

// Data @ 0x43174E
uint8_t word_43174E[2] = {
    0xE0, 0x01
};

// Data @ 0x431760
const char word_431760[] = "&";

// Data @ 0x43176C
uint8_t word_43176C[2] = {
    0xBE, 0x01
};

// Data @ 0x43177A
const char word_43177A[] = "V";

// Data @ 0x43178C
uint8_t word_43178C[2] = {
    0x90, 0x01
};

// Data @ 0x43179E
uint8_t word_43179E[2] = {
    0x19, 0x01
};

// Data @ 0x4317B4
const char word_4317B4[] = "5";

// Data @ 0x4317C0
const char word_4317C0[] = "b";

// Data @ 0x4317D4
uint8_t word_4317D4[2] = {
    0xFC, 0x00
};

// Data @ 0x4317E4
uint8_t word_4317E4[2] = {
    0xDC, 0x01
};

// Data @ 0x4317F4
uint8_t word_4317F4[2] = {
    0x92, 0x01
};

// Data @ 0x431806
uint8_t word_431806[2] = {
    0x9A, 0x02
};

// Data @ 0x431816
uint8_t word_431816[2] = {
    0x15, 0x00
};

// Data @ 0x431828
uint8_t word_431828[2] = {
    0x12, 0x01
};

// Data @ 0x431836
uint8_t word_431836[2] = {
    0xDD, 0x00
};

// Data @ 0x431848
uint8_t word_431848[2] = {
    0x95, 0x00
};

// Data @ 0x43185C
uint8_t word_43185C[2] = {
    0x82, 0x02
};

// Data @ 0x431870
const char word_431870[] = "*";

// Data @ 0x43187E
const char word_43187E[] = "3";

// Data @ 0x431892
const char word_431892[] = "\x07";

// Data @ 0x43189E
uint8_t word_43189E[2] = {
    0xB5, 0x00
};

// Data @ 0x4318B0
const char word_4318B0[] = "4";

// Data @ 0x4318C0
const char word_4318C0[] = "9";

// Data @ 0x4318D6
uint8_t word_4318D6[2] = {
    0xC4, 0x01
};

// Data @ 0x4318E4
const char word_4318E4[] = "'";

// Data @ 0x4318F4
uint8_t word_4318F4[2] = {
    0x1E, 0x01
};

// Data @ 0x431912
uint8_t word_431912[2] = {
    0x02, 0x01
};

// Data @ 0x431920
uint8_t word_431920[2] = {
    0x8E, 0x00
};

// Data @ 0x431930
const char word_431930[] = "L";

// Data @ 0x43194E
uint8_t word_43194E[2] = {
    0x8F, 0x01
};

// Data @ 0x43195A
uint8_t word_43195A[2] = {
    0x1C, 0x02
};

// Data @ 0x43196C
uint8_t word_43196C[2] = {
    0xB9, 0x00
};

// Data @ 0x431978
const char word_431978[] = "[";

// Data @ 0x43198E
const char word_43198E[] = "q";

// Data @ 0x4319A6
const char word_4319A6[] = "y";

// Data @ 0x4319B6
uint8_t word_4319B6[2] = {
    0xD2, 0x01
};

// Data @ 0x4319C4
uint8_t word_4319C4[2] = {
    0x00, 0x02
};

// Data @ 0x4319DE
const char word_4319DE[] = "[";

// Data @ 0x4319EE
const char word_4319EE[] = "X";

// Data @ 0x431A00
const char word_431A00[] = "R";

// Data @ 0x431A0C
const char word_431A0C[] = "0";

// Data @ 0x431A22
const char word_431A22[] = "\x08";

// Data @ 0x431A38
const char word_431A38[] = ",";

// Data @ 0x431A48
const char word_431A48[] = "-";

// Data @ 0x431A5A
uint8_t word_431A5A[2] = {
    0x84, 0x00
};

// Data @ 0x431A6C
uint8_t word_431A6C[2] = {
    0x05, 0x02
};

// Data @ 0x431A7A
uint8_t word_431A7A[2] = {
    0x16, 0x00
};

// Data @ 0x431A8C
const char word_431A8C[] = ":";

// Data @ 0x431A98
uint8_t word_431A98[2] = {
    0x86, 0x02
};

// Data @ 0x431AAE
const char word_431AAE[] = "B";

// Data @ 0x431ABA
uint8_t word_431ABA[2] = {
    0xEB, 0x00
};

// Data @ 0x431ACA
const char word_431ACA[] = "Y";

// Data @ 0x431ADC
uint8_t word_431ADC[2] = {
    0x01, 0x01
};

// Data @ 0x431AEC
const char word_431AEC[] = "^";

// Data @ 0x431AFE
const char word_431AFE[] = "_";

// Data @ 0x431B16
const char word_431B16[] = "#";

// Data @ 0x431B26
const char word_431B26[] = "B";

// Data @ 0x431B34
const char word_431B34[] = """;

// Data @ 0x431B48
uint8_t word_431B48[2] = {
    0x1C, 0x01
};

// Data @ 0x431B52
uint8_t word_431B52[2] = {
    0xF2, 0x01
};

// Data @ 0x431B64
uint8_t word_431B64[2] = {
    0xE7, 0x00
};

// Data @ 0x431B74
uint8_t word_431B74[2] = {
    0xAC, 0x02
};

// Data @ 0x431B80
uint8_t word_431B80[2] = {
    0xA6, 0x02
};

// Data @ 0x431B8C
uint8_t word_431B8C[2] = {
    0xE4, 0x00
};

// Data @ 0x431B9A
uint8_t word_431B9A[2] = {
    0x85, 0x01
};

// Data @ 0x431BA4
const char word_431BA4[] = "L";

// Data @ 0x431BB4
const char word_431BB4[] = "D";

// Data @ 0x431BC0
const char word_431BC0[] = "\n";

// Data @ 0x431BD2
uint8_t word_431BD2[2] = {
    0x02, 0x00
};

// Data @ 0x431BE8
const char word_431BE8[] = "/";

// Data @ 0x431BF4
const char word_431BF4[] = "C";

// Data @ 0x431C02
uint8_t word_431C02[2] = {
    0xB9, 0x01
};

// Data @ 0x431C14
uint8_t word_431C14[2] = {
    0x0F, 0x02
};

// Data @ 0x431C2A
uint8_t word_431C2A[2] = {
    0x91, 0x02
};

// Data @ 0x431C3A
const char word_431C3A[] = "W";

// Data @ 0x431C54
uint8_t word_431C54[2] = {
    0xB4, 0x01
};

// Data @ 0x431C64
uint8_t word_431C64[2] = {
    0x88, 0x01
};

// Data @ 0x431C78
const char word_431C78[] = "^";

// Data @ 0x431C8A
uint8_t word_431C8A[2] = {
    0xC9, 0x01
};

// Data @ 0x431C98
const char word_431C98[] = "j";

// Data @ 0x431CA6
const char word_431CA6[] = "%";

// Data @ 0x431CB2
const char word_431CB2[] = ":";

// Data @ 0x431CC4
uint8_t word_431CC4[2] = {
    0x03, 0x02
};

// Data @ 0x431CD0
const char word_431CD0[] = "T";

// Data @ 0x431CDE
uint8_t word_431CDE[2] = {
    0x0C, 0x00
};

// Data @ 0x431CEC
uint8_t word_431CEC[2] = {
    0xBB, 0x00
};

// Data @ 0x431CF8
const char word_431CF8[] = "s";

// Data @ 0x431D0A
uint8_t word_431D0A[2] = {
    0xAF, 0x00
};

// Data @ 0x431D16
const char word_431D16[] = "d";

// Data @ 0x431D24
uint8_t word_431D24[2] = {
    0x9A, 0x01
};

// Data @ 0x431D32
uint8_t word_431D32[2] = {
    0xFF, 0x00
};

// Data @ 0x431D46
uint8_t word_431D46[2] = {
    0xED, 0x00
};

// Data @ 0x431D56
uint8_t word_431D56[2] = {
    0xEA, 0x01
};

// Data @ 0x431D62
const char word_431D62[] = "D";

// Data @ 0x431D76
uint8_t word_431D76[2] = {
    0xAB, 0x01
};

// Data @ 0x431D84
uint8_t word_431D84[2] = {
    0x8D, 0x00
};

// Data @ 0x431D92
const char word_431D92[] = "@";

// Data @ 0x431DAA
const char word_431DAA[] = "D";

// Data @ 0x431DB4
const char word_431DB4[] = "2";

// Data @ 0x431DCA
uint8_t word_431DCA[2] = {
    0xBD, 0x01
};

// Data @ 0x431DD8
const char word_431DD8[] = "/";

// Data @ 0x431DE6
const char word_431DE6[] = "z";

// Data @ 0x431DF8
const char word_431DF8[] = "q";

// Data @ 0x431E06
uint8_t word_431E06[2] = {
    0xF6, 0x01
};

// Data @ 0x431E22
uint8_t word_431E22[2] = {
    0xE1, 0x01
};

// Data @ 0x431E38
const char aUser32Dll[] = "USER32.dll";

// Data @ 0x431E44
const char word_431E44[] = "$";

// Data @ 0x431E54
uint8_t word_431E54[2] = {
    0x1A, 0x01
};

// Data @ 0x431E62
uint8_t word_431E62[2] = {
    0xF3, 0x01
};

// Data @ 0x431E72
uint8_t word_431E72[2] = {
    0xCD, 0x01
};

// Data @ 0x431E80
const char word_431E80[] = "O";

// Data @ 0x431E8E
const char word_431E8E[] = "i";

// Data @ 0x431E9E
const char word_431E9E[] = "\x07";

// Data @ 0x431EAC
const char word_431EAC[] = "%";

// Data @ 0x431EBC
const char word_431EBC[] = "_";

// Data @ 0x431ECE
const char word_431ECE[] = "P";

// Data @ 0x431EDA
uint8_t word_431EDA[2] = {
    0xC0, 0x01
};

// Data @ 0x431EE4
uint8_t word_431EE4[2] = {
    0xB9, 0x01
};

// Data @ 0x431EF0
uint8_t word_431EF0[2] = {
    0xC7, 0x01
};

// Data @ 0x431F00
uint8_t word_431F00[2] = {
    0xCE, 0x01
};

// Data @ 0x431F0C
uint8_t word_431F0C[2] = {
    0xE2, 0x01
};

// Data @ 0x431F1A
uint8_t word_431F1A[2] = {
    0xF6, 0x01
};

// Data @ 0x431F2E
uint8_t word_431F2E[2] = {
    0x8C, 0x01
};

// Data @ 0x431F44
uint8_t word_431F44[2] = {
    0xF5, 0x01
};

// Data @ 0x431F58
uint8_t word_431F58[2] = {
    0xC1, 0x01
};

// Data @ 0x431F6E
uint8_t word_431F6E[2] = {
    0xF9, 0x01
};

// Data @ 0x431F80
uint8_t word_431F80[2] = {
    0xC2, 0x01
};

// Data @ 0x431F94
uint8_t word_431F94[2] = {
    0x80, 0x01
};

// Data @ 0x431FA8
const char word_431FA8[] = "S";

// Data @ 0x431FB8
const char word_431FB8[] = "x";

// Data @ 0x431FCC
const char word_431FCC[] = "{";

// Data @ 0x431FDE
const char word_431FDE[] = "M";

// Data @ 0x431FF2
uint8_t word_431FF2[2] = {
    0xAA, 0x01
};

// Data @ 0x431FFE
uint8_t word_431FFE[2] = {
    0xAE, 0x01
};

// Data @ 0x43200C
uint8_t word_43200C[2] = {
    0x05, 0x02
};

// Data @ 0x432018
uint8_t word_432018[2] = {
    0x9E, 0x00
};

// Data @ 0x432026
uint8_t word_432026[2] = {
    0x95, 0x00
};

// Data @ 0x432030
const char word_432030[] = "N";

// Data @ 0x43203A
uint8_t word_43203A[2] = {
    0x82, 0x01
};

// Data @ 0x432044
const char word_432044[] = "G";

// Data @ 0x432052
uint8_t word_432052[2] = {
    0x94, 0x01
};

// Data @ 0x43205C
const char aGdi32Dll[] = "GDI32.dll";

// Data @ 0x432066
const char word_432066[] = "\x0b";

// Data @ 0x43207A
const char word_43207A[] = "\t";

// Data @ 0x43208E
const char word_43208E[] = "\x07";

// Data @ 0x43209E
const char aComdlg32Dll[] = "comdlg32.dll";

// Data @ 0x4320AC
uint8_t word_4320AC[2] = {
    0x1C, 0x00
};

// Data @ 0x4320BC
const char word_4320BC[] = "G";

// Data @ 0x4320D2
const char word_4320D2[] = "|";

// Data @ 0x4320E2
const char aWinspoolDrv[] = "WINSPOOL.DRV";

// Data @ 0x4320F0
const char word_4320F0[] = "[";

// Data @ 0x4320FE
const char word_4320FE[] = "j";

// Data @ 0x43210E
const char word_43210E[] = "r";

// Data @ 0x43211E
const char word_43211E[] = "q";

// Data @ 0x43212C
const char word_43212C[] = "_";

// Data @ 0x43213E
uint8_t word_43213E[2] = {
    0x86, 0x01
};

// Data @ 0x432150
const char aAdvapi32Dll[] = "ADVAPI32.dll";

// Data @ 0x43215E
const char word_43215E[] = "r";

// Data @ 0x43216E
const char aShell32Dll[] = "SHELL32.dll";

// Data @ 0x43217A
const char aComctl32Dll[] = "COMCTL32.dll";

// Data @ 0x432188
const char aOledlgDll[] = "oledlg.dll";

// Data @ 0x432194
uint8_t word_432194[2] = {
    0x05, 0x00
};

// Data @ 0x4321A6
uint8_t word_4321A6[2] = {
    0x06, 0x00
};

// Data @ 0x4321B8
uint8_t word_4321B8[2] = {
    0x1C, 0x00
};

// Data @ 0x4321CC
const char word_4321CC[] = "\n";

// Data @ 0x4321EA
uint8_t word_4321EA[2] = {
    0xFE, 0x00
};

// Data @ 0x43220A
const char word_43220A[] = "`";

// Data @ 0x432226
const char word_432226[] = "O";

// Data @ 0x432236
const char word_432236[] = "N";

// Data @ 0x432248
uint8_t word_432248[2] = {
    0xC9, 0x00
};

// Data @ 0x432258
uint8_t word_432258[2] = {
    0xE0, 0x00
};

// Data @ 0x43226A
uint8_t word_43226A[2] = {
    0x16, 0x00
};

// Data @ 0x432282
const char word_432282[] = "@";

// Data @ 0x43229C
const char word_43229C[] = "G";

// Data @ 0x4322B2
uint8_t word_4322B2[2] = {
    0xC4, 0x00
};

// Data @ 0x4322C6
uint8_t word_4322C6[2] = {
    0xCB, 0x00
};

// Data @ 0x4322DE
const char aOle32Dll[] = "ole32.dll";

// Data @ 0x4322E8
const char aOlepro32Dll[] = "OLEPRO32.DLL";

// Data @ 0x4322F6
const char aOleaut32Dll[] = "OLEAUT32.dll";

// Data @ 0x432304
const char word_432304[] = "K";

// Data @ 0x432318
uint8_t word_432318[2] = {
    0x91, 0x01
};

// Data @ 0x43232A
const char word_43232A[] = "~";

// Data @ 0x432338
uint8_t word_432338[2] = {
    0xA6, 0x00
};

// Data @ 0x432348
uint8_t word_432348[2] = {
    0xD2, 0x00
};

// Data @ 0x43235C
const char word_43235C[] = "e";

// Data @ 0x432368
const char word_432368[] = "f";

// Data @ 0x432374
uint8_t word_432374[2] = {
    0x8B, 0x02
};

// Data @ 0x432388
const char word_432388[] = "p";

// Data @ 0x43239E
uint8_t word_43239E[2] = {
    0x11, 0x00
};

// Data @ 0x4323A8
const char word_4323A8[] = "*";

// Data @ 0x4323BE
const char word_4323BE[] = "0";

============================================================
// Segment: .data
============================================================


// Data @ 0x433000
uint8_t dword_433000[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x433084
uint8_t dword_433084[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x433088
uint8_t First[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x43309C
uint8_t Last[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4330A0
uint8_t dword_4330A0[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4330A8
uint8_t dword_4330A8[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4330AC
uint8_t dword_4330AC[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4330B4
uint8_t dword_4330B4[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x4330C0
const char byte_4330C0[] = "F%d";

// Data @ 0x4330C4
uint8_t byte_4330C4[1] = {
    0xCE
};

// Data @ 0x4330CC
const char Ptr[] = "http://www.266.cc/webz/1%d.htm";

// Data @ 0x4330EC
const char aHttpWww266CcWe[] = "http://www.266.cc/webz/10%d.htm";

// Data @ 0x43310C
const char aSetIni[] = "set.ini";

// Data @ 0x433114
const char aWhatisbestinli[] = "WhatIsBestInLife";

// Data @ 0x433128
const char aLeaveyoursleep[] = "LeaveYourSleep";

// Data @ 0x433138
const char aImadoctornotar[] = "ImADoctorNotARoachJim";

// Data @ 0x433150
const char aMoredotsmoredo[] = "MoreDotsMoreDots";

// Data @ 0x433164
const char aSosayweall[] = "SoSayWeAll";

// Data @ 0x433170
const char aTerribleterrib[] = "TerribleTerribleDamage";

// Data @ 0x433188
const char aTooktheredpill[] = "TookTheRedPill";

// Data @ 0x433198
const char aBunker55alivei[] = "Bunker55AliveInside";

// Data @ 0x4331AC
const char aCatfoodforpraw[] = "CatFoodForPrawnGuns";

// Data @ 0x4331C0
const char aWhorunbarterto[] = "WhoRunBartertown";

// Data @ 0x4331D4
const char aWeb[] = "Web";

// Data @ 0x4331E8
const char aHttpWww266CcWe_1[] = " http://www.266.cc/webz/ceshi.htm";

// Data @ 0x43320C
const char aHtmlfileShellO[] = "htmlfile\\shell\\open\\command";

// Data @ 0x433228
const char byte_433228[] = "F11";

// Data @ 0x43322C
const char byte_43322C[] = "F10";

// Data @ 0x433230
const char byte_433230[] = "F9";

// Data @ 0x433234
const char byte_433234[] = "F8";

// Data @ 0x433238
const char byte_433238[] = "F7";

// Data @ 0x43323C
const char byte_43323C[] = "F6";

// Data @ 0x433240
const char byte_433240[] = "F5";

// Data @ 0x433244
const char byte_433244[] = "F4";

// Data @ 0x433248
const char byte_433248[] = "F3";

// Data @ 0x43324C
const char byte_43324C[] = "F2";

// Data @ 0x433250
const char byte_433250[] = "%d\n";

// Data @ 0x433254
const char unk_433254[] = "set";

// Data @ 0x43326C
uint8_t Text[1] = {
    0xD2
};

// Data @ 0x433284
const char Substr[] = ".set";

// Data @ 0x43328C
const char aOpen[] = "open";

// Data @ 0x433294
const char aHttpWww266CcWe_2[] = "http://www.266.cc/webz/gengxing.htm";

// Data @ 0x4332B8
const char aHttpWww266CcWe_3[] = "http://www.266.cc/webz/guanyu.htm";

// Data @ 0x4332DC
uint8_t unk_4332DC[1] = {
    0x0E
};

// Data @ 0x433350
const char aCwebbrowser2[] = "CWebBrowser2";

// Data @ 0x433360
uint8_t dword_433360[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x433368
const char ??_R0?AVCNoTrackObject@@@8[] = "X";

// Data @ 0x433370
const char aAvcnotrackobje[] = ".?AVCNoTrackObject@@";

// Data @ 0x433388
const char ??_R0?AV_AFX_WIN_STATE@@@8[] = "X";

// Data @ 0x433390
const char aAvAfxWinState[] = ".?AV_AFX_WIN_STATE@@";

// Data @ 0x4333A8
const char ??_R0?AVCObject@@@8[] = "X";

// Data @ 0x4333B0
const char aAvcobject[] = ".?AVCObject@@";

// Data @ 0x4333C0
const char ??_R0?AVCCmdTarget@@@8[] = "X";

// Data @ 0x4333C8
const char aAvccmdtarget[] = ".?AVCCmdTarget@@";

// Data @ 0x4333E0
const char ??_R0?AVCWinThread@@@8[] = "X";

// Data @ 0x4333E8
const char aAvcwinthread[] = ".?AVCWinThread@@";

// Data @ 0x433400
const char ??_R0?AVCWinApp@@@8[] = "X";

// Data @ 0x433408
const char aAvcwinapp[] = ".?AVCWinApp@@";

// Data @ 0x433418
const char ??_R0PAVCException@@@8[] = "X";

// Data @ 0x433438
const char ??_R0?AV_AFX_CTL3D_STATE@@@8[] = "X";

// Data @ 0x433440
const char aAvAfxCtl3dStat[] = ".?AV_AFX_CTL3D_STATE@@";

// Data @ 0x433458
const char ??_R0?AV_AFX_CTL3D_THREAD@@@8[] = "X";

// Data @ 0x433460
const char aAvAfxCtl3dThre[] = ".?AV_AFX_CTL3D_THREAD@@";

// Data @ 0x433488
const char ??_R0?AVCCmdUI@@@8[] = "X";

// Data @ 0x433490
const char aAvccmdui[] = ".?AVCCmdUI@@";

// Data @ 0x4334A0
const char off_4334A0[] = "V";

// Data @ 0x4334A8
const char ??_R0?AVCWnd@@@8[] = "X";

// Data @ 0x4334B0
const char aAvcwnd[] = ".?AVCWnd@@";

// Data @ 0x4334C0
const char ??_R0?AVCDialog@@@8[] = "X";

// Data @ 0x4334C8
const char aAvcdialog[] = ".?AVCDialog@@";

// Data @ 0x4334D8
const char ??_R0?AVCComboBox@@@8[] = "X";

// Data @ 0x4334E0
const char aAvccombobox[] = ".?AVCComboBox@@";

// Data @ 0x4334F0
const char ??_R0?AVCTestCmdUI@@@8[] = "X";

// Data @ 0x4334F8
const char aAvctestcmdui[] = ".?AVCTestCmdUI@@";

// Data @ 0x433510
const char ??_R0PAVCUserException@@@8[] = "X";

// Data @ 0x433518
const char aPavcuserexcept[] = ".PAVCUserException@@";

// Data @ 0x433530
const char ??_R0?AVCTempWnd@@@8[] = "X";

// Data @ 0x433538
const char aAvctempwnd[] = ".?AVCTempWnd@@";

// Data @ 0x433548
const char off_433548[] = "\\5C";

// Data @ 0x43354C
const char off_43354C[] = "P5C";

// Data @ 0x433550
uint8_t unk_433550[1] = {
    0xFF
};

// Data @ 0x43355C
uint8_t unk_43355C[1] = {
    0x00
};

// Data @ 0x433560
const char ??_R0?AVCOccManager@@@8[] = "X";

// Data @ 0x433568
const char aAvcoccmanager[] = ".?AVCOccManager@@";

// Data @ 0x433580
const char ??_R0?AV_AFX_THREAD_STATE@@@8[] = "X";

// Data @ 0x433588
const char aAvAfxThreadSta[] = ".?AV_AFX_THREAD_STATE@@";

// Data @ 0x4335A0
const char ??_R0?AVAFX_MODULE_STATE@@@8[] = "X";

// Data @ 0x4335A8
const char aAvafxModuleSta[] = ".?AVAFX_MODULE_STATE@@";

// Data @ 0x4335C0
const char ??_R0?AVAFX_MODULE_THREAD_STATE@@@8[] = "X";

// Data @ 0x4335C8
const char aAvafxModuleThr[] = ".?AVAFX_MODULE_THREAD_STATE@@";

// Data @ 0x4335E8
const char ??_R0?AV_AFX_BASE_MODULE_STATE@@@8[] = "X";

// Data @ 0x4335F0
const char aAvAfxBaseModul[] = ".?AV_AFX_BASE_MODULE_STATE@@";

// Data @ 0x433610
uint8_t unk_433610[1] = {
    0xFF
};

// Data @ 0x433614
uint8_t unk_433614[1] = {
    0xFF
};

// Data @ 0x433618
const char ??_R0?AUIOleWindow@@@8[] = "X";

// Data @ 0x433620
const char aAuiolewindow[] = ".?AUIOleWindow@@";

// Data @ 0x433638
const char ??_R0?AUIOleInPlaceUIWindow@@@8[] = "X";

// Data @ 0x433640
const char aAuioleinplaceu[] = ".?AUIOleInPlaceUIWindow@@";

// Data @ 0x433660
const char ??_R0?AUIOleInPlaceFrame@@@8[] = "X";

// Data @ 0x433668
const char aAuioleinplacef[] = ".?AUIOleInPlaceFrame@@";

// Data @ 0x433680
const char ??_R0?AVXOleIPFrame@COleControlContainer@@@8[] = "X";

// Data @ 0x433688
const char aAvxoleipframeC[] = ".?AVXOleIPFrame@COleControlContainer@@";

// Data @ 0x4336B0
const char ??_R0?AVCOleControlContainer@@@8[] = "X";

// Data @ 0x4336B8
const char aAvcolecontrolc[] = ".?AVCOleControlContainer@@";

// Data @ 0x4336D8
const char ??_R0?AUIUnknown@@@8[] = "X";

// Data @ 0x4336E0
const char aAuiunknown[] = ".?AUIUnknown@@";

// Data @ 0x4336F0
const char ??_R0?AUIParseDisplayName@@@8[] = "X";

// Data @ 0x4336F8
const char aAuiparsedispla[] = ".?AUIParseDisplayName@@";

// Data @ 0x433710
const char ??_R0?AUIOleContainer@@@8[] = "X";

// Data @ 0x433718
const char aAuiolecontaine[] = ".?AUIOleContainer@@";

// Data @ 0x433730
const char ??_R0?AVXOleContainer@COleControlContainer@@@8[] = "X";

// Data @ 0x433738
const char aAvxolecontaine[] = ".?AVXOleContainer@COleControlContainer@@";

// Data @ 0x433768
const char ??_R0?AVCFont@@@8[] = "X";

// Data @ 0x433770
const char aAvcfont[] = ".?AVCFont@@";

// Data @ 0x433780
const char ??_R0?AVCGdiObject@@@8[] = "X";

// Data @ 0x433788
const char aAvcgdiobject[] = ".?AVCGdiObject@@";

// Data @ 0x4337A0
const char ??_R0?AVCEnumArray@@@8[] = "X";

// Data @ 0x4337A8
const char aAvcenumarray[] = ".?AVCEnumArray@@";

// Data @ 0x4337C0
const char ??_R0?AVCEnumUnknown@@@8[] = "X";

// Data @ 0x4337C8
const char aAvcenumunknown[] = ".?AVCEnumUnknown@@";

// Data @ 0x4337E0
const char ??_R0?AVCFile@@@8[] = "X";

// Data @ 0x4337E8
const char aAvcfile[] = ".?AVCFile@@";

// Data @ 0x4337F8
const char ??_R0?AVCStdioFile@@@8[] = "X";

// Data @ 0x433800
const char aAvcstdiofile[] = ".?AVCStdioFile@@";

// Data @ 0x433818
const char ??_R0?AVCException@@@8[] = "X";

// Data @ 0x433820
const char aAvcexception[] = ".?AVCException@@";

// Data @ 0x433838
const char ??_R0?AVCFileException@@@8[] = "X";

// Data @ 0x433840
const char aAvcfileexcepti[] = ".?AVCFileException@@";

// Data @ 0x433858
const char ??_R0?AVCDC@@@8[] = "X";

// Data @ 0x433860
const char aAvcdc[] = ".?AVCDC@@";

// Data @ 0x433870
const char ??_R0?AVCClientDC@@@8[] = "X";

// Data @ 0x433878
const char aAvcclientdc[] = ".?AVCClientDC@@";

// Data @ 0x433888
const char ??_R0?AVCWindowDC@@@8[] = "X";

// Data @ 0x433890
const char aAvcwindowdc[] = ".?AVCWindowDC@@";

// Data @ 0x4338A0
const char ??_R0?AVCPaintDC@@@8[] = "X";

// Data @ 0x4338A8
const char aAvcpaintdc[] = ".?AVCPaintDC@@";

// Data @ 0x4338B8
const char ??_R0?AVCTempDC@@@8[] = "X";

// Data @ 0x4338C0
const char aAvctempdc[] = ".?AVCTempDC@@";

// Data @ 0x4338D0
const char ??_R0?AVCTempGdiObject@@@8[] = "X";

// Data @ 0x4338D8
const char aAvctempgdiobje[] = ".?AVCTempGdiObject@@";

// Data @ 0x4338F0
const char ??_R0PAX@8[] = "X";

// Data @ 0x4338F8
const char aPax[] = ".PAX";

// Data @ 0x433900
const char ??_R0PAVCObject@@@8[] = "X";

// Data @ 0x433908
const char aPavcobject[] = ".PAVCObject@@";

// Data @ 0x433918
const char ??_R0PAVCSimpleException@@@8[] = "X";

// Data @ 0x433920
const char aPavcsimpleexce[] = ".PAVCSimpleException@@";

// Data @ 0x433938
const char ??_R0PAVCResourceException@@@8[] = "X";

// Data @ 0x433940
const char aPavcresourceex[] = ".PAVCResourceException@@";

// Data @ 0x433960
const char ??_R0?AVCSimpleException@@@8[] = "X";

// Data @ 0x433968
const char aAvcsimpleexcep[] = ".?AVCSimpleException@@";

// Data @ 0x433980
const char ??_R0?AVCResourceException@@@8[] = "X";

// Data @ 0x433988
const char aAvcresourceexc[] = ".?AVCResourceException@@";

// Data @ 0x4339A8
const char ??_R0?AVCUserException@@@8[] = "X";

// Data @ 0x4339B0
const char aAvcuserexcepti[] = ".?AVCUserException@@";

// Data @ 0x4339C8
const char ??_R0?AVCCommonDialog@@@8[] = "X";

// Data @ 0x4339D0
const char aAvccommondialo[] = ".?AVCCommonDialog@@";

// Data @ 0x4339E8
const char ??_R0?AVCFileDialog@@@8[] = "X";

// Data @ 0x4339F0
const char aAvcfiledialog[] = ".?AVCFileDialog@@";

// Data @ 0x433A08
const char ??_R0?AUCThreadData@@@8[] = "X";

// Data @ 0x433A10
const char aAucthreaddata[] = ".?AUCThreadData@@";

// Data @ 0x433A28
const char ??_R0PAVCMemoryException@@@8[] = "X";

// Data @ 0x433A30
const char aPavcmemoryexce[] = ".PAVCMemoryException@@";

// Data @ 0x433A48
const char ??_R0PAVCNotSupportedException@@@8[] = "X";

// Data @ 0x433A50
const char aPavcnotsupport[] = ".PAVCNotSupportedException@@";

// Data @ 0x433A70
const char ??_R0?AVCMemoryException@@@8[] = "X";

// Data @ 0x433A78
const char aAvcmemoryexcep[] = ".?AVCMemoryException@@";

// Data @ 0x433A90
const char ??_R0?AVCNotSupportedException@@@8[] = "X";

// Data @ 0x433A98
const char aAvcnotsupporte[] = ".?AVCNotSupportedException@@";

// Data @ 0x433AB8
const char ??_R0?AVCHandleMap@@@8[] = "X";

// Data @ 0x433AC0
const char aAvchandlemap[] = ".?AVCHandleMap@@";

// Data @ 0x433AD8
const char ??_R0?AVCMapPtrToPtr@@@8[] = "X";

// Data @ 0x433AE0
const char aAvcmapptrtoptr[] = ".?AVCMapPtrToPtr@@";

// Data @ 0x433AF8
const char ??_R0?AVCMenu@@@8[] = "X";

// Data @ 0x433B00
const char aAvcmenu[] = ".?AVCMenu@@";

// Data @ 0x433B10
const char ??_R0?AVCTempMenu@@@8[] = "X";

// Data @ 0x433B18
const char aAvctempmenu[] = ".?AVCTempMenu@@";

// Data @ 0x433B28
const char ??_R0?AUIRowsetNotify@@@8[] = "X";

// Data @ 0x433B30
const char aAuirowsetnotif[] = ".?AUIRowsetNotify@@";

// Data @ 0x433B48
const char ??_R0?AVXRowsetNotify@COleControlSite@@@8[] = "X";

// Data @ 0x433B50
const char aAvxrowsetnotif[] = ".?AVXRowsetNotify@COleControlSite@@";

// Data @ 0x433B78
const char ??_R0?AUIOleInPlaceSite@@@8[] = "X";

// Data @ 0x433B80
const char aAuioleinplaces[] = ".?AUIOleInPlaceSite@@";

// Data @ 0x433B98
const char ??_R0?AVXOleIPSite@COleControlSite@@@8[] = "X";

// Data @ 0x433BA0
const char aAvxoleipsiteCo[] = ".?AVXOleIPSite@COleControlSite@@";

// Data @ 0x433BC8
const char ??_R0?AUINotifyDBEvents@@@8[] = "X";

// Data @ 0x433BD0
const char aAuinotifydbeve[] = ".?AUINotifyDBEvents@@";

// Data @ 0x433BE8
const char ??_R0?AVXNotifyDBEvents@COleControlSite@@@8[] = "X";

// Data @ 0x433BF0
const char aAvxnotifydbeve[] = ".?AVXNotifyDBEvents@COleControlSite@@";

// Data @ 0x433C18
const char ??_R0?AUIOleClientSite@@@8[] = "X";

// Data @ 0x433C20
const char aAuioleclientsi[] = ".?AUIOleClientSite@@";

// Data @ 0x433C38
const char ??_R0?AVXOleClientSite@COleControlSite@@@8[] = "X";

// Data @ 0x433C40
const char aAvxoleclientsi[] = ".?AVXOleClientSite@COleControlSite@@";

// Data @ 0x433C68
const char ??_R0?AUIBoundObjectSite@@@8[] = "X";

// Data @ 0x433C70
const char aAuiboundobject[] = ".?AUIBoundObjectSite@@";

// Data @ 0x433C88
const char ??_R0?AVXBoundObjectSite@COleControlSite@@@8[] = "X";

// Data @ 0x433C90
const char aAvxboundobject[] = ".?AVXBoundObjectSite@COleControlSite@@";

// Data @ 0x433CB8
const char ??_R0?AVXEventSink@COleControlSite@@@8[] = "X";

// Data @ 0x433CC0
const char aAvxeventsinkCo[] = ".?AVXEventSink@COleControlSite@@";

// Data @ 0x433CE8
const char ??_R0?AVCOleControlSite@@@8[] = "X";

// Data @ 0x433CF0
const char aAvcolecontrols[] = ".?AVCOleControlSite@@";

// Data @ 0x433D08
const char ??_R0?AUIPropertyNotifySink@@@8[] = "X";

// Data @ 0x433D10
const char aAuipropertynot[] = ".?AUIPropertyNotifySink@@";

// Data @ 0x433D30
const char ??_R0?AVXPropertyNotifySink@COleControlSite@@@8[] = "X";

// Data @ 0x433D38
const char aAvxpropertynot[] = ".?AVXPropertyNotifySink@COleControlSite@@";

// Data @ 0x433D68
const char ??_R0?AUIDispatch@@@8[] = "X";

// Data @ 0x433D70
const char aAuidispatch[] = ".?AUIDispatch@@";

// Data @ 0x433D80
const char ??_R0?AVXAmbientProps@COleControlSite@@@8[] = "X";

// Data @ 0x433D88
const char aAvxambientprop[] = ".?AVXAmbientProps@COleControlSite@@";

// Data @ 0x433DB0
const char ??_R0?AUIOleControlSite@@@8[] = "X";

// Data @ 0x433DB8
const char aAuiolecontrols[] = ".?AUIOleControlSite@@";

// Data @ 0x433DD0
const char ??_R0?AVXOleControlSite@COleControlSite@@@8[] = "X";

// Data @ 0x433DD8
const char aAvxolecontrols[] = ".?AVXOleControlSite@COleControlSite@@";

// Data @ 0x433E00
const char ??_R0?AVCDataSourceControl@@@8[] = "X";

// Data @ 0x433E08
const char aAvcdatasourcec[] = ".?AVCDataSourceControl@@";

// Data @ 0x433E28
uint8_t unk_433E28[1] = {
    0x05
};

// Data @ 0x433E38
uint8_t unk_433E38[1] = {
    0x11
};

// Data @ 0x433E48
uint8_t unk_433E48[1] = {
    0x8C
};

// Data @ 0x433E58
const char ??_R0?AVCMemFile@@@8[] = "X";

// Data @ 0x433E60
const char aAvcmemfile[] = ".?AVCMemFile@@";

// Data @ 0x433E70
const char ??_R0?AVCPtrList@@@8[] = "X";

// Data @ 0x433E78
const char aAvcptrlist[] = ".?AVCPtrList@@";

// Data @ 0x433E88
const char ??_R0PAVCOleDispatchException@@@8[] = "X";

// Data @ 0x433E90
const char aPavcoledispatc[] = ".PAVCOleDispatchException@@";

// Data @ 0x433EB0
const char ??_R0PAVCOleException@@@8[] = "X";

// Data @ 0x433EB8
const char aPavcoleexcepti[] = ".PAVCOleException@@";

// Data @ 0x433ED0
const char ??_R0?AVCOleDispatchException@@@8[] = "X";

// Data @ 0x433ED8
const char aAvcoledispatch[] = ".?AVCOleDispatchException@@";

// Data @ 0x433EF8
const char ??_R0?AUIEnumVOID@@@8[] = "X";

// Data @ 0x433F00
const char aAuienumvoid[] = ".?AUIEnumVOID@@";

// Data @ 0x433F10
const char ??_R0?AVXEnumVOID@CEnumArray@@@8[] = "X";

// Data @ 0x433F18
const char aAvxenumvoidCen[] = ".?AVXEnumVOID@CEnumArray@@";

// Data @ 0x433F54
uint8_t dword_433F54[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x433F58
uint8_t dword_433F58[52] = {
    0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0xB5, 0x00, 0x00, 0x00, 0xD4, 0x00, 0x00, 0x00,
    0xF3, 0x00, 0x00, 0x00, 0x11, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x4E, 0x01, 0x00, 0x00,
    0x6D, 0x01, 0x00, 0x00
};

// Data @ 0x433F8C
uint8_t dword_433F8C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x433F90
const char ??_R0?AUISequentialStream@@@8[] = "X";

// Data @ 0x433F98
const char aAuisequentials[] = ".?AUISequentialStream@@";

// Data @ 0x433FB0
const char ??_R0?AUIStream@@@8[] = "X";

// Data @ 0x433FB8
const char aAuistream[] = ".?AUIStream@@";

// Data @ 0x433FC8
const char ??_R0?AVCArchiveStream@@@8[] = "X";

// Data @ 0x433FD0
const char aAvcarchivestre[] = ".?AVCArchiveStream@@";

// Data @ 0x433FE8
const char ??_R0?AVCOleException@@@8[] = "X";

// Data @ 0x433FF0
const char aAvcoleexceptio[] = ".?AVCOleException@@";

// Data @ 0x434008
const char ??_R0?AVCOleMessageFilter@@@8[] = "X";

// Data @ 0x434010
const char aAvcolemessagef[] = ".?AVCOleMessageFilter@@";

// Data @ 0x434028
const char ??_R0?AUIMessageFilter@@@8[] = "X";

// Data @ 0x434030
const char aAuimessagefilt[] = ".?AUIMessageFilter@@";

// Data @ 0x434048
const char ??_R0?AVXMessageFilter@COleMessageFilter@@@8[] = "X";

// Data @ 0x434050
const char aAvxmessagefilt[] = ".?AVXMessageFilter@COleMessageFilter@@";

// Data @ 0x434078
const char ??_R0?AVCOleDialog@@@8[] = "X";

// Data @ 0x434080
const char aAvcoledialog[] = ".?AVCOleDialog@@";

// Data @ 0x434098
const char ??_R0?AVCOleBusyDialog@@@8[] = "X";

// Data @ 0x4340A0
const char aAvcolebusydial[] = ".?AVCOleBusyDialog@@";

// Data @ 0x4340B8
const char ??_R0?AV_AFX_OLE_STATE@@@8[] = "X";

// Data @ 0x4340C0
const char aAvAfxOleState[] = ".?AV_AFX_OLE_STATE@@";

// Data @ 0x4340D8
const char dword_4340D8[] = " ";

// Data @ 0x4340E8
uint8_t off_4340E8[4] = {
    0xA4, 0xD2, 0x40, 0x00
};

// Data @ 0x4340EC
uint8_t dword_4340EC[4] = {
    0x02, 0x00, 0x00, 0x00
};

// Data @ 0x4340F0
const char ??_R0?AVtype_info@@@8[] = "X";

// Data @ 0x4340F8
const char aAvtypeInfo[] = ".?AVtype_info@@";

// Data @ 0x434128
uint8_t off_434128[4] = {
    0xCB, 0xE1, 0x40, 0x00
};

// Data @ 0x434140
uint8_t unk_434140[1] = {
    0x01
};

// Data @ 0x434144
uint8_t dword_434144[4] = {
    0x16, 0x00, 0x00, 0x00
};

// Data @ 0x4342A8
uint8_t byte_4342A8[1] = {
    0x01
};

// Data @ 0x4342B0
uint8_t unk_4342B0[1] = {
    0xA4
};

// Data @ 0x4342B4
const char unk_4342B4[] = "`";

// Data @ 0x4342C0
uint8_t unk_4342C0[1] = {
    0xA6
};

// Data @ 0x4343A0
const char dword_4343A0[] = "?";

// Data @ 0x434443
uint8_t unk_434443[1] = {
    0x00
};

// Data @ 0x434460
const char off_434460[] = "X";

// Data @ 0x434470
uint8_t dwTlsIndex[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x434474
const char off_434474[] = "~DC";

// Data @ 0x43447C
uint8_t __ctype[4] = {
    0x00, 0x00, 0x20, 0x00
};

// Data @ 0x434680
uint8_t cbMultiByte[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x434684
const char byte_434684[] = ".";

// Data @ 0x434690
uint8_t dword_434690[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x434694
const char off_434694[] = "@";

// Data @ 0x4346B4
const char off_4346B4[] = "p";

// Data @ 0x4346C4
uint8_t off_4346C4[4] = {
    0x88, 0x94, 0x43, 0x00
};

// Data @ 0x4346D4
const char lpCriticalSection[] = "X";

// Data @ 0x434750
uint8_t unk_434750[1] = {
    0x05
};

// Data @ 0x4347C8
uint8_t dword_4347C8[4] = {
    0x03, 0x00, 0x00, 0x00
};

// Data @ 0x4347CC
const char dword_4347CC[] = "\x07";

// Data @ 0x4347D4
const char dword_4347D4[] = "\n";

// Data @ 0x4347D8
uint8_t unk_4347D8[1] = {
    0xFF
};

// Data @ 0x434800
uint8_t dword_434800[4] = {
    0x02, 0x00, 0x00, 0x00
};

// Data @ 0x434804
const char off_434804[] = "0";

// Data @ 0x434890
uint8_t off_434890[4] = {
    0x90, 0x48, 0x43, 0x00
};

// Data @ 0x434894
uint8_t off_434894[4] = {
    0x90, 0x48, 0x43, 0x00
};

// Data @ 0x4348A0
uint8_t dword_4348A0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4348A8
uint8_t unk_4348A8[1] = {
    0xF0
};

// Data @ 0x4368B0
uint8_t off_4368B0[4] = {
    0x90, 0x48, 0x43, 0x00
};

// Data @ 0x4368B4
uint8_t dword_4368B4[4] = {
    0xE0, 0x01, 0x00, 0x00
};

// Data @ 0x4368C0
const char off_4368C0[] = "d";

// Data @ 0x4368C4
const char off_4368C4[] = "T";

// Data @ 0x4368D0
uint8_t off_4368D0[4] = {
    0xC2, 0x5F, 0x41, 0x00
};

// Data @ 0x4368D4
uint8_t off_4368D4[4] = {
    0xC2, 0x5F, 0x41, 0x00
};

// Data @ 0x4368D8
uint8_t off_4368D8[4] = {
    0xC2, 0x5F, 0x41, 0x00
};

// Data @ 0x4368DC
uint8_t off_4368DC[4] = {
    0xC2, 0x5F, 0x41, 0x00
};

// Data @ 0x4368E0
uint8_t off_4368E0[4] = {
    0xC2, 0x5F, 0x41, 0x00
};

// Data @ 0x4368E4
uint8_t off_4368E4[4] = {
    0xC2, 0x5F, 0x41, 0x00
};

// Data @ 0x4368F0
uint8_t off_4368F0[4] = {
    0x80, 0x97, 0x43, 0x00
};

// Data @ 0x436900
uint8_t unk_436900[1] = {
    0x00
};

// Data @ 0x436910
uint8_t unk_436910[1] = {
    0x00
};

// Data @ 0x436930
uint8_t unk_436930[1] = {
    0x00
};

// Data @ 0x436960
uint8_t dword_436960[496] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436B50
uint8_t stru_436B50[32] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436B70
uint8_t unk_436B70[1] = {
    0x14
};

// Data @ 0x436C88
uint8_t dword_436C88[4] = {
    0x80, 0x70, 0x00, 0x00
};

// Data @ 0x436C8C
uint8_t dword_436C8C[4] = {
    0x01, 0x00, 0x00, 0x00
};

// Data @ 0x436C90
uint8_t dword_436C90[4] = {
    0xF0, 0xF1, 0xFF, 0xFF
};

// Data @ 0x436C94
const char unk_436C94[] = "PST";

// Data @ 0x436CD4
const char unk_436CD4[] = "PDT";

// Data @ 0x436D14
uint8_t Destination[4] = {
    0x94, 0x6C, 0x43, 0x00
};

// Data @ 0x436D18
uint8_t off_436D18[4] = {
    0xD4, 0x6C, 0x43, 0x00
};

// Data @ 0x436D20
uint8_t dword_436D20[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x436D24
uint8_t dword_436D24[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436D28
uint8_t dword_436D28[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436D30
uint8_t dword_436D30[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x436D34
uint8_t dword_436D34[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436D38
uint8_t dword_436D38[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436E4C
uint8_t dword_436E4C[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436E50
uint8_t dword_436E50[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x436E80
const char dword_436E80[] = "m";

// Data @ 0x436E84
uint8_t dword_436E84[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x436EC0
uint8_t dword_436EC0[24] = {
    0x00, 0x04, 0x00, 0x00, 0x01, 0xFC, 0xFF, 0xFF, 0x35, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00
};

// Data @ 0x436ED8
uint8_t dword_436ED8[104] = {
    0x80, 0x00, 0x00, 0x00, 0x81, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x94, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x6E, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00,
    0x4C, 0x97, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00,
    0x4C, 0x97, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00, 0x4C, 0x97, 0x43, 0x00,
    0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00, 0x6F, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Data @ 0x436F40
uint8_t unk_436F40[1] = {
    0x00
};

// Data @ 0x4370A0
uint8_t unk_4370A0[1] = {
    0xCD
};

// Data @ 0x4371FC
const char aEdit[] = "edit";

// Data @ 0x437204
const char aHangeul[] = "hangeul";

// Data @ 0x43720C
const char aKanji[] = "kanji";

// Data @ 0x437214
const char aEnglish[] = "english";

// Data @ 0x43721C
const char Default[] = "roman";

// Data @ 0x437224
const char aHangeulmenu[] = "hangeulmenu";

// Data @ 0x437230
const char KeyName[] = "kanjimenu";

// Data @ 0x43723C
const char AppName[] = "windows";

// Data @ 0x437244
const char aC3dhnew[] = "C3dHNew";

// Data @ 0x43724C
const char aC3dlnew[] = "C3dLNew";

// Data @ 0x437254
const char aC3dnew[] = "C3dNew";

// Data @ 0x43725C
const char aC3dh[] = "C3dH";

// Data @ 0x437264
const char aC3dl[] = "C3dL";

// Data @ 0x43726C
const char aC3d[] = "C3d";

// Data @ 0x437270
const char aC3dd[] = "C3dD";

// Data @ 0x437278
const char a32770[] = "#32770";

// Data @ 0x437280
const char asc_437280[] = "X";

// Data @ 0x437284
const char aDisablethreadl[] = "DisableThreadLibraryCalls";

// Data @ 0x4372A0
const char aKernel32Dll_0[] = "KERNEL32.DLL";

// Data @ 0x4372B0
uint8_t dword_4372B0[196] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x437374
uint8_t unk_437374[1] = {
    0x00
};

// Data @ 0x437378
uint8_t dword_437378[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x43737C
uint8_t dword_43737C[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x437380
uint8_t byte_437380[1] = {
    0x00
};

// Data @ 0x437384
uint8_t dword_437384[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x437388
uint8_t dword_437388[4] = {
    0x00, 0x00, 0x00, 0x00
};

// Data @ 0x438B88
uint8_t byte_438B88[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438BB0
uint8_t unk_438BB0[1] = {
    0xFF
};

// Data @ 0x438BF0
uint8_t unk_438BF0[1] = {
    0xFF
};

// Data @ 0x438C30
uint8_t unk_438C30[1] = {
    0xFF
};

// Data @ 0x438C6C
uint8_t byte_438C6C[1] = {
    0xFF
};

// Data @ 0x438C70
uint8_t unk_438C70[1] = {
    0xFF
};

// Data @ 0x438CAC
uint8_t dword_438CAC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CB0
uint8_t GetSystemMetrics_0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CB4
uint8_t MonitorFromWindow[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CB8
uint8_t MonitorFromRect[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CBC
uint8_t MonitorFromPoint[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CC0
uint8_t GetMonitorInfoA[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CC4
uint8_t EnumDisplayMonitors[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CC8
uint8_t dword_438CC8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CD0
uint8_t byte_438CD0[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438CF8
uint8_t byte_438CF8[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438D20
uint8_t byte_438D20[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438D48
uint8_t byte_438D48[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438D70
uint8_t byte_438D70[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438D74
uint8_t unk_438D74[1] = {
    0xFF
};

// Data @ 0x438D78
uint8_t unk_438D78[1] = {
    0xFF
};

// Data @ 0x438D7C
uint8_t unk_438D7C[1] = {
    0xFF
};

// Data @ 0x438D80
uint8_t byte_438D80[1] = {
    0xFF
};

// Data @ 0x438D88
uint8_t dword_438D88[152] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438E20
uint8_t dword_438E20[152] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438EB8
uint8_t byte_438EB8[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438EE0
uint8_t byte_438EE0[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438F08
uint8_t dword_438F08[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438F0C
uint8_t dword_438F0C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438F10
uint8_t unk_438F10[1] = {
    0xFF
};

// Data @ 0x438F48
uint8_t dword_438F48[152] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x438FE0
uint8_t dword_438FE0[152] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439078
uint8_t dword_439078[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4390C0
uint8_t CriticalSection[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4390D8
uint8_t stru_4390D8[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439270
uint8_t dword_439270[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439274
uint8_t dword_439274[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439278
uint8_t dword_439278[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43927C
uint8_t dword_43927C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439290
uint8_t dword_439290[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439294
uint8_t dword_439294[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392B4
uint8_t hCursor[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392B8
uint8_t dword_4392B8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392C8
uint8_t hBitmapChecked[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392CC
uint8_t dword_4392CC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392D4
uint8_t dword_4392D4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392E0
uint8_t dword_4392E0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392E4
uint8_t unk_4392E4[1] = {
    0xFF
};

// Data @ 0x4392E8
uint8_t dword_4392E8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392EC
uint8_t dword_4392EC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4392F0
uint8_t byte_4392F0[1] = {
    0xFF
};

// Data @ 0x4392F8
uint8_t byte_4392F8[40] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439320
uint8_t word_439320[2] = {
    0xFF, 0xFF
};

// Data @ 0x439328
uint8_t dword_439328[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439330
uint8_t dword_439330[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439334
uint8_t dword_439334[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439338
uint8_t dword_439338[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43933C
uint8_t dword_43933C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439340
uint8_t dword_439340[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439344
uint8_t dword_439344[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439348
uint8_t dword_439348[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439350
uint8_t dword_439350[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439354
uint8_t dword_439354[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439358
uint8_t dword_439358[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43935C
uint8_t dword_43935C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439360
uint8_t dword_439360[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439364
uint8_t byte_439364[1] = {
    0xFF
};

// Data @ 0x439368
uint8_t dword_439368[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439370
uint8_t unk_439370[1] = {
    0xFF
};

// Data @ 0x4393A0
uint8_t unk_4393A0[1] = {
    0xFF
};

// Data @ 0x4393A4
uint8_t Source[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393AC
uint8_t dword_4393AC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393B4
uint8_t dword_4393B4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393B8
uint8_t dword_4393B8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393BC
uint8_t dword_4393BC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393C0
uint8_t dword_4393C0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393C4
uint8_t dword_4393C4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393C8
uint8_t dword_4393C8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393D0
uint8_t dword_4393D0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393D4
uint8_t dword_4393D4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393D8
uint8_t dword_4393D8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393E0
uint8_t dword_4393E0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393E8
uint8_t byte_4393E8[1] = {
    0xFF
};

// Data @ 0x4393EC
uint8_t dword_4393EC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393F0
uint8_t dword_4393F0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393F8
uint8_t dword_4393F8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4393FC
uint8_t dword_4393FC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439418
uint8_t unk_439418[1] = {
    0xFF
};

// Data @ 0x439440
uint8_t unk_439440[1] = {
    0xFF
};

// Data @ 0x439458
uint8_t unk_439458[1] = {
    0xFF
};

// Data @ 0x439470
uint8_t unk_439470[1] = {
    0xFF
};

// Data @ 0x439488
uint8_t unk_439488[1] = {
    0xFF
};

// Data @ 0x4394A0
uint8_t Filename[260] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395A4
uint8_t dword_4395A4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395A8
uint8_t dword_4395A8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395AC
uint8_t dword_4395AC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395B0
uint8_t dword_4395B0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395B4
uint8_t dword_4395B4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395B8
uint8_t lpfn[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395BC
uint8_t dword_4395BC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395C0
uint8_t dword_4395C0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395C4
uint8_t dword_4395C4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395C8
uint8_t dword_4395C8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395CC
uint8_t dword_4395CC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395D4
uint8_t unk_4395D4[1] = {
    0xFF
};

// Data @ 0x4395DC
uint8_t dword_4395DC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395EC
uint8_t dword_4395EC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4395F8
uint8_t dword_4395F8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439600
uint8_t TimeZoneInformation[172] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4396AC
uint8_t Str2[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4396B0
uint8_t dword_4396B0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4396C0
uint8_t MessageBoxA_0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4396C4
uint8_t GetActiveWindow_0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x4396C8
uint8_t GetLastActivePopup_0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439730
uint8_t dword_439730[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439734
uint8_t dword_439734[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439738
uint8_t dword_439738[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43973C
uint8_t dword_43973C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439754
uint8_t dword_439754[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439760
uint8_t dword_439760[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439764
uint8_t hhk[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439768
uint8_t dwNewLong[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43976C
uint8_t byte_43976C[1] = {
    0xFF
};

// Data @ 0x439770
uint8_t dword_439770[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439774
uint8_t Addend[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439778
uint8_t dword_439778[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x439780
uint8_t unk_439780[1] = {
    0xFF
};

// Data @ 0x43A780
uint8_t dword_43A780[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A784
uint8_t dword_43A784[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A788
uint8_t dword_43A788[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A78C
uint8_t dword_43A78C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A790
uint8_t dword_43A790[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A794
uint8_t dword_43A794[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A798
uint8_t lpMem[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A79C
uint8_t dword_43A79C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A7A0
uint8_t hHeap[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A7A4
uint8_t dword_43A7A4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A7C0
uint8_t dword_43A7C0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A7C4
uint8_t unk_43A7C4[1] = {
    0xFF
};

// Data @ 0x43A8C0
uint8_t uNumber[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A8C4
uint8_t CodePage[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A8D0
uint8_t dword_43A8D0[12] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A8DC
uint8_t dword_43A8DC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43A8E0
uint8_t byte_43A8E0[1] = {
    0xFF
};

// Data @ 0x43A9E0
uint8_t unk_43A9E0[1] = {
    0xFF
};

// Data @ 0x43A9E1
uint8_t byte_43A9E1[1] = {
    0xFF
};

// Data @ 0x43AAE4
uint8_t Locale[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AAE8
uint8_t dword_43AAE8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AAEC
uint8_t dword_43AAEC[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AAF0
uint8_t dword_43AAF0[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AAF4
uint8_t dword_43AAF4[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AAF8
uint8_t dword_43AAF8[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB00
uint8_t stru_43AB00[24] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB20
uint8_t dword_43AB20[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB24
uint8_t dword_43AB24[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB28
uint8_t nAtom[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB2A
uint8_t word_43AB2A[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB2C
uint8_t word_43AB2C[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB2E
uint8_t lpString[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB30
uint8_t word_43AB30[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB32
uint8_t word_43AB32[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB34
uint8_t word_43AB34[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB38
uint8_t hModule[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB3C
uint8_t hmod[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB40
uint8_t word_43AB40[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB42
uint8_t word_43AB42[2] = {
    0xFF, 0xFF
};

// Data @ 0x43AB44
uint8_t color[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB48
uint8_t dword_43AB48[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB50
uint8_t dword_43AB50[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB5C
uint8_t dword_43AB5C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB64
uint8_t dword_43AB64[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB68
uint8_t h[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB6C
uint8_t dword_43AB6C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB70
uint8_t dword_43AB70[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB74
uint8_t dword_43AB74[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB78
uint8_t dword_43AB78[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB7C
uint8_t dword_43AB7C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB80
uint8_t dword_43AB80[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB84
uint8_t dword_43AB84[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB88
uint8_t dword_43AB88[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB8C
uint8_t dword_43AB8C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43AB90
uint8_t dword_43AB90[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B580
uint8_t dword_43B580[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B584
uint8_t dword_43B584[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B610
uint8_t hData[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B614
uint8_t dword_43B614[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B618
uint8_t dword_43B618[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B61C
uint8_t dword_43B61C[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B620
uint8_t dword_43B620[4] = {
    0xFF, 0xFF, 0xFF, 0xFF
};

// Data @ 0x43B624
uint8_t byte_43B624[1] = {
    0xFF
};

// Data @ 0x43B625
uint8_t byte_43B625[1] = {
    0xFF
};

